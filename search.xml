<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2022/09/22/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>springboot前言</title>
    <url>/2022/09/23/springboot%E5%89%8D%E8%A8%80/</url>
    <content><![CDATA[<h3 id="文档更新日志"><a href="#文档更新日志" class="headerlink" title="文档更新日志"></a>文档更新日志</h3><table>
<thead>
<tr>
<th>版本</th>
<th>更新日期</th>
<th>操作</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>v1.0</td>
<td>2021&#x2F;11&#x2F;14</td>
<td>A</td>
<td>基础篇</td>
</tr>
<tr>
<td>v1.0.1</td>
<td>2021&#x2F;11&#x2F;30</td>
<td>U</td>
<td>更新基础篇错别字若干，不涉及内容变更</td>
</tr>
<tr>
<td>v2.0</td>
<td>2021&#x2F;12&#x2F;01</td>
<td>A</td>
<td>运维实用篇</td>
</tr>
<tr>
<td>V3.0</td>
<td>2022&#x2F;2&#x2F;21</td>
<td>A</td>
<td>开发实用篇</td>
</tr>
<tr>
<td>V4.0</td>
<td>2022&#x2F;3&#x2F;29</td>
<td>A</td>
<td>原理篇</td>
</tr>
</tbody></table>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>​		很荣幸有机会能以这样的形式和互联网上的各位小伙伴一起学习交流技术课程，这次给大家带来的是Spring家族中比较重要的一门技术课程——SpringBoot。一句话介绍这个技术，应该怎么说呢？现在如果开发Spring程序不用SpringBoot那就是给自己过不去，SpringBoot为我们开发Spring程序提供了太多的帮助，在此借这个机会给大家分享这门课程，希望各位小伙伴学有所得，学有所用，学有所成。</p>
<p>​		正如上面提到的，这门技术是用来加速开发Spring程序的，因此学习这门技术是有一定的门槛的。你可以理解为你现在是一门传统的手工艺人，现在工艺升级，可以加速你的生产制作过程，但是前提是你要会原始工艺，然后才能学习新的工艺。嗯，怎么说呢？有一定的门槛，至少Spring怎么回事，与Spring配合在一起工作的一堆技术又是怎么回事，这些搞明白才能来看这个技术，不然就只能学个皮毛，或者学着学着就开始因为其他技术不太过关，然后就学不下去了，然后，就没有然后了，果断弃坑了。不管怎么说，既来之则安之，加油学习吧，投资自己肯定是没毛病的。</p>
<h3 id="课程内容说明"><a href="#课程内容说明" class="headerlink" title="课程内容说明"></a>课程内容说明</h3><p>​		SpringBoot这门技术课程所包含的技术点其实并不是很多，但是围绕着SpringBoot的周边知识，也就是SpringBoot整合其他技术，这样的知识量很大，例如SpringBoot整合MyBatis等等。因此为了能够将本课程制作的能够适应于各个层面的学习者进行学习，本套课程会针对小白，初学者，开发者三种不同的人群来设计全套课程。具体这三种人群如何划分，就按照我的描述形式来分吧，各位小伙伴可以对号入座，每种人群看课程的起始位置略有差别。</p>
<table>
<thead>
<tr>
<th>学习者</th>
<th>归类方式</th>
</tr>
</thead>
<tbody><tr>
<td><strong>小白</strong></td>
<td>完全没有用过SpringBoot技术</td>
</tr>
<tr>
<td><strong>初学者</strong></td>
<td>能使用SpringBoot技术完成基础的SSM整合</td>
</tr>
<tr>
<td><strong>开发者</strong></td>
<td>能使用SpringBoot技术实现常见的技术整合工作</td>
</tr>
</tbody></table>
<p>​		简单说就是你能用SpringBoot做多少东西，一点不会就是小白，会一点就是初学者，大部分都会就是开发者。其实这个划分也不用过于纠结，这个划分仅仅是为了帮助你对本技术课程所包含的阶段模块划分做一个清晰认知，因为本课程中会将SpringBoot技术划分成4个单元，每个单元是针对不同的学习者准备的。</p>
<table>
<thead>
<tr>
<th>学习者</th>
<th>课程单元</th>
</tr>
</thead>
<tbody><tr>
<td><strong>小白</strong></td>
<td><font color="#ff0000"><b>基础篇</b></font></td>
</tr>
<tr>
<td><strong>初学者</strong></td>
<td><font color="#cc0000"><b>应用篇</b></font>（  运维实用篇  &amp;  开发实用篇  ）</td>
</tr>
<tr>
<td><strong>开发者</strong></td>
<td><font color="#990000"><b>原理篇</b></font></td>
</tr>
</tbody></table>
<p>​		看完这个划分你就应该有这么个概念，我没有用过SpringBoot技术，所以从基础篇开始学习；或者我会一点SpringBoot技术，那我从实用篇开始学就好了，就是这个意思。</p>
<p>​		每个课程单元内容设置不同，目标也不一样，作为学习者如果想达成最佳的学习效果，最好明确自己的学习目标再进行学习，这样目标明确，学习的时候能够更轻松，你就不会在学习的时候纠结如下的问题了。比如学着<font color="#ff0000"><b>基础篇</b></font>在那想，这个东西是个什么原理啊？这个东西是这么用的，那个东西该怎么用啊？因为原理性的内容统一放置到了<font color="#990000"><b>原理篇</b></font>讲解了，应用相关的内容统一放到<font color="#cc0000"><b>应用篇</b></font>里面讲解，你在<font color="#ff0000"><b>基础篇</b></font>阶段纠结也没有用，这一部分不讲这些知识，在<font color="#ff0000"><b>基础篇</b></font>先把SpringBoot的基础使用掌握完再说后面的知识吧。</p>
<p>​		此外还有一点需要说明的是，目前SpringBoot技术发展速度很快，更新速度也很快，因此后续还会对本套课程进行持续更新，特此在三个课程单元的基础上追加一个<strong>番外篇</strong>。番外篇的设置为了解决如下问题：</p>
<ul>
<li>持续更新SpringBoot后续发展出现的新技术</li>
<li>讲解部分知识点规模较大的支线知识（例如WebFlux）</li>
<li>扩展非实用性知识，扩展学习者视野</li>
</ul>
<p>​		每一个课程单元的学习目标如下，请各位查收，在学习的过程中可以阶段性的给自己提个问题，下面列出来的这些学习目标你是否达成了，可以检验你的学习成果。</p>
<table>
<thead>
<tr>
<th>课程单元</th>
<th>学习目标</th>
</tr>
</thead>
<tbody><tr>
<td><font color="#ff0000"><b>基础篇</b></font></td>
<td>能够创建SpringBoot工程<br/>基于SpringBoot实现ssm&#x2F;ssmp整合</td>
</tr>
<tr>
<td><font color="#cc0000"><b>应用篇</b></font></td>
<td>能够掌握SpringBoot程序多环境开发<br/>能够基于Linux系统发布SpringBoot工程<br/>能够解决线上灵活配置SpringBoot工程的需求<br/>能够基于SpringBoot整合任意第三方技术</td>
</tr>
<tr>
<td><font color="#990000"><b>原理篇</b></font></td>
<td>掌握SpringBoot内部工作流程<br/>理解SpringBoot整合第三方技术的原理<br/>实现自定义开发整合第三方技术的组件</td>
</tr>
<tr>
<td><strong>番外篇</strong></td>
<td>掌握SpringBoot整合非常见的第三方技术<br/>掌握相同领域的更多的解决方案，并提升同领域方案设计能力</td>
</tr>
</tbody></table>
<p>​		整体课程包含的内容就是这些啦，要想完成前面这些内容的学习，顺利的达成学习目标，有些东西还是要提前和大家说清楚的。SpringBoot课程不像是Java基础，不管你有没有基础，都可以听一听，这个课程还真不行，需要一定的前置知识。下面给大家列表一些前置知识，如果还有不太会的，需要想办法快速补救一下。</p>
<h3 id="课程前置知识说明"><a href="#课程前置知识说明" class="headerlink" title="课程前置知识说明"></a>课程前置知识说明</h3><table>
<thead>
<tr>
<th>课程单元</th>
<th>前置知识</th>
<th>要求</th>
</tr>
</thead>
<tbody><tr>
<td><font color="#ff0000"><b>基础篇</b></font></td>
<td>Java基础语法</td>
<td>面向对象，封装，继承，多态，类与接口，集合，IO，网络编程等</td>
</tr>
<tr>
<td><font color="#ff0000"><b>基础篇</b></font></td>
<td>Spring与SpringMVC</td>
<td>知道Spring是用来管理bean，能够基于Restful实现页面请求交互功能</td>
</tr>
<tr>
<td><font color="#ff0000"><b>基础篇</b></font></td>
<td>Mybatis与Mybatis-Plus</td>
<td>基于Mybatis和MybatisPlus能够开发出包含基础CRUD功能的标准Dao模块</td>
</tr>
<tr>
<td><font color="#ff0000"><b>基础篇</b></font></td>
<td>数据库MySQL</td>
<td>能够读懂基础CRUD功能的SQL语句</td>
</tr>
<tr>
<td><font color="#ff0000"><b>基础篇</b></font></td>
<td>服务器</td>
<td>知道服务器与web工程的关系，熟悉web服务器的基础配置</td>
</tr>
<tr>
<td><font color="#ff0000"><b>基础篇</b></font></td>
<td>maven</td>
<td>知道maven的依赖关系，知道什么是依赖范围，依赖传递，排除依赖，可选依赖，继承</td>
</tr>
<tr>
<td><font color="#ff0000"><b>基础篇</b></font></td>
<td>web技术（含vue，ElementUI)</td>
<td>知道vue如何发送ajax请求，如何获取响应数据，如何进行数据模型双向绑定</td>
</tr>
<tr>
<td><font color="#cc0000"><b>应用篇</b></font></td>
<td>Linux（CenterOS7）</td>
<td>熟悉常用的Linux基础指令，熟悉Linux系统目录结构</td>
</tr>
<tr>
<td><font color="#cc0000"><b>应用篇</b></font></td>
<td>实用开发技术</td>
<td>缓存：Redis、MongoDB、……<br/>消息中间件:RocketMq、RabbitMq、……</td>
</tr>
<tr>
<td><font color="#990000"><b>原理篇</b></font></td>
<td>Spring</td>
<td>了解Spring加载bean的各种方式<br/>知道Spring容器底层工作原理，能够阅读简单的Spring底层源码</td>
</tr>
</tbody></table>
<p>​		看着略微有点多，其实还好吧，如果个别技术真的不会，在学习课程的时候多用心听就好，基础篇是可以跟着学下来了，后面的实用篇和原理篇就比较难了。比如我要在Linux系统下操作，命令我就直接使用了，然后你看不懂可能学习起来就比较心累了。</p>
<p>​		课程安排就说到这里了，下面进入到SpringBoot<font color="#ff0000"><b>基础篇</b></font>的学习</p>
]]></content>
      <categories>
        <category>boot系列</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title>springboot运维实用篇</title>
    <url>/2022/09/23/springboot%E8%BF%90%E7%BB%B4%E5%AE%9E%E7%94%A8%E7%AF%87/</url>
    <content><![CDATA[<p>​		下面就从运维实用篇开始讲，在运维实用篇中，我给学习者的定位是玩转配置，为开发实用篇中做各种技术的整合做好准备工作。与开发实用篇相比，运维实用篇的内容显得略微单薄，并且有部分知识模块在运维实用篇和开发实用篇中都要讲一部分，这些内容都后置到开发实用篇中了。废话不说了，先看看运维实用篇中都包含哪些内容：</p>
<ul>
<li>SpringBoot程序的打包与运行</li>
<li>配置高级</li>
<li>多环境开发</li>
<li>日志</li>
</ul>
<p>​		下面开启第一部分SpringBoot程序打包与运行的学习</p>
<h2 id="YW-1-SpringBoot程序的打包与运行"><a href="#YW-1-SpringBoot程序的打包与运行" class="headerlink" title="YW-1.SpringBoot程序的打包与运行"></a>YW-1.SpringBoot程序的打包与运行</h2><p>​		刚开始做开发学习的小伙伴可能在有一个知识上面有错误的认知，我们天天写程序是在Idea下写的，运行也是在Idea下运行的。</p>
<img src="image-20211201091317258.png" alt="image-20211201091317258" style="zoom:67%;" />



<p>​		但是实际开发完成后，我们的项目是不可能运行在自己的电脑上的。</p>
<img src="image-20211201091341645.png" alt="image-20211201091341645" style="zoom:67%;" />

<p>​		我们以后制作的程序是运行在专用的服务器上的，简单说就是将你做的程序放在一台独立运行的电脑上，这台电脑要比你开发使用的计算机更专业，并且安全等级各个方面要远超过你现在的电脑。</p>
<img src="image-20211201091502040.png" alt="image-20211201091502040" style="zoom:67%;" />

<p>​		那我们的程序如何放置在这台专用的电脑上呢，这就要将我们的程序先组织成一个文件，然后将这个文件传输到这台服务器上。这里面就存在两个过程，一个是打包的过程，另一个是运行的过程。</p>
<p><font color="#f0f"><b>温馨提示</b></font></p>
<p>​		企业项目上线为了保障环境适配性会采用下面流程发布项目，这里不讨论此过程。</p>
<ol>
<li>开发部门使用Git、SVN等版本控制工具上传工程到版本服务器</li>
<li>服务器使用版本控制工具下载工程</li>
<li>服务器上使用Maven工具在当前真机环境下重新构建项目</li>
<li>启动服务</li>
</ol>
<p>​		继续说我们的打包和运行过程。所谓打包指将程序转换成一个可执行的文件，所谓运行指不依赖开发环境执行打包产生的文件。上述两个操作都有对应的命令可以快速执行。</p>
<h3 id="程序打包"><a href="#程序打包" class="headerlink" title="程序打包"></a><strong>程序打包</strong></h3><p>​		SpringBoot程序是基于Maven创建的，在Maven中提供有打包的指令，叫做package。本操作可以在Idea环境下执行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mvn <span class="keyword">package</span></span><br></pre></td></tr></table></figure>

<p>​		打包后会产生一个与工程名类似的jar文件，其名称是由模块名+版本号+.jar组成的。</p>
<h3 id="程序运行"><a href="#程序运行" class="headerlink" title="程序运行"></a><strong>程序运行</strong></h3><p>​		程序包打好以后，就可以直接执行了。在程序包所在路径下，执行指令。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java -jar 工程包名.jar</span><br></pre></td></tr></table></figure>

<p>​		执行程序打包指令后，程序正常运行，与在Idea下执行程序没有区别。</p>
<p>​		<font color="#ff0000"><b>特别关注</b></font>：如果你的计算机中没有安装java的jdk环境，是无法正确执行上述操作的，因为程序执行使用的是java指令。</p>
<p>​		<font color="#ff0000"><b>特别关注</b></font>：在使用向导创建SpringBoot工程时，pom.xml文件中会有如下配置，这一段配置千万不能删除，否则打包后无法正常执行程序。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>总结</strong></p>
<ol>
<li>SpringBoot工程可以基于java环境下独立运行jar文件启动服务</li>
<li>SpringBoot工程执行mvn命令package进行打包</li>
<li>执行jar命令：java –jar 工程名.jar</li>
</ol>
<h3 id="SpringBoot程序打包失败处理"><a href="#SpringBoot程序打包失败处理" class="headerlink" title="SpringBoot程序打包失败处理"></a>SpringBoot程序打包失败处理</h3><p>​		有些小伙伴打包以后执行会出现一些问题，导致程序无法正常执行，例如下面的现象</p>
<img src="image-20211201094223991.png" alt="image-20211201094223991" style="zoom:67%;" />

<p>​		要想搞清楚这个问题就要说说.jar文件的工作机制了，知道了这个东西就知道如何避免此类问题的发生了。</p>
<p>​		搞java开发平时会接触很多jar包，比如mysql的驱动jar包，而上面我们打包程序后得到的也是一个jar文件。这个时候如果你使用上面的java -jar指令去执行mysql的驱动jar包就会出现上述不可执行的现象，而我们的SpringBoot项目为什么能执行呢？其实是因为打包方式不一样。</p>
<p>​		在SpringBoot工程的pom.xml中有下面这组配置，这组配置决定了打包出来的程序包是否可以执行。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>​		我们分别开启这段配置和注释掉这段配置分别执行两次打包，然后观察两次打包后的程序包的差别，共有3处比较明显的特征</p>
<ul>
<li>打包后文件的大小不同</li>
<li>打包后所包含的内容不同</li>
<li>打包程序中个别文件内容不同</li>
</ul>
<p>​		先看第一个现象，文件大小不同。带有配置时打包生成的程序包大小如下：</p>
<img src="image-20211201095610270.png" alt="image-20211201095610270" style="zoom:150%;" />

<p>​		不难看出，带有配置的程序包体积比不带配置的大了30倍，那这里面都有什么呢？能差这么多？下面看看里面的内容有什么区别。</p>
<p>​		<img src="image-20211201101541267.png" alt="image-20211201101541267" style="zoom:50%;" /><img src="image-20211201101652868.png" alt="image-20211201101652868" style="zoom:50%;" /></p>
<p>​		我们发现内容也完全不一样，仅有一个目录是一样的，叫做META-INF。打开容量大的程序包中的BOOT-INF目录下的classes目录，我们发现其中的内容居然和容量小的程序包中的内容完全一样。</p>
<p>​		<img src="image-20211201101805569.png" alt="image-20211201101805569" style="zoom:50%;" /><img src="image-20211201101652868.png" alt="image-20211201101652868" style="zoom:50%;" /></p>
<p>​		原来大的程序包中除了包含小的程序包中的内容，还有别的东西。都有什么呢？回到BOOT-INF目录下，打开lib目录，里面显示了很多个jar文件。</p>
<p>​		<img src="image-20211201102025791.png" alt="image-20211201102025791" style="zoom:50%;" /></p>
<p>​		仔细翻阅不难发现，这些jar文件都是我们制作这个工程时导入的坐标对应的文件。大概可以想明白了，SpringBoot程序为了让自己打包生成的程序可以独立运行，不仅将项目中自己开发的内容进行了打包，还把当前工程运行需要使用的jar包全部打包进来了。为什么这样做呢？就是为了可以独立运行。不依赖程序包外部的任何资源可以独立运行当前程序。这也是为什么大的程序包容量是小的程序包容量的30倍的主要原因。</p>
<p>​		再看看大程序包还有什么不同之处，在最外层目录包含一个org目录，进入此目录，目录名是org\springframework\boot\loader，在里面可以找到一个<font color="#ff0000"><b>JarLauncher.class</b></font>的文件，先记得这个文件。再看这套目录名，明显是一个Spring的目录名，为什么要把Spring框架的东西打包到这个程序包中呢？不清楚。</p>
<p>​		回到两个程序包的最外层目录，查看名称相同的文件夹META-INF下都有一个叫做MANIFEST.MF的文件，但是大小不同，打开文件，比较内容区别</p>
<ul>
<li><p>小容量文件的MANIFEST.MF</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Manifest-Version: <span class="number">1.0</span></span><br><span class="line">Implementation-Title: springboot_08_ssmp</span><br><span class="line">Implementation-Version: <span class="number">0.0</span><span class="number">.1</span>-SNAPSHOT</span><br><span class="line">Build-Jdk-Spec: <span class="number">1.8</span></span><br><span class="line">Created-By: Maven Jar Plugin <span class="number">3.2</span><span class="number">.0</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>大容量文件的MANIFEST.MF</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Manifest-Version: <span class="number">1.0</span></span><br><span class="line">Spring-Boot-Classpath-Index: BOOT-INF/classpath.idx</span><br><span class="line">Implementation-Title: springboot_08_ssmp</span><br><span class="line">Implementation-Version: <span class="number">0.0</span><span class="number">.1</span>-SNAPSHOT</span><br><span class="line">Spring-Boot-Layers-Index: BOOT-INF/layers.idx</span><br><span class="line">Start-Class: com.itheima.SSMPApplication</span><br><span class="line">Spring-Boot-Classes: BOOT-INF/classes/</span><br><span class="line">Spring-Boot-Lib: BOOT-INF/lib/</span><br><span class="line">Build-Jdk-Spec: <span class="number">1.8</span></span><br><span class="line">Spring-Boot-Version: <span class="number">2.5</span><span class="number">.4</span></span><br><span class="line">Created-By: Maven Jar Plugin <span class="number">3.2</span><span class="number">.0</span></span><br><span class="line">Main-Class: org.springframework.boot.loader.JarLauncher</span><br></pre></td></tr></table></figure></li>
</ul>
<p>​		大文件中明显比小文件中多了几行信息，其中最后一行信息是Main-Class: org.springframework.boot.loader.<font color="#ff0000"><b>JarLauncher</b></font>。这句话什么意思呢？如果使用java -jar执行此程序包，将执行Main-Class属性配置的类，这个类恰巧就是前面看到的那个文件。原来SpringBoot打包程序中出现Spring框架的东西是为这里服务的。而这个org.springframework.boot.loader.<font color="#ff0000"><b>JarLauncher</b></font>类内部要查找Start-Class属性中配置的类，并执行对应的类。这个属性在当前配置中也存在，对应的就是我们的引导类类名。</p>
<p>​		现在这组设定的作用就搞清楚了</p>
<ol>
<li>SpringBoot程序添加配置后会打出一个特殊的包，包含Spring框架部分功能，原始工程内容，原始工程依赖的jar包</li>
<li>首先读取MANIFEST.MF文件中的Main-Class属性，用来标记执行java -jar命令后运行的类</li>
<li>JarLauncher类执行时会找到Start-Class属性，也就是启动类类名</li>
<li>运行启动类时会运行当前工程的内容</li>
<li>运行当前工程时会使用依赖的jar包，从lib目录中查找</li>
</ol>
<p>​		看来SpringBoot打出来了包为了能够独立运行，简直是煞费苦心，将所有需要使用的资源全部都添加到了这个包里。这就是为什么这个jar包能独立运行的原因。</p>
<p>​		再来看之前的报错信息：</p>
<img src="image-20211201094223991.png" alt="image-20211201094223991" style="zoom:67%;" />

<p>​		由于打包时没有使用那段配置，结果打包后形成了一个普通的jar包，在MANIFEST.MF文件中也就没有了Main-Class对应的属性了，所以运行时提示找不到主清单属性，这就是报错的原因。</p>
<p>​		上述内容搞清楚对我们编程意义并不大，但是对各位小伙伴理清楚SpringBoot工程独立运行的机制是有帮助的。其实整体过程主要是带着大家分析，如果以后遇到了类似的问题，多给自己提问，多问一个为什么，兴趣自己就可以独立解决问题了。</p>
<p><strong>总结</strong></p>
<ol>
<li>spring-boot-maven-plugin插件用于将当前程序打包成一个可以独立运行的程序包</li>
</ol>
<h3 id="命令行启动常见问题及解决方案"><a href="#命令行启动常见问题及解决方案" class="headerlink" title="命令行启动常见问题及解决方案"></a>命令行启动常见问题及解决方案</h3><p>​		各位小伙伴在DOS环境下启动SpringBoot工程时，可能会遇到端口占用的问题。给大家一组命令，不用深入学习，备用吧。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># 查询端口</span><br><span class="line">netstat -ano</span><br><span class="line"># 查询指定端口</span><br><span class="line">netstat -ano |findstr <span class="string">&quot;端口号&quot;</span></span><br><span class="line"># 根据进程PID查询进程名称</span><br><span class="line">tasklist |findstr <span class="string">&quot;进程PID号&quot;</span></span><br><span class="line"># 根据PID杀死任务</span><br><span class="line">taskkill /F /PID <span class="string">&quot;进程PID号&quot;</span></span><br><span class="line"># 根据进程名称杀死任务</span><br><span class="line">taskkill -f -t -im <span class="string">&quot;进程名称&quot;</span></span><br></pre></td></tr></table></figure>

<p>​		关于打包与运行程序其实还有一系列的配置和参数，下面的内容中遇到再说，这里先开个头，知道如何打包和运行程序。</p>
<h3 id="SpringBoot项目快速启动（Linux版）"><a href="#SpringBoot项目快速启动（Linux版）" class="headerlink" title="SpringBoot项目快速启动（Linux版）"></a>SpringBoot项目快速启动（Linux版）</h3><p>​		其实对于Linux系统下的程序运行与Windows系统下的程序运行差别不大，命令还是那组命令，只不过各位小伙伴可能对Linux指令不太熟悉，结果就会导致各种各样的问题发生。比如防火墙如何关闭，IP地址如何查询，JDK如何安装等等。这里不作为重点内容给大家普及了，了解一下整体过程就行了。</p>
<h2 id="YW-2-配置高级"><a href="#YW-2-配置高级" class="headerlink" title="YW-2.配置高级"></a>YW-2.配置高级</h2><p>​		关于配置在基础篇讲过一部分，基础篇的配置总体上来说就是让各位小伙伴掌握配置的格式。比如配置文件如何写啊，写好的数据如何读取啊，都是基础的语法级知识。在实用篇中就要集中在配置的应用这个方面了，下面就开始配置高级相关内容的第一部分学习，为什么说第一部分，因为在开发实用篇中还有对应的配置高级知识要进行学习。</p>
<h3 id="YW-2-1-临时属性设置"><a href="#YW-2-1-临时属性设置" class="headerlink" title="YW-2-1.临时属性设置"></a>YW-2-1.临时属性设置</h3><p>​		目前我们的程序包打好了，可以发布了。但是程序包打好以后，里面的配置都已经是固定的了，比如配置了服务器的端口是8080。如果我要启动项目，发现当前我的服务器上已经有应用启动起来并且占用了8080端口，这个时候就尴尬了。难道要重新把打包好的程序修改一下吗？比如我要把打包好的程序启动端口改成80。</p>
<p><img src="/2022/09/23/springboot%E8%BF%90%E7%BB%B4%E5%AE%9E%E7%94%A8%E7%AF%87/image-20211206095113771.png" alt="image-20211206095113771">             <img src="/2022/09/23/springboot%E8%BF%90%E7%BB%B4%E5%AE%9E%E7%94%A8%E7%AF%87/image-20211206095524343.png" alt="image-20211206095524343">             <img src="/2022/09/23/springboot%E8%BF%90%E7%BB%B4%E5%AE%9E%E7%94%A8%E7%AF%87/image-20211206095101581.png" alt="image-20211206095101581"></p>
<p>​		SpringBoot提供了灵活的配置方式，如果你发现你的项目中有个别属性需要重新配置，可以使用临时属性的方式快速修改某些配置。方法也特别简单，在启动的时候添加上对应参数就可以了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java –jar springboot.jar –-server.port=<span class="number">80</span></span><br></pre></td></tr></table></figure>

<p>​		上面的命令是启动SpringBoot程序包的命令，在命令输入完毕后，空一格，然后输入两个-号。下面按照属性名&#x3D;属性值的形式添加对应参数就可以了。记得，这里的格式不是yaml中的书写格式，当属性存在多级名称时，中间使用点分隔，和properties文件中的属性格式完全相同。</p>
<p>​		如果你发现要修改的属性不止一个，可以按照上述格式继续写，属性与属性之间使用空格分隔。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java –jar springboot.jar –-server.port=<span class="number">80</span> --logging.level.root=debug</span><br></pre></td></tr></table></figure>

<h4 id="属性加载优先级"><a href="#属性加载优先级" class="headerlink" title="属性加载优先级"></a><strong>属性加载优先级</strong></h4><p>​		现在我们的程序配置受两个地方控制了，第一配置文件，第二临时属性。并且我们发现临时属性的加载优先级要高于配置文件的。那是否还有其他的配置方式呢？其实是有的，而且还不少，打开官方文档中对应的内容，就可以查看配置读取的优先顺序。地址奉上：<a href="https://docs.spring.io/spring-boot/docs/current/reference/html/spring-boot-features.html">https://docs.spring.io/spring-boot/docs/current/reference/html/spring-boot-features.html#boot-features-external-config</a></p>
<img src="image-20211206100859236.png" alt="image-20211206100859236" style="zoom:67%;" />

<p>​		我们可以看到，居然有14种配置的位置，而我们现在使用的是这里面的2个。第3条Config data说的就是使用配置文件，第11条Command line arguments说的就是使用命令行临时参数。而这14种配置的顺序就是SpringBoot加载配置的顺序，言外之意，命令行临时属性比配置文件的加载优先级高，所以这个列表上面的优先级低，下面的优先级高。其实这个东西不用背的，你就记得一点，你最终要什么效果，你自己是知道的，不管这个顺序是怎么个高低排序，开发时一定要配置成你要的顺序为准。这个顺序只是在你想不明白问题的时候帮助你分析罢了。</p>
<p>​		比如你现在加载了一个user.name属性。结果你发现出来的结果和你想的不一样，那肯定是别的优先级比你高的属性覆盖你的配置属性了，那你就可以看着这个顺序挨个排查。哪个位置有可能覆盖了你的属性。</p>
<p>​		我在课程评论区看到小伙伴学习基础篇的时候问这个问题了，就是这个原因造成的。在yaml中配置了user.name属性值，然后读取出来的时候居然不是自己的配置值，因为在系统属性中有一个属性叫做user.name，两个相互冲突了。而系统属性的加载优先顺序在上面这个列表中是5号，高于3号，所以SpringBoot最终会加载系统配置属性user.name。</p>
<p><strong>总结</strong></p>
<ol>
<li>使用jar命令启动SpringBoot工程时可以使用临时属性替换配置文件中的属性</li>
<li>临时属性添加方式：java –jar 工程名.jar –-属性名&#x3D;值</li>
<li>多个临时属性之间使用空格分隔</li>
<li>临时属性必须是当前boot工程支持的属性，否则设置无效</li>
</ol>
<h4 id="开发环境中使用临时属性"><a href="#开发环境中使用临时属性" class="headerlink" title="开发环境中使用临时属性"></a>开发环境中使用临时属性</h4><p>​		临时使用目前是有了，但是上线的时候通过命令行输入的临时属性必须是正确的啊，那这些属性配置值我们必须在开发环境中测试好才行。下面说一下开发环境中如何使用临时属性，其实就是Idea界面下如何操作了。</p>
<p>​		打开SpringBoot引导类的运行界面，在里面找到配置项。其中Program arguments对应的位置就是添加临时属性的，可以加几个试试效果。</p>
<img src="image-20211206101947622.png" alt="image-20211206101947622" style="zoom:80%;" />

<p>​		做到这里其实可以产生一个思考了，如果对java编程熟悉的小伙伴应该知道，我们运行main方法的时候，如果想使用main方法的参数，也就是下面的args参数，就是在上面这个位置添加的参数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		原来是这样，通过这个args就可以获取到参数。再来看我们的引导类是如何书写的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    SpringApplication.run(SSMPApplication.class,args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		这个args参数居然传递给了run方法，看来在Idea中配置的临时参数就是通过这个位置传递到我们的程序中的。言外之意，这里如果不用这个args是不是就断开了外部传递临时属性的入口呢？是这样的，我们可以使用下面的调用方式，这样外部临时属性就无法进入到SpringBoot程序中了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    SpringApplication.run(SSMPApplication.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		或者还可以使用如下格式来玩这个操作，就是将配置不写在配置文件中，直接写成一个字符串数组，传递给程序入口。当然，这种做法并没有什么实际开发意义。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    String[] arg = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">1</span>];</span><br><span class="line">    arg[<span class="number">0</span>] = <span class="string">&quot;--server.port=8082&quot;</span>;</span><br><span class="line">    SpringApplication.run(SSMPApplication.class, arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结</strong></p>
<ol>
<li>启动SpringBoot程序时，可以选择是否使用命令行属性为SpringBoot程序传递启动属性</li>
</ol>
<p><strong>思考</strong></p>
<p>​		现在使用临时属性可以在启动项目前临时更改配置了，但是新的问题又出来了。临时属性好用是好用，就是写的多了会很麻烦。比如我现在有个需求，上线的时候使用临时属性配置20个值，这下可麻烦了，能不能搞得简单点，集中管理一下呢？比如说搞个文件，加载指定文件？还真可以。怎么做呢？咱们下一节再说。</p>
<h3 id="YW-2-2-配置文件分类"><a href="#YW-2-2-配置文件分类" class="headerlink" title="YW-2-2.配置文件分类"></a>YW-2-2.配置文件分类</h3><p>​		SpringBoot提供了配置文件和临时属性的方式来对程序进行配置。前面一直说的是临时属性，这一节要说说配置文件了。其实这个配置文件我们一直在使用，只不过我们用的是SpringBoot提供的4级配置文件中的其中一个级别。4个级别分别是：</p>
<ul>
<li>类路径下配置文件（一直使用的是这个，也就是resources目录中的application.yml文件）</li>
<li>类路径下config目录下配置文件</li>
<li>程序包所在目录中配置文件</li>
<li>程序包所在目录中config目录下配置文件</li>
</ul>
<p>​		好复杂，一个一个说。其实上述4种文件是提供给你了4种配置文件书写的位置，功能都是一样的，都是做配置的。那大家关心的就是差别了，没错，就是因为位置不同，产生了差异。总体上来说，4种配置文件如果都存在的话，有一个优先级的问题，说白了就是加入4个文件我都有，里面都有一样的配置，谁生效的问题。上面4个文件的加载优先顺序为</p>
<ol>
<li>file ：config&#x2F;application.yml <strong>【最高】</strong></li>
<li>file ：application.yml</li>
<li>classpath：config&#x2F;application.yml</li>
<li>classpath：application.yml  <strong>【最低】</strong></li>
</ol>
<p>​		那为什么设计这种多种呢？说一个最典型的应用吧。</p>
<ul>
<li>场景A：你作为一个开发者，你做程序的时候为了方便自己写代码，配置的数据库肯定是连接你自己本机的，咱们使用4这个级别，也就是之前一直用的application.yml。</li>
<li>场景B：现在项目开发到了一个阶段，要联调测试了，连接的数据库是测试服务器的数据库，肯定要换一组配置吧。你可以选择把你之前的文件中的内容都改了，目前还不麻烦。</li>
<li>场景C：测试完了，一切OK。你继续写你的代码，你发现你原来写的配置文件被改成测试服务器的内容了，你要再改回来。现在明白了不？场景B中把你的内容都改掉了，你现在要重新改回来，以后呢？改来改去吗？</li>
</ul>
<p>​		解决方案很简单，用上面的3这个级别的配置文件就可以快速解决这个问题，再写一个配置就行了。两个配置文件共存，因为config目录中的配置加载优先级比你的高，所以配置项如果和级别4里面的内容相同就覆盖了，这样是不是很简单？</p>
<p>​		级别1和2什么时候使用呢？程序打包以后就要用这个级别了，管你程序里面配置写的是什么？我的级别高，可以轻松覆盖你，就不用考虑这些配置冲突的问题了。</p>
<p><strong>总结</strong></p>
<ol>
<li><p>配置文件分为4种</p>
<ul>
<li>项目类路径配置文件：服务于开发人员本机开发与测试</li>
<li>项目类路径config目录中配置文件：服务于项目经理整体调控</li>
<li>工程路径配置文件：服务于运维人员配置涉密线上环境</li>
<li>工程路径config目录中配置文件：服务于运维经理整体调控</li>
</ul>
</li>
<li><p>多层级配置文件间的属性采用叠加并覆盖的形式作用于程序</p>
</li>
</ol>
<h3 id="YW-2-3-自定义配置文件"><a href="#YW-2-3-自定义配置文件" class="headerlink" title="YW-2-3.自定义配置文件"></a>YW-2-3.自定义配置文件</h3><p>​		之前咱们做配置使用的配置文件都是application.yml，其实这个文件也是可以改名字的，这样方便维护。比如我2020年4月1日搞活动，走了一组配置，2020年5月1日活动取消，恢复原始配置，这个时候只需要重新更换一下配置文件就可以了。但是你总不能在原始配置文件上修改吧，不然搞完活动以后，活动的配置就留不下来了，不利于维护。</p>
<p>​		自定义配置文件方式有如下两种：</p>
<p><strong>方式一：使用临时属性设置配置文件名，注意仅仅是名称，不要带扩展名</strong></p>
<img src="image-20211206105548238.png" alt="image-20211206105548238" style="zoom:67%;" />

<p><strong>方式二：使用临时属性设置配置文件路径，这个是全路径名</strong></p>
<img src="image-20211206105716450.png" alt="image-20211206105716450" style="zoom:67%;" />

<p>​		也可以设置加载多个配置文件</p>
<img src="image-20211206105750285.png" alt="image-20211206105750285" style="zoom:67%;" />

<p>​		使用的属性一个是spring.config.name，另一个是spring.config.location，这个一定要区别清楚。</p>
<p><font color="#f0f"><b>温馨提示</b></font></p>
<p>​		我们现在研究的都是SpringBoot单体项目，就是单服务器版本。其实企业开发现在更多的是使用基于SpringCloud技术的多服务器项目。这种配置方式和我们现在学习的完全不一样，所有的服务器将不再设置自己的配置文件，而是通过配置中心获取配置，动态加载配置信息。为什么这样做？集中管理。这里不再说这些了，后面再讲这些东西。</p>
<p><strong>总结</strong></p>
<ol>
<li>配置文件可以修改名称，通过启动参数设定</li>
<li>配置文件可以修改路径，通过启动参数设定</li>
<li>微服务开发中配置文件通过配置中心进行设置</li>
</ol>
<h2 id="YW-3-多环境开发"><a href="#YW-3-多环境开发" class="headerlink" title="YW-3.多环境开发"></a>YW-3.多环境开发</h2><p>​		讲的内容距离线上开发越来越近了，下面说一说多环境开发问题。</p>
<p>​		什么是多环境？其实就是说你的电脑上写的程序最终要放到别人的服务器上去运行。每个计算机环境不一样，这就是多环境。常见的多环境开发主要兼顾3种环境设置，开发环境——自己用的，测试环境——自己公司用的，生产环境——甲方爸爸用的。因为这是绝对不同的三台电脑，所以环境肯定有所不同，比如连接的数据库不一样，设置的访问端口不一样等等。</p>
<img src="image-20211206110958819.png" alt="image-20211206110958819" style="zoom:67%;" />

<h3 id="YW-3-1-多环境开发（yaml单一文件版）"><a href="#YW-3-1-多环境开发（yaml单一文件版）" class="headerlink" title="YW-3-1.多环境开发（yaml单一文件版）"></a>YW-3-1.多环境开发（yaml单一文件版）</h3><p>​		那什么是多环境开发？就是针对不同的环境设置不同的配置属性即可。比如你自己开发时，配置你的端口如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>

<p>​		如何想设计两组环境呢？中间使用三个减号分隔开</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">81</span></span><br></pre></td></tr></table></figure>

<p>​		如何区分两种环境呢？起名字呗</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">	<span class="attr">profiles:</span> <span class="string">pro</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">	<span class="attr">port:</span> <span class="number">80</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">	<span class="attr">profiles:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">	<span class="attr">port:</span> <span class="number">81</span></span><br></pre></td></tr></table></figure>

<p>​		那用哪一个呢？设置默认启动哪个就可以了</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">	<span class="attr">profiles:</span></span><br><span class="line">		<span class="attr">active:</span> <span class="string">pro</span>		<span class="comment"># 启动pro</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">	<span class="attr">profiles:</span> <span class="string">pro</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">	<span class="attr">port:</span> <span class="number">80</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">	<span class="attr">profiles:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">	<span class="attr">port:</span> <span class="number">81</span></span><br></pre></td></tr></table></figure>

<p>​		就这么简单，再多来一组环境也OK</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">	<span class="attr">profiles:</span></span><br><span class="line">		<span class="attr">active:</span> <span class="string">pro</span>		<span class="comment"># 启动pro</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">	<span class="attr">profiles:</span> <span class="string">pro</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">	<span class="attr">port:</span> <span class="number">80</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">	<span class="attr">profiles:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">	<span class="attr">port:</span> <span class="number">81</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">	<span class="attr">profiles:</span> <span class="string">test</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">	<span class="attr">port:</span> <span class="number">82</span></span><br></pre></td></tr></table></figure>

<p>​		其中关于环境名称定义上述格式是过时格式，标准格式如下</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">	<span class="attr">config:</span></span><br><span class="line">    	<span class="attr">activate:</span></span><br><span class="line">        	<span class="attr">on-profile:</span> <span class="string">pro</span></span><br></pre></td></tr></table></figure>

<p><strong>总结</strong></p>
<ol>
<li>多环境开发需要设置若干种常用环境，例如开发、生产、测试环境</li>
<li>yaml格式中设置多环境使用—区分环境设置边界</li>
<li>每种环境的区别在于加载的配置属性不同</li>
<li>启用某种环境时需要指定启动时使用该环境</li>
</ol>
<h3 id="YW-3-2-多环境开发（yaml多文件版）"><a href="#YW-3-2-多环境开发（yaml多文件版）" class="headerlink" title="YW-3-2.多环境开发（yaml多文件版）"></a>YW-3-2.多环境开发（yaml多文件版）</h3><p>​		将所有的配置都放在一个配置文件中，尤其是每一个配置应用场景都不一样，这显然不合理，于是就有了将一个配置文件拆分成多个配置文件的想法。拆分后，每个配置文件中写自己的配置，主配置文件中写清楚用哪一个配置文件就好了。</p>
<p><strong>主配置文件</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">	<span class="attr">profiles:</span></span><br><span class="line">		<span class="attr">active:</span> <span class="string">pro</span>		<span class="comment"># 启动pro</span></span><br></pre></td></tr></table></figure>

<p><strong>环境配置文件</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">	<span class="attr">port:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>

<p>​		环境配置文件因为每一个都是配置自己的项，所以连名字都不用写里面了。那问题是如何区分这是哪一组配置呢？使用文件名区分。</p>
<p><strong>application-pro.yaml</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">	<span class="attr">port:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>

<p><strong>application-dev.yaml</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">	<span class="attr">port:</span> <span class="number">81</span></span><br></pre></td></tr></table></figure>

<p>​		文件的命名规则为：application-环境名.yml。</p>
<p>​		在配置文件中，如果某些配置项所有环境都一样，可以将这些项写入到主配置中，只有哪些有区别的项才写入到环境配置文件中。</p>
<ul>
<li>主配置文件中设置公共配置（全局）</li>
<li>环境分类配置文件中常用于设置冲突属性（局部）</li>
</ul>
<p><strong>总结</strong></p>
<ol>
<li><p>可以使用独立配置文件定义环境属性</p>
</li>
<li><p>独立配置文件便于线上系统维护更新并保障系统安全性</p>
</li>
</ol>
<h3 id="YW-3-3-多环境开发（properties多文件版）"><a href="#YW-3-3-多环境开发（properties多文件版）" class="headerlink" title="YW-3-3.多环境开发（properties多文件版）"></a>YW-3-3.多环境开发（properties多文件版）</h3><p>​		SpringBoot最早期提供的配置文件格式是properties格式的，这种格式的多环境配置也了解一下吧。</p>
<p><strong>主配置文件</strong></p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring.profiles.active</span>=<span class="string">pro</span></span><br></pre></td></tr></table></figure>

<p><strong>环境配置文件</strong></p>
<p><strong>application-pro.properties</strong></p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">server.port</span>=<span class="string">80</span></span><br></pre></td></tr></table></figure>

<p><strong>application-dev.properties</strong></p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">server.port</span>=<span class="string">81</span></span><br></pre></td></tr></table></figure>

<p>​		文件的命名规则为：application-环境名.properties。</p>
<p><strong>总结</strong></p>
<ol>
<li>properties文件多环境配置仅支持多文件格式</li>
</ol>
<h3 id="YW-3-4-多环境开发独立配置文件书写技巧"><a href="#YW-3-4-多环境开发独立配置文件书写技巧" class="headerlink" title="YW-3-4.多环境开发独立配置文件书写技巧"></a>YW-3-4.多环境开发独立配置文件书写技巧</h3><p>​		作为程序员在搞配置的时候往往处于一种分久必合合久必分的局面。开始先写一起，后来为了方便维护就拆分。对于多环境开发也是如此，下面给大家说一下如何基于多环境开发做配置独立管理，务必掌握。</p>
<p><strong>准备工作</strong></p>
<p>​		将所有的配置根据功能对配置文件中的信息进行拆分，并制作成独立的配置文件，命名规则如下</p>
<ul>
<li>application-devDB.yml</li>
<li>application-devRedis.yml</li>
<li>application-devMVC.yml</li>
</ul>
<p><strong>使用</strong></p>
<p>​		使用include属性在激活指定环境的情况下，同时对多个环境进行加载使其生效，多个环境间使用逗号分隔</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">	<span class="attr">profiles:</span></span><br><span class="line">    	<span class="attr">active:</span> <span class="string">dev</span></span><br><span class="line">        <span class="attr">include:</span> <span class="string">devDB,devRedis,devMVC</span></span><br></pre></td></tr></table></figure>

<p>​		比较一下，现在相当于加载dev配置时，再加载对应的3组配置，从结构上就很清晰，用了什么，对应的名称是什么</p>
<p><strong>注意</strong></p>
<p>​		当主环境dev与其他环境有相同属性时，主环境属性生效；其他环境中有相同属性时，最后加载的环境属性生效</p>
<p><strong>改良</strong></p>
<p>​		但是上面的设置也有一个问题，比如我要切换dev环境为pro时，include也要修改。因为include属性只能使用一次，这就比较麻烦了。SpringBoot从2.4版开始使用group属性替代include属性，降低了配置书写量。简单说就是我先写好，你爱用哪个用哪个。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">	<span class="attr">profiles:</span></span><br><span class="line">    	<span class="attr">active:</span> <span class="string">dev</span></span><br><span class="line">        <span class="attr">group:</span></span><br><span class="line">        	<span class="attr">&quot;dev&quot;:</span> <span class="string">devDB,devRedis,devMVC</span></span><br><span class="line">      		<span class="attr">&quot;pro&quot;:</span> <span class="string">proDB,proRedis,proMVC</span></span><br><span class="line">      		<span class="attr">&quot;test&quot;:</span> <span class="string">testDB,testRedis,testMVC</span></span><br></pre></td></tr></table></figure>

<p>​		现在再来看，如果切换dev到pro，只需要改一下是不是就结束了？完美！</p>
<p><strong>总结</strong></p>
<ol>
<li>多环境开发使用group属性设置配置文件分组，便于线上维护管理</li>
</ol>
<h3 id="YW-3-5-多环境开发控制"><a href="#YW-3-5-多环境开发控制" class="headerlink" title="YW-3-5.多环境开发控制"></a>YW-3-5.多环境开发控制</h3><p>​		多环境开发到这里基本上说完了，最后说一个冲突问题。就是maven和SpringBoot同时设置多环境的话怎么搞。</p>
<p>​		要想处理这个冲突问题，你要先理清一个关系，究竟谁在多环境开发中其主导地位。也就是说如果现在都设置了多环境，谁的应该是保留下来的，另一个应该遵从相同的设置。</p>
<p>​		maven是做什么的？项目构建管理的，最终生成代码包的，SpringBoot是干什么的？简化开发的。简化，又不是其主导作用。最终还是要靠maven来管理整个工程，所以SpringBoot应该听maven的。整个确认后下面就好做了。大体思想如下：</p>
<ul>
<li>先在maven环境中设置用什么具体的环境</li>
<li>在SpringBoot中读取maven设置的环境即可</li>
</ul>
<p><strong>maven中设置多环境（使用属性方式区分环境）</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">profiles</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>env_dev<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">profile.active</span>&gt;</span>dev<span class="tag">&lt;/<span class="name">profile.active</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">activation</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">activeByDefault</span>&gt;</span>true<span class="tag">&lt;/<span class="name">activeByDefault</span>&gt;</span>		<span class="comment">&lt;!--默认启动环境--&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>env_pro<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">profile.active</span>&gt;</span>pro<span class="tag">&lt;/<span class="name">profile.active</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">profiles</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>SpringBoot中读取maven设置值</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">	<span class="attr">profiles:</span></span><br><span class="line">    	<span class="attr">active:</span> <span class="string">@profile.active@</span></span><br></pre></td></tr></table></figure>

<p>​		上面的@属性名@就是读取maven中配置的属性值的语法格式。</p>
<p><strong>总结</strong></p>
<ol>
<li>当Maven与SpringBoot同时对多环境进行控制时，以Mavn为主，SpringBoot使用@..@占位符读取Maven对应的配置属性值</li>
<li>基于SpringBoot读取Maven配置属性的前提下，如果在Idea下测试工程时pom.xml每次更新需要手动compile方可生效</li>
</ol>
<h2 id="YW-4-日志"><a href="#YW-4-日志" class="headerlink" title="YW-4.日志"></a>YW-4.日志</h2><p>​		运维篇最后一部分我们来聊聊日志，日志大家不陌生，简单介绍一下。日志其实就是记录程序日常运行的信息，主要作用如下：</p>
<ul>
<li>编程期调试代码</li>
<li>运营期记录信息</li>
<li>记录日常运营重要信息（峰值流量、平均响应时长……）</li>
<li>记录应用报错信息（错误堆栈）</li>
<li>记录运维过程数据（扩容、宕机、报警……）</li>
</ul>
<p>​		或许各位小伙伴并不习惯于使用日志，没关系，慢慢多用，习惯就好。想进大厂，这是最基本的，别去面试的时候说没用过，完了，没机会了。</p>
<h4 id="YW-4-1-代码中使用日志工具记录日志"><a href="#YW-4-1-代码中使用日志工具记录日志" class="headerlink" title="YW-4-1.代码中使用日志工具记录日志"></a>YW-4-1.代码中使用日志工具记录日志</h4><p>​		日志的使用格式非常固定，直接上操作步骤：</p>
<p><strong>步骤①</strong>：添加日志记录操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/books&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookController</span> <span class="keyword">extends</span> <span class="title class_">BaseClass</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(BookController.class);</span><br><span class="line">    <span class="meta">@GetMapping</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getById</span><span class="params">()</span>&#123;</span><br><span class="line">        log.debug(<span class="string">&quot;debug...&quot;</span>);</span><br><span class="line">        log.info(<span class="string">&quot;info...&quot;</span>);</span><br><span class="line">        log.warn(<span class="string">&quot;warn...&quot;</span>);</span><br><span class="line">        log.error(<span class="string">&quot;error...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;springboot is running...2&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		上述代码中log对象就是用来记录日志的对象，下面的log.debug，log.info这些操作就是写日志的API了。</p>
<p><strong>步骤②</strong>：设置日志输出级别</p>
<p>​		日志设置好以后可以根据设置选择哪些参与记录。这里是根据日志的级别来设置的。日志的级别分为6种，分别是：</p>
<ul>
<li>TRACE：运行堆栈信息，使用率低</li>
<li>DEBUG：程序员调试代码使用</li>
<li>INFO：记录运维过程数据</li>
<li>WARN：记录运维过程报警数据</li>
<li>ERROR：记录错误堆栈信息</li>
<li>FATAL：灾难信息，合并计入ERROR</li>
</ul>
<p>​		一般情况下，开发时候使用DEBUG，上线后使用INFO，运维信息记录使用WARN即可。下面就设置一下日志级别：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 开启debug模式，输出调试信息，常用于检查系统运行状况</span></span><br><span class="line"><span class="attr">debug:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>​		这么设置太简单粗暴了，日志系统通常都提供了细粒度的控制</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 开启debug模式，输出调试信息，常用于检查系统运行状况</span></span><br><span class="line"><span class="attr">debug:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置日志级别，root表示根节点，即整体应用日志级别</span></span><br><span class="line"><span class="attr">logging:</span></span><br><span class="line">	<span class="attr">level:</span></span><br><span class="line">    	<span class="attr">root:</span> <span class="string">debug</span></span><br></pre></td></tr></table></figure>

<p>​		还可以再设置更细粒度的控制</p>
<p><strong>步骤③</strong>：设置日志组，控制指定包对应的日志输出级别，也可以直接控制指定包对应的日志输出级别</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">logging:</span></span><br><span class="line">	<span class="comment"># 设置日志组</span></span><br><span class="line">    <span class="attr">group:</span></span><br><span class="line">    	<span class="comment"># 自定义组名，设置当前组中所包含的包</span></span><br><span class="line">        <span class="attr">ebank:</span> <span class="string">com.itheima.controller</span></span><br><span class="line">    <span class="attr">level:</span></span><br><span class="line">    	<span class="attr">root:</span> <span class="string">warn</span></span><br><span class="line">        <span class="comment"># 为对应组设置日志级别</span></span><br><span class="line">        <span class="attr">ebank:</span> <span class="string">debug</span></span><br><span class="line">    	<span class="comment"># 为对包设置日志级别</span></span><br><span class="line">        <span class="attr">com.itheima.controller:</span> <span class="string">debug</span></span><br></pre></td></tr></table></figure>

<p>​		说白了就是总体设置一下，每个包设置一下，如果感觉设置的麻烦，就先把包分个组，对组设置，没了，就这些。</p>
<p><strong>总结</strong></p>
<ol>
<li>日志用于记录开发调试与运维过程消息</li>
<li>日志的级别共6种，通常使用4种即可，分别是DEBUG，INFO,WARN,ERROR</li>
<li>可以通过日志组或代码包的形式进行日志显示级别的控制</li>
</ol>
<h4 id="教你一招：优化日志对象创建代码"><a href="#教你一招：优化日志对象创建代码" class="headerlink" title="教你一招：优化日志对象创建代码"></a>教你一招：优化日志对象创建代码</h4><p>​		写代码的时候每个类都要写创建日志记录对象，这个可以优化一下，使用前面用过的lombok技术给我们提供的工具类即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/books&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookController</span> <span class="keyword">extends</span> <span class="title class_">BaseClass</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(BookController.class);	<span class="comment">//这一句可以不写了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		导入lombok后使用注解搞定，日志对象名为log</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span>		<span class="comment">//这个注解替代了下面那一行</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/books&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookController</span> <span class="keyword">extends</span> <span class="title class_">BaseClass</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(BookController.class);	<span class="comment">//这一句可以不写了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结</strong></p>
<ol>
<li>基于lombok提供的@Slf4j注解为类快速添加日志对象</li>
</ol>
<h4 id="YW-4-2-日志输出格式控制"><a href="#YW-4-2-日志输出格式控制" class="headerlink" title="YW-4-2.日志输出格式控制"></a>YW-4-2.日志输出格式控制</h4><p>​		日志已经能够记录了，但是目前记录的格式是SpringBoot给我们提供的，如果想自定义控制就需要自己设置了。先分析一下当前日志的记录格式。</p>
<p><img src="/2022/09/23/springboot%E8%BF%90%E7%BB%B4%E5%AE%9E%E7%94%A8%E7%AF%87/image-20211206123431222.png" alt="image-20211206123431222"></p>
<p>​		对于单条日志信息来说，日期，触发位置，记录信息是最核心的信息。级别用于做筛选过滤，PID与线程名用于做精准分析。了解这些信息后就可以DIY日志格式了。本课程不做详细的研究，有兴趣的小伙伴可以学习相关的知识。下面给出课程中模拟的官方日志模板的书写格式，便于大家学习。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">logging:</span></span><br><span class="line">	<span class="attr">pattern:</span></span><br><span class="line">    	<span class="attr">console:</span> <span class="string">&quot;%d %clr(%p) --- [%16t] %clr(%-40.40c)&#123;cyan&#125; : %m %n&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>总结</strong></p>
<ol>
<li>日志输出格式设置规则</li>
</ol>
<h4 id="YW-4-3-日志文件"><a href="#YW-4-3-日志文件" class="headerlink" title="YW-4-3.日志文件"></a>YW-4-3.日志文件</h4><p>​		日志信息显示，记录已经控制住了，下面就要说一下日志的转存了。日志不能仅显示在控制台上，要把日志记录到文件中，方便后期维护查阅。</p>
<p>​		对于日志文件的使用存在各种各样的策略，例如每日记录，分类记录，报警后记录等。这里主要研究日志文件如何记录。</p>
<p>​		记录日志到文件中格式非常简单，设置日志文件名即可。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">logging:</span></span><br><span class="line">	<span class="attr">file:</span></span><br><span class="line">    	<span class="attr">name:</span> <span class="string">server.log</span></span><br></pre></td></tr></table></figure>

<p>​		虽然使用上述格式可以将日志记录下来了，但是面对线上的复杂情况，一个文件记录肯定是不能够满足运维要求的，通常会每天记录日志文件，同时为了便于维护，还要限制每个日志文件的大小。下面给出日志文件的常用配置方式：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">logging:</span></span><br><span class="line">	<span class="attr">logback:</span></span><br><span class="line">    	<span class="attr">rollingpolicy:</span></span><br><span class="line">        	<span class="attr">max-file-size:</span> <span class="string">3KB</span></span><br><span class="line">            <span class="attr">file-name-pattern:</span> <span class="string">server.%d&#123;yyyy-MM-dd&#125;.%i.log</span></span><br></pre></td></tr></table></figure>

<p>​		以上格式是基于logback日志技术设置每日日志文件的设置格式，要求容量到达3KB以后就转存信息到第二个文件中。文件命名规则中的%d标识日期，%i是一个递增变量，用于区分日志文件。</p>
<p><strong>总结</strong></p>
<ol>
<li>日志记录到文件</li>
<li>日志文件格式设置</li>
</ol>
<h2 id="运维实用篇完结"><a href="#运维实用篇完结" class="headerlink" title="运维实用篇完结"></a>运维实用篇完结</h2><p>​		运维实用篇到这里就要先告一段落了，为什么不说结束呢？因为运维篇中还有一些知识，但是现在讲解过于分散了。所以要把这些知识与开发实用篇的知识结合在一起讲，也是本课程的教学设计的体现。</p>
<p>​		在整体运维实用篇中带着大家学习了4块内容，首先学习了如何运行SpringBoot程序，也就是程序的打包与运行，接下来对配置进行了升级学习，不再局限在配置文件中进行设置，通过临时属性，外部配置文件对项目的配置进行管控。在多环境开发中给大家介绍了多种多环境开发的格式，其实掌握一种即可，此外还给大家讲了多环境开发的一些技巧以及与maven的冲突解决方案。最后给大家介绍了日志系统，老实说日志这里讲的相当的潦草，因为大部分日志相关的知识都不应该在这门课中学习，这里只是告诉大家如何整合实用而已。</p>
<p>​		看了各位小伙伴的评论，知道你们再催更，我也在加油，一起努力吧，实用开发篇再会。实用开发篇会提高更新频度，不全部做完给大家更新了，我先把做好的一部分开放出来，随后做完一点就更新一点，额，好吧，就说到这里吧。</p>
]]></content>
      <categories>
        <category>boot系列</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title>springboot原理篇</title>
    <url>/2022/09/23/springboot%E5%8E%9F%E7%90%86%E7%AF%87/</url>
    <content><![CDATA[<p>​		在学习前面三篇的时候，好多小伙伴一直在B站评论区嚷嚷着期待原理篇，今天可以正式的宣布了，他来了他来了他脚踏祥云进来了（此处请自行脑补BGM）。</p>
<p>​		其实从本人的角度出发，看了这么多学习java的小伙伴的学习过程，个人观点，不建议小伙伴过早的去研究技术的原理。原因有二：一，<strong>先应用熟练</strong>，<strong>培养技术应用的条件反射</strong>，然后再学原理。大把的学习者天天还纠结于这里少写一个这，那里少写一个那，程序都跑不下去，要啥原理，要啥自行车。这里要说一句啊，懂不懂啥意思那不叫原理，原理是抽象到顶层设计层面的东西。知道为什么写这句话，知道错误的原因和懂原理是两码事。二， <strong>原理真不是看源码</strong>，源码只能称作原理的落地实现方式，当好的落地实现方式出现后，就会有新旧版本的迭代，底层实现方式也会伴随着更新升级。但是原理不变，只是找到了更好的实现最初目标的路径。一个好的课程，一位好的老师，不会用若干行云里雾里的源代码把学习者带到沟里，然后爬不出来，深陷泥潭。一边沮丧的看着源码，一边舔着老师奉其为大神，这就叫不干人事。原理就应该使用最通俗易懂的语言，把设计思想讲出来，至于看源码，只是因为目前的技术原创人员只想到了当前这种最笨的设计方案，还没有更好的。比如spirng程序，写起来很费劲，springboot出来以后就简单轻松了很多，实现方案变了，原理不变。但凡你想通过下面的课程学习去读懂若干行代码，然后特别装逼的告诉自己，我懂原理了。我只能告诉你，你选了一条成本最高的路线，看源码仅仅是验证原理，源码仅对应程序流程，不对应原理。原理是思想级的，不是代码级的，原理是原本的道理。</p>
<p>​		springboot技术本身就是为了加速spring程序的开发的，可以大胆的说，springboot技术没有自己的原理层面的设计，仅仅是实现方案进行了改进。将springboot定位成工具，你就不会去想方设法的学习其原理了。就像是将木头分割成若干份，我们可以用斧子，用锯子，用刀，用火烧或者一脚踹断它，这些都是方式方法，而究其本质底层原理是植物纤维的组织方式，研究完这个，你再看前述的各种工具，都是基于这个原理在说如何变更破坏这种植物纤维的方式。所以不要一张嘴说了若干种技术，然后告诉自己，这就是spirngboot的原理。没有的事，springboot作为一款工具，压根就没有原理。我们下面要学习的其实就是spirngboot程序的工作流程。</p>
<p>​		下面就开始学习原理篇，因为没有想出来特别好的名字，所以还是先称作原理篇吧。原理篇中包含如下内容：</p>
<ul>
<li>自动配置工作流程</li>
<li>自定义starter开发</li>
<li>springboot程序启动流程</li>
</ul>
<p>​		下面开启第一部分自动配置工作流程的学习</p>
<h2 id="YL-1-自动配置工作流程"><a href="#YL-1-自动配置工作流程" class="headerlink" title="YL-1.自动配置工作流程"></a>YL-1.自动配置工作流程</h2><p>​		自动配置是springboot技术非常好用的核心因素，前面学习了这么多种技术的整合，每一个都离不开自动配置。不过在学习自动配置的时候，需要你对spring容器如何进行bean管理的过程非常熟悉才行，所以这里需要先复习一下有关spring技术中bean加载相关的知识。方式方法很多，逐一快速复习一下，查漏补缺。不过这里需要声明一点，这里列出的bean的加载方式仅仅应用于后面课程的学习，并不是所有的spring加载bean的方式。跟着我的步伐一种一种的复习，他们这些方案之间有千丝万缕的关系，顺着看完，你就懂自动配置是怎么回事了。</p>
<h3 id="YL-1-1-bean的加载方式"><a href="#YL-1-1-bean的加载方式" class="headerlink" title="YL-1-1.bean的加载方式"></a>YL-1-1.bean的加载方式</h3><p>​		关于bean的加载方式，spring提供了各种各样的形式。因为spring管理bean整体上来说就是由spring维护对象的生命周期，所以bean的加载可以从大的方面划分成2种形式。已知类并交给spring管理，和已知类名并交给spring管理。有什么区别？一个给.class，一个给类名字符串。内部其实都一样，都是通过spring的BeanDefinition对象初始化spring的bean。如果前面这句话看起来有障碍，可以去复习一下spring的相关知识。B站中有我尊敬的满一航老师录制的spring高级课程，链接地址如下，欢迎大家捧场，记得一键三连哦。</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="function">https://<span class="title">www.bilibili.com</span>/<span class="title">video</span>/<span class="title">BV1P44y1N7QG</span></span></span><br></pre></td></tr></table></figure>

<h4 id="方式一：配置文件-lt-bean-gt-标签"><a href="#方式一：配置文件-lt-bean-gt-标签" class="headerlink" title="方式一：配置文件+&lt;bean/&gt;标签"></a>方式一：配置文件+<code>&lt;bean/&gt;</code>标签</h4><p>​		最高端的食材往往只需要最简单的烹饪方法，搞错了，再来。最初级的bean的加载方式其实可以直击spring管控bean的核心思想，就是提供类名，然后spring就可以管理了。所以第一种方式就是给出bean的类名，至于内部嘛就是反射机制加载成class，然后，就没有然后了，拿到了class你就可以搞定一切了。如果这句话听不太懂，请这些小盆友转战java基础高级部分复习一下反射相关知识。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--xml方式声明自己开发的bean--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;cat&quot;</span> <span class="attr">class</span>=<span class="string">&quot;Cat&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;Dog&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--xml方式声明第三方开发的bean--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="方式二：配置文件扫描-注解定义bean"><a href="#方式二：配置文件扫描-注解定义bean" class="headerlink" title="方式二：配置文件扫描+注解定义bean"></a>方式二：配置文件扫描+注解定义bean</h4><p>​		由于方式一种需要将spring管控的bean全部写在xml文件中，对于程序员来说非常不友好，所以就有了第二种方式。哪一个类要受到spring管控加载成bean，就在这个类的上面加一个注解，还可以顺带起一个bean的名字（id）。这里可以使用的注解有@Component以及三个衍生注解@Service、@Controller、@Repository。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component(&quot;tom&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cat</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Mouse</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		当然，由于我们无法在第三方提供的技术源代码中去添加上述4个注解，因此当你需要加载第三方开发的bean的时候可以使用下列方式定义注解式的bean。@Bean定义在一个方法上方，当前方法的返回值就可以交给spring管控，记得这个方法所在的类一定要定义在@Component修饰的类中，有人会说不是@Configuration吗？建议把spring注解开发相关课程学习一下，就不会有这个疑问了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DbConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DruidDataSource <span class="title function_">dataSource</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">DruidDataSource</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">        <span class="keyword">return</span> ds;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		上面提供的仅仅是bean的声明，spring并没有感知到这些东西，像极了上课积极回答问题的你，手举的非常高，可惜老师都没有往你的方向看上一眼。想让spring感知到这些积极的小伙伴，必须设置spring去检查这些类，看他们是否贴标签，想当积极分子。可以通过下列xml配置设置spring去检查哪些包，发现定了对应注解，就将对应的类纳入spring管控范围，声明成bean。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">    &quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--指定扫描加载bean的位置--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.itheima.bean,com.itheima.config&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>​		方式二声明bean的方式是目前企业中较为常见的bean的声明方式，但是也有缺点。方式一中，通过一个配置文件，你可以查阅当前spring环境中定义了多少个或者说多少种bean，但是方式二没有任何一个地方可以查阅整体信息，只有当程序运行起来才能感知到加载了多少个bean。</p>
<h4 id="方式三：注解方式声明配置类"><a href="#方式三：注解方式声明配置类" class="headerlink" title="方式三：注解方式声明配置类"></a>方式三：注解方式声明配置类</h4><p>​		方式二已经完美的简化了bean的声明，以后再也不用写茫茫多的配置信息了。仔细观察xml配置文件，会发现这个文件中只剩了扫描包这句话，于是就有人提出，使用java类替换掉这种固定格式的配置，所以下面这种格式就出现了。严格意义上讲不能算全新的方式，但是由于此种开发形式是企业级开发中的主流形式，所以单独独立出来做成一种方式。嗯……，怎么说呢？方式二和方式三其实差别还是挺大的，番外篇找个时间再聊吧。</p>
<p>​		定义一个类并使用@ComponentScan替代原始xml配置中的包扫描这个动作，其实功能基本相同。为什么说基本，还是有差别的。先卖个关子吧，番外篇再聊。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ComponentScan(&#123;&quot;com.itheima.bean&quot;,&quot;com.itheima.config&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig3</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DogFactoryBean <span class="title function_">dog</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DogFactoryBean</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="使用FactroyBean接口"><a href="#使用FactroyBean接口" class="headerlink" title="使用FactroyBean接口"></a>使用FactroyBean接口</h5><p>​		补充一个小知识，spring提供了一个接口FactoryBean，也可以用于声明bean，只不过实现了FactoryBean接口的类造出来的对象不是当前类的对象，而是FactoryBean接口泛型指定类型的对象。如下列，造出来的bean并不是DogFactoryBean，而是Dog。有什么用呢？可以在对象初始化前做一些事情，下例中的注释位置就是让你自己去扩展要做的其他事情的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DogFactoryBean</span> <span class="keyword">implements</span> <span class="title class_">FactoryBean</span>&lt;Dog&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Dog <span class="title function_">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Dog</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">        <span class="comment">//.........</span></span><br><span class="line">        <span class="keyword">return</span> d;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">        <span class="keyword">return</span> Dog.class;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSingleton</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		有人说，注释中的代码写入Dog的构造方法不就行了吗？干嘛这么费劲转一圈，还写个类，还要实现接口，多麻烦啊。还真不一样，你可以理解为Dog是一个抽象后剥离的特别干净的模型，但是实际使用的时候必须进行一系列的初始化动作。只不过根据情况不同，初始化动作不同而已。如果写入Dog，或许初始化动作A当前并不能满足你的需要，这个时候你就要做一个DogB的方案了。然后，就没有然后了，你就要做两个Dog类。当时使用FactoryBean接口就可以完美解决这个问题。</p>
<p>​		通常实现了FactoryBean接口的类使用@Bean的形式进行加载，当然你也可以使用@Component去声明DogFactoryBean，只要被扫描加载到即可，但是这种格式加载总觉得怪怪的，指向性不是很明确。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ComponentScan(&#123;&quot;com.itheima.bean&quot;,&quot;com.itheima.config&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig3</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DogFactoryBean <span class="title function_">dog</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DogFactoryBean</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="注解格式导入XML格式配置的bean"><a href="#注解格式导入XML格式配置的bean" class="headerlink" title="注解格式导入XML格式配置的bean"></a>注解格式导入XML格式配置的bean</h5><p>​		再补充一个小知识，由于早起开发的系统大部分都是采用xml的形式配置bean，现在的企业级开发基本上不用这种模式了。但是如果你特别幸运，需要基于之前的系统进行二次开发，这就尴尬了。新开发的用注解格式，之前开发的是xml格式。这个时候可不是让你选择用哪种模式的，而是两种要同时使用。spring提供了一个注解可以解决这个问题，@ImportResource，在配置类上直接写上要被融合的xml配置文件名即可，算的上一种兼容性解决方案，没啥实际意义。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ImportResource(&quot;applicationContext1.xml&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig32</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="proxyBeanMethods属性"><a href="#proxyBeanMethods属性" class="headerlink" title="proxyBeanMethods属性"></a>proxyBeanMethods属性</h5><p>​		前面的例子中用到了@Configuration这个注解，当我们使用AnnotationConfigApplicationContext加载配置类的时候，配置类可以不添加这个注解。但是这个注解有一个更加强大的功能，它可以保障配置类中使用方法创建的bean的唯一性。为@Configuration注解设置proxyBeanMethods属性值为true即可，由于此属性默认值为true，所以很少看见明确书写的，除非想放弃此功能。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig33</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Cat <span class="title function_">cat</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		下面通过容器再调用上面的cat方法时，得到的就是同一个对象了。注意，必须使用spring容器对象调用此方法才有保持bean唯一性的特性。此特性在很多底层源码中有应用，前面讲MQ时，也应用了此特性，只不过当前没有解释而已。这里算是填个坑吧。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App33</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(SpringConfig33.class);</span><br><span class="line">        String[] names = ctx.getBeanDefinitionNames();</span><br><span class="line">        <span class="keyword">for</span> (String name : names) &#123;</span><br><span class="line">            System.out.println(name);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;-------------------------&quot;</span>);</span><br><span class="line">        <span class="type">SpringConfig33</span> <span class="variable">springConfig33</span> <span class="operator">=</span> ctx.getBean(<span class="string">&quot;springConfig33&quot;</span>, SpringConfig33.class);</span><br><span class="line">        System.out.println(springConfig33.cat());</span><br><span class="line">        System.out.println(springConfig33.cat());</span><br><span class="line">        System.out.println(springConfig33.cat());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="方式四：使用-Import注解注入bean"><a href="#方式四：使用-Import注解注入bean" class="headerlink" title="方式四：使用@Import注解注入bean"></a>方式四：使用@Import注解注入bean</h4><p>​		使用扫描的方式加载bean是企业级开发中常见的bean的加载方式，但是由于扫描的时候不仅可以加载到你要的东西，还有可能加载到各种各样的乱七八糟的东西，万一没有控制好得不偿失了。</p>
<p>​		有人就会奇怪，会有什么问题呢？比如你扫描了com.itheima.service包，后来因为业务需要，又扫描了com.itheima.dao包，你发现com.itheima包下面只有service和dao这两个包，这就简单了，直接扫描com.itheima就行了。但是万万没想到，十天后你加入了一个外部依赖包，里面也有com.itheima包，这下就热闹了，该来的不该来的全来了。</p>
<p>​		所以我们需要一种精准制导的加载方式，使用@Import注解就可以解决你的问题。它可以加载所有的一切，只需要在注解的参数中写上加载的类对应的.class即可。有人就会觉得，还要自己手写，多麻烦，不如扫描好用。对呀，但是他可以指定加载啊，好的命名规范配合@ComponentScan可以解决很多问题，但是@Import注解拥有其重要的应用场景。有没有想过假如你要加载的bean没有使用@Component修饰呢？这下就无解了，而@Import就无需考虑这个问题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Import(&#123;Dog.class,DbConfig.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig4</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="使用-Import注解注入配置类"><a href="#使用-Import注解注入配置类" class="headerlink" title="使用@Import注解注入配置类"></a>使用@Import注解注入配置类</h5><p>​		除了加载bean，还可以使用@Import注解加载配置类。其实本质上是一样的，不解释太多了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Import(DogFactoryBean.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig4</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="方式五：编程形式注册bean"><a href="#方式五：编程形式注册bean" class="headerlink" title="方式五：编程形式注册bean"></a>方式五：编程形式注册bean</h4><p>​		前面介绍的加载bean的方式都是在容器启动阶段完成bean的加载，下面这种方式就比较特殊了，可以在容器初始化完成后手动加载bean。通过这种方式可以实现编程式控制bean的加载。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App5</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AnnotationConfigApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(SpringConfig.class);</span><br><span class="line">        <span class="comment">//上下文容器对象已经初始化完毕后，手工加载bean</span></span><br><span class="line">        ctx.register(Mouse.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		其实这种方式坑还是挺多的，比如容器中已经有了某种类型的bean，再加载会不会覆盖呢？这都是要思考和关注的问题。新手慎用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App5</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AnnotationConfigApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(SpringConfig.class);</span><br><span class="line">        <span class="comment">//上下文容器对象已经初始化完毕后，手工加载bean</span></span><br><span class="line">        ctx.registerBean(<span class="string">&quot;tom&quot;</span>, Cat.class,<span class="number">0</span>);</span><br><span class="line">        ctx.registerBean(<span class="string">&quot;tom&quot;</span>, Cat.class,<span class="number">1</span>);</span><br><span class="line">        ctx.registerBean(<span class="string">&quot;tom&quot;</span>, Cat.class,<span class="number">2</span>);</span><br><span class="line">        System.out.println(ctx.getBean(Cat.class));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="方式六：导入实现了ImportSelector接口的类"><a href="#方式六：导入实现了ImportSelector接口的类" class="headerlink" title="方式六：导入实现了ImportSelector接口的类"></a>方式六：导入实现了ImportSelector接口的类</h4><p>​		在方式五种，我们感受了bean的加载可以进行编程化的控制，添加if语句就可以实现bean的加载控制了。但是毕竟是在容器初始化后实现bean的加载控制，那是否可以在容器初始化过程中进行控制呢？答案是必须的。实现ImportSelector接口的类可以设置加载的bean的全路径类名，记得一点，只要能编程就能判定，能判定意味着可以控制程序的运行走向，进而控制一切。</p>
<p>​		现在又多了一种控制bean加载的方式，或者说是选择bean的方式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyImportSelector</span> <span class="keyword">implements</span> <span class="title class_">ImportSelector</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String[] selectImports(AnnotationMetadata metadata) &#123;</span><br><span class="line">        <span class="comment">//各种条件的判定，判定完毕后，决定是否装载指定的bean</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> metadata.hasAnnotation(<span class="string">&quot;org.springframework.context.annotation.Configuration&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;com.itheima.bean.Dog&quot;</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;com.itheima.bean.Cat&quot;</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="方式七：导入实现了ImportBeanDefinitionRegistrar接口的类"><a href="#方式七：导入实现了ImportBeanDefinitionRegistrar接口的类" class="headerlink" title="方式七：导入实现了ImportBeanDefinitionRegistrar接口的类"></a>方式七：导入实现了ImportBeanDefinitionRegistrar接口的类</h4><p>​		方式六中提供了给定类全路径类名控制bean加载的形式，如果对spring的bean的加载原理比较熟悉的小伙伴知道，其实bean的加载不是一个简简单单的对象，spring中定义了一个叫做BeanDefinition的东西，它才是控制bean初始化加载的核心。BeanDefinition接口中给出了若干种方法，可以控制bean的相关属性。说个最简单的，创建的对象是单例还是非单例，在BeanDefinition中定义了scope属性就可以控制这个。如果你感觉方式六没有给你开放出足够的对bean的控制操作，那么方式七你值得拥有。我们可以通过定义一个类，然后实现ImportBeanDefinitionRegistrar接口的方式定义bean，并且还可以让你对bean的初始化进行更加细粒度的控制，不过对于新手并不是很友好。忽然给你开放了若干个操作，还真不知道如何下手。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRegistrar</span> <span class="keyword">implements</span> <span class="title class_">ImportBeanDefinitionRegistrar</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerBeanDefinitions</span><span class="params">(AnnotationMetadata metadata, BeanDefinitionRegistry registry)</span> &#123;</span><br><span class="line">        <span class="type">BeanDefinition</span> <span class="variable">beanDefinition</span> <span class="operator">=</span> 	</span><br><span class="line">            BeanDefinitionBuilder.rootBeanDefinition(BookServiceImpl2.class).getBeanDefinition();</span><br><span class="line">        registry.registerBeanDefinition(<span class="string">&quot;bookService&quot;</span>,beanDefinition);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="方式八：导入实现了BeanDefinitionRegistryPostProcessor接口的类"><a href="#方式八：导入实现了BeanDefinitionRegistryPostProcessor接口的类" class="headerlink" title="方式八：导入实现了BeanDefinitionRegistryPostProcessor接口的类"></a>方式八：导入实现了BeanDefinitionRegistryPostProcessor接口的类</h4><p>​		上述七种方式都是在容器初始化过程中进行bean的加载或者声明，但是这里有一个bug。这么多种方式，它们之间如果有冲突怎么办？谁能有最终裁定权？这是个好问题，当某种类型的bean被接二连三的使用各种方式加载后，在你对所有加载方式的加载顺序没有完全理解清晰之前，你还真不知道最后谁说了算。即便你理清楚了，保不齐和你一起开发的猪队友又添加了一个bean，得嘞，这下就热闹了。</p>
<p>​		spring挥舞它仲裁者的大刀来了一个致命一击，都别哔哔了，我说了算，BeanDefinitionRegistryPostProcessor，看名字知道，BeanDefinition意思是bean定义，Registry注册的意思，Post后置，Processor处理器，全称bean定义后处理器，干啥的？在所有bean注册都折腾完后，它把最后一道关，说白了，它说了算，这下消停了，它是最后一个运行的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyPostProcessor</span> <span class="keyword">implements</span> <span class="title class_">BeanDefinitionRegistryPostProcessor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postProcessBeanDefinitionRegistry</span><span class="params">(BeanDefinitionRegistry registry)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="type">BeanDefinition</span> <span class="variable">beanDefinition</span> <span class="operator">=</span> </span><br><span class="line">            BeanDefinitionBuilder.rootBeanDefinition(BookServiceImpl4.class).getBeanDefinition();</span><br><span class="line">        registry.registerBeanDefinition(<span class="string">&quot;bookService&quot;</span>,beanDefinition);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​		总体上来说，上面介绍了各种各样的bean的注册加载初始化方式，脑子里建立个概念吧，方式很多，spring源码中大量运用各种方式。复习的内容就先说到这里。</p>
<p><strong>总结</strong></p>
<ol>
<li>bean的定义由前期xml配置逐步演化成注解配置，本质是一样的，都是通过反射机制加载类名后创建对象，对象就是spring管控的bean</li>
<li>@Import注解可以指定加载某一个类作为spring管控的bean，如果被加载的类中还具有@Bean相关的定义，会被一同加载</li>
<li>spring开放出了若干种可编程控制的bean的初始化方式，通过分支语句由固定的加载bean转成了可以选择bean是否加载或者选择加载哪一种bean</li>
</ol>
<h3 id="YL-1-2-bean的加载控制"><a href="#YL-1-2-bean的加载控制" class="headerlink" title="YL-1-2.bean的加载控制"></a>YL-1-2.bean的加载控制</h3><p>​		前面复习bean的加载时，提出了有关加载控制的方式，其中手工注册bean，ImportSelector接口，ImportBeanDefinitionRegistrar接口，BeanDefinitionRegistryPostProcessor接口都可以控制bean的加载，这一节就来说说这些加载控制。</p>
<p>​		企业级开发中不可能在spring容器中进行bean的饱和式加载的。什么是饱和式加载，就是不管用不用，全部加载。比如jdk中有两万个类，那就加载两万个bean，显然是不合理的，因为你压根就不会使用其中大部分的bean。那合理的加载方式是什么？肯定是必要性加载，就是用什么加载什么。继续思考，加载哪些bean通常受什么影响呢？最容易想的就是你要用什么技术，就加载对应的bean。用什么技术意味着什么？就是加载对应技术的类。所以在spring容器中，通过判定是否加载了某个类来控制某些bean的加载是一种常见操作。下例给出了对应的代码实现，其实思想很简单，先判断一个类的全路径名是否能够成功加载，加载成功说明有这个类，那就干某项具体的工作，否则就干别的工作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyImportSelector</span> <span class="keyword">implements</span> <span class="title class_">ImportSelector</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String[] selectImports(AnnotationMetadata importingClassMetadata) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class&lt;?&gt; clazz = Class.forName(<span class="string">&quot;com.itheima.bean.Mouse&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span>(clazz != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;com.itheima.bean.Cat&quot;</span>&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line"><span class="comment">//            e.printStackTrace();</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		通过上述的分析，可以看到此类操作将成为企业级开发中的常见操作，于是springboot将把这些常用操作给我们做了一次封装。这种逻辑判定你开发者就别搞了，我springboot信不过你这种新手开发者，我给你封装一下，做几个注解，你填参数吧，耶，happy。</p>
<p>​		下例使用@ConditionalOnClass注解实现了当虚拟机中加载了com.itheima.bean.Wolf类时加载对应的bean。比较一下上面的代码和下面的代码，有没有感觉很清爽。其实此类注解还有很多。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(name = &quot;com.itheima.bean.Wolf&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Cat <span class="title function_">tom</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		@ConditionalOnMissingClass注解控制虚拟机中没有加载指定的类才加载对应的bean。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingClass(&quot;com.itheima.bean.Dog&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Cat <span class="title function_">tom</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		这种条件还可以做并且的逻辑关系，写2个就是2个条件都成立，写多个就是多个条件都成立。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(name = &quot;com.itheima.bean.Wolf&quot;)</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingClass(&quot;com.itheima.bean.Mouse&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Cat <span class="title function_">tom</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		除了判定是否加载类，还可以对当前容器类型做判定，下例是判定当前容器环境是否是web环境。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnWebApplication</span></span><br><span class="line"><span class="keyword">public</span> Cat <span class="title function_">tom</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		下面是判定容器环境是否是非web环境。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnNotWebApplication</span></span><br><span class="line"><span class="keyword">public</span> Cat <span class="title function_">tom</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		当然还可以判定是否加载了指定名称的bean，这种有什么用呢？太有用了。比如当前容器中已经提供了jdbcTemplate对应的bean，你还需要再加载一个全新的jdbcTemplate的bean吗？没有必要了嘛。spring说，如果你自己写的话，我就不帮你操这份心了，如果你没写，我再给你提供。自适应，自适应，明白？没有的话就提供给你，有的话就用你自己的，是不是很帅？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnBean(name=&quot;jerry&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Cat <span class="title function_">tom</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		以下就是判定当前是否加载了mysql的驱动类，如果加载了，我就给你搞一个Druid的数据源对象出来，完美！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnClass(name=&quot;com.mysql.jdbc.Driver&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> DruidDataSource <span class="title function_">dataSource</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		其中springboot的bean加载控制注解还有很多，这里就不一一列举了，最常用的判定条件就是根据类是否加载来进行控制。</p>
<p><strong>总结</strong></p>
<ol>
<li>springboot定义了若干种控制bean加载的条件设置注解，由spring固定加载bean变成了可以根据情况选择性的加载bean</li>
</ol>
<h3 id="YL-1-3-bean的依赖属性配置管理"><a href="#YL-1-3-bean的依赖属性配置管理" class="headerlink" title="YL-1-3.bean的依赖属性配置管理"></a>YL-1-3.bean的依赖属性配置管理</h3><p>​		bean的加载及加载控制已经搞完了，下面研究一下bean内部的事情。bean在运行的时候，实现对应的业务逻辑时有可能需要开发者提供一些设置值，有就是属性了。如果使用构造方法将参数固定，灵活性不足，这个时候就可以使用前期学习的bean的属性配置相关的知识进行灵活的配置了。先通过yml配置文件，设置bean运行需要使用的配置信息。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">cartoon:</span></span><br><span class="line">  <span class="attr">cat:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">&quot;图多盖洛&quot;</span></span><br><span class="line">    <span class="attr">age:</span> <span class="number">5</span></span><br><span class="line">  <span class="attr">mouse:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">&quot;泰菲&quot;</span></span><br><span class="line">    <span class="attr">age:</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>​		然后定义一个封装属性的专用类，加载配置属性，读取对应前缀相关的属性值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;cartoon&quot;)</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CartoonProperties</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Cat cat;</span><br><span class="line">    <span class="keyword">private</span> Mouse mouse;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		最后在使用的位置注入对应的配置即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableConfigurationProperties(CartoonProperties.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CartoonCatAndMouse</span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> CartoonProperties cartoonProperties;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		建议在业务类上使用@EnableConfigurationProperties声明bean，这样在不使用这个类的时候，也不会无故加载专用的属性配置类CartoonProperties，减少spring管控的资源数量。</p>
<p><strong>总结</strong></p>
<ol>
<li>bean的运行如果需要外部设置值，建议将设置值封装成专用的属性类* * * * Properties</li>
<li>设置属性类加载指定前缀的配置信息</li>
<li>在需要使用属性类的位置通过注解@EnableConfigurationProperties加载bean，而不要直接在属性配置类上定义bean，减少资源加载的数量，因需加载而不要饱和式加载。</li>
</ol>
<h3 id="YL-1-4-自动配置原理（工作流程）"><a href="#YL-1-4-自动配置原理（工作流程）" class="headerlink" title="YL-1-4.自动配置原理（工作流程）"></a>YL-1-4.自动配置原理（工作流程）</h3><p>​		经过前面的知识复习，下面终于进入到了本章核心内容的学习，自动配置原理。原理谈不上，就是自动配置的工作流程。</p>
<p>​		啥叫自动配置呢？简单说就是springboot根据我们开发者的行为猜测你要做什么事情，然后把你要用的bean都给你准备好。听上去是不是很神奇？其实非常简单，前面复习的东西都已经讲完了。springboot咋做到的呢？就是看你导入了什么类，就知道你想干什么了。然后把你有可能要用的bean（注意是有可能）都给你加载好，你直接使用就行了，springboot把所需要的一切工作都做完了。</p>
<p>​		自动配置的意义就是加速开发效率，将开发者使用某种技术时需要使用的bean根据情况提前加载好，实现自动配置的效果。当然，开发者有可能需要提供必要的参数，比如你要用mysql技术，导入了mysql的坐标，springboot就知道了你要做数据库操作，一系列的数据库操作相关的bean都给你提前声明好，但是你要告诉springboot你到底用哪一个数据库，像什么IP地址啊，端口啊，你不告诉spirngboot，springboot就无法帮你把自动配置相关的工作做完。</p>
<p>​		而这种思想其实就是在日常的开发过程中根据开发者的习惯慢慢抽取得到了。整体过程分为2个阶段：</p>
<p>​		<strong>阶段一：准备阶段</strong></p>
<ol>
<li><p>springboot的开发人员先大量收集Spring开发者的编程习惯，整理开发过程每一个程序经常使用的技术列表，形成一个<strong>技术集A</strong></p>
</li>
<li><p>收集常用技术(<strong>技术集A</strong>)的使用参数，不管你用什么常用设置，我用什么常用设置，统统收集起来整理一下，得到开发过程中每一个技术的常用设置，形成每一个技术对应的<strong>设置集B</strong></p>
<p><strong>阶段二：加载阶段</strong></p>
</li>
<li><p>springboot初始化Spring容器基础环境，读取用户的配置信息，加载用户自定义的bean和导入的其他坐标，形成<strong>初始化环境</strong></p>
</li>
<li><p>springboot将<strong>技术集A</strong>包含的所有技术在SpringBoot启动时默认全部加载，这时肯定加载的东西有一些是无效的，没有用的</p>
</li>
<li><p>springboot会对<strong>技术集A</strong>中每一个技术约定出启动这个技术对应的条件，并设置成按条件加载，由于开发者导入了一些bean和其他坐标，也就是与<strong>初始化环境</strong>，这个时候就可以根据这个<strong>初始化环境</strong>与springboot的<strong>技术集A</strong>进行比对了，哪个匹配上加载哪个</p>
</li>
<li><p>因为有些技术不做配置就无法工作，所以springboot开始对<strong>设置集B</strong>下手了。它统计出各个国家各个行业的开发者使用某个技术时最常用的设置是什么，然后把这些设置作为默认值直接设置好，并告诉开发者当前设置我已经给你搞了一套，你要用可以直接用，这样可以减少开发者配置参数的工作量</p>
</li>
<li><p>但是默认配置不一定能解决问题，于是springboot开放修改<strong>设置集B</strong>的接口，可以由开发者根据需要决定是否覆盖默认配置</p>
</li>
</ol>
<p>​		以上这些仅仅是一个思想，落地到代码实现阶段就要好好思考一下怎么实现了。假定我们想自己实现自动配置的功能，都要做哪些工作呢？</p>
<ul>
<li>首先指定一个技术X，我们打算让技术X具备自动配置的功能，这个技术X可以是任意功能，这个技术隶属于上面描述的<strong>技术集A</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CartoonCatAndMouse</span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>然后找出技术X使用过程中的常用配置Y，这个配置隶属于上面表述的<strong>设置集B</strong></li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">cartoon:</span></span><br><span class="line">  <span class="attr">cat:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">&quot;图多盖洛&quot;</span></span><br><span class="line">    <span class="attr">age:</span> <span class="number">5</span></span><br><span class="line">  <span class="attr">mouse:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">&quot;泰菲&quot;</span></span><br><span class="line">    <span class="attr">age:</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<ul>
<li>将常用配置Y设计出对应的yml配置书写格式，然后定义一个属性类封装对应的配置属性，这个过程其实就是上一节咱们做的bean的依赖属性管理，一模一样</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;cartoon&quot;)</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CartoonProperties</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Cat cat;</span><br><span class="line">    <span class="keyword">private</span> Mouse mouse;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>最后做一个配置类，当这个类加载的时候就可以初始化对应的功能bean，并且可以加载到对应的配置</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableConfigurationProperties(CartoonProperties.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CartoonCatAndMouse</span> <span class="keyword">implements</span> <span class="title class_">ApplicationContextAware</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> CartoonProperties cartoonProperties;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>当然，你也可以为当前自动配置类设置上激活条件，例如使用@CondtionOn* * * * 为其设置加载条件</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ConditionalOnClass(name=&quot;org.springframework.data.redis.core.RedisOperations&quot;)</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(CartoonProperties.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CartoonCatAndMouse</span> <span class="keyword">implements</span> <span class="title class_">ApplicationContextAware</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> CartoonProperties cartoonProperties;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		做到这里都已经做完了，但是遇到了一个全新的问题，如何让springboot启动的时候去加载这个类呢？如果不加载的话，我们做的条件判定，做的属性加载这些全部都失效了。springboot为我们开放了一个配置入口，在配置目录中创建META-INF目录，并创建spring.factories文件，在其中添加设置，说明哪些类要启动自动配置就可以了。</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"># Auto Configure</span><br><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</span><br><span class="line">com.itheima.bean.CartoonCatAndMouse</span><br></pre></td></tr></table></figure>

<p>​		其实这个文件就做了一件事，通过这种配置的方式加载了指定的类。转了一圈，就是个普通的bean的加载，和最初使用xml格式加载bean几乎没有区别，格式变了而已。那自动配置的核心究竟是什么呢？自动配置其实是一个小的生态，可以按照如下思想理解：</p>
<ol>
<li>自动配置从根本上来说就是一个bean的加载</li>
<li>通过bean加载条件的控制给开发者一种感觉，自动配置是自适应的，可以根据情况自己判定，但实际上就是最普通的分支语句的应用，这是蒙蔽我们双眼的第一层面纱</li>
<li>使用bean的时候，如果不设置属性，就有默认值，如果不想用默认值，就可以自己设置，也就是可以修改部分或者全部参数，感觉这个过程好屌，也是一种自适应的形式，其实还是需要使用分支语句来做判断的，这是蒙蔽我们双眼的第二层面纱</li>
<li>springboot技术提前将大量开发者有可能使用的技术提前做好了，条件也写好了，用的时候你导入了一个坐标，对应技术就可以使用了，其实就是提前帮我们把spring.factories文件写好了，这是蒙蔽我们双眼的第三层面纱</li>
</ol>
<p>​		你在不知道自动配置这个知识的情况下，经过上面这一二三，你当然觉得自动配置是一种特别牛的技术，但是一窥究竟后发现，也就那么回事。而且现在springboot程序启动时，在后台偷偷的做了这么多次检测，这么多种情况判定，不用问了，效率一定是非常低的，毕竟它要检测100余种技术是否在你程序中使用。</p>
<p>​		以上内容是自动配置的工作流程。</p>
<p><strong>总结</strong></p>
<ol>
<li>springboot启动时先加载spring.factories文件中的org.springframework.boot.autoconfigure.EnableAutoConfiguration配置项，将其中配置的所有的类都加载成bean</li>
<li>在加载bean的时候，bean对应的类定义上都设置有加载条件，因此有可能加载成功，也可能条件检测失败不加载bean</li>
<li>对于可以正常加载成bean的类，通常会通过@EnableConfigurationProperties注解初始化对应的配置属性类并加载对应的配置</li>
<li>配置属性类上通常会通过@ConfigurationProperties加载指定前缀的配置，当然这些配置通常都有默认值。如果没有默认值，就强制你必须配置后使用了</li>
</ol>
<h3 id="YL-1-5-变更自动配置"><a href="#YL-1-5-变更自动配置" class="headerlink" title="YL-1-5.变更自动配置"></a>YL-1-5.变更自动配置</h3><p>​		知道了自动配置的执行过程，下面就可以根据这个自动配置的流程做一些高级定制了。例如系统默认会加载100多种自动配置的技术，如果我们先手工干预此工程，禁用自动配置是否可行呢？答案一定是可以的。方式还挺多：</p>
<p><strong>方式一：通过yaml配置设置排除指定的自动配置类</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">autoconfigure:</span></span><br><span class="line">    <span class="attr">exclude:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">org.springframework.boot.autoconfigure.task.TaskExecutionAutoConfiguration</span></span><br></pre></td></tr></table></figure>

<p><strong>方式二：通过注解参数排除自动配置类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableAutoConfiguration(excludeName = &quot;&quot;,exclude = &#123;&#125;)</span></span><br></pre></td></tr></table></figure>

<p><strong>方式三：排除坐标（应用面较窄）</strong></p>
<p>如果当前自动配置中包含有更多的自动配置功能，也就是一个套娃的效果。此时可以通过检测条件的控制来管理自动配置是否启动。例如web程序启动时会自动启动tomcat服务器，可以通过排除坐标的方式，让加载tomcat服务器的条件失效。不过需要提醒一点，你把tomcat排除掉，记得再加一种可以运行的服务器。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--web起步依赖环境中，排除Tomcat起步依赖，匹配自动配置条件--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--添加Jetty起步依赖，匹配自动配置条件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-jetty<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>总结</strong></p>
<ol>
<li>springboot的自动配置并不是必然运行的，可以通过配置的形式干预是否启用对应的自动配置功能</li>
</ol>
<h2 id="YL-2-自定义starter开发"><a href="#YL-2-自定义starter开发" class="headerlink" title="YL-2.自定义starter开发"></a>YL-2.自定义starter开发</h2><p>​		自动配置学习完后，我们就可以基于自动配置的特性，开发springboot技术中最引以为傲的功能了，starter。其实通过前期学习，我们发现用什么技术直接导入对应的starter，然后就实现了springboot整合对应技术，再加上一些简单的配置，就可以直接使用了。这种设计方式对开发者非常友好，本章就通过一个案例的制作，开发自定义starter来实现自定义功能的快捷添加。</p>
<h3 id="YL-2-1-案例：记录系统访客独立IP访问次数"><a href="#YL-2-1-案例：记录系统访客独立IP访问次数" class="headerlink" title="YL-2-1.案例：记录系统访客独立IP访问次数"></a>YL-2-1.案例：记录系统访客独立IP访问次数</h3><p>​		本案例的功能是统计网站独立IP访问次数的功能，并将访问信息在后台持续输出。整体功能是在后台每10秒输出一次监控信息（格式：IP+访问次数） ，当用户访问网站时，对用户的访问行为进行统计。</p>
<p>​		例如：张三访问网站功能15次，IP地址：192.168.0.135，李四访问网站功能20次，IP地址：61.129.65.248。那么在网站后台就输出如下监控信息，此信息每10秒刷新一次。</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">         IP访问监控</span><br><span class="line">+-----ip-address-----+--num--+</span><br><span class="line">|     192.168.0.135  |   15  |</span><br><span class="line">|     61.129.65.248  |   20  |</span><br><span class="line">+--------------------+-------+</span><br></pre></td></tr></table></figure>

<p>​		在进行具体制作之前，先对功能做具体的分析</p>
<ol>
<li><p>数据记录在什么位置</p>
<p>最终记录的数据是一个字符串（IP地址）对应一个数字（访问次数），此处可以选择的数据存储模型可以使用java提供的map模型，也就是key-value的键值对模型，或者具有key-value键值对模型的存储技术，例如redis技术。本案例使用map作为实现方案，有兴趣的小伙伴可以使用redis作为解决方案。</p>
</li>
<li><p>统计功能运行位置，因为每次web请求都需要进行统计，因此使用拦截器会是比较好的方案，本案例使用拦截器来实现。不过在制作初期，先使用调用的形式进行测试，等功能完成了，再改成拦截器的实现方案。</p>
</li>
<li><p>为了提升统计数据展示的灵活度，为统计功能添加配置项。输出频度，输出的数据格式，统计数据的显示模式均可以通过配置实现调整。</p>
<ul>
<li>输出频度，默认10秒</li>
<li>数据特征：累计数据 &#x2F; 阶段数据，默认累计数据</li>
<li>输出格式：详细模式 &#x2F; 极简模式</li>
</ul>
</li>
</ol>
<p>​		在下面的制作中，分成若干个步骤实现。先完成最基本的统计功能的制作，然后开发出统计报表，接下来把所有的配置都设置好，最后将拦截器功能实现，整体功能就做完了。</p>
<h3 id="YL-2-2-IP计数业务功能开发（自定义starter）"><a href="#YL-2-2-IP计数业务功能开发（自定义starter）" class="headerlink" title="YL-2-2.IP计数业务功能开发（自定义starter）"></a>YL-2-2.IP计数业务功能开发（自定义starter）</h3><p>​		本功能最终要实现的效果是在现有的项目中导入一个starter，对应的功能就添加上了，删除掉对应的starter，功能就消失了，要求功能要与原始项目完全解耦。因此需要开发一个独立的模块，制作对应功能。</p>
<p><strong>步骤一：创建全新的模块，定义业务功能类</strong></p>
<p>​		功能类的制作并不复杂，定义一个业务类，声明一个Map对象，用于记录ip访问次数，key是ip地址，value是访问次数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IpCountService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,Integer&gt; ipCountMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String,Integer&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		有些小伙伴可能会有疑问，不设置成静态的，如何在每次请求时进行数据共享呢？记得，当前类加载成bean以后是一个单例对象，对象都是单例的，哪里存在多个对象共享变量的问题。</p>
<p><strong>步骤二：制作统计功能</strong></p>
<p>​		制作统计操作对应的方法，每次访问后对应ip的记录次数+1。需要分情况处理，如果当前没有对应ip的数据，新增一条数据，否则就修改对应key的值+1即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IpCountService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,Integer&gt; ipCountMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String,Integer&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">count</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//每次调用当前操作，就记录当前访问的IP，然后累加访问次数</span></span><br><span class="line">        <span class="comment">//1.获取当前操作的IP地址</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">ip</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//2.根据IP地址从Map取值，并递增</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">count</span> <span class="operator">=</span> ipCountMap.get(ip);</span><br><span class="line">        <span class="keyword">if</span>(count == <span class="literal">null</span>)&#123;</span><br><span class="line">            ipCountMap.put(ip,<span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            ipCountMap.put(ip,count + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		因为当前功能最终导入到其他项目中进行，而导入当前功能的项目是一个web项目，可以从容器中直接获取请求对象，因此获取IP地址的操作可以通过自动装配得到请求对象，然后获取对应的访问IP地址。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IpCountService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,Integer&gt; ipCountMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String,Integer&gt;();</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="comment">//当前的request对象的注入工作由使用当前starter的工程提供自动装配</span></span><br><span class="line">    <span class="keyword">private</span> HttpServletRequest httpServletRequest;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">count</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//每次调用当前操作，就记录当前访问的IP，然后累加访问次数</span></span><br><span class="line">        <span class="comment">//1.获取当前操作的IP地址</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">ip</span> <span class="operator">=</span> httpServletRequest.getRemoteAddr();</span><br><span class="line">        <span class="comment">//2.根据IP地址从Map取值，并递增</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">count</span> <span class="operator">=</span> ipCountMap.get(ip);</span><br><span class="line">        <span class="keyword">if</span>(count == <span class="literal">null</span>)&#123;</span><br><span class="line">            ipCountMap.put(ip,<span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            ipCountMap.put(ip,count + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>步骤三：定义自动配置类</strong></p>
<p>​		我们需要做到的效果是导入当前模块即开启此功能，因此使用自动配置实现功能的自动装载，需要开发自动配置类在启动项目时加载当前功能。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IpAutoConfiguration</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> IpCountService <span class="title function_">ipCountService</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">IpCountService</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		自动配置类需要在spring.factories文件中做配置方可自动运行。</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Auto Configure</span></span><br><span class="line"><span class="attr">org.springframework.boot.autoconfigure.EnableAutoConfiguration</span>=<span class="string">cn.itcast.autoconfig.IpAutoConfiguration</span></span><br></pre></td></tr></table></figure>

<p><strong>步骤四：在原始项目中模拟调用，测试功能</strong></p>
<p>​		原始调用项目中导入当前开发的starter</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.itcast<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>ip_spring_boot_starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>​		推荐选择调用方便的功能做测试，推荐使用分页操作，当然也可以换其他功能位置进行测试。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/books&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> IpCountService ipCountService;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;&#123;currentPage&#125;/&#123;pageSize&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> R <span class="title function_">getPage</span><span class="params">(<span class="meta">@PathVariable</span> <span class="type">int</span> currentPage,<span class="meta">@PathVariable</span> <span class="type">int</span> pageSize,Book book)</span>&#123;</span><br><span class="line">        ipCountService.count();</span><br><span class="line">        IPage&lt;Book&gt; page = bookService.getPage(currentPage, pageSize,book);</span><br><span class="line">        <span class="keyword">if</span>( currentPage &gt; page.getPages())&#123;</span><br><span class="line">            page = bookService.getPage((<span class="type">int</span>)page.getPages(), pageSize,book);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">R</span>(<span class="literal">true</span>, page);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><font color="#f0f"><b>温馨提示</b></font></p>
<p>​		由于当前制作的功能需要在对应的调用位置进行坐标导入，因此必须保障仓库中具有当前开发的功能，所以每次原始代码修改后，需要重新编译并安装到仓库中。为防止问题出现，建议每次安装之前先clean然后install，保障资源进行了更新。切记切记！！</p>
<p><strong>当前效果</strong></p>
<p>​		每次调用分页操作后，可以在控制台输出当前访问的IP地址，此功能可以在count操作中添加日志或者输出语句进行测试。</p>
<h3 id="YL-2-3-定时任务报表开发"><a href="#YL-2-3-定时任务报表开发" class="headerlink" title="YL-2-3.定时任务报表开发"></a>YL-2-3.定时任务报表开发</h3><p>​		当前已经实现了在业务功能类中记录访问数据，但是还没有输出监控的信息到控制台。由于监控信息需要每10秒输出1次，因此需要使用定时器功能。可以选取第三方技术Quartz实现，也可以选择Spring内置的task来完成此功能，此处选用Spring的task作为实现方案。</p>
<p><strong>步骤一：开启定时任务功能</strong></p>
<p>​		定时任务功能开启需要在当前功能的总配置中设置，结合现有业务设定，比较合理的位置是设置在自动配置类上。加载自动配置类即启用定时任务功能。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableScheduling</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IpAutoConfiguration</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> IpCountService <span class="title function_">ipCountService</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">IpCountService</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>步骤二：制作显示统计数据功能</strong></p>
<p>​		定义显示统计功能的操作print()，并设置定时任务，当前设置每5秒运行一次统计数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IpCountService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,Integer&gt; ipCountMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String,Integer&gt;();</span><br><span class="line">    <span class="meta">@Scheduled(cron = &quot;0/5 * * * * ?&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;         IP访问监控&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;+-----ip-address-----+--num--+&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; entry : ipCountMap.entrySet()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">value</span> <span class="operator">=</span> entry.getValue();</span><br><span class="line">            System.out.println(String.format(<span class="string">&quot;|%18s  |%5d  |&quot;</span>,key,value));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;+--------------------+-------+&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		其中关于统计报表的显示信息拼接可以使用各种形式进行，此处使用String类中的格式化字符串操作进行，学习者可以根据自己的喜好调整实现方案。</p>
<p><font color="#f0f"><b>温馨提示</b></font></p>
<p>​		每次运行效果之前先clean然后install，切记切记！！</p>
<p><strong>当前效果</strong></p>
<p>​		每次调用分页操作后，可以在控制台看到统计数据，到此基础功能已经开发完毕。</p>
<h3 id="YL-2-4-使用属性配置设置功能参数"><a href="#YL-2-4-使用属性配置设置功能参数" class="headerlink" title="YL-2-4.使用属性配置设置功能参数"></a>YL-2-4.使用属性配置设置功能参数</h3><p>​		由于当前报表显示的信息格式固定，为提高报表信息显示的灵活性，需要通过yml文件设置参数，控制报表的显示格式。</p>
<p><strong>步骤一：定义参数格式</strong></p>
<p>​		设置3个属性，分别用来控制显示周期（cycle），阶段数据是否清空（cycleReset），数据显示格式（model）</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">tools:</span></span><br><span class="line">  <span class="attr">ip:</span></span><br><span class="line">    <span class="attr">cycle:</span> <span class="number">10</span></span><br><span class="line">    <span class="attr">cycleReset:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">model:</span> <span class="string">&quot;detail&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>步骤二：定义封装参数的属性类，读取配置参数</strong></p>
<p>​		为防止项目组定义的参数种类过多，产生冲突，通常设置属性前缀会至少使用两级属性作为前缀进行区分。</p>
<p>​		日志输出模式是在若干个类别选项中选择某一项，对于此种分类性数据建议制作枚举定义分类数据，当然使用字符串也可以。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;tools.ip&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IpProperties</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 日志显示周期</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Long</span> <span class="variable">cycle</span> <span class="operator">=</span> <span class="number">5L</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否周期内重置数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Boolean</span> <span class="variable">cycleReset</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 日志输出模式  detail：详细模式  simple：极简模式</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">model</span> <span class="operator">=</span> LogModel.DETAIL.value;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">LogModel</span>&#123;</span><br><span class="line">        DETAIL(<span class="string">&quot;detail&quot;</span>),</span><br><span class="line">        SIMPLE(<span class="string">&quot;simple&quot;</span>);</span><br><span class="line">        <span class="keyword">private</span> String value;</span><br><span class="line">        LogModel(String value) &#123;</span><br><span class="line">            <span class="built_in">this</span>.value = value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">getValue</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>步骤三：加载属性类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableScheduling</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(IpProperties.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IpAutoConfiguration</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> IpCountService <span class="title function_">ipCountService</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">IpCountService</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>步骤四：应用配置属性</strong></p>
<p>​		在应用配置属性的功能类中，使用自动装配加载对应的配置bean，然后使用配置信息做分支处理。</p>
<p>​		注意：清除数据的功能一定要在输出后运行，否则每次查阅的数据均为空白数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IpCountService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,Integer&gt; ipCountMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String,Integer&gt;();</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> IpProperties ipProperties;</span><br><span class="line">    <span class="meta">@Scheduled(cron = &quot;0/5 * * * * ?&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(ipProperties.getModel().equals(IpProperties.LogModel.DETAIL.getValue()))&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;         IP访问监控&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;+-----ip-address-----+--num--+&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; entry : ipCountMap.entrySet()) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">                <span class="type">Integer</span> <span class="variable">value</span> <span class="operator">=</span> entry.getValue();</span><br><span class="line">                System.out.println(String.format(<span class="string">&quot;|%18s  |%5d  |&quot;</span>,key,value));</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;+--------------------+-------+&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ipProperties.getModel().equals(IpProperties.LogModel.SIMPLE.getValue()))&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;     IP访问监控&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;+-----ip-address-----+&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (String key: ipCountMap.keySet()) &#123;</span><br><span class="line">                System.out.println(String.format(<span class="string">&quot;|%18s  |&quot;</span>,key));</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;+--------------------+&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//阶段内统计数据归零</span></span><br><span class="line">        <span class="keyword">if</span>(ipProperties.getCycleReset())&#123;</span><br><span class="line">            ipCountMap.clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><font color="#f0f"><b>温馨提示</b></font></p>
<p>​		每次运行效果之前先clean然后install，切记切记！！</p>
<p><strong>当前效果</strong></p>
<p>​		在web程序端可以通过控制yml文件中的配置参数对统计信息进行格式控制。但是数据显示周期还未进行控制。</p>
<h3 id="YL-2-5-使用属性配置设置定时器参数"><a href="#YL-2-5-使用属性配置设置定时器参数" class="headerlink" title="YL-2-5.使用属性配置设置定时器参数"></a>YL-2-5.使用属性配置设置定时器参数</h3><p>​		在使用属性配置中的显示周期数据时，遇到了一些问题。由于无法在@Scheduled注解上直接使用配置数据，改用曲线救国的方针，放弃使用@EnableConfigurationProperties注解对应的功能，改成最原始的bean定义格式。</p>
<p><strong>步骤一：@Scheduled注解使用#{}读取bean属性值</strong></p>
<p>​		此处读取bean名称为ipProperties的bean的cycle属性值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Scheduled(cron = &quot;0/#&#123;ipProperties.cycle&#125; * * * * ?&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>步骤二：属性类定义bean并指定bean的访问名称</strong></p>
<p>​		如果此处不设置bean的访问名称，spring会使用自己的命名生成器生成bean的长名称，无法实现属性的读取</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component(&quot;ipProperties&quot;)</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;tools.ip&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IpProperties</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>步骤三：弃用@EnableConfigurationProperties注解对应的功能，改为导入bean的形式加载配置属性类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableScheduling</span></span><br><span class="line"><span class="comment">//@EnableConfigurationProperties(IpProperties.class)</span></span><br><span class="line"><span class="meta">@Import(IpProperties.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IpAutoConfiguration</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> IpCountService <span class="title function_">ipCountService</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">IpCountService</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><font color="#f0f"><b>温馨提示</b></font></p>
<p>​		每次运行效果之前先clean然后install，切记切记！！</p>
<p><strong>当前效果</strong></p>
<p>​		在web程序端可以通过控制yml文件中的配置参数对统计信息的显示周期进行控制</p>
<h3 id="YL-2-6-拦截器开发"><a href="#YL-2-6-拦截器开发" class="headerlink" title="YL-2-6.拦截器开发"></a>YL-2-6.拦截器开发</h3><p>​		基础功能基本上已经完成了制作，下面进行拦截器的开发。开发时先在web工程中制作，然后将所有功能挪入starter模块中</p>
<p><strong>步骤一：开发拦截器</strong></p>
<p>​		使用自动装配加载统计功能的业务类，并在拦截器中调用对应功能</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IpCountInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> IpCountService ipCountService;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, </span></span><br><span class="line"><span class="params">                             HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        ipCountService.count();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>步骤二：配置拦截器</strong></p>
<p>​		配置mvc拦截器，设置拦截对应的请求路径。此处拦截所有请求，用户可以根据使用需要设置要拦截的请求。甚至可以在此处加载IpCountProperties中的属性，通过配置设置拦截器拦截的请求。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringMvcConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">        registry.addInterceptor(ipCountInterceptor()).addPathPatterns(<span class="string">&quot;/**&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> IpCountInterceptor <span class="title function_">ipCountInterceptor</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">IpCountInterceptor</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><font color="#f0f"><b>温馨提示</b></font></p>
<p>​		每次运行效果之前先clean然后install，切记切记！！</p>
<p><strong>当前效果</strong></p>
<p>​		在web程序端导入对应的starter后功能开启，去掉坐标后功能消失，实现自定义starter的效果。</p>
<p>​		到此当前案例全部完成，自定义stater的开发其实在第一轮开发中就已经完成了，就是创建独立模块导出独立功能，需要使用的位置导入对应的starter即可。如果是在企业中开发，记得不仅需要将开发完成的starter模块install到自己的本地仓库中，开发完毕后还要deploy到私服上，否则别人就无法使用了。</p>
<h3 id="YL-2-7-功能性完善——开启yml提示功能"><a href="#YL-2-7-功能性完善——开启yml提示功能" class="headerlink" title="YL-2-7.功能性完善——开启yml提示功能"></a>YL-2-7.功能性完善——开启yml提示功能</h3><p>​		我们在使用springboot的配置属性时，都可以看到提示，尤其是导入了对应的starter后，也会有对应的提示信息出现。但是现在我们的starter没有对应的提示功能，这种设定就非常的不友好，本节解决自定义starter功能如何开启配置提示的问题。</p>
<p>​		springboot提供有专用的工具实现此功能，仅需要导入下列坐标。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>​		程序编译后，在META-INF目录中会生成对应的提示文件，然后拷贝生成出的文件到自己开发的META-INF目录中，并对其进行编辑。打开生成的文件，可以看到如下信息。其中groups属性定义了当前配置的提示信息总体描述，当前配置属于哪一个属性封装类，properties属性描述了当前配置中每一个属性的具体设置，包含名称、类型、描述、默认值等信息。hints属性默认是空白的，没有进行设置。hints属性可以参考springboot源码中的制作，设置当前属性封装类专用的提示信息，下例中为日志输出模式属性model设置了两种可选提示信息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;groups&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">&quot;name&quot;</span>: <span class="string">&quot;tools.ip&quot;</span>,</span><br><span class="line">      <span class="string">&quot;type&quot;</span>: <span class="string">&quot;cn.itcast.properties.IpProperties&quot;</span>,</span><br><span class="line">      <span class="string">&quot;sourceType&quot;</span>: <span class="string">&quot;cn.itcast.properties.IpProperties&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="string">&quot;properties&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">&quot;name&quot;</span>: <span class="string">&quot;tools.ip.cycle&quot;</span>,</span><br><span class="line">      <span class="string">&quot;type&quot;</span>: <span class="string">&quot;java.lang.Long&quot;</span>,</span><br><span class="line">      <span class="string">&quot;description&quot;</span>: <span class="string">&quot;日志显示周期&quot;</span>,</span><br><span class="line">      <span class="string">&quot;sourceType&quot;</span>: <span class="string">&quot;cn.itcast.properties.IpProperties&quot;</span>,</span><br><span class="line">      <span class="string">&quot;defaultValue&quot;</span>: <span class="number">5</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">&quot;name&quot;</span>: <span class="string">&quot;tools.ip.cycle-reset&quot;</span>,</span><br><span class="line">      <span class="string">&quot;type&quot;</span>: <span class="string">&quot;java.lang.Boolean&quot;</span>,</span><br><span class="line">      <span class="string">&quot;description&quot;</span>: <span class="string">&quot;是否周期内重置数据&quot;</span>,</span><br><span class="line">      <span class="string">&quot;sourceType&quot;</span>: <span class="string">&quot;cn.itcast.properties.IpProperties&quot;</span>,</span><br><span class="line">      <span class="string">&quot;defaultValue&quot;</span>: <span class="literal">false</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">&quot;name&quot;</span>: <span class="string">&quot;tools.ip.model&quot;</span>,</span><br><span class="line">      <span class="string">&quot;type&quot;</span>: <span class="string">&quot;java.lang.String&quot;</span>,</span><br><span class="line">      <span class="string">&quot;description&quot;</span>: <span class="string">&quot;日志输出模式  detail：详细模式  simple：极简模式&quot;</span>,</span><br><span class="line">      <span class="string">&quot;sourceType&quot;</span>: <span class="string">&quot;cn.itcast.properties.IpProperties&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="string">&quot;hints&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">&quot;name&quot;</span>: <span class="string">&quot;tools.ip.model&quot;</span>,</span><br><span class="line">      <span class="string">&quot;values&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="string">&quot;value&quot;</span>: <span class="string">&quot;detail&quot;</span>,</span><br><span class="line">          <span class="string">&quot;description&quot;</span>: <span class="string">&quot;详细模式.&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="string">&quot;value&quot;</span>: <span class="string">&quot;simple&quot;</span>,</span><br><span class="line">          <span class="string">&quot;description&quot;</span>: <span class="string">&quot;极简模式.&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结</strong></p>
<ol>
<li>自定义starter其实就是做一个独立的功能模块，核心技术是利用自动配置的效果在加载模块后加载对应的功能</li>
<li>通常会为自定义starter的自动配置功能添加足够的条件控制，而不会做成100%加载对功能的效果</li>
<li>本例中使用map保存数据，如果换用redis方案，在starter开发模块中就要导入redis对应的starter</li>
<li>对于配置属性务必开启提示功能，否则使用者无法感知配置应该如何书写</li>
</ol>
<h2 id="YL-3-SpringBoot程序启动流程解析"><a href="#YL-3-SpringBoot程序启动流程解析" class="headerlink" title="YL-3.SpringBoot程序启动流程解析"></a>YL-3.SpringBoot程序启动流程解析</h2><p>​		原理篇学习到这里即将结束，最后一章说一下springboot程序的启动流程。对于springboot技术来说，它用于加速spring程序的开发，核心本质还是spring程序的运行，所以于其说是springboot程序的启动流程，不如说是springboot对spring程序的启动流程做了哪些更改。</p>
<p>​		其实不管是springboot程序还是spring程序，启动过程本质上都是在做容器的初始化，并将对应的bean初始化出来放入容器。在spring环境中，每个bean的初始化都要开发者自己添加设置，但是切换成springboot程序后，自动配置功能的添加帮助开发者提前预设了很多bean的初始化过程，加上各种各样的参数设置，使得整体初始化过程显得略微复杂，但是核心本质还是在做一件事，初始化容器。作为开发者只要搞清楚springboot提供了哪些参数设置的环节，同时初始化容器的过程中都做了哪些事情就行了。</p>
<p>​		springboot初始化的参数根据参数的提供方，划分成如下3个大类，每个大类的参数又被封装了各种各样的对象，具体如下：</p>
<ul>
<li>环境属性（Environment）</li>
<li>系统配置（spring.factories）</li>
<li>参数（Arguments、application.properties）</li>
</ul>
<p>​		以下通过代码流向介绍了springboot程序启动时每一环节做的具体事情。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Springboot30StartupApplication【<span class="number">10</span>】-&gt;SpringApplication.run(Springboot30StartupApplication.class, args);</span><br><span class="line">    SpringApplication【<span class="number">1332</span>】-&gt;<span class="keyword">return</span> run(<span class="keyword">new</span> <span class="title class_">Class</span>&lt;?&gt;[] &#123; primarySource &#125;, args);</span><br><span class="line">        SpringApplication【<span class="number">1343</span>】-&gt;<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SpringApplication</span>(primarySources).run(args);</span><br><span class="line">            SpringApplication【<span class="number">1343</span>】-&gt;SpringApplication(primarySources)</span><br><span class="line">            # 加载各种配置信息，初始化各种配置对象</span><br><span class="line">                SpringApplication【<span class="number">266</span>】-&gt;<span class="built_in">this</span>(<span class="literal">null</span>, primarySources);</span><br><span class="line">                    SpringApplication【<span class="number">280</span>】-&gt;<span class="keyword">public</span> <span class="title function_">SpringApplication</span><span class="params">(ResourceLoader resourceLoader, Class&lt;?&gt;... primarySources)</span></span><br><span class="line">                        SpringApplication【<span class="number">281</span>】-&gt;<span class="built_in">this</span>.resourceLoader = resourceLoader;</span><br><span class="line">                        # 初始化资源加载器</span><br><span class="line">                        SpringApplication【<span class="number">283</span>】-&gt;<span class="built_in">this</span>.primarySources = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;(Arrays.asList(primarySources));</span><br><span class="line">                        # 初始化配置类的类名信息（格式转换）</span><br><span class="line">                        SpringApplication【<span class="number">284</span>】-&gt;<span class="built_in">this</span>.webApplicationType = WebApplicationType.deduceFromClasspath();</span><br><span class="line">                        # 确认当前容器加载的类型</span><br><span class="line">                        SpringApplication【<span class="number">285</span>】-&gt;<span class="built_in">this</span>.bootstrapRegistryInitializers = getBootstrapRegistryInitializersFromSpringFactories();</span><br><span class="line">                        # 获取系统配置引导信息</span><br><span class="line">                        SpringApplication【<span class="number">286</span>】-&gt;setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class));</span><br><span class="line">                        # 获取ApplicationContextInitializer.class对应的实例</span><br><span class="line">                        SpringApplication【<span class="number">287</span>】-&gt;setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));</span><br><span class="line">                        # 初始化监听器，对初始化过程及运行过程进行干预</span><br><span class="line">                        SpringApplication【<span class="number">288</span>】-&gt;<span class="built_in">this</span>.mainApplicationClass = deduceMainApplicationClass();</span><br><span class="line">                        # 初始化了引导类类名信息，备用</span><br><span class="line">            SpringApplication【<span class="number">1343</span>】-&gt;<span class="keyword">new</span> <span class="title class_">SpringApplication</span>(primarySources).run(args)</span><br><span class="line">            # 初始化容器，得到ApplicationContext对象</span><br><span class="line">                SpringApplication【<span class="number">323</span>】-&gt;<span class="type">StopWatch</span> <span class="variable">stopWatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StopWatch</span>();</span><br><span class="line">                # 设置计时器</span><br><span class="line">                SpringApplication【<span class="number">324</span>】-&gt;stopWatch.start();</span><br><span class="line">                # 计时开始</span><br><span class="line">                SpringApplication【<span class="number">325</span>】-&gt;<span class="type">DefaultBootstrapContext</span> <span class="variable">bootstrapContext</span> <span class="operator">=</span> createBootstrapContext();</span><br><span class="line">                # 系统引导信息对应的上下文对象</span><br><span class="line">                SpringApplication【<span class="number">327</span>】-&gt;configureHeadlessProperty();</span><br><span class="line">                # 模拟输入输出信号，避免出现因缺少外设导致的信号传输失败，进而引发错误（模拟显示器，键盘，鼠标...）</span><br><span class="line">                    java.awt.headless=<span class="literal">true</span></span><br><span class="line">                SpringApplication【<span class="number">328</span>】-&gt;<span class="type">SpringApplicationRunListeners</span> <span class="variable">listeners</span> <span class="operator">=</span> getRunListeners(args);</span><br><span class="line">                # 获取当前注册的所有监听器</span><br><span class="line">                SpringApplication【<span class="number">329</span>】-&gt;listeners.starting(bootstrapContext, <span class="built_in">this</span>.mainApplicationClass);</span><br><span class="line">                # 监听器执行了对应的操作步骤</span><br><span class="line">                SpringApplication【<span class="number">331</span>】-&gt;<span class="type">ApplicationArguments</span> <span class="variable">applicationArguments</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultApplicationArguments</span>(args);</span><br><span class="line">                # 获取参数</span><br><span class="line">                SpringApplication【<span class="number">333</span>】-&gt;<span class="type">ConfigurableEnvironment</span> <span class="variable">environment</span> <span class="operator">=</span> prepareEnvironment(listeners, bootstrapContext, applicationArguments);</span><br><span class="line">                # 将前期读取的数据加载成了一个环境对象，用来描述信息</span><br><span class="line">                SpringApplication【<span class="number">333</span>】-&gt;configureIgnoreBeanInfo(environment);</span><br><span class="line">                # 做了一个配置，备用</span><br><span class="line">                SpringApplication【<span class="number">334</span>】-&gt;<span class="type">Banner</span> <span class="variable">printedBanner</span> <span class="operator">=</span> printBanner(environment);</span><br><span class="line">                # 初始化logo</span><br><span class="line">                SpringApplication【<span class="number">335</span>】-&gt;context = createApplicationContext();</span><br><span class="line">                # 创建容器对象，根据前期配置的容器类型进行判定并创建</span><br><span class="line">                SpringApplication【<span class="number">363</span>】-&gt;context.setApplicationStartup(<span class="built_in">this</span>.applicationStartup);</span><br><span class="line">                # 设置启动模式</span><br><span class="line">                SpringApplication【<span class="number">337</span>】-&gt;prepareContext(bootstrapContext, context, environment, listeners, applicationArguments, printedBanner);</span><br><span class="line">                # 对容器进行设置，参数来源于前期的设定</span><br><span class="line">                SpringApplication【<span class="number">338</span>】-&gt;refreshContext(context);</span><br><span class="line">                # 刷新容器环境</span><br><span class="line">                SpringApplication【<span class="number">339</span>】-&gt;afterRefresh(context, applicationArguments);</span><br><span class="line">                # 刷新完毕后做后处理</span><br><span class="line">                SpringApplication【<span class="number">340</span>】-&gt;stopWatch.stop();</span><br><span class="line">                # 计时结束</span><br><span class="line">                SpringApplication【<span class="number">341</span>】-&gt;<span class="keyword">if</span> (<span class="built_in">this</span>.logStartupInfo) &#123;</span><br><span class="line">                # 判定是否记录启动时间的日志</span><br><span class="line">                SpringApplication【<span class="number">342</span>】-&gt;    <span class="keyword">new</span> <span class="title class_">StartupInfoLogger</span>(<span class="built_in">this</span>.mainApplicationClass).logStarted(getApplicationLog(), stopWatch);</span><br><span class="line">                # 创建日志对应的对象，输出日志信息，包含启动时间</span><br><span class="line">                SpringApplication【<span class="number">344</span>】-&gt;listeners.started(context);</span><br><span class="line">                # 监听器执行了对应的操作步骤</span><br><span class="line">                SpringApplication【<span class="number">345</span>】-&gt;callRunners(context, applicationArguments);</span><br><span class="line">                # 调用运行器</span><br><span class="line">                SpringApplication【<span class="number">353</span>】-&gt;listeners.running(context);</span><br><span class="line">                # 监听器执行了对应的操作步骤</span><br></pre></td></tr></table></figure>

<p>​		上述过程描述了springboot程序启动过程中做的所有的事情，这个时候好奇宝宝们就会提出一个问题。如果想干预springboot的启动过程，比如自定义一个数据库环境检测的程序，该如何将这个过程加入springboot的启动流程呢？</p>
<p>​		遇到这样的问题，大部分技术是这样设计的，设计若干个标准接口，对应程序中的所有标准过程。当你想干预某个过程时，实现接口就行了。例如spring技术中bean的生命周期管理就是采用标准接口进行的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Abc</span> <span class="keyword">implements</span> <span class="title class_">InitializingBean</span>, DisposableBean &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//销毁操作</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//初始化操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		springboot启动过程由于存在着大量的过程阶段，如果设计接口就要设计十余个标准接口，这样对开发者不友好，同时整体过程管理分散，十余个过程各自为政，管理难度大，过程过于松散。那springboot如何解决这个问题呢？它采用了一种最原始的设计模式来解决这个问题，这就是监听器模式，使用监听器来解决这个问题。</p>
<p>​		springboot将自身的启动过程比喻成一个大的事件，该事件是由若干个小的事件组成的。例如：</p>
<ul>
<li>org.springframework.boot.context.event.ApplicationStartingEvent<ul>
<li>应用启动事件，在应用运行但未进行任何处理时，将发送 ApplicationStartingEvent</li>
</ul>
</li>
<li>org.springframework.boot.context.event.ApplicationEnvironmentPreparedEvent<ul>
<li>环境准备事件，当Environment被使用，且上下文创建之前，将发送 ApplicationEnvironmentPreparedEvent</li>
</ul>
</li>
<li>org.springframework.boot.context.event.ApplicationContextInitializedEvent<ul>
<li>上下文初始化事件</li>
</ul>
</li>
<li>org.springframework.boot.context.event.ApplicationPreparedEvent<ul>
<li>应用准备事件，在开始刷新之前，bean定义被加载之后发送 ApplicationPreparedEvent</li>
</ul>
</li>
<li>org.springframework.context.event.ContextRefreshedEvent<ul>
<li>上下文刷新事件</li>
</ul>
</li>
<li>org.springframework.boot.context.event.ApplicationStartedEvent<ul>
<li>应用启动完成事件，在上下文刷新之后且所有的应用和命令行运行器被调用之前发送 ApplicationStartedEvent</li>
</ul>
</li>
<li>org.springframework.boot.context.event.ApplicationReadyEvent<ul>
<li>应用准备就绪事件，在应用程序和命令行运行器被调用之后，将发出 ApplicationReadyEvent，用于通知应用已经准备处理请求</li>
</ul>
</li>
<li>org.springframework.context.event.ContextClosedEvent（上下文关闭事件，对应容器关闭）</li>
</ul>
<p>​		上述列出的仅仅是部分事件，当应用启动后走到某一个过程点时，监听器监听到某个事件触发，就会执行对应的事件。除了系统内置的事件处理，用户还可以根据需要自定义开发当前事件触发时要做的其他动作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//设定监听器，在应用启动开始事件时进行功能追加</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyListener</span> <span class="keyword">implements</span> <span class="title class_">ApplicationListener</span>&lt;ApplicationStartingEvent&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onApplicationEvent</span><span class="params">(ApplicationStartingEvent event)</span> &#123;</span><br><span class="line">		<span class="comment">//自定义事件处理逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		按照上述方案处理，用户就可以干预springboot启动过程的所有工作节点，设置自己的业务系统中独有的功能点。</p>
<p><strong>总结</strong></p>
<ol>
<li>springboot启动流程是先初始化容器需要的各种配置，并加载成各种对象，初始化容器时读取这些对象，创建容器</li>
<li>整体流程采用事件监听的机制进行过程控制，开发者可以根据需要自行扩展，添加对应的监听器绑定具体事件，就可以在事件触发位置执行开发者的业务代码</li>
</ol>
<h2 id="原理篇完结"><a href="#原理篇完结" class="headerlink" title="原理篇完结"></a>原理篇完结</h2><p>​		原理篇到这里就要结束了，springboot2整套课程的基础篇、实用篇和原理篇就全部讲完了。至于后面的番外篇由于受B站视频上传总量不得超过200个视频的约束，番外篇的内容不会在当前课程中发布了，会重新定义一个课程继续发布，至于具体时间，暂时还无法给到各位小伙伴。</p>
<p>​		原理篇个人感觉略微有点偷懒，怎么说呢？学习原理篇需要的前置铺垫知识太多，比如最后一节讲到启动流程时，看到reflush方法时我就想现在在看这套课程的小伙伴是否真的懂这个过程呢？但是如果把这些东西都讲了，那估计要补充的知识就太多了，就是将spring的很多知识加入到这里面重新讲解了，会出现喧宾夺主的现象。很纠结，( ´•︵•&#96; )</p>
<p>​		课程做到这里就要和各位小伙伴先say顾拜了，感谢各位小伙伴的支持，也欢迎各位小伙伴持续关注黑马程序员出品的各种视频教程。黑马程序员的每位老师做课程都是认真的，都是为了各位致力于IT研发事业的小伙伴能够学习之路上少遇沟沟坎坎，顺利到达成功的彼岸。</p>
<p>​		番外篇，さようなら！ 안녕히 계십시오！แล้วเจอกัน！До свидания ！خداحافظ ！</p>
]]></content>
      <categories>
        <category>boot系列</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title>springboot基础篇</title>
    <url>/2022/09/23/springboot%E5%9F%BA%E7%A1%80%E7%AF%87/</url>
    <content><![CDATA[<p>​		在基础篇中，我给学习者的定位是先上手，能够使用SpringBoot搭建基于SpringBoot的web项目开发，所以内容设置较少，主要包含如下内容：</p>
<ul>
<li>SpringBoot快速入门</li>
<li>SpringBoot基础配置</li>
<li>基于SpringBoot整合SSMP</li>
</ul>
<h2 id="JC-1-快速上手SpringBoot"><a href="#JC-1-快速上手SpringBoot" class="headerlink" title="JC-1.快速上手SpringBoot"></a>JC-1.快速上手SpringBoot</h2><p>​		学习任意一项技术，首先要知道这个技术的作用是什么，不然学完以后，你都不知道什么时候使用这个技术，也就是技术对应的应用场景。SpringBoot技术由Pivotal团队研发制作，功能的话简单概括就是加速Spring程序的开发，这个加速要从如下两个方面来说</p>
<ul>
<li>Spring程序初始搭建过程</li>
<li>Spring程序的开发过程</li>
</ul>
<p>​	通过上面两个方面的定位，我们可以产生两个模糊的概念：</p>
<ol>
<li>SpringBoot开发团队认为原始的Spring程序初始搭建的时候可能有些繁琐，这个过程是可以简化的，那原始的Spring程序初始搭建过程都包含哪些东西了呢？为什么觉得繁琐呢？最基本的Spring程序至少有一个配置文件或配置类，用来描述Spring的配置信息，莫非这个文件都可以不写？此外现在企业级开发使用Spring大部分情况下是做web开发，如果做web开发的话，还要在加载web环境时加载时加载指定的spring配置，这都是最基本的需求了，不写的话怎么知道加载哪个配置文件&#x2F;配置类呢？那换了SpringBoot技术以后呢，这些还要写吗？谜底稍后揭晓，先卖个关子</li>
<li>SpringBoot开发团队认为原始的Spring程序开发的过程也有些繁琐，这个过程仍然可以简化。开发过程无外乎使用什么技术，导入对应的jar包（或坐标）然后将这个技术的核心对象交给Spring容器管理，也就是配置成Spring容器管控的bean就可以了。这都是基本操作啊，难道这些东西SpringBoot也能帮我们简化？</li>
</ol>
<p>​	带着上面这些疑问我们就着手第一个SpringBoot程序的开发了，看看到底使用SpringBoot技术能简化开发到什么程度。</p>
<p><font color="#f0f"><b>温馨提示</b></font></p>
<p>​		如果对Spring程序的基础开发不太懂的小伙伴，看到这里可以弃坑了，下面的内容学习需要具备Spring技术的知识，硬着头皮学不下去的。</p>
<h3 id="JC-1-1-SpringBoot入门程序制作（一）"><a href="#JC-1-1-SpringBoot入门程序制作（一）" class="headerlink" title="JC-1-1.SpringBoot入门程序制作（一）"></a>JC-1-1.SpringBoot入门程序制作（一）</h3><p>​		下面让我们开始做第一个SpringBoot程序吧，本课程基于Idea2020.3版本制作，使用的Maven版本为3.6.1，JDK版本为1.8。如果你的环境和上述环境不同，可能在操作界面和操作过程中略有不同，只要软件匹配兼容即可（说到这个Idea和Maven，它们两个还真不是什么版本都能搭到一起的，说多了都是泪啊）。</p>
<p>​		下面使用SpringBoot技术快速构建一个SpringMVC的程序，通过这个过程体会<font color="#ff0000"><b>简化</b></font>二字的含义。</p>
<p><strong>步骤①</strong>：创建新模块，选择Spring Initializr，并配置模块相关基础信息</p>
<p><img src="/2022/09/23/springboot%E5%9F%BA%E7%A1%80%E7%AF%87/image-20211116125259385.png" alt="图片加载失败"></p>
<p>​		<font color="#ff0000"><b>特别关注</b></font>：第3步点击Next时，Idea需要联网状态才可以进入到后面那一页，如果不能正常联网，就无法正确到达右面那个设置页了，会一直<font color="#ff0000"><b>联网</b></font>转转转。</p>
<p>​		<font color="#ff0000"><b>特别关注</b></font>：第5步选择java版本和你计算机上安装的JDK版本匹配即可，但是最低要求为JDK8或以上版本，推荐使用8或11。</p>
<p><strong>步骤②</strong>：选择当前模块需要使用的技术集</p>
<p><img src="/2022/09/23/springboot%E5%9F%BA%E7%A1%80%E7%AF%87/image-20211116125615728.png" alt="image-20211116125615728"></p>
<p>​		按照要求，左侧选择web，然后在中间选择Spring Web即可，选完右侧就出现了新的内容项，这就表示勾选成功了。</p>
<p>​		<font color="#ff0000"><b>关注</b></font>：此处选择的SpringBoot的版本使用默认的就可以了，需要说一点，SpringBoot的版本升级速度很快，可能昨天创建工程的时候默认版本是2.5.4，今天再创建工程默认版本就变成2.5.5了，差别不大，无需过于纠结，并且还可以到配置文件中修改对应的版本。</p>
<p><strong>步骤③</strong>：开发控制器类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Rest模式</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/books&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookController</span> &#123;</span><br><span class="line">    <span class="meta">@GetMapping</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getById</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;springboot is running...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;springboot is running...&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		入门案例制作的SpringMVC的控制器基于Rest风格开发，当然此处使用原始格式制作SpringMVC的程序也是没有问题的，上例中的@RestController与@GetMapping注解是基于Restful开发的典型注解。</p>
<p>​		<font color="#ff0000"><b>关注</b></font>：做到这里SpringBoot程序的最基础的开发已经做完了，现在就可以正常的运行Spring程序了。可能有些小伙伴会有疑惑，Tomcat服务器没有配置，Spring也没有配置，什么都没有配置这就能用吗？这就是SpringBoot技术的强大之处。关于内部工作流程后面再说，先专心学习开发过程。</p>
<p><strong>步骤④</strong>：运行自动生成的Application类</p>
<p><img src="/2022/09/23/springboot%E5%9F%BA%E7%A1%80%E7%AF%87/image-20211116130152452.png" alt="image-20211116130152452"></p>
<p>​		使用带main方法的java程序的运行形式来运行程序，运行完毕后，控制台输出上述信息。</p>
<p>​		不难看出，运行的信息中包含了8080的端口，Tomcat这种熟悉的字样，难道这里启动了Tomcat服务器？是的，这里已经启动了。那服务器没有配置，哪里来的呢？后面再说。现在你就可以通过浏览器访问请求的路径，测试功能是否工作正常了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">访问路径：	http:<span class="comment">//localhost:8080/books</span></span><br></pre></td></tr></table></figure>

<p>​		是不是感觉很神奇？当前效果其实依赖的底层逻辑还是很复杂的，但是从开发者角度来看，目前只有两个文件展现到了开发者面前。</p>
<ul>
<li><p>pom.xml</p>
<p>这是maven的配置文件，描述了当前工程构建时相应的配置信息。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.itheima<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springboot_01_01_quickstart<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>配置中有两个信息需要关注，一个是parent，也就是当前工程继承了另外一个工程，干什么用的后面再说，还有依赖坐标，干什么用的后面再说。</p>
</li>
<li><p>Application类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个类功能很简单，就一句代码，前面运行程序就是运行的这个类。</p>
</li>
</ul>
<p>​       到这里我们可以大胆推测一下，如果上面这两个文件没有的话，SpringBoot肯定没法玩，看来核心就是这两个文件了。由于是制作第一个SpringBoot程序，先不要关注这两个文件的功能，后面详细讲解内部工作流程。</p>
<p>​       通过上面的制作，我们不难发现，SpringBoot程序简直太好写了，几乎什么都没写，功能就有了，这也是SpringBoot技术为什么现在这么火的原因，和Spring程序相比，SpringBoot程序在开发的过程中各个层面均具有优势。</p>
<table>
<thead>
<tr>
<th><strong>类配置文件</strong></th>
<th><strong>Spring</strong></th>
<th><strong>SpringBoot</strong></th>
</tr>
</thead>
<tbody><tr>
<td>pom文件中的坐标</td>
<td><strong>手工添加</strong></td>
<td><strong>勾选添加</strong></td>
</tr>
<tr>
<td>web3.0配置类</td>
<td><strong>手工制作</strong></td>
<td><strong>无</strong></td>
</tr>
<tr>
<td>Spring&#x2F;SpringMVC配置类</td>
<td><strong>手工制作</strong></td>
<td><strong>无</strong></td>
</tr>
<tr>
<td>控制器</td>
<td><strong>手工制作</strong></td>
<td><strong>手工制作</strong></td>
</tr>
</tbody></table>
<p>​		一句话总结一下就是<font color="#ff0000"><b>能少写就少写</b></font>，<font color="#ff0000"><b>能不写就不写</b></font>，这就是SpringBoot技术给我们带来的好处，行了，现在你就可以动手做一做SpringBoot程序了，看看效果如何，是否真的帮助你简化开发了。</p>
<p><strong>总结</strong></p>
<ol>
<li>开发SpringBoot程序在Idea工具中基于联网的前提下可以根据向导快速制作</li>
<li>SpringBoot程序需要依赖JDK，版本要求最低为JDK8</li>
<li>SpringBoot程序中需要使用某种功能时可以通过勾选的形式选择技术，也可以手工添加对应的要使用的技术（后期讲解）</li>
<li>运行SpringBoot程序通过运行Application程序进行</li>
</ol>
<p><strong>思考</strong></p>
<p>​		前面制作的时候说过，这个过程必须联网才可以进行，但是有些时候你会遇到一些莫名其妙的问题，比如基于Idea开发时，你会发现你配置了一些坐标，然后Maven下载对应东西的时候死慢死慢的，甚至还会失败。其实这种现象和Idea这款IDE工具有关，万一Idea不能正常访问网络的话，我们是不是就无法制作SpringBoot程序了呢？咱们下一节再说。</p>
<h3 id="JC-1-2-SpringBoot入门程序制作（二）"><a href="#JC-1-2-SpringBoot入门程序制作（二）" class="headerlink" title="JC-1-2.SpringBoot入门程序制作（二）"></a>JC-1-2.SpringBoot入门程序制作（二）</h3><p>​		如果Idea不能正常联网，这个SpringBoot程序就无法制作了吗？开什么玩笑，世上IDE工具千千万，难道SpringBoot技术还必须基于Idea来做了？这是不可能的。开发SpringBoot程序可以不基于IDE工具进行，在SpringBoot官网中可以直接创建SpringBoot程序。</p>
<p>​		SpringBoot官网和Spring的官网是在一起的，都是  spring.io  。你可以通过项目一级一级的找到SpringBoot技术的介绍页，然后在页面中间部位找到如下内容</p>
<img src="image-20211122150444816.png" alt="image-20211122150444816" style="zoom: 67%;" />

<p><strong>步骤①</strong>：点击<strong>Spring Initializr</strong>后进入到创建SpringBoot程序界面，接下来就是输入信息的过程，和在Idea中制作是一样的，只是界面发生了变化，根据自己的要求，在左侧选择对应信息和输入对应的信息。</p>
<img src="image-20211122150608039.png" alt="image-20211122150608039"  />

<p><strong>步骤②</strong>：右侧的<strong>ADD DEPENDENCIES</strong>用于选择使用何种技术，和之前勾选的Spring WEB是在做同一件事，仅仅是界面不同而已，点击后打开网页版的技术选择界面。</p>
<img src="image-20211122161257361.png" alt="image-20211122161257361" style="zoom:50%;" />

<p><strong>步骤③</strong>：所有信息设置完毕后，点击下面左侧<strong>GENERATE</strong>按钮，生成一个文件包。</p>
<p><img src="/2022/09/23/springboot%E5%9F%BA%E7%A1%80%E7%AF%87/image-202111221615480212.png" alt="image-20211122161548022"></p>
<p><strong>步骤④</strong>：保存后得到一个压缩文件，这个文件就是创建的SpringBoot工程		</p>
<p><img src="/2022/09/23/springboot%E5%9F%BA%E7%A1%80%E7%AF%87/image-20211122161709478.png" alt="image-20211122161709478"></p>
<p><strong>步骤⑤</strong>：解压缩此文件得到工程目录，在Idea中导入即可直接使用，和之前在Idea环境下根据向导创建的工程完全一样，你可以创建一个Controller测试一下当前工程是否可用。</p>
<p><font color="#f0f"><b>温馨提示</b></font></p>
<p>​		做到这里其实可以透漏一个小秘密，Idea工具中创建SpringBoot工程其实连接的就是SpringBoot的官网，还句话说这种方式和第一种方式是一模一样的，只不过Idea把界面给整合了一下，读取Spring官网信息，然后展示到Idea界面中而已，可以通过如下信息比对一下</p>
<p><strong>Idea中创建工程时默认选项</strong></p>
<img src="image-20211122162443035.png" alt="image-20211122162443035" style="zoom: 67%;" />

<p><strong>SpringBoot官网创建工程时对应的地址</strong></p>
<p>​		看看SpringBoot官网创建工程的URL地址，是不是和Idea中使用的URL地址是一样的？</p>
<img src="image-20211122162820719.png" alt="image-20211122162820719"  />

<p><strong>总结</strong></p>
<ol>
<li><p>打开SpringBoot官网，选择<strong>Quickstart Your Project</strong>中的Spring Initializr。</p>
<img src="image-20211122150444816.png" alt="image-20211122150444816" style="zoom: 67%;" />
</li>
<li><p>创建工程。</p>
<img src="image-20211122150608039.png" alt="image-20211122150608039"  />
</li>
<li><p>保存项目文件。</p>
<p><img src="/2022/09/23/springboot%E5%9F%BA%E7%A1%80%E7%AF%87/image-20211122161548022.png" alt="image-20211122161548022"></p>
</li>
<li><p>解压项目，通过IDE导入项目后进行编辑使用。</p>
</li>
</ol>
<p><strong>思考</strong></p>
<p>​		现在创建工程靠的是访问国外的Spring主站，但是互联网信息的访问是可以被约束的，如果一天这个网站你在国内无法访问了，那前面这两种方式就无法创建SpringBoot工程了，这时候又该怎么解决这个问题呢？咱们下一节再说。</p>
<h3 id="JC-1-3-SpringBoot入门程序制作（三）"><a href="#JC-1-3-SpringBoot入门程序制作（三）" class="headerlink" title="JC-1-3.SpringBoot入门程序制作（三）"></a>JC-1-3.SpringBoot入门程序制作（三）</h3><p>​		前面提到网站如果被限制访问了，该怎么办？开动脑筋想一想，不管是方式一还是方式二其实走的都是同一个路线，就是通过SpringBoot官网创建SpringBoot工程，假如国内有这么一个网站也能提供这样的功能，是不是就解决了呢？必然的嘛，新的问题又来了，国内有提供这样功能的网站吗？还真有，阿里提供了一个，下面问题就简单了，网址告诉我们就OK了，没错，就是这样。</p>
<p>​		创建工程时，切换选择starter服务路径，然后手工输入阿里云地址即可，地址：<a href="http://start.aliyun.com或https//start.aliyun.com">http://start.aliyun.com或https://start.aliyun.com</a></p>
<p><img src="/2022/09/23/springboot%E5%9F%BA%E7%A1%80%E7%AF%87/image-20211122163605950.png" alt="image-20211122163605950"></p>
<p>​		阿里为了便于自己公司开发使用，特此在依赖坐标中添加了一些阿里自主的技术，也是为了推广自己的技术吧，所以在依赖选择列表中，你有了更多的选择。此外，阿里提供的地址更符合国内开发者的使用习惯，里面有一些SpringBoot官网上没有给出的坐标，大家可以好好看一看。</p>
<p><img src="/2022/09/23/springboot%E5%9F%BA%E7%A1%80%E7%AF%87/image-20211122163937408.png" alt="image-20211122163937408"></p>
<p>​		不过有一点需要说清楚，阿里云地址默认创建的SpringBoot工程版本是<font color="#ff0000"><b>2.4.1</b></font>，所以如果你想更换其他的版本，创建项目后在pom文件中手工修改即可，别忘了刷新一下，加载新版本信息。</p>
<p>​		<font color="#ff0000"><b>注意</b></font>：阿里云提供的工程创建地址初始化完毕后和使用SpringBoot官网创建出来的工程略有区别，主要是在配置文件的形式上有区别,这个信息在后面讲解SpringBoot程序的执行流程时给大家揭晓。</p>
<p><strong>总结</strong></p>
<ol>
<li>选择start来源为自定义URL</li>
<li>输入阿里云starter地址</li>
<li>创建项目</li>
</ol>
<p><strong>思考</strong></p>
<p>​		做到这里我们已经有了三种方式创建SpringBoot工程，但是每种方式都要求你必须能上网才能创建工程。假如有一天，你加入了一个保密级别比较高的项目组，整个项目组没有外网，这个事情是不是就不能做了呢？咱们下一节再说。</p>
<h3 id="JC-1-4-SpringBoot入门程序制作（四）"><a href="#JC-1-4-SpringBoot入门程序制作（四）" class="headerlink" title="JC-1-4.SpringBoot入门程序制作（四）"></a>JC-1-4.SpringBoot入门程序制作（四）</h3><p>​		不能上网，还想创建SpringBoot工程，能不能做呢？能做，但是你要先问问自己联网和不联网到底差别是什么？这个差别找到以后，你就发现，你把联网要干的事情都提前准备好，就无需联网了。</p>
<p>​		联网做什么呢？首先SpringBoot工程也是基于Maven构建的，而Maven工程中如果加载一些工程需要使用又不存在的东西时，就要联网去下载。其实SpringBoot工程创建的时候就是要去下载一些必要的组件。如果把这些东西提前准备好呢？是的，就是这样。</p>
<p>​		下面就手工创建一个SpringBoot工程，如果需要使用的东西提前保障在maven仓库中存在，整个过程就可以不依赖联网环境了。不过咱们已经用3种方式创建了SprongBoot工程了，所以下面也没什么东西需要下载了。</p>
<p><strong>步骤①</strong>：创建工程时，选择创建普通Maven工程。</p>
<img src="image-20211122165341684.png" alt="image-20211122165341684" style="zoom:50%;" />

<p><strong>步骤②</strong>：参照标准SpringBoot工程的pom文件，书写自己的pom文件即可。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.itheima<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springboot_01_04_quickstart<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>​		用什么写什么，不用的都可以不写。当然，现在小伙伴们可能还不知道用什么和不用什么，最简单的就是复制粘贴了，随着后面的学习，你就知道哪些可以省略了。此处我删减了一些目前不是必须的东西，一样能用。核心的内容有两条，一个是继承了一个父工程，另外添加了一个依赖。</p>
<p><strong>步骤③</strong>：之前运行SpringBoot工程需要一个类，这个缺不了，自己手写一个就行了，建议按照之前的目录结构来创建，先别玩花样，先学走后学跑。类名可以自定义，关联的名称同步修改即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(Application.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		<font color="#ff0000"><b>关注</b></font>：类上面的注解@SpringBootApplication千万别丢了，这个是核心，后面再介绍。</p>
<p>​		<font color="#ff0000"><b>关注</b></font>：类名可以自定义，只要保障下面代码中使用的类名和你自己定义的名称一样即可，也就是run方法中的那个class对应的名称。</p>
<p><strong>步骤④</strong>：下面就可以自己创建一个Controller测试一下是否能用了，和之前没有差别的。</p>
<p>​		看到这里其实应该能够想明白了，通过向导或者网站创建的SpringBoot工程其实就是帮你写了一些代码，而现在是自己手写，写的内容都一样，仅此而已。</p>
<p><font color="#f0f"><b>温馨提示</b></font></p>
<p>​		如果你的计算机上从来没有创建成功过SpringBoot工程，自然也就没有下载过SpringBoot对应的坐标相关的资源，那用手写创建的方式在不联网的情况下肯定该是不能用的。所谓手写，其实就是自己写别人帮你生成的东西，但是引用的坐标对应的资源必须保障maven仓库里面有才行，如果没有，还是要去下载的。</p>
<p><strong>总结</strong></p>
<ol>
<li>创建普通Maven工程</li>
<li>继承spring-boot-starter-parent</li>
<li>添加依赖spring-boot-starter-web</li>
<li>制作引导类Application</li>
</ol>
<p>​        到这里已经学习了4种创建SpringBoot工程的方式，其实本质是一样的，都是根据SpringBoot工程的文件格式要求，通过不同时方式生成或者手写得到对应的文件，效果完全一样。</p>
<h4 id="教你一招：在Idea中隐藏指定文件-x2F-文件夹"><a href="#教你一招：在Idea中隐藏指定文件-x2F-文件夹" class="headerlink" title="教你一招：在Idea中隐藏指定文件&#x2F;文件夹"></a>教你一招：在Idea中隐藏指定文件&#x2F;文件夹</h4><p>​		创建SpringBoot工程时，使用SpringBoot向导也好，阿里云也罢，其实都是为了一个目的，得到一个标准的SpringBoot工程文件结构。这个时候就有新的问题出现了，标准的工程结构中包含了一些未知的文件夹，在开发的时候看起来特别别扭，这一节就来说说这些文件怎么处理。</p>
<p>​		处理方案无外乎两种，如果你对每一个文件&#x2F;目录足够了解，有用的留着，没有用的完全可以删除掉。或者不删除，但是看着别扭，就设置文件为看不到就行了。删除不说了，选中后直接Delete掉就好了，这一节说说如何隐藏指定的文件或文件夹信息。</p>
<p>​		既然是在Idea下做隐藏功能，肯定隶属于Idea的设置，设置方式如下。</p>
<p><strong>步骤①</strong>：打开设置，【Files】→【Settings】。</p>
<img src="image-20211122173835517.png" alt="image-20211122173835517" style="zoom:80%;" />

<p><strong>步骤②</strong>：打开文件类型设置界面后，【Editor】→【File Types】→【Ignored Files and Folders】，忽略文件或文件夹显示。</p>
<img src="image-20211122174020028.png" alt="image-20211122174020028" style="zoom: 67%;" />

<p><strong>步骤③</strong>：添加你要隐藏的文件名称或文件夹名称，可以使用*号通配符，表示任意，设置完毕即可。</p>
<p>​	到这里就做完了，其实就是Idea的一个小功能</p>
<p><strong>总结</strong></p>
<ol>
<li>Idea中隐藏指定文件或指定类型文件<ol>
<li>【Files】→【Settings】</li>
<li>【Editor】→【File Types】→【Ignored Files and Folders】</li>
<li>输入要隐藏的名称，支持*号通配符</li>
<li>回车确认添加</li>
</ol>
</li>
</ol>
<h3 id="JC-1-5-SpringBoot简介"><a href="#JC-1-5-SpringBoot简介" class="headerlink" title="JC-1-5.SpringBoot简介"></a>JC-1-5.SpringBoot简介</h3><p>​		入门案例做完了，这个时候回忆一下咱们之前说的SpringBoot的功能是什么还记得吗？加速Spring程序的开发，现在是否深有体会？再来看SpringBoot技术的设计初衷就很容易理解了。</p>
<p>​		SpringBoot是由Pivotal团队提供的全新框架，其设计目的是用来<font color="#ff0000"><b>简化Spring应用的初始搭建以及开发过程</b></font>。</p>
<p>​		都简化了了哪些东西呢？其实就是针对原始的Spring程序制作的两个方面进行了简化：</p>
<ul>
<li>Spring程序缺点<ul>
<li>依赖设置繁琐<ul>
<li>以前写Spring程序，使用的技术都要自己一个一个的写，现在不需要了，如果做过原始SpringMVC程序的小伙伴应该知道，写SpringMVC程序，最基础的spring-web和spring-webmvc这两个坐标是必须的，就这还不包含你用json啊等等这些坐标，现在呢？一个坐标搞定了。</li>
</ul>
</li>
<li>配置繁琐<ul>
<li>以前写配置类或者配置文件，然后用什么东西就要自己写加载bean这些东西，现在呢？什么都没写，照样能用。</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>回顾</p>
<p>​	通过上面两个方面的定位，我们可以产生两个模糊的概念：</p>
<ol>
<li>SpringBoot开发团队认为原始的Spring程序初始搭建的时候可能有些繁琐，这个过程是可以简化的，那原始的Spring程序初始搭建过程都包含哪些东西了呢？为什么觉得繁琐呢？最基本的Spring程序至少有一个配置文件或配置类，用来描述Spring的配置信息，莫非这个文件都可以不写？此外现在企业级开发使用Spring大部分情况下是做web开发，如果做web开发的话，还要在加载web环境时加载时加载指定的spring配置，这都是最基本的需求了，不写的话怎么知道加载哪个配置文件&#x2F;配置类呢？那换了SpringBoot技术以后呢，这些还要写吗？谜底稍后揭晓，先卖个关子</li>
<li>SpringBoot开发团队认为原始的Spring程序开发的过程也有些繁琐，这个过程仍然可以简化。开发过程无外乎使用什么技术，导入对应的jar包（或坐标）然后将这个技术的核心对象交给Spring容器管理，也就是配置成Spring容器管控的bean就可以了。这都是基本操作啊，难道这些东西SpringBoot也能帮我们简化？</li>
</ol>
</blockquote>
<p>​		再来看看前面提出的两个问题，已经有答案了，都简化了，都不用写了，这就是SpringBoot给我们带来的好处。这些简化操作在SpringBoot中有专业的用语，也是SpringBoot程序的核心功能及优点：</p>
<ul>
<li>起步依赖（简化依赖配置）<ul>
<li>依赖配置的书写简化就是靠这个起步依赖达成的。</li>
</ul>
</li>
<li>自动配置（简化常用工程相关配置）<ul>
<li>配置过于繁琐，使用自动配置就可以做相应的简化，但是内部还是很复杂的，后面具体展开说。</li>
</ul>
</li>
<li>辅助功能（内置服务器，……）<ul>
<li>除了上面的功能，其实SpringBoot程序还有其他的一些优势，比如我们没有配置Tomcat服务器，但是能正常运行，这是SpringBoot入门程序中一个可以感知到的功能，也是SpringBoot的辅助功能之一。一个辅助功能都能做的这么6，太牛了。</li>
</ul>
</li>
</ul>
<p>​		下面结合入门程序来说说这些简化操作都在哪些方面进行体现的，一共分为4个方面</p>
<ul>
<li>parent</li>
<li>starter</li>
<li>引导类</li>
<li>内嵌tomcat</li>
</ul>
<h4 id="parent"><a href="#parent" class="headerlink" title="parent"></a>parent</h4><p>​		SpringBoot关注到开发者在进行开发时，往往对依赖版本的选择具有固定的搭配格式，并且这些依赖版本的选择还不能乱搭配。比如A技术的2.0版，在与B技术进行配合使用时，与B技术的3.5版可以合作在一起工作，但是和B技术的3.7版合作开发使用时就有冲突。其实很多开发者都一直想做一件事情，就是将各种各样的技术配合使用的常见依赖版本进行收集整理，制作出了最合理的依赖版本配置方案，这样使用起来就方便多了。</p>
<p>​		SpringBoot一看这种情况so easy啊，于是将所有的技术版本的常见使用方案都给开发者整理了出来，以后开发者使用时直接用它提供的版本方案，就不用担心冲突问题了，相当于SpringBoot做了无数个技术版本搭配的列表，这个技术搭配列表的名字叫做<font color="#ff0000"><b>parent</b></font>。</p>
<p>​		<font color="#ff0000"><b>parent</b></font>自身具有很多个版本，每个<font color="#ff0000"><b>parent</b></font>版本中包含有几百个其他技术的版本号，不同的parent间使用的各种技术的版本号有可能会发生变化。当开发者使用某些技术时，直接使用SpringBoot提供的<font color="#ff0000"><b>parent</b></font>就行了，由<font color="#ff0000"><b>parent</b></font>帮助开发者统一的进行各种技术的版本管理。</p>
<p>​		比如你现在要使用Spring配合MyBatis开发，没有parent之前怎么做呢？选个Spring的版本，再选个MyBatis的版本，再把这些技术使用时关联的其他技术的版本逐一确定下来。当你Spring的版本发生变化需要切换时，你的MyBatis版本有可能也要跟着切换，关联技术呢？可能都要切换，而且切换后还可能出现其他问题。现在这一切工作都可以交给parent来做了。你无需关注这些技术间的版本冲突问题，你只需要关注你用什么技术就行了，冲突问题由<font color="#ff0000"><b>parent</b></font>负责处理。</p>
<p>​		有人可能会提出来，万一<font color="#ff0000"><b>parent</b></font>给我导入了一些我不想使用的依赖怎么办？记清楚，这一点很关键，<font color="#ff0000"><b>parent</b></font>仅仅帮我们进行版本管理，它不负责帮你导入坐标，说白了用什么还是你自己定，只不过版本不需要你管理了。整体上来说，<font color="#ff0000"><b>使用parent可以帮助开发者进行版本的统一管理。</b></font></p>
<p>​		<font color="#ff0000"><b>关注</b></font>：parent定义出来以后，并不是直接使用的，仅仅给了开发者一个说明书，但是并没有实际使用，这个一定要确认清楚。</p>
<p>​		那SpringBoot又是如何做到这一点的呢？可以查阅SpringBoot的配置源码，看到这些定义。</p>
<ul>
<li>项目中的pom.xml中继承了一个坐标</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>打开后可以查阅到其中又继承了一个坐标</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>这个坐标中定义了两组信息</li>
</ul>
<p>第一组是各式各样的依赖版本号属性，下面列出依赖版本属性的局部，可以看的出来，定义了若干个技术的依赖版本号。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">activemq.version</span>&gt;</span>5.16.3<span class="tag">&lt;/<span class="name">activemq.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aspectj.version</span>&gt;</span>1.9.7<span class="tag">&lt;/<span class="name">aspectj.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">assertj.version</span>&gt;</span>3.19.0<span class="tag">&lt;/<span class="name">assertj.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">commons-codec.version</span>&gt;</span>1.15<span class="tag">&lt;/<span class="name">commons-codec.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">commons-dbcp2.version</span>&gt;</span>2.8.0<span class="tag">&lt;/<span class="name">commons-dbcp2.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">commons-lang3.version</span>&gt;</span>3.12.0<span class="tag">&lt;/<span class="name">commons-lang3.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">commons-pool.version</span>&gt;</span>1.6<span class="tag">&lt;/<span class="name">commons-pool.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">commons-pool2.version</span>&gt;</span>2.9.0<span class="tag">&lt;/<span class="name">commons-pool2.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2.version</span>&gt;</span>1.4.200<span class="tag">&lt;/<span class="name">h2.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">hibernate.version</span>&gt;</span>5.4.32.Final<span class="tag">&lt;/<span class="name">hibernate.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">hibernate-validator.version</span>&gt;</span>6.2.0.Final<span class="tag">&lt;/<span class="name">hibernate-validator.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">httpclient.version</span>&gt;</span>4.5.13<span class="tag">&lt;/<span class="name">httpclient.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">jackson-bom.version</span>&gt;</span>2.12.4<span class="tag">&lt;/<span class="name">jackson-bom.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">javax-jms.version</span>&gt;</span>2.0.1<span class="tag">&lt;/<span class="name">javax-jms.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">javax-json.version</span>&gt;</span>1.1.4<span class="tag">&lt;/<span class="name">javax-json.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">javax-websocket.version</span>&gt;</span>1.1<span class="tag">&lt;/<span class="name">javax-websocket.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">jetty-el.version</span>&gt;</span>9.0.48<span class="tag">&lt;/<span class="name">jetty-el.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">junit.version</span>&gt;</span>4.13.2<span class="tag">&lt;/<span class="name">junit.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>第二组是各式各样的依赖坐标信息，可以看出依赖坐标定义中没有具体的依赖版本号，而是引用了第一组信息中定义的依赖版本属性值.</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.hibernate<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hibernate-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;hibernate.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;junit.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>​		<font color="#ff0000"><b>关注</b></font>：上面的依赖坐标定义是出现在<dependencyManagement>标签中的，是对引用坐标的依赖管理，并不是实际使用的坐标。因此当你的项目中继承了这组parent信息后，在不使用对应坐标的情况下，前面的这组定义是不会具体导入某个依赖的。</p>
<p>​		<font color="#ff0000"><b>关注</b></font>：因为在maven中继承机会只有一次，上述继承的格式还可以切换成导入的形式进行，并且在阿里云的starter创建工程时就使用了此种形式。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-boot.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>总结</strong></p>
<ol>
<li>开发SpringBoot程序要继承spring-boot-starter-parent</li>
<li>spring-boot-starter-parent中定义了若干个依赖管理</li>
<li>继承parent模块可以避免多个依赖使用相同技术时出现依赖版本冲突</li>
<li>继承parent的形式也可以采用引入依赖的形式实现效果</li>
</ol>
<p><strong>思考</strong></p>
<p>​		parent中定义了若干个依赖版本管理，但是也没有使用，那这个设定也就不生效啊，究竟谁在使用这些定义呢？</p>
<h4 id="starter"><a href="#starter" class="headerlink" title="starter"></a>starter</h4><p>​		SpringBoot关注到实际开发时，开发者对于依赖坐标的使用往往都有一些固定的组合方式，比如使用spring-webmvc就一定要使用spring-web。每次都要固定搭配着写，非常繁琐，而且格式固定，没有任何技术含量。</p>
<p>​		SpringBoot一看这种情况，看来需要给开发者带来一些帮助了。安排，把所有的技术使用的固定搭配格式都给开发出来，以后你用某个技术，就不用每次写一堆依赖了，还容易写错，我给你做一个东西，代表一堆东西，开发者使用的时候，直接用我做好的这个东西就好了，对于这样的固定技术搭配，SpringBoot给它起了个名字叫做<font color="#ff0000"><b>starter</b></font>。</p>
<p>​		starter定义了使用某种技术时对于依赖的固定搭配格式，也是一种最佳解决方案，<font color="#ff0000"><b>使用starter可以帮助开发者减少依赖配置</b></font>。</p>
<p>​		这个东西其实在入门案例里面已经使用过了，入门案例中的web功能就是使用这种方式添加依赖的。可以查阅SpringBoot的配置源码，看到这些定义。</p>
<ul>
<li>项目中的pom.xml定义了使用SpringMVC技术，但是并没有写SpringMVC的坐标，而是添加了一个名字中包含starter的依赖</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>在spring-boot-starter-web中又定义了若干个具体依赖的坐标</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-json<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>​		之前提到过开发SpringMVC程序需要导入spring-webmvc的坐标和spring整合web开发的坐标，就是上面这组坐标中的最后两个了。</p>
<p>​		但是我们发现除了这两个坐标，还有其他的坐标。比如第二个，叫做spring-boot-starter-json。看名称就知道，这个是与json有关的坐标了，但是看名字发现和最后两个又不太一样，它的名字中也有starter，打开看看里面有什么？</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.12.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.datatype<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-datatype-jdk8<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.12.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.datatype<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-datatype-jsr310<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.12.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.module<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-module-parameter-names<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.12.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>​		我们可以发现，这个starter中又包含了若干个坐标，其实就是使用SpringMVC开发通常都会使用到Json，使用json又离不开这里面定义的这些坐标，看来还真是方便，SpringBoot把我们开发中使用的东西能用到的都给提前做好了。你仔细看完会发现，里面有一些你没用过的。的确会出现这种过量导入的可能性，没关系，可以通过maven中的排除依赖剔除掉一部分。不过你不管它也没事，大不了就是过量导入呗。</p>
<p>​	到这里基本上得到了一个信息，使用starter可以帮开发者快速配置依赖关系。以前写依赖3个坐标的，现在写导入一个就搞定了，就是加速依赖配置的。</p>
<p><strong>starter与parent的区别</strong></p>
<p>​		朦朦胧胧中感觉starter与parent好像都是帮助我们简化配置的，但是功能又不一样，梳理一下。</p>
<p>​		<font color="#ff0000"><b>starter</b></font>是一个坐标中定了若干个坐标，以前写多个的，现在写一个，<font color="#ff0000"><b>是用来减少依赖配置的书写量的</b></font>。</p>
<p>​		<font color="#ff0000"><b>parent</b></font>是定义了几百个依赖版本号，以前写依赖需要自己手工控制版本，现在由SpringBoot统一管理，这样就不存在版本冲突了，<font color="#ff0000"><b>是用来减少依赖冲突的</b></font>。</p>
<p><strong>实际开发应用方式</strong></p>
<ul>
<li><p>实际开发中如果需要用什么技术，先去找有没有这个技术对应的starter</p>
<ul>
<li>如果有对应的starter，直接写starter，而且无需指定版本，版本由parent提供</li>
<li>如果没有对应的starter，手写坐标即可</li>
</ul>
</li>
<li><p>实际开发中如果发现坐标出现了冲突现象，确认你要使用的可行的版本号，使用手工书写的方式添加对应依赖，覆盖SpringBoot提供给我们的配置管理</p>
<ul>
<li>方式一：直接写坐标</li>
<li>方式二：覆盖<properties>中定义的版本号，就是下面这堆东西了，哪个冲突了覆盖哪个就OK了</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">activemq.version</span>&gt;</span>5.16.3<span class="tag">&lt;/<span class="name">activemq.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aspectj.version</span>&gt;</span>1.9.7<span class="tag">&lt;/<span class="name">aspectj.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">assertj.version</span>&gt;</span>3.19.0<span class="tag">&lt;/<span class="name">assertj.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">commons-codec.version</span>&gt;</span>1.15<span class="tag">&lt;/<span class="name">commons-codec.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">commons-dbcp2.version</span>&gt;</span>2.8.0<span class="tag">&lt;/<span class="name">commons-dbcp2.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">commons-lang3.version</span>&gt;</span>3.12.0<span class="tag">&lt;/<span class="name">commons-lang3.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">commons-pool.version</span>&gt;</span>1.6<span class="tag">&lt;/<span class="name">commons-pool.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">commons-pool2.version</span>&gt;</span>2.9.0<span class="tag">&lt;/<span class="name">commons-pool2.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2.version</span>&gt;</span>1.4.200<span class="tag">&lt;/<span class="name">h2.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">hibernate.version</span>&gt;</span>5.4.32.Final<span class="tag">&lt;/<span class="name">hibernate.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">hibernate-validator.version</span>&gt;</span>6.2.0.Final<span class="tag">&lt;/<span class="name">hibernate-validator.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">httpclient.version</span>&gt;</span>4.5.13<span class="tag">&lt;/<span class="name">httpclient.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">jackson-bom.version</span>&gt;</span>2.12.4<span class="tag">&lt;/<span class="name">jackson-bom.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">javax-jms.version</span>&gt;</span>2.0.1<span class="tag">&lt;/<span class="name">javax-jms.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">javax-json.version</span>&gt;</span>1.1.4<span class="tag">&lt;/<span class="name">javax-json.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">javax-websocket.version</span>&gt;</span>1.1<span class="tag">&lt;/<span class="name">javax-websocket.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">jetty-el.version</span>&gt;</span>9.0.48<span class="tag">&lt;/<span class="name">jetty-el.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">junit.version</span>&gt;</span>4.13.2<span class="tag">&lt;/<span class="name">junit.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><font color="#f0f"><b>温馨提示</b></font></p>
<p>​		SpringBoot官方给出了好多个starter的定义，方便我们使用，而且名称都是如下格式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">命名规则：spring-boot-starter-技术名称</span><br></pre></td></tr></table></figure>

<p>​	所以后期见了spring-boot-starter-aaa这样的名字，这就是SpringBoot官方给出的starter定义。那非官方定义的也有吗？有的，具体命名方式到整合技术的章节再说。</p>
<p><strong>总结</strong></p>
<ol>
<li>开发SpringBoot程序需要导入坐标时通常导入对应的starter</li>
<li>每个不同的starter根据功能不同，通常包含多个依赖坐标</li>
<li>使用starter可以实现快速配置的效果，达到简化配置的目的</li>
</ol>
<h4 id="引导类"><a href="#引导类" class="headerlink" title="引导类"></a>引导类</h4><p>​		配置说完了，我们发现SpringBoot确实帮助我们减少了很多配置工作，下面说一下程序是如何运行的。目前程序运行的入口就是SpringBoot工程创建时自带的那个类，也就是带有main方法的那个类，运行这个类就可以启动SpringBoot工程的运行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Springboot0101QuickstartApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(Springboot0101QuickstartApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		SpringBoot本身是为了加速Spring程序的开发的，而Spring程序运行的基础是需要创建Spring容器对象（IoC容器）并将所有的对象放置到Spring容器中管理，也就是一个一个的Bean。现在改用SpringBoot加速开发Spring程序，这个容器还在吗？这个疑问不用说，一定在。其实当前这个类运行后就会产生一个Spring容器对象，并且可以将这个对象保存起来，通过容器对象直接操作Bean。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QuickstartApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ConfigurableApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> SpringApplication.run(QuickstartApplication.class, args);</span><br><span class="line">        <span class="type">BookController</span> <span class="variable">bean</span> <span class="operator">=</span> ctx.getBean(BookController.class);</span><br><span class="line">        System.out.println(<span class="string">&quot;bean======&gt;&quot;</span> + bean);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		通过上述操作不难看出，其实SpringBoot程序启动还是创建了一个Spring容器对象。当前运行的这个类在SpringBoot程序中是所有功能的入口，称为<font color="#ff0000"><b>引导类</b></font>。</p>
<p>​		作为一个引导类最典型的特征就是当前类上方声明了一个注解<font color="#ff0000"><b>@SpringBootApplication</b></font>。</p>
<p><strong>总结</strong></p>
<ol>
<li>SpringBoot工程提供引导类用来启动程序</li>
<li>SpringBoot工程启动后创建并初始化Spring容器</li>
</ol>
<p><strong>思考</strong></p>
<p>​		程序现在已经运行了，通过引导类的main方法运行了起来。但是运行java程序不应该是执行完就结束了吗？但是我们现在明显是启动了一个web服务器啊，不然网页怎么能正常访问呢？这个服务器是在哪里写的呢？</p>
<h4 id="内嵌tomcat"><a href="#内嵌tomcat" class="headerlink" title="内嵌tomcat"></a>内嵌tomcat</h4><p>​		当前我们做的SpringBoot入门案例勾选了Spring-web的功能，并且导入了对应的starter。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>​		SpringBoot发现，既然你要做web程序，肯定离不开使用web服务器，这样吧，帮人帮到底，送佛送到西，我帮你搞一个web服务器，你要愿意用的，直接使用就好了。SpringBoot又琢磨，提供一种服务器万一不满足开发者需要呢？干脆我再多给你几种选择，你随便切换。万一你不想用我给你提供的，也行，你可以自己搞。</p>
<p>​		由于这个功能不属于程序的主体功能，可用可不用，于是乎SpringBoot将其定位成辅助功能，别小看这么一个辅助功能，它可是帮我们开发者又减少了好多的设置性工作。</p>
<p>​		下面就围绕着这个内置的web服务器，也可以说是内置的tomcat服务器来研究几个问题：</p>
<ol>
<li>这个服务器在什么位置定义的</li>
<li>这个服务器是怎么运行的</li>
<li>这个服务器如果想换怎么换？虽然这个需求很垃圾，搞得开发者会好多web服务器一样，用别人提供好的不香么？非要自己折腾</li>
</ol>
<p><strong>内嵌Tomcat定义位置</strong></p>
<p>​		说到定义的位置，我们就想，如果我们不开发web程序，用的着web服务器吗？肯定用不着啊。那如果这个东西被加入到你的程序中，伴随着什么技术进来的呢？肯定是web相关的功能啊，没错，就是前面导入的web相关的starter做的这件事。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>​		打开web对应的starter查看导入了哪些东西。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-json<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>​		第三个依赖就是tomcat对应的东西了，居然也是一个starter，再打开看看。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>jakarta.annotation<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jakarta.annotation-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.tomcat.embed<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tomcat-embed-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>9.0.52<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tomcat-annotations-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.tomcat<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.tomcat.embed<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tomcat-embed-el<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>9.0.52<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.tomcat.embed<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tomcat-embed-websocket<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>9.0.52<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tomcat-annotations-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.tomcat<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>​		这里面有一个核心的坐标，tomcat-embed-core，叫做tomcat内嵌核心。就是这个东西把tomcat功能引入到了我们的程序中的。目前解决了第一个问题，找到根儿了，谁把tomcat引入到程序中的？spring-boot-starter-web中的spring-boot-starter-tomcat做的。之所以你感觉很奇妙的原因就是，这个东西是默认加入到程序中了，所以感觉很神奇，居然什么都不做，就有了web服务器对应的功能。再来说第二个问题，这个服务器是怎么运行的。</p>
<p><strong>内嵌Tomcat运行原理</strong></p>
<p>​		Tomcat服务器是一款软件，而且是一款使用java语言开发的软件，熟悉tomcat的话应该知道tomcat安装目录中保存有很多jar文件。</p>
<p>​		下面的问题来了，既然是使用java语言开发的，运行的时候肯定符合java程序运行的原理，java程序运行靠的是什么？对象呀，一切皆对象，万物皆对象。那tomcat运行起来呢？也是对象啊。</p>
<p>​		如果是对象，那Spring容器是用来管理对象的，这个对象能交给Spring容器管理吗？把吗去掉，是个对象都可以交给Spring容器管理，行了，这下通了，tomcat服务器运行其实是以对象的形式在Spring容器中运行的。怪不得我们没有安装这个tomcat但是还能用，闹了白天这东西最后是以一个对象的形式存在，保存在Spring容器中悄悄运行的。具体运行的是什么呢？其实就是上前面提到的那个tomcat内嵌核心。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.tomcat.embed<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tomcat-embed-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>9.0.52<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>​		那既然是个对象，如果把这个对象从Spring容器中去掉是不是就没有web服务器的功能呢？是这样的，通过依赖排除可以去掉这个web服务器功能。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>​		上面对web-starter做了一个操作，使用maven的排除依赖去掉了使用tomcat的starter。这下好了，容器中肯定没有这个对象了，重新启动程序可以观察到程序运行了，但是并没有像之前那样运行后是一个一直运行的服务，而是直接停掉了，就是这个原因。</p>
<p><strong>更换内嵌Tomcat</strong></p>
<p>​		那根据上面的操作我们思考是否可以换个服务器呢？必须的嘛。根据SpringBoot的工作机制，用什么技术，加入什么依赖就行了。SpringBoot提供了3款内置的服务器：</p>
<ul>
<li><p>tomcat(默认)：apache出品，粉丝多，应用面广，负载了若干较重的组件</p>
</li>
<li><p>jetty：更轻量级，负载性能远不及tomcat</p>
</li>
<li><p>undertow：负载性能勉强跑赢tomcat</p>
<p>想用哪个，加个坐标就OK。前提是把tomcat排除掉，因为tomcat是默认加载的。</p>
</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-jetty<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>​		现在就已经成功替换了web服务器，核心思想就是用什么加入对应坐标就可以了。如果有starter，优先使用starter。</p>
<p><strong>总结</strong></p>
<ol>
<li>内嵌Tomcat服务器是SpringBoot辅助功能之一</li>
<li>内嵌Tomcat工作原理是将Tomcat服务器作为对象运行，并将该对象交给Spring容器管理</li>
<li>变更内嵌服务器思想是去除现有服务器，添加全新的服务器</li>
</ol>
<p>​		到这里第一章快速上手SpringBoot就结束了，这一章我们学习了两大块知识</p>
<ol>
<li><p>使用了4种方式制作了SpringBoot的入门程序，不管是哪一种，其实内部都是一模一样的</p>
</li>
<li><p>学习了入门程序的工作流程，知道什么是parent，什么是starter，这两个东西是怎么配合工作的，以及我们的程序为什么启动起来是一个tomcat服务器等等</p>
<p>第一章到这里就结束了，再往下学习就要去基于会创建SpringBoot工程的基础上，研究SpringBoot工程的具体细节了。</p>
</li>
</ol>
<h2 id="JC-2-SpringBoot基础配置"><a href="#JC-2-SpringBoot基础配置" class="headerlink" title="JC-2.SpringBoot基础配置"></a>JC-2.SpringBoot基础配置</h2><p>​		入门案例做完了，下面就要研究SpringBoot的用法了。通过入门案例，各位小伙伴能够感知到一个信息，SpringBoot没有具体的功能，它是辅助加快Spring程序的开发效率的。我们发现，现在几乎不用做任何配置功能就有了，确实很好用。但是仔细想想，没有做配置意味着什么？意味着配置已经做好了，不用你自己写了。但是新的问题又来了，如果不想用已经写好的默认配置，该如何干预呢？这就是这一章咱们要研究的问题。</p>
<p>​		如果想修改默认的配置，这个信息应该写在什么位置呢？目前我们接触的入门案例中一共有3个文件，第一是pom.xml文件，设置项目的依赖，这个没什么好研究的，相关的高级内容咱们到原理篇再说，第二是引导类，这个是执行SpringBoot程序的入口，也不像是做功能配置的地方，其实还有一个信息，就是在resources目录下面有一个空白的文件，叫做application.properties。一看就是个配置文件，咱们这一章就来说说配置文件怎么写，能写什么，怎么覆盖SpringBoot的默认配置修改成自己的配置。</p>
<p>​	</p>
<h3 id="JC-2-1-属性配置"><a href="#JC-2-1-属性配置" class="headerlink" title="JC-2-1.属性配置"></a>JC-2-1.属性配置</h3><p>​		SpringBoot通过配置文件application.properties就可以修改默认的配置，那咱们就先找个简单的配置下手，当前访问tomcat的默认端口是8080，好熟悉的味道，但是不便于书写，我们先改成80，通过这个操作来熟悉一下SpringBoot的配置格式是什么样的。</p>
<p><img src="/2022/09/23/springboot%E5%9F%BA%E7%A1%80%E7%AF%87/image-20211123165428245.png" alt="image-20211123165428245"></p>
<p>​		那该如何写呢？properties格式的文件书写规范是key&#x3D;value</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">name</span>=<span class="string">itheima</span></span><br></pre></td></tr></table></figure>

<p>​		这个格式肯定是不能颠覆的，那就尝试性的写就行了，改端口，写port。当你输入port后，神奇的事情就发生了，这玩意儿带提示，太好了。</p>
<img src="image-20211123165719091.png" alt="image-20211123165719091" style="zoom:80%;" />

<p>​		根据提示敲回车，输入80端口，搞定。</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">server.port</span>=<span class="string">80</span></span><br></pre></td></tr></table></figure>

<p>​		下面就可以直接运行程序，测试效果了。</p>
<p>​		我们惊奇的发现SpringBoot这玩意儿狠啊，以前修改端口在哪里改？tomcat服务器的配置文件中改，现在呢？SpringBoot专用的配置文件中改，是不是意味着以后所有的配置都可以写在这一个文件中呢？是的，简化开发者配置的书写位置，集中管理。妙啊，妈妈再也不用担心我找不到配置文件了。</p>
<p>​		其实到这里我们应该得到如下三个信息：</p>
<ol>
<li>SpringBoot程序可以在application.properties文件中进行属性配置</li>
<li>application.properties文件中只要输入要配置的属性关键字就可以根据提示进行设置</li>
<li>SpringBoot将配置信息集中在一个文件中写，不管你是服务器的配置，还是数据库的配置，总之都写在一起，逃离一个项目十几种配置文件格式的尴尬局面</li>
</ol>
<p><strong>总结</strong></p>
<ol>
<li>SpringBoot默认配置文件是application.properties</li>
</ol>
<p>​		做完了端口的配置，趁热打铁，再做几个配置，目前项目启动时会显示一些日志信息，就来改一改这里面的一些设置。</p>
<p><strong>关闭运行日志图表（banner)</strong></p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring.main.banner-mode</span>=<span class="string">off</span></span><br></pre></td></tr></table></figure>

<p><strong>设置运行日志的显示级别</strong></p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">logging.level.root</span>=<span class="string">debug</span></span><br></pre></td></tr></table></figure>

<p>​		你会发现，现在这么搞配置太爽了，以前你做配置怎么做？不同的技术有自己专用的配置文件，文件不同格式也不统一，现在呢？不用东奔西走的找配置文件写配置了，统一格式了，这就是大秦帝国啊，统一六国。SpringBoot比大秦狠，因为未来出现的技术还没出现呢，但是现在已经确认了，配置都写这个文件里面。</p>
<p>​		我们现在配置了3个信息，但是又有新的问题了。这个配置是随便写的吗？什么都能配？有没有一个东西显示所有能配置的项呢？此外这个配置和什么东西有关呢？会不会因为我写了什么东西以后才可以写什么配置呢？比如我现在没有写数据库相关的东西，能否配置数据呢？一个一个来，先说第一个问题，都能配置什么。</p>
<p>​		打开SpringBoot的官网，找到SpringBoot官方文档，打开查看附录中的Application Properties就可以获取到对应的配置项了，网址奉上：<a href="https://docs.spring.io/spring-boot/docs/current/reference/html/application-properties.html#application-properties">https://docs.spring.io/spring-boot/docs/current/reference/html/application-properties.html#application-properties</a></p>
<p>​		能写什么的问题解决了，再来说第二个问题，这个配置项和什么有关。在pom中注释掉导入的spring-boot-starter-web，然后刷新工程，你会发现配置的提示消失了。闹了半天是设定使用了什么技术才能做什么配置。也合理，不然没有使用对应技术，配了也是白配。</p>
<p><font color="#f0f"><b>温馨提示</b></font></p>
<p>​		所有的starter中都会依赖下面这个starter，叫做spring-boot-starter。这个starter是所有的SpringBoot的starter的基础依赖，里面定义了SpringBoot相关的基础配置，关于这个starter我们到开发应用篇和原理篇中再深入讲解。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">2.5</span><span class="number">.4</span>&lt;/version&gt;</span><br><span class="line">    &lt;scope&gt;compile&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p><strong>总结</strong></p>
<ol>
<li>SpringBoot中导入对应starter后，提供对应配置属性</li>
<li>书写SpringBoot配置采用关键字+提示形式书写</li>
</ol>
<h3 id="JC-2-2-配置文件分类"><a href="#JC-2-2-配置文件分类" class="headerlink" title="JC-2-2.配置文件分类"></a>JC-2-2.配置文件分类</h3><p>​		现在已经能够进行SpringBoot相关的配置了，但是properties格式的配置写起来总是觉得看着不舒服，所以就期望存在一种书写起来更简便的配置格式提供给开发者使用。有吗？还真有，SpringBoot除了支持properties格式的配置文件，还支持另外两种格式的配置文件。三种配置文件格式分别如下:</p>
<ul>
<li>properties格式</li>
<li>yml格式</li>
<li>yaml格式</li>
</ul>
<p>​		一看到全新的文件格式，各位小伙伴肯定想，这下又要学习新的语法格式了。怎么说呢？从知识角度来说，要学，从开发角度来说，不用学。为什么呢？因为SpringBoot的配置在Idea工具下有提示啊，跟着提示走就行了。下面列举三种不同文件格式配置相同的属性范例，先了解一下。</p>
<ul>
<li>application.properties（properties格式）</li>
</ul>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">server.port</span>=<span class="string">80</span></span><br></pre></td></tr></table></figure>

<ul>
<li>application.yml（yml格式）</li>
</ul>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">81</span></span><br></pre></td></tr></table></figure>

<ul>
<li>application.yaml（yaml格式）</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">82</span></span><br></pre></td></tr></table></figure>

<p>​		仔细看会发现yml格式和yaml格式除了文件名后缀不一样，格式完全一样，是这样的，yml和yaml文件格式就是一模一样的，只是文件后缀不同，所以可以合并成一种格式来看。那对于这三种格式来说，以后用哪一种比较多呢？记清楚，以后基本上都是用yml格式的，本课程后面的所有知识都是基于yml格式来制作的，以后在企业开发过程中用这个格式的机会也最多，一定要重点掌握。</p>
<p><strong>总结</strong></p>
<ol>
<li>SpringBoot提供了3种配置文件的格式<ul>
<li>properties（传统格式&#x2F;默认格式）</li>
<li><strong>yml</strong>（主流格式）</li>
<li>yaml</li>
</ul>
</li>
</ol>
<p><strong>思考</strong></p>
<p>​		现在我们已经知道使用三种格式都可以做配置了，好奇宝宝们就有新的灵魂拷问了，万一我三个都写了，他们三个谁说了算呢？打一架吗？</p>
<h4 id="配置文件优先级"><a href="#配置文件优先级" class="headerlink" title="配置文件优先级"></a>配置文件优先级</h4><p>​		其实三个文件如果共存的话，谁生效说的就是配置文件加载的优先级别。先说一点，虽然以后这种情况很少出现，但是这个知识还是可以学习一下的。我们就让三个配置文件书写同样的信息，比如都配置端口，然后我们让每个文件配置的端口号都不一样，最后启动程序后看启动端口是多少就知道谁的加载优先级比较高了。</p>
<ul>
<li>application.properties（properties格式）</li>
</ul>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">server.port</span>=<span class="string">80</span></span><br></pre></td></tr></table></figure>

<ul>
<li>application.yml（yml格式）</li>
</ul>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">81</span></span><br></pre></td></tr></table></figure>

<ul>
<li>application.yaml（yaml格式）</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">82</span></span><br></pre></td></tr></table></figure>

<p>​		启动后发现目前的启动端口为80，把80对应的文件删除掉，然后再启动，现在端口又改成了81。现在我们就已经知道了3个文件的加载优先顺序是什么。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">application.properties  &gt;  application.yml  &gt;  application.yaml</span><br></pre></td></tr></table></figure>

<p>​		虽然得到了一个知识结论，但是我们实际开发的时候还是要看最终的效果为准。也就是你要的最终效果是什么自己是明确的，上述结论只能帮助你分析结论产生的原因。这个知识了解一下就行了，因为以后同时写多种配置文件格式的情况实在是较少。</p>
<p>​		最后我们把配置文件内容给修改一下</p>
<ul>
<li>application.properties（properties格式）</li>
</ul>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">server.port</span>=<span class="string">80</span></span><br><span class="line"><span class="attr">spring.main.banner-mode</span>=<span class="string">off</span></span><br></pre></td></tr></table></figure>

<ul>
<li>application.yml（yml格式）</li>
</ul>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">81</span></span><br><span class="line"><span class="attr">logging:</span> </span><br><span class="line">  <span class="attr">level:</span> </span><br><span class="line">    <span class="attr">root:</span> <span class="string">debug</span></span><br></pre></td></tr></table></figure>

<ul>
<li>application.yaml（yaml格式）</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">82</span></span><br></pre></td></tr></table></figure>

<p>​		我们发现不仅端口生效了，最终显示80，同时其他两条配置也生效了，看来每个配置文件中的项都会生效，只不过如果多个配置文件中有相同类型的配置会优先级高的文件覆盖优先级的文件中的配置。如果配置项不同的话，所有的配置项都会生效。</p>
<p><strong>总结</strong></p>
<ol>
<li>配置文件间的加载优先级	properties（最高）&gt;  yml  &gt;  yaml（最低）</li>
<li>不同配置文件中相同配置按照加载优先级相互覆盖，不同配置文件中不同配置全部保留</li>
</ol>
<h4 id="教你一招：自动提示功能消失解决方案"><a href="#教你一招：自动提示功能消失解决方案" class="headerlink" title="教你一招：自动提示功能消失解决方案"></a>教你一招：<strong>自动提示功能消失解决方案</strong></h4><p>​		在做程序的过程中，可能有些小伙伴会基于各种各样的原因导致配置文件中没有提示，这个确实很让人头疼，所以下面给大家说一下如果自动提示功能消失了怎么解决。</p>
<p>​		先要明确一个核心，就是自动提示功能不是SpringBoot技术给我们提供的，是我们在Idea工具下编程，这个编程工具给我们提供的。明白了这一点后，再来说为什么会出现这种现象。其实这个自动提示功能消失的原因还是蛮多的，如果想解决这个问题，就要知道为什么会消失，大体原因有如下2种：</p>
<ol>
<li><p>Idea认为你现在写配置的文件不是个配置文件，所以拒绝给你提供提示功能</p>
</li>
<li><p>Idea认定你是合理的配置文件，但是Idea加载不到对应的提示信息</p>
<p>这里我们主要解决第一个现象，第二种现象到原理篇再讲解。第一种现象的解决方式如下：</p>
</li>
</ol>
<p><strong>步骤①</strong>：打开设置，【Files】→【Project Structure…】</p>
<p><img src="/2022/09/23/springboot%E5%9F%BA%E7%A1%80%E7%AF%87/image-20211126160548690.png" alt="image-20211126160548690"></p>
<p><strong>步骤②</strong>：在弹出窗口中左侧选择【Facets】，右侧选中Spring路径下对应的模块名称，也就是你自动提示功能消失的那个模块</p>
<p><img src="image-20211126160726589.png" alt="image-20211126160726589" style="zoom:67%;" /><img src="/2022/09/23/springboot%E5%9F%BA%E7%A1%80%E7%AF%87/image-20211126160844372.png" alt="image-20211126160844372"></p>
<p><strong>步骤③</strong>：点击Customize Spring Boot按钮，此时可以看到当前模块对应的配置文件是哪些了。如果没有你想要称为配置文件的文件格式，就有可能无法弹出提示</p>
<p><img src="/2022/09/23/springboot%E5%9F%BA%E7%A1%80%E7%AF%87/image-20211126160946448.png" alt="image-20211126160946448"><img src="image-20211126160954338.png" alt="image-20211126160954338" style="zoom:80%;" /></p>
<p><strong>步骤④</strong>：选择添加配置文件，然后选中要作为配置文件的具体文件就OK了</p>
<p><img src="image-20211126161145082.png" alt="image-20211126161145082" style="zoom:80%;" /><img src="image-20211126161156324.png" alt="image-20211126161156324" style="zoom: 67%;" /></p>
<p>​		到这里就做完了，其实就是Idea的一个小功能</p>
<p><img src="/2022/09/23/springboot%E5%9F%BA%E7%A1%80%E7%AF%87/image-20211126161301699.png" alt="image-20211126161301699"></p>
<p><strong>总结</strong></p>
<ol>
<li><p>指定SpringBoot配置文件</p>
<ul>
<li>Setting → Project Structure → Facets</li>
<li>选中对应项目&#x2F;工程</li>
<li>Customize Spring Boot</li>
<li>选择配置文件</li>
</ul>
</li>
</ol>
<h3 id="JC-2-3-yaml文件"><a href="#JC-2-3-yaml文件" class="headerlink" title="JC-2-3.yaml文件"></a>JC-2-3.yaml文件</h3><p>​		SpringBoot的配置以后主要使用yml结尾的这种文件格式，并且在书写时可以通过提示的形式加载正确的格式。但是这种文件还是有严格的书写格式要求的。下面就来说一下具体的语法格式。</p>
<p>​		YAML（YAML Ain’t Markup Language），一种数据序列化格式。具有容易阅读、容易与脚本语言交互、以数据为核心，重数据轻格式的特点。常见的文件扩展名有两种：</p>
<ul>
<li><p>.yml格式（主流）</p>
</li>
<li><p>.yaml格式</p>
<p>具体的语法格式要求如下：</p>
</li>
</ul>
<ol>
<li>大小写敏感</li>
<li>属性层级关系使用多行描述，<strong>每行结尾使用冒号结束</strong></li>
<li>使用缩进表示层级关系，同层级左侧对齐，只允许使用空格（不允许使用Tab键）</li>
<li>属性值前面添加空格（属性名与属性值之间使用冒号+空格作为分隔）</li>
<li>#号 表示注释</li>
</ol>
<p>​		上述规则不要死记硬背，按照书写习惯慢慢适应，并且在Idea下由于具有提示功能，慢慢适应着写格式就行了。核心的一条规则要记住，<font color="#ff0000"><b>数据前面要加空格与冒号隔开</b></font>。</p>
<p>​		下面列出常见的数据书写格式，熟悉一下</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">boolean:</span> <span class="literal">TRUE</span>  						<span class="comment">#TRUE,true,True,FALSE,false，False均可</span></span><br><span class="line"><span class="attr">float:</span> <span class="number">3.14</span>    						<span class="comment">#6.8523015e+5  #支持科学计数法</span></span><br><span class="line"><span class="attr">int:</span> <span class="number">123</span>       						<span class="comment">#0b1010_0111_0100_1010_1110    #支持二进制、八进制、十六进制</span></span><br><span class="line"><span class="attr">null:</span> <span class="string">~</span>        						<span class="comment">#使用~表示null</span></span><br><span class="line"><span class="attr">string:</span> <span class="string">HelloWorld</span>      			<span class="comment">#字符串可以直接书写</span></span><br><span class="line"><span class="attr">string2:</span> <span class="string">&quot;Hello World&quot;</span>  			<span class="comment">#可以使用双引号包裹特殊字符</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2018-02-17</span>        			<span class="comment">#日期必须使用yyyy-MM-dd格式</span></span><br><span class="line"><span class="attr">datetime:</span> <span class="number">2018-02-17T15:02:31+08:00</span>  <span class="comment">#时间和日期之间使用T连接，最后使用+代表时区</span></span><br></pre></td></tr></table></figure>

<p>​		此外，yaml格式中也可以表示数组，在属性名书写位置的下方使用减号作为数据开始符号，每行书写一个数据，减号与数据间空格分隔。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">subject:</span></span><br><span class="line">	<span class="bullet">-</span> <span class="string">Java</span></span><br><span class="line">	<span class="bullet">-</span> <span class="string">前端</span></span><br><span class="line">	<span class="bullet">-</span> <span class="string">大数据</span></span><br><span class="line"><span class="attr">enterprise:</span></span><br><span class="line">	<span class="attr">name:</span> <span class="string">itcast</span></span><br><span class="line">    <span class="attr">age:</span> <span class="number">16</span></span><br><span class="line">    <span class="attr">subject:</span></span><br><span class="line">    	<span class="bullet">-</span> <span class="string">Java</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">前端</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">大数据</span></span><br><span class="line"><span class="attr">likes:</span> [<span class="string">王者荣耀</span>,<span class="string">刺激战场</span>]			<span class="comment">#数组书写缩略格式</span></span><br><span class="line"><span class="attr">users:</span>							 <span class="comment">#对象数组格式一</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Tom</span></span><br><span class="line">   	<span class="attr">age:</span> <span class="number">4</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Jerry</span></span><br><span class="line">    <span class="attr">age:</span> <span class="number">5</span></span><br><span class="line"><span class="attr">users:</span>							 <span class="comment">#对象数组格式二</span></span><br><span class="line">  <span class="bullet">-</span>  </span><br><span class="line">    <span class="attr">name:</span> <span class="string">Tom</span></span><br><span class="line">    <span class="attr">age:</span> <span class="number">4</span></span><br><span class="line">  <span class="bullet">-</span>   </span><br><span class="line">    <span class="attr">name:</span> <span class="string">Jerry</span></span><br><span class="line">    <span class="attr">age:</span> <span class="number">5</span>			    </span><br><span class="line"><span class="attr">users2:</span> [ &#123; <span class="string">name:Tom</span> , <span class="string">age:4</span> &#125; , &#123; <span class="string">name:Jerry</span> , <span class="string">age:5</span> &#125; ]	<span class="comment">#对象数组缩略格式</span></span><br></pre></td></tr></table></figure>

<p><strong>总结</strong></p>
<ol>
<li>yaml语法规则<ul>
<li>大小写敏感</li>
<li>属性层级关系使用多行描述，每行结尾使用冒号结束</li>
<li>使用缩进表示层级关系，同层级左侧对齐，只允许使用空格（不允许使用Tab键）</li>
<li>属性值前面添加空格（属性名与属性值之间使用冒号+空格作为分隔）</li>
<li>#号 表示注释</li>
</ul>
</li>
<li>注意属性名冒号后面与数据之间有一个<strong>空格</strong></li>
<li>字面值、对象数据格式、数组数据格式</li>
</ol>
<p><strong>思考</strong></p>
<p>​		现在我们已经知道了yaml具有严格的数据格式要求，并且已经可以正确的书写yaml文件了，那这些文件书写后其实是在定义一些数据。这些数据是给谁用的呢？大部分是SpringBoot框架内部使用，但是如果我们想配置一些数据自己使用，能不能用呢？答案是可以的，那如何读取yaml文件中的数据呢？咱们下一节再说。</p>
<h3 id="JC-2-4-yaml数据读取"><a href="#JC-2-4-yaml数据读取" class="headerlink" title="JC-2-4.yaml数据读取"></a>JC-2-4.yaml数据读取</h3><p>​		对于yaml文件中的数据，其实你就可以想象成这就是一个小型的数据库，里面保存有若干数据，每个数据都有一个独立的名字，如果你想读取里面的数据，肯定是支持的，下面就介绍3种读取数据的方式。</p>
<h4 id="读取单一数据"><a href="#读取单一数据" class="headerlink" title="读取单一数据"></a>读取单一数据</h4><p>​		yaml中保存的单个数据，可以使用Spring中的注解@Value读取单个数据，属性名引用方式：<font color="#ff0000"><b>${一级属性名.二级属性名……}</b></font></p>
<img src="image-20211126180433356.png" alt="image-20211126180433356" style="zoom:80%;" />

<p>​		记得使用@Value注解时，要将该注解写在某一个指定的Spring管控的bean的属性名上方，这样当bean进行初始化时候就可以读取到对应的单一数据了。</p>
<p><strong>总结</strong></p>
<ol>
<li>使用@Value配合SpEL读取单个数据</li>
<li>如果数据存在多层级，依次书写层级名称即可</li>
</ol>
<h4 id="读取全部数据"><a href="#读取全部数据" class="headerlink" title="读取全部数据"></a>读取全部数据</h4><p>​		读取单一数据可以解决读取数据的问题，但是如果定义的数据量过大，这么一个一个书写肯定会累死人的，SpringBoot提供了一个对象，能够把所有的数据都封装到这一个对象中，这个对象叫做Environment，使用自动装配注解可以将所有的yaml数据封装到这个对象中</p>
<img src="image-20211126180738569.png" alt="image-20211126180738569" style="zoom:80%;" />

<p>​		数据封装到了Environment对象中，获取属性时，通过Environment的接口操作进行，具体方法是getProperties（String），参数填写属性名即可</p>
<p><strong>总结</strong></p>
<ol>
<li>使用Environment对象封装全部配置信息</li>
<li>使用@Autowired自动装配数据到Environment对象中</li>
</ol>
<h4 id="读取对象数据"><a href="#读取对象数据" class="headerlink" title="读取对象数据"></a>读取对象数据</h4><p>​		单一数据读取书写比较繁琐，全数据读取封装的太厉害了，每次拿数据还要一个一个的getProperties（）,总之用起来都不是很舒服。由于Java是一个面向对象的语言，很多情况下，我们会将一组数据封装成一个对象。SpringBoot也提供了可以将一组yaml对象数据封装一个Java对象的操作</p>
<p>​		首先定义一个对象，并将该对象纳入Spring管控的范围，也就是定义成一个bean，然后使用注解@ConfigurationProperties指定该对象加载哪一组yaml中配置的信息。</p>
<img src="image-20211126181126382.png" alt="image-20211126181126382" style="zoom:80%;" />

<p>​		这个@ConfigurationProperties必须告诉他加载的数据前缀是什么，这样指定前缀下的所有属性就封装到这个对象中。记得数据属性名要与对象的变量名一一对应啊，不然没法封装。其实以后如果你要定义一组数据自己使用，就可以先写一个对象，然后定义好属性，下面到配置中根据这个格式书写即可。</p>
<p>​	<img src="image-20211126181423432.png" alt="image-20211126181423432" style="zoom:80%;" /></p>
<p><font color="#f0f"><b>温馨提示</b></font></p>
<p>​		细心的小伙伴会发现一个问题，自定义的这种数据在yaml文件中书写时没有弹出提示，咱们到原理篇再揭秘如何弹出提示。</p>
<p><strong>总结</strong></p>
<ol>
<li>使用@ConfigurationProperties注解绑定配置信息到封装类中</li>
<li>封装类需要定义为Spring管理的bean，否则无法进行属性注入</li>
</ol>
<h4 id="yaml文件中的数据引用"><a href="#yaml文件中的数据引用" class="headerlink" title="yaml文件中的数据引用"></a>yaml文件中的数据引用</h4><p>​		如果你在书写yaml数据时，经常出现如下现象，比如很多个文件都具有相同的目录前缀</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">center:</span></span><br><span class="line">	<span class="attr">dataDir:</span> <span class="string">/usr/local/fire/data</span></span><br><span class="line">    <span class="attr">tmpDir:</span> <span class="string">/usr/local/fire/tmp</span></span><br><span class="line">    <span class="attr">logDir:</span> <span class="string">/usr/local/fire/log</span></span><br><span class="line">    <span class="attr">msgDir:</span> <span class="string">/usr/local/fire/msgDir</span></span><br></pre></td></tr></table></figure>

<p>​		或者</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">center:</span></span><br><span class="line">	<span class="attr">dataDir:</span> <span class="string">D:/usr/local/fire/data</span></span><br><span class="line">    <span class="attr">tmpDir:</span> <span class="string">D:/usr/local/fire/tmp</span></span><br><span class="line">    <span class="attr">logDir:</span> <span class="string">D:/usr/local/fire/log</span></span><br><span class="line">    <span class="attr">msgDir:</span> <span class="string">D:/usr/local/fire/msgDir</span></span><br></pre></td></tr></table></figure>

<p>​		这个时候你可以使用引用格式来定义数据，其实就是搞了个变量名，然后引用变量了，格式如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">baseDir:</span> <span class="string">/usr/local/fire</span></span><br><span class="line"><span class="attr">center:</span></span><br><span class="line">    <span class="attr">dataDir:</span> <span class="string">$&#123;baseDir&#125;/data</span></span><br><span class="line">    <span class="attr">tmpDir:</span> <span class="string">$&#123;baseDir&#125;/tmp</span></span><br><span class="line">    <span class="attr">logDir:</span> <span class="string">$&#123;baseDir&#125;/log</span></span><br><span class="line">    <span class="attr">msgDir:</span> <span class="string">$&#123;baseDir&#125;/msgDir</span></span><br></pre></td></tr></table></figure>

<p>​	还有一个注意事项，在书写字符串时，如果需要使用转义字符，需要将数据字符串使用双引号包裹起来</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">lesson:</span> <span class="string">&quot;Spring\tboot\nlesson&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>总结</strong></p>
<ol>
<li>在配置文件中可以使用${属性名}方式引用属性值</li>
<li>如果属性中出现特殊字符，可以使用双引号包裹起来作为字符解析</li>
</ol>
<p>​		到这里有关yaml文件的基础使用就先告一段落，实用篇中再继续研究更深入的内容。</p>
<h2 id="JC-3-基于SpringBoot实现SSMP整合"><a href="#JC-3-基于SpringBoot实现SSMP整合" class="headerlink" title="JC-3.基于SpringBoot实现SSMP整合"></a>JC-3.基于SpringBoot实现SSMP整合</h2><p>​		重头戏来了，SpringBoot之所以好用，就是它能方便快捷的整合其他技术，这一部分咱们就来聊聊一些技术的整合方式，通过这一章的学习，大家能够感受到SpringBoot到底有多酷炫。这一章咱们学习如下技术的整合方式</p>
<ul>
<li><p>整合JUnit</p>
</li>
<li><p>整合MyBatis</p>
</li>
<li><p>整合MyBatis-Plus</p>
</li>
<li><p>整合Druid</p>
<p>上面这些技术都整合完毕后，我们做一个小案例，也算是学有所用吧。涉及的技术比较多，综合运用一下。</p>
</li>
</ul>
<h3 id="JC-3-1-整合JUnit"><a href="#JC-3-1-整合JUnit" class="headerlink" title="JC-3-1.整合JUnit"></a>JC-3-1.整合JUnit</h3><p>​		SpringBoot技术的定位用于简化开发，再具体点是简化Spring程序的开发。所以在整合任意技术的时候，如果你想直观感触到简化的效果，你必须先知道使用非SpringBoot技术时对应的整合是如何做的，然后再看基于SpringBoot的整合是如何做的，才能比对出来简化在了哪里。</p>
<p>​		我们先来看一下不使用SpringBoot技术时，Spring整合JUnit的制作方式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//加载spring整合junit专用的类运行器</span></span><br><span class="line"><span class="meta">@RunWith(SpringJUnit4ClassRunner.class)</span></span><br><span class="line"><span class="comment">//指定对应的配置信息</span></span><br><span class="line"><span class="meta">@ContextConfiguration(classes = SpringConfig.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountServiceTestCase</span> &#123;</span><br><span class="line">    <span class="comment">//注入你要测试的对象</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AccountService accountService;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testGetById</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//执行要测试的对象对应的方法</span></span><br><span class="line">        System.out.println(accountService.findById(<span class="number">2</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​		其中核心代码是前两个注解，第一个注解@RunWith是设置Spring专用的测试类运行器，简单说就是Spring程序执行程序有自己的一套独立的运行程序的方式，不能使用JUnit提供的类运行方式了，必须指定一下，但是格式是固定的，琢磨一下，<font color="#ff0000"><b>每次都指定一样的东西，这个东西写起来没有技术含量啊</b></font>，第二个注解@ContextConfiguration是用来设置Spring核心配置文件或配置类的，简单说就是加载Spring的环境你要告诉Spring具体的环境配置是在哪里写的，虽然每次加载的文件都有可能不同，但是仔细想想，如果文件名是固定的，这个貌似也是一个固定格式。既然<font color="#ff0000"><b>有可能是固定格式，那就有可能每次都写一样的东西，也是一个没有技术含量的内容书写</b></font></p>
<p>​		SpringBoot就抓住上述两条没有技术含量的内容书写进行开发简化，能走默认值的走默认值，能不写的就不写，具体格式如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Springboot04JunitApplicationTests</span> &#123;</span><br><span class="line">    <span class="comment">//注入你要测试的对象</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BookDao bookDao;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//执行要测试的对象对应的方法</span></span><br><span class="line">        bookDao.save();</span><br><span class="line">        System.out.println(<span class="string">&quot;two...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		看看这次简化成什么样了，一个注解就搞定了，而且还没有参数，再体会SpringBoot整合其他技术的优势在哪里，就两个字——<font color="#ff0000"><b>简化</b></font>。使用一个注解@SpringBootTest替换了前面两个注解。至于内部是怎么回事？和之前一样，只不过都走默认值。</p>
<p>​		这个时候有人就问了，你加载的配置类或者配置文件是哪一个？就是我们前面启动程序使用的引导类。如果想手工指定引导类有两种方式，第一种方式使用属性的形式进行，在注解@SpringBootTest中添加classes属性指定配置类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest(classes = Springboot04JunitApplication.class)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Springboot04JunitApplicationTests</span> &#123;</span><br><span class="line">    <span class="comment">//注入你要测试的对象</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BookDao bookDao;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//执行要测试的对象对应的方法</span></span><br><span class="line">        bookDao.save();</span><br><span class="line">        System.out.println(<span class="string">&quot;two...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		第二种方式回归原始配置方式，仍然使用@ContextConfiguration注解进行，效果是一样的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@ContextConfiguration(classes = Springboot04JunitApplication.class)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Springboot04JunitApplicationTests</span> &#123;</span><br><span class="line">    <span class="comment">//注入你要测试的对象</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BookDao bookDao;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//执行要测试的对象对应的方法</span></span><br><span class="line">        bookDao.save();</span><br><span class="line">        System.out.println(<span class="string">&quot;two...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><font color="#f0f"><b>温馨提示</b></font></p>
<p>​		使用SpringBoot整合JUnit需要保障导入test对应的starter，由于初始化项目时此项是默认导入的，所以此处没有提及，其实和之前学习的内容一样，用什么技术导入对应的starter即可。</p>
<p><strong>总结</strong></p>
<ol>
<li>导入测试对应的starter</li>
<li>测试类使用@SpringBootTest修饰</li>
<li>使用自动装配的形式添加要测试的对象</li>
<li>测试类如果存在于引导类所在包或子包中无需指定引导类</li>
<li>测试类如果不存在于引导类所在的包或子包中需要通过classes属性指定引导类</li>
</ol>
<h3 id="JC-3-2-整合MyBatis"><a href="#JC-3-2-整合MyBatis" class="headerlink" title="JC-3-2.整合MyBatis"></a>JC-3-2.整合MyBatis</h3><p>​		整合完JUnit下面再来说一下整合MyBatis，这个技术是大部分公司都要使用的技术，务必掌握。如果对Spring整合MyBatis不熟悉的小伙伴好好复习一下，下面列举出原始整合的全部内容，以配置类的形式为例进行</p>
<ul>
<li><p>导入坐标，MyBatis坐标不能少，Spring整合MyBatis还有自己专用的坐标，此外Spring进行数据库操作的jdbc坐标是必须的，剩下还有mysql驱动坐标，本例中使用了Druid数据源，这个倒是可以不要</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.16<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.47<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--1.导入mybatis与spring整合的jar包--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--导入spring操作数据库必选的包--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.10.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Spring核心配置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.itheima&quot;)</span></span><br><span class="line"><span class="meta">@PropertySource(&quot;jdbc.properties&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>MyBatis要交给Spring接管的bean</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义mybatis专用的配置类</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBatisConfig</span> &#123;</span><br><span class="line"><span class="comment">//    定义创建SqlSessionFactory对应的bean</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> SqlSessionFactoryBean <span class="title function_">sqlSessionFactory</span><span class="params">(DataSource dataSource)</span>&#123;</span><br><span class="line">        <span class="comment">//SqlSessionFactoryBean是由mybatis-spring包提供的，专用于整合用的对象</span></span><br><span class="line">        <span class="type">SqlSessionFactoryBean</span> <span class="variable">sfb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBean</span>();</span><br><span class="line">        <span class="comment">//设置数据源替代原始配置中的environments的配置</span></span><br><span class="line">        sfb.setDataSource(dataSource);</span><br><span class="line">        <span class="comment">//设置类型别名替代原始配置中的typeAliases的配置</span></span><br><span class="line">        sfb.setTypeAliasesPackage(<span class="string">&quot;com.itheima.domain&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> sfb;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    定义加载所有的映射配置</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MapperScannerConfigurer <span class="title function_">mapperScannerConfigurer</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">MapperScannerConfigurer</span> <span class="variable">msc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MapperScannerConfigurer</span>();</span><br><span class="line">        msc.setBasePackage(<span class="string">&quot;com.itheima.dao&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> msc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>数据源对应的bean，此处使用Druid数据源</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdbcConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.driver&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String driver;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.url&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.username&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.password&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(&quot;dataSource&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">dataSource</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">DruidDataSource</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">        ds.setDriverClassName(driver);</span><br><span class="line">        ds.setUrl(url);</span><br><span class="line">        ds.setUsername(userName);</span><br><span class="line">        ds.setPassword(password);</span><br><span class="line">        <span class="keyword">return</span> ds;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>数据库连接信息（properties格式）</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">jdbc.driver</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="attr">jdbc.url</span>=<span class="string">jdbc:mysql://localhost:3306/spring_db?useSSL=false</span></span><br><span class="line"><span class="attr">jdbc.username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">jdbc.password</span>=<span class="string">root</span></span><br></pre></td></tr></table></figure>

<p>上述格式基本上是最简格式了，要写的东西还真不少。下面看看SpringBoot整合MyBaits格式</p>
</li>
</ul>
<p><strong>步骤①</strong>：创建模块</p>
<p><img src="/2022/09/23/springboot%E5%9F%BA%E7%A1%80%E7%AF%87/image-20211129092156020.png" alt="image-20211129092156020"></p>
<p><strong>步骤②</strong>：勾选要使用的技术，MyBatis，由于要操作数据库，还要勾选对应数据库</p>
<p><img src="/2022/09/23/springboot%E5%9F%BA%E7%A1%80%E7%AF%87/image-20211129092210993.png" alt="image-20211129092210993"></p>
<p>​	或者手工导入对应技术的starter，和对应数据库的坐标</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--1.导入对应的starter--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>步骤③</strong>：配置数据源相关信息，没有这个信息你连接哪个数据库都不知道</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#2.配置相关信息</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/ssm_db</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">root</span></span><br></pre></td></tr></table></figure>

<p>​		结束了，就这么多，没了。有人就很纳闷，这就结束了？对，这就结束了，SpringBoot把配置中所有可能出现的通用配置都简化了。下面写一个MyBatis程序运行需要的Dao（或者Mapper）就可以运行了</p>
<p><strong>实体类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Book</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String type;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String description;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>映射接口（Dao）</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="meta">@Select(&quot;select * from tbl_book where id = #&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Book <span class="title function_">getById</span><span class="params">(Integer id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>测试类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Springboot05MybatisApplicationTests</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BookDao bookDao;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(bookDao.getById(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		完美，开发从此变的就这么简单。再体会一下SpringBoot如何进行第三方技术整合的，是不是很优秀？具体内部的原理到原理篇再展开讲解</p>
<p>​		<font color="#ff0000"><b>注意</b></font>：当前使用的SpringBoot版本是2.5.4，对应的坐标设置中Mysql驱动使用的是8x版本。使用SpringBoot2.4.3（不含）之前版本会出现一个小BUG，就是MySQL驱动升级到8以后要求强制配置时区，如果不设置会出问题。解决方案很简单，驱动url上面添加上对应设置就行了</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#2.配置相关信息</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/ssm_db?serverTimezone=UTC</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">root</span></span><br></pre></td></tr></table></figure>

<p>​		这里设置的UTC是全球标准时间，你也可以理解为是英国时间，中国处在东八区，需要在这个基础上加上8小时，这样才能和中国地区的时间对应的，也可以修改配置为Asia&#x2F;Shanghai，同样可以解决这个问题。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#2.配置相关信息</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/ssm_db?serverTimezone=Asia/Shanghai</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">root</span></span><br></pre></td></tr></table></figure>

<p>​		如果不想每次都设置这个东西，也可以去修改mysql中的配置文件mysql.ini，在mysqld项中添加default-time-zone&#x3D;+8:00也可以解决这个问题。其实方式方法很多，这里就说这么多吧。</p>
<p>​		此外在运行程序时还会给出一个提示，说数据库驱动过时的警告，根据提示修改配置即可，弃用<strong>com.mysql.jdbc.Driver</strong>，换用<font color="#ff0000"><b>com.mysql.cj.jdbc.Driver</b></font>。前面的例子中已经更换了驱动了，在此说明一下。</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">Loading class `com.mysql.jdbc.Driver&#x27;. This is deprecated. The new driver class is `com.mysql.cj.jdbc.Driver&#x27;. The driver is automatically registered via the SPI and manual loading of the driver class is generally unnecessary.</span><br></pre></td></tr></table></figure>

<p><strong>总结</strong></p>
<ol>
<li><p>整合操作需要勾选MyBatis技术，也就是导入MyBatis对应的starter</p>
</li>
<li><p>数据库连接相关信息转换成配置</p>
</li>
<li><p>数据库SQL映射需要添加@Mapper被容器识别到</p>
</li>
<li><p>MySQL 8.X驱动强制要求设置时区</p>
<ul>
<li>修改url，添加serverTimezone设定</li>
<li>修改MySQL数据库配置</li>
</ul>
</li>
<li><p>驱动类过时，提醒更换为com.mysql.cj.jdbc.Driver</p>
</li>
</ol>
<h3 id="JC-3-3-整合MyBatis-Plus"><a href="#JC-3-3-整合MyBatis-Plus" class="headerlink" title="JC-3-3.整合MyBatis-Plus"></a>JC-3-3.整合MyBatis-Plus</h3><p>​		做完了两种技术的整合了，各位小伙伴要学会总结，我们做这个整合究竟哪些是核心？总结下来就两句话</p>
<ul>
<li><p>导入对应技术的starter坐标</p>
</li>
<li><p>根据对应技术的要求做配置</p>
<p>虽然看起来有点虚，但是确实是这个理儿，下面趁热打铁，再换一个技术，看看是不是上面这两步。</p>
</li>
</ul>
<p>​		接下来在MyBatis的基础上再升级一下，整合MyBaitsPlus（简称MP），国人开发的技术，符合中国人开发习惯，谁用谁知道。来吧，一起做整合</p>
<p><strong>步骤①</strong>：导入对应的starter</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>​		关于这个坐标，此处要说明一点，之前我们看的starter都是spring-boot-starter-？？？，也就是说都是下面的格式</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">Spring-boot-start-***</span><br></pre></td></tr></table></figure>

<p>​	而MyBatis与MyBatisPlus这两个坐标的名字书写比较特殊，是第三方技术名称在前，boot和starter在后。此处简单提一下命名规范，后期原理篇会再详细讲解</p>
<table>
<thead>
<tr>
<th>starter所属</th>
<th>命名规则</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>官方提供</td>
<td>spring-boot-starter-技术名称</td>
<td>spring-boot-starter-web <br/>spring-boot-starter-test</td>
</tr>
<tr>
<td>第三方提供</td>
<td>第三方技术名称-spring-boot-starter</td>
<td>mybatis-spring-boot-starter<br/>druid-spring-boot-starter</td>
</tr>
<tr>
<td>第三方提供</td>
<td>第三方技术名称-boot-starter（第三方技术名称过长，简化命名）</td>
<td>mybatis-plus-boot-starter</td>
</tr>
</tbody></table>
<p><font color="#f0f"><b>温馨提示</b></font></p>
<p>​		有些小伙伴在创建项目时想通过勾选的形式找到这个名字，别翻了，没有。截止目前，SpringBoot官网还未收录此坐标，而我们Idea创建模块时读取的是SpringBoot官网的Spring Initializr，所以也没有。如果换用阿里云的url创建项目可以找到对应的坐标。</p>
<p><strong>步骤②</strong>：配置数据源相关信息</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#2.配置相关信息</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/ssm_db</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">root</span></span><br></pre></td></tr></table></figure>

<p>​	没了，就这么多，剩下的就是写MyBaitsPlus的程序了</p>
<p><strong>映射接口（Dao）</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BookDao</span> <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;Book&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	核心在于Dao接口继承了一个BaseMapper的接口，这个接口中帮助开发者预定了若干个常用的API接口，简化了通用API接口的开发工作。</p>
<img src="image-20211129100313919.png" alt="image-20211129100313919" style="zoom:80%;" />

<p>​	下面就可以写一个测试类进行测试了，此处省略。</p>
<p><font color="#f0f"><b>温馨提示</b></font></p>
<p>​		目前数据库的表名定义规则是tbl_模块名称，为了能和实体类相对应，需要做一个配置，相关知识各位小伙伴可以到MyBatisPlus课程中去学习，此处仅给出解决方案。配置application.yml文件，添加如下配置即可，设置所有表名的通用前缀名</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">global-config:</span></span><br><span class="line">    <span class="attr">db-config:</span></span><br><span class="line">      <span class="attr">table-prefix:</span> <span class="string">tbl_</span>		<span class="comment">#设置所有表的通用前缀名称为tbl_</span></span><br></pre></td></tr></table></figure>

<p><strong>总结</strong></p>
<ol>
<li>手工添加MyBatis-Plus对应的starter</li>
<li>数据层接口使用BaseMapper简化开发</li>
<li>需要使用的第三方技术无法通过勾选确定时，需要手工添加坐标</li>
</ol>
<h3 id="JC-3-4-整合Druid"><a href="#JC-3-4-整合Druid" class="headerlink" title="JC-3-4.整合Druid"></a>JC-3-4.整合Druid</h3><p>​		使用SpringBoot整合了3个技术了，发现套路基本相同，导入对应的starter，然后做配置，各位小伙伴需要一直强化这套思想。下面再整合一个技术，继续深入强化此思想。</p>
<p>​		前面整合MyBatis和MyBatisPlus的时候，使用的数据源对象都是SpringBoot默认的数据源对象，下面我们手工控制一下，自己指定了一个数据源对象，Druid。</p>
<p>​		在没有指定数据源时，我们的配置如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#2.配置相关信息</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/ssm_db?serverTimezone=Asia/Shanghai</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">root</span></span><br></pre></td></tr></table></figure>

<p>​		此时虽然没有指定数据源，但是根据SpringBoot的德行，肯定帮我们选了一个它认为最好的数据源对象，这就是HiKari。通过启动日志可以查看到对应的身影。</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">2021-11-29 09:39:15.202  INFO 12260 --- [           main] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Starting...</span><br><span class="line">2021-11-29 09:39:15.208  WARN 12260 --- [           main] com.zaxxer.hikari.util.DriverDataSource  : Registered driver with driverClassName=com.mysql.jdbc.Driver was not found, trying direct instantiation.</span><br><span class="line">2021-11-29 09:39:15.551  INFO 12260 --- [           main] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Start completed.</span><br></pre></td></tr></table></figure>

<p>​		上述信息中每一行都有HiKari的身影，如果需要更换数据源，其实只需要两步即可。</p>
<ol>
<li><p>导入对应的技术坐标</p>
</li>
<li><p>配置使用指定的数据源类型</p>
<p>下面就切换一下数据源对象</p>
</li>
</ol>
<p><strong>步骤①</strong>：导入对应的坐标（注意，是坐标，此处不是starter）</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.16<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>步骤②</strong>：修改配置，在数据源配置中有一个type属性，专用于指定数据源类型</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/ssm_db?serverTimezone=UTC</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">com.alibaba.druid.pool.DruidDataSource</span></span><br></pre></td></tr></table></figure>

<p>​		这里其实要提出一个问题的，目前的数据源配置格式是一个通用格式，不管你换什么数据源都可以用这种形式进行配置。但是新的问题又来了，如果对数据源进行个性化的配置，例如配置数据源对应的连接数量，这个时候就有新的问题了。每个数据源技术对应的配置名称都一样吗？肯定不是啊，各个厂商不可能提前商量好都写一样的名字啊，怎么办？就要使用专用的配置格式了。这个时候上面这种通用格式就不能使用了，怎么办？还能怎么办？按照SpringBoot整合其他技术的通用规则来套啊，导入对应的starter，进行相应的配置即可。</p>
<p><strong>步骤①</strong>：导入对应的starter</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>步骤②</strong>：修改配置</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">druid:</span></span><br><span class="line">      <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">      <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/ssm_db?serverTimezone=UTC</span></span><br><span class="line">      <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">      <span class="attr">password:</span> <span class="string">root</span></span><br></pre></td></tr></table></figure>

<p>​		注意观察，配置项中，在datasource下面并不是直接配置url这些属性的，而是先配置了一个druid节点，然后再配置的url这些东西。言外之意，url这个属性是druid下面的属性，那你能想到什么？除了这4个常规配置外，还有druid专用的其他配置。通过提示功能可以打开druid相关的配置查阅</p>
<img src="image-20211129112610729.png" alt="image-20211129112610729" style="zoom:80%;" />

<p>​	与druid相关的配置超过200条以上，这就告诉你，如果想做druid相关的配置，使用这种格式就可以了，这里就不展开描述了，太多了。</p>
<p>​	这是我们做的第4个技术的整合方案，还是那两句话：<font color="#ff0000"><b>导入对应starter，使用对应配置</b></font>。没了，SpringBoot整合其他技术就这么简单粗暴。</p>
<p><strong>总结</strong></p>
<ol>
<li>整合Druid需要导入Druid对应的starter</li>
<li>根据Druid提供的配置方式进行配置</li>
<li>整合第三方技术通用方式<ul>
<li>导入对应的starter</li>
<li>根据提供的配置格式，配置非默认值对应的配置项</li>
</ul>
</li>
</ol>
<h3 id="JC-3-5-SSMP整合综合案例"><a href="#JC-3-5-SSMP整合综合案例" class="headerlink" title="JC-3-5.SSMP整合综合案例"></a>JC-3-5.SSMP整合综合案例</h3><p>​		SpringBoot能够整合的技术太多太多了，对于初学者来说慢慢来，一点点掌握。前面咱们做了4个整合了，下面就通过一个稍微综合一点的案例，将所有知识贯穿起来，同时做一个小功能，体会一下。不过有言在先，这个案例制作的时候，你可能会有这种感觉，说好的SpringBoot整合其他技术的案例，为什么感觉SpringBoot整合其他技术的身影不多呢？因为这东西书写太简单了，简单到瞬间写完，大量的时间做的不是这些整合工作。</p>
<p>​		先看一下这个案例的最终效果</p>
<p><strong>主页面</strong></p>
<p><img src="/2022/09/23/springboot%E5%9F%BA%E7%A1%80%E7%AF%87/image-20211129113447844.png" alt="image-20211129113447844"></p>
<p><strong>添加</strong></p>
<p><img src="/2022/09/23/springboot%E5%9F%BA%E7%A1%80%E7%AF%87/image-20211129113522459.png" alt="image-20211129113522459"></p>
<p><strong>删除</strong></p>
<p><img src="/2022/09/23/springboot%E5%9F%BA%E7%A1%80%E7%AF%87/image-20211129113550829.png" alt="image-20211129113550829"></p>
<p><strong>修改</strong></p>
<p><img src="/2022/09/23/springboot%E5%9F%BA%E7%A1%80%E7%AF%87/image-20211129113610966.png" alt="image-20211129113610966"></p>
<p><strong>分页</strong></p>
<p><img src="/2022/09/23/springboot%E5%9F%BA%E7%A1%80%E7%AF%87/image-20211129113628969.png" alt="image-20211129113628969"></p>
<p><strong>条件查询</strong></p>
<p><img src="/2022/09/23/springboot%E5%9F%BA%E7%A1%80%E7%AF%87/image-20211129113650369.png" alt="image-20211129113650369"></p>
<p>​	整体案例中需要采用的技术如下，先了解一下，做到哪一个说哪一个</p>
<ol>
<li>实体类开发————使用Lombok快速制作实体类</li>
<li>Dao开发————整合MyBatisPlus，制作数据层测试</li>
<li>Service开发————基于MyBatisPlus进行增量开发，制作业务层测试类</li>
<li>Controller开发————基于Restful开发，使用PostMan测试接口功能</li>
<li>Controller开发————前后端开发协议制作</li>
<li>页面开发————基于VUE+ElementUI制作，前后端联调，页面数据处理，页面消息处理<ul>
<li>列表</li>
<li>新增</li>
<li>修改</li>
<li>删除</li>
<li>分页</li>
<li>查询</li>
</ul>
</li>
<li>项目异常处理</li>
<li>按条件查询————页面功能调整、Controller修正功能、Service修正功能</li>
</ol>
<p>​		可以看的出来，东西还是很多的，希望通过这个案例，各位小伙伴能够完成基础开发的技能训练。整体开发过程采用做一层测一层的形式进行，过程完整，战线较长，希望各位能跟紧进度，完成这个小案例的制作。</p>
<h4 id="0-模块创建"><a href="#0-模块创建" class="headerlink" title="0.模块创建"></a>0.模块创建</h4><p>​		对于这个案例如果按照企业开发的形式进行应该制作后台微服务，前后端分离的开发。</p>
<img src="image-20211129114306062.png" alt="image-20211129114306062" style="zoom:80%;" />

<p>​		我知道这个对初学的小伙伴要求太高了，咱们简化一下。后台做单体服务器，前端不使用前后端分离的制作了。</p>
<img src="image-20211129114328967.png" alt="image-20211129114328967" style="zoom:80%;" />

<p>​		一个服务器即充当后台服务调用，又负责前端页面展示，降低学习的门槛。</p>
<p>​		下面我们创建一个新的模块，加载要使用的技术对应的starter，修改配置文件格式为yml格式，并把web访问端口先设置成80。</p>
<p><strong>pom.xml</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>application.yml</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>



<h4 id="1-实体类开发"><a href="#1-实体类开发" class="headerlink" title="1.实体类开发"></a>1.实体类开发</h4><p>​		本案例对应的模块表结构如下：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">-- ----------------------------</span><br><span class="line">-- Table structure for tbl<span class="built_in">_</span>book</span><br><span class="line">-- ----------------------------</span><br><span class="line">DROP TABLE IF EXISTS `tbl<span class="built_in">_</span>book`;</span><br><span class="line">CREATE TABLE `tbl<span class="built_in">_</span>book`  (</span><br><span class="line">  `id` int(11) NOT NULL AUTO<span class="built_in">_</span>INCREMENT,</span><br><span class="line">  `type` varchar(20) CHARACTER SET utf8 COLLATE utf8<span class="built_in">_</span>general<span class="built_in">_</span>ci NULL DEFAULT NULL,</span><br><span class="line">  `name` varchar(50) CHARACTER SET utf8 COLLATE utf8<span class="built_in">_</span>general<span class="built_in">_</span>ci NULL DEFAULT NULL,</span><br><span class="line">  `description` varchar(255) CHARACTER SET utf8 COLLATE utf8<span class="built_in">_</span>general<span class="built_in">_</span>ci NULL DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`) USING BTREE</span><br><span class="line">) ENGINE = InnoDB AUTO<span class="built_in">_</span>INCREMENT = 51 CHARACTER SET = utf8 COLLATE = utf8<span class="built_in">_</span>general<span class="built_in">_</span>ci ROW<span class="built_in">_</span>FORMAT = Dynamic;</span><br><span class="line"></span><br><span class="line">-- ----------------------------</span><br><span class="line">-- Records of tbl<span class="built_in">_</span>book</span><br><span class="line">-- ----------------------------</span><br><span class="line">INSERT INTO `tbl<span class="built_in">_</span>book` VALUES (1, &#x27;计算机理论&#x27;, &#x27;Spring实战 第5版&#x27;, &#x27;Spring入门经典教程，深入理解Spring原理技术内幕&#x27;);</span><br><span class="line">INSERT INTO `tbl<span class="built_in">_</span>book` VALUES (2, &#x27;计算机理论&#x27;, &#x27;Spring 5核心原理与30个类手写实战&#x27;, &#x27;十年沉淀之作，手写Spring精华思想&#x27;);</span><br><span class="line">INSERT INTO `tbl<span class="built_in">_</span>book` VALUES (3, &#x27;计算机理论&#x27;, &#x27;Spring 5 设计模式&#x27;, &#x27;深入Spring源码剖析Spring源码中蕴含的10大设计模式&#x27;);</span><br><span class="line">INSERT INTO `tbl<span class="built_in">_</span>book` VALUES (4, &#x27;计算机理论&#x27;, &#x27;Spring MVC+MyBatis开发从入门到项目实战&#x27;, &#x27;全方位解析面向Web应用的轻量级框架，带你成为Spring MVC开发高手&#x27;);</span><br><span class="line">INSERT INTO `tbl<span class="built_in">_</span>book` VALUES (5, &#x27;计算机理论&#x27;, &#x27;轻量级Java Web企业应用实战&#x27;, &#x27;源码级剖析Spring框架，适合已掌握Java基础的读者&#x27;);</span><br><span class="line">INSERT INTO `tbl<span class="built_in">_</span>book` VALUES (6, &#x27;计算机理论&#x27;, &#x27;Java核心技术 卷I 基础知识（原书第11版）&#x27;, &#x27;Core Java 第11版，Jolt大奖获奖作品，针对Java SE9、10、11全面更新&#x27;);</span><br><span class="line">INSERT INTO `tbl<span class="built_in">_</span>book` VALUES (7, &#x27;计算机理论&#x27;, &#x27;深入理解Java虚拟机&#x27;, &#x27;5个维度全面剖析JVM，大厂面试知识点全覆盖&#x27;);</span><br><span class="line">INSERT INTO `tbl<span class="built_in">_</span>book` VALUES (8, &#x27;计算机理论&#x27;, &#x27;Java编程思想（第4版）&#x27;, &#x27;Java学习必读经典,殿堂级著作！赢得了全球程序员的广泛赞誉&#x27;);</span><br><span class="line">INSERT INTO `tbl<span class="built_in">_</span>book` VALUES (9, &#x27;计算机理论&#x27;, &#x27;零基础学Java（全彩版）&#x27;, &#x27;零基础自学编程的入门图书，由浅入深，详解Java语言的编程思想和核心技术&#x27;);</span><br><span class="line">INSERT INTO `tbl<span class="built_in">_</span>book` VALUES (10, &#x27;市场营销&#x27;, &#x27;直播就该这么做：主播高效沟通实战指南&#x27;, &#x27;李子柒、李佳琦、薇娅成长为网红的秘密都在书中&#x27;);</span><br><span class="line">INSERT INTO `tbl<span class="built_in">_</span>book` VALUES (11, &#x27;市场营销&#x27;, &#x27;直播销讲实战一本通&#x27;, &#x27;和秋叶一起学系列网络营销书籍&#x27;);</span><br><span class="line">INSERT INTO `tbl<span class="built_in">_</span>book` VALUES (12, &#x27;市场营销&#x27;, &#x27;直播带货：淘宝、天猫直播从新手到高手&#x27;, &#x27;一本教你如何玩转直播的书，10堂课轻松实现带货月入3W+&#x27;);</span><br></pre></td></tr></table></figure>

<p>​		根据上述表结构，制作对应的实体类</p>
<p><strong>实体类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Book</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String type;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String description;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		实体类的开发可以自动通过工具手工生成get&#x2F;set方法，然后覆盖toString()方法，方便调试，等等。不过这一套操作书写很繁琐，有对应的工具可以帮助我们简化开发，介绍一个小工具，lombok。</p>
<p>​		Lombok，一个Java类库，提供了一组注解，简化POJO实体类开发，SpringBoot目前默认集成了lombok技术，并提供了对应的版本控制，所以只需要提供对应的坐标即可，在pom.xml中添加lombok的坐标。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--lombok--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>​		使用lombok可以通过一个注解@Data完成一个实体类对应的getter，setter，toString，equals，hashCode等操作的快速添加</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Book</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String type;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String description;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		到这里实体类就做好了，是不是比不使用lombok简化好多，这种工具在Java开发中还有N多，后面遇到了能用的实用开发技术时，在不增加各位小伙伴大量的学习时间的情况下，尽量多给大家介绍一些。</p>
<p><strong>总结</strong></p>
<ol>
<li>实体类制作</li>
<li>使用lombok简化开发<ul>
<li>导入lombok无需指定版本，由SpringBoot提供版本</li>
<li>@Data注解</li>
</ul>
</li>
</ol>
<h4 id="2-数据层开发——基础CRUD"><a href="#2-数据层开发——基础CRUD" class="headerlink" title="2.数据层开发——基础CRUD"></a>2.数据层开发——基础CRUD</h4><p>​		数据层开发本次使用MyBatisPlus技术，数据源使用前面学习的Druid，学都学了都用上。</p>
<p><strong>步骤①</strong>：导入MyBatisPlus与Druid对应的starter，当然mysql的驱动不能少</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>步骤②</strong>：配置数据库连接相关的数据源配置</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">druid:</span></span><br><span class="line">      <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">      <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/ssm_db?serverTimezone=UTC</span></span><br><span class="line">      <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">      <span class="attr">password:</span> <span class="string">root</span></span><br></pre></td></tr></table></figure>

<p><strong>步骤③</strong>：使用MyBatisPlus的标准通用接口BaseMapper加速开发，别忘了@Mapper和泛型的指定</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BookDao</span> <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;Book&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>步骤④</strong>：制作测试类测试结果，这个测试类制作是个好习惯，不过在企业开发中往往都为加速开发跳过此步，且行且珍惜吧</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.core.metadata.IPage;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.extension.plugins.pagination.Page;</span><br><span class="line"><span class="keyword">import</span> com.itheima.domain.Book;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoTestCase</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BookDao bookDao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testGetById</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(bookDao.selectById(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testSave</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Book</span> <span class="variable">book</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Book</span>();</span><br><span class="line">        book.setType(<span class="string">&quot;测试数据123&quot;</span>);</span><br><span class="line">        book.setName(<span class="string">&quot;测试数据123&quot;</span>);</span><br><span class="line">        book.setDescription(<span class="string">&quot;测试数据123&quot;</span>);</span><br><span class="line">        bookDao.insert(book);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testUpdate</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Book</span> <span class="variable">book</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Book</span>();</span><br><span class="line">        book.setId(<span class="number">17</span>);</span><br><span class="line">        book.setType(<span class="string">&quot;测试数据abcdefg&quot;</span>);</span><br><span class="line">        book.setName(<span class="string">&quot;测试数据123&quot;</span>);</span><br><span class="line">        book.setDescription(<span class="string">&quot;测试数据123&quot;</span>);</span><br><span class="line">        bookDao.updateById(book);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testDelete</span><span class="params">()</span>&#123;</span><br><span class="line">        bookDao.deleteById(<span class="number">16</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testGetAll</span><span class="params">()</span>&#123;</span><br><span class="line">        bookDao.selectList(<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><font color="#f0f"><b>温馨提示</b></font></p>
<p>​		MyBatisPlus技术默认的主键生成策略为雪花算法，生成的主键ID长度较大，和目前的数据库设定规则不相符，需要配置一下使MyBatisPlus使用数据库的主键生成策略，方式嘛还是老一套，做配置。在application.yml中添加对应配置即可，具体如下</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">druid:</span></span><br><span class="line">      <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">      <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/ssm_db?serverTimezone=UTC</span></span><br><span class="line">      <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">      <span class="attr">password:</span> <span class="string">root</span></span><br><span class="line"></span><br><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">global-config:</span></span><br><span class="line">    <span class="attr">db-config:</span></span><br><span class="line">      <span class="attr">table-prefix:</span> <span class="string">tbl_</span>		<span class="comment">#设置表名通用前缀</span></span><br><span class="line">      <span class="attr">id-type:</span> <span class="string">auto</span>				<span class="comment">#设置主键id字段的生成策略为参照数据库设定的策略，当前数据库设置id生成策略为自增</span></span><br></pre></td></tr></table></figure>

<h5 id="查看MyBatisPlus运行日志"><a href="#查看MyBatisPlus运行日志" class="headerlink" title="查看MyBatisPlus运行日志"></a>查看MyBatisPlus运行日志</h5><p>​		在进行数据层测试的时候，因为基础的CRUD操作均由MyBatisPlus给我们提供了，所以就出现了一个局面，开发者不需要书写SQL语句了，这样程序运行的时候总有一种感觉，一切的一切都是黑盒的，作为开发者我们啥也不知道就完了。如果程序正常运行还好，如果报错了，这个时候就很崩溃，你甚至都不知道从何下手，因为传递参数、封装SQL语句这些操作完全不是你开发出来的，所以查看执行期运行的SQL语句就成为当务之急。</p>
<p>​		SpringBoot整合MyBatisPlus的时候充分考虑到了这点，通过配置的形式就可以查阅执行期SQL语句，配置如下</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">global-config:</span></span><br><span class="line">    <span class="attr">db-config:</span></span><br><span class="line">      <span class="attr">table-prefix:</span> <span class="string">tbl_</span></span><br><span class="line">      <span class="attr">id-type:</span> <span class="string">auto</span></span><br><span class="line">  <span class="attr">configuration:</span></span><br><span class="line">    <span class="attr">log-impl:</span> <span class="string">org.apache.ibatis.logging.stdout.StdOutImpl</span></span><br></pre></td></tr></table></figure>

<p>​		再来看运行结果，此时就显示了运行期执行SQL的情况。</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">Creating a new SqlSession</span><br><span class="line">SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@2c9a6717] was not registered for synchronization because synchronization is not active</span><br><span class="line">JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@6ca30b8a] will not be managed by Spring</span><br><span class="line">==&gt;  Preparing: SELECT id,type,name,description FROM tbl<span class="built_in">_</span>book</span><br><span class="line">==&gt; Parameters: </span><br><span class="line">&lt;==    Columns: id, type, name, description</span><br><span class="line">&lt;==        Row: 1, 计算机理论, Spring实战 第5版, Spring入门经典教程，深入理解Spring原理技术内幕</span><br><span class="line">&lt;==        Row: 2, 计算机理论, Spring 5核心原理与30个类手写实战, 十年沉淀之作，手写Spring精华思想</span><br><span class="line">&lt;==        Row: 3, 计算机理论, Spring 5 设计模式, 深入Spring源码剖析Spring源码中蕴含的10大设计模式</span><br><span class="line">&lt;==        Row: 4, 计算机理论, Spring MVC+MyBatis开发从入门到项目实战, 全方位解析面向Web应用的轻量级框架，带你成为Spring MVC开发高手</span><br><span class="line">&lt;==        Row: 5, 计算机理论, 轻量级Java Web企业应用实战, 源码级剖析Spring框架，适合已掌握Java基础的读者</span><br><span class="line">&lt;==        Row: 6, 计算机理论, Java核心技术 卷I 基础知识（原书第11版）, Core Java 第11版，Jolt大奖获奖作品，针对Java SE9、10、11全面更新</span><br><span class="line">&lt;==        Row: 7, 计算机理论, 深入理解Java虚拟机, 5个维度全面剖析JVM，大厂面试知识点全覆盖</span><br><span class="line">&lt;==        Row: 8, 计算机理论, Java编程思想（第4版）, Java学习必读经典,殿堂级著作！赢得了全球程序员的广泛赞誉</span><br><span class="line">&lt;==        Row: 9, 计算机理论, 零基础学Java（全彩版）, 零基础自学编程的入门图书，由浅入深，详解Java语言的编程思想和核心技术</span><br><span class="line">&lt;==        Row: 10, 市场营销, 直播就该这么做：主播高效沟通实战指南, 李子柒、李佳琦、薇娅成长为网红的秘密都在书中</span><br><span class="line">&lt;==        Row: 11, 市场营销, 直播销讲实战一本通, 和秋叶一起学系列网络营销书籍</span><br><span class="line">&lt;==        Row: 12, 市场营销, 直播带货：淘宝、天猫直播从新手到高手, 一本教你如何玩转直播的书，10堂课轻松实现带货月入3W+</span><br><span class="line">&lt;==        Row: 13, 测试类型, 测试数据, 测试描述数据</span><br><span class="line">&lt;==        Row: 14, 测试数据update, 测试数据update, 测试数据update</span><br><span class="line">&lt;==        Row: 15, -----------------, 测试数据123, 测试数据123</span><br><span class="line">&lt;==      Total: 15</span><br></pre></td></tr></table></figure>

<p>​		其中清晰的标注了当前执行的SQL语句是什么，携带了什么参数，对应的执行结果是什么，所有信息应有尽有。</p>
<p>​		此处设置的是日志的显示形式，当前配置的是控制台输出，当然还可以由更多的选择，根据需求切换即可</p>
<img src="image-20211129143207295.png" alt="image-20211129143207295" style="zoom:80%;" />



<p><strong>总结</strong></p>
<ol>
<li><p>手工导入starter坐标（2个），mysql驱动（1个）</p>
</li>
<li><p>配置数据源与MyBatisPlus对应的配置</p>
</li>
<li><p>开发Dao接口（继承BaseMapper）</p>
</li>
<li><p>制作测试类测试Dao功能是否有效</p>
</li>
<li><p>使用配置方式开启日志，设置日志输出方式为标准输出即可查阅SQL执行日志</p>
</li>
</ol>
<h4 id="3-数据层开发——分页功能制作"><a href="#3-数据层开发——分页功能制作" class="headerlink" title="3.数据层开发——分页功能制作"></a>3.数据层开发——分页功能制作</h4><p>​		前面仅仅是使用了MyBatisPlus提供的基础CRUD功能，实际上MyBatisPlus给我们提供了几乎所有的基础操作，这一节说一下如何实现数据库端的分页操作。</p>
<p>​		MyBatisPlus提供的分页操作API如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testGetPage</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">IPage</span> <span class="variable">page</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Page</span>(<span class="number">2</span>,<span class="number">5</span>);</span><br><span class="line">    bookDao.selectPage(page, <span class="literal">null</span>);</span><br><span class="line">    System.out.println(page.getCurrent());</span><br><span class="line">    System.out.println(page.getSize());</span><br><span class="line">    System.out.println(page.getTotal());</span><br><span class="line">    System.out.println(page.getPages());</span><br><span class="line">    System.out.println(page.getRecords());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		其中selectPage方法需要传入一个封装分页数据的对象，可以通过new的形式创建这个对象，当然这个对象也是MyBatisPlus提供的，别选错包了。创建此对象时需要指定两个分页的基本数据</p>
<ul>
<li>当前显示第几页</li>
<li>每页显示几条数据</li>
</ul>
<p>​		可以通过创建Page对象时利用构造方法初始化这两个数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">IPage</span> <span class="variable">page</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Page</span>(<span class="number">2</span>,<span class="number">5</span>);</span><br></pre></td></tr></table></figure>

<p>​		将该对象传入到查询方法selectPage后，可以得到查询结果，但是我们会发现当前操作查询结果返回值仍然是一个IPage对象，这又是怎么回事？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">IPage</span> <span class="variable">page</span> <span class="operator">=</span> bookDao.selectPage(page, <span class="literal">null</span>);</span><br></pre></td></tr></table></figure>

<p>​		原来这个IPage对象中封装了若干个数据，而查询的结果作为IPage对象封装的一个数据存在的，可以理解为查询结果得到后，又塞到了这个IPage对象中，其实还是为了高度的封装，一个IPage描述了分页所有的信息。下面5个操作就是IPage对象中封装的所有信息了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testGetPage</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">IPage</span> <span class="variable">page</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Page</span>(<span class="number">2</span>,<span class="number">5</span>);</span><br><span class="line">    bookDao.selectPage(page, <span class="literal">null</span>);</span><br><span class="line">    System.out.println(page.getCurrent());		<span class="comment">//当前页码值</span></span><br><span class="line">    System.out.println(page.getSize());			<span class="comment">//每页显示数</span></span><br><span class="line">    System.out.println(page.getTotal());		<span class="comment">//数据总量</span></span><br><span class="line">    System.out.println(page.getPages());		<span class="comment">//总页数</span></span><br><span class="line">    System.out.println(page.getRecords());		<span class="comment">//详细数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		到这里就知道这些数据如何获取了，但是当你去执行这个操作时，你会发现并不像我们分析的这样，实际上这个分页功能当前是无效的。为什么这样呢？这个要源于MyBatisPlus的内部机制。</p>
<p>​		对于MySQL的分页操作使用limit关键字进行，而并不是所有的数据库都使用limit关键字实现的，这个时候MyBatisPlus为了制作的兼容性强，将分页操作设置为基础查询操作的升级版，你可以理解为IPhone6与IPhone6S-PLUS的关系。</p>
<p>​		基础操作中有查询全部的功能，而在这个基础上只需要升级一下（PLUS）就可以得到分页操作。所以MyBatisPlus将分页操作做成了一个开关，你用分页功能就把开关开启，不用就不需要开启这个开关。而我们现在没有开启这个开关，所以分页操作是没有的。这个开关是通过MyBatisPlus的拦截器的形式存在的，其中的原理这里不分析了，有兴趣的小伙伴可以学习MyBatisPlus这门课程进行详细解读。具体设置方式如下：</p>
<p><strong>定义MyBatisPlus拦截器并将其设置为Spring管控的bean</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MPConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MybatisPlusInterceptor <span class="title function_">mybatisPlusInterceptor</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">MybatisPlusInterceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MybatisPlusInterceptor</span>();</span><br><span class="line">        interceptor.addInnerInterceptor(<span class="keyword">new</span> <span class="title class_">PaginationInnerInterceptor</span>());</span><br><span class="line">        <span class="keyword">return</span> interceptor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		上述代码第一行是创建MyBatisPlus的拦截器栈，这个时候拦截器栈中没有具体的拦截器，第二行是初始化了分页拦截器，并添加到拦截器栈中。如果后期开发其他功能，需要添加全新的拦截器，按照第二行的格式继续add进去新的拦截器就可以了。</p>
<p><strong>总结</strong></p>
<ol>
<li>使用IPage封装分页数据</li>
<li>分页操作依赖MyBatisPlus分页拦截器实现功能</li>
<li>借助MyBatisPlus日志查阅执行SQL语句</li>
</ol>
<h4 id="4-数据层开发——条件查询功能制作"><a href="#4-数据层开发——条件查询功能制作" class="headerlink" title="4.数据层开发——条件查询功能制作"></a>4.数据层开发——条件查询功能制作</h4><p>​		除了分页功能，MyBatisPlus还提供有强大的条件查询功能。以往我们写条件查询要自己动态拼写复杂的SQL语句，现在简单了，MyBatisPlus将这些操作都制作成API接口，调用一个又一个的方法就可以实现各种条件的拼装。这里给大家普及一下基本格式，详细的操作还是到MyBatisPlus的课程中查阅吧。</p>
<p>​		下面的操作就是执行一个模糊匹配对应的操作，由like条件书写变为了like方法的调用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testGetBy</span><span class="params">()</span>&#123;</span><br><span class="line">    QueryWrapper&lt;Book&gt; qw = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">    qw.like(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;Spring&quot;</span>);</span><br><span class="line">    bookDao.selectList(qw);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		其中第一句QueryWrapper对象是一个用于封装查询条件的对象，该对象可以动态使用API调用的方法添加条件，最终转化成对应的SQL语句。第二句就是一个条件了，需要什么条件，使用QueryWapper对象直接调用对应操作即可。比如做大于小于关系，就可以使用lt或gt方法，等于使用eq方法，等等，此处不做更多的解释了。</p>
<p>​		这组API使用还是比较简单的，但是关于属性字段名的书写存在着安全隐患，比如查询字段name，当前是以字符串的形态书写的，万一写错，编译器还没有办法发现，只能将问题抛到运行器通过异常堆栈告诉开发者，不太友好。</p>
<p>​		MyBatisPlus针对字段检查进行了功能升级，全面支持Lambda表达式，就有了下面这组API。由QueryWrapper对象升级为LambdaQueryWrapper对象，这下就避免了上述问题的出现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testGetBy2</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;1&quot;</span>;</span><br><span class="line">    LambdaQueryWrapper&lt;Book&gt; lqw = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;Book&gt;();</span><br><span class="line">    lqw.like(Book::getName,name);</span><br><span class="line">    bookDao.selectList(lqw);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		为了便于开发者动态拼写SQL，防止将null数据作为条件使用，MyBatisPlus还提供了动态拼装SQL的快捷书写方式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testGetBy2</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;1&quot;</span>;</span><br><span class="line">    LambdaQueryWrapper&lt;Book&gt; lqw = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;Book&gt;();</span><br><span class="line">    <span class="comment">//if(name != null) lqw.like(Book::getName,name);		//方式一：JAVA代码控制</span></span><br><span class="line">    lqw.like(name != <span class="literal">null</span>,Book::getName,name);				<span class="comment">//方式二：API接口提供控制开关</span></span><br><span class="line">    bookDao.selectList(lqw);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		其实就是个格式，没有区别。关于MyBatisPlus的基础操作就说到这里吧，如果这一块知识不太熟悉的小伙伴建议还是完整的学习一下MyBatisPlus的知识吧，这里只是蜻蜓点水的用了几个操作而已。</p>
<p><strong>总结</strong></p>
<ol>
<li><p>使用QueryWrapper对象封装查询条件</p>
</li>
<li><p>推荐使用LambdaQueryWrapper对象</p>
</li>
<li><p>所有查询操作封装成方法调用</p>
</li>
<li><p>查询条件支持动态条件拼装</p>
</li>
</ol>
<h4 id="5-业务层开发"><a href="#5-业务层开发" class="headerlink" title="5.业务层开发"></a>5.业务层开发</h4><p>​		数据层开发告一段落，下面进行业务层开发，其实标准业务层开发很多初学者认为就是调用数据层，怎么说呢？这个理解是没有大问题的，更精准的说法应该是<font color="#ff0000"><b>组织业务逻辑功能，并根据业务需求，对数据持久层发起调用</b></font>。有什么差别呢？目标是为了组织出符合需求的业务逻辑功能，至于调不调用数据层还真不好说，有需求就调用，没有需求就不调用。</p>
<p>​		一个常识性的知识普及一下，业务层的方法名定义一定要与业务有关，例如登录操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">login(String username,String password);</span><br></pre></td></tr></table></figure>

<p>​		而数据层的方法名定义一定与业务无关，是一定，不是可能，也不是有可能，例如根据用户名密码查询</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">selectByUserNameAndPassword(String username,String password);</span><br></pre></td></tr></table></figure>

<p>​		我们在开发的时候是可以根据完成的工作不同划分成不同职能的开发团队的。比如一个哥们制作数据层，他就可以不知道业务是什么样子，拿到的需求文档要求可能是这样的</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">接口：传入用户名与密码字段，查询出对应结果，结果是单条数据</span><br><span class="line">接口：传入ID字段，查询出对应结果，结果是单条数据</span><br><span class="line">接口：传入离职字段，查询出对应结果，结果是多条数据</span><br></pre></td></tr></table></figure>

<p>​		但是进行业务功能开发的哥们，拿到的需求文档要求差别就很大</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">接口：传入用户名与密码字段，对用户名字段做长度校验，4-15位，对密码字段做长度校验，8到24位，对密码字段做特殊字符校验，不允许存在空格，查询结果为对象。如果为null，返回BusinessException，封装消息码INFO<span class="built_in">_</span>LOGON<span class="built_in">_</span>USERNAME<span class="built_in">_</span>PASSWORD<span class="built_in">_</span>ERROR</span><br></pre></td></tr></table></figure>

<p>​		你比较一下，能是一回事吗？差别太大了，所以说业务层方法定义与数据层方法定义差异化很大，只不过有些入门级的开发者手懒或者没有使用过公司相关的ISO标准化文档而已。</p>
<p>​		多余的话不说了，咱们做案例就简单制作了，业务层接口定义如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BookService</span> &#123;</span><br><span class="line">    Boolean <span class="title function_">save</span><span class="params">(Book book)</span>;</span><br><span class="line">    Boolean <span class="title function_">update</span><span class="params">(Book book)</span>;</span><br><span class="line">    Boolean <span class="title function_">delete</span><span class="params">(Integer id)</span>;</span><br><span class="line">    Book <span class="title function_">getById</span><span class="params">(Integer id)</span>;</span><br><span class="line">    List&lt;Book&gt; <span class="title function_">getAll</span><span class="params">()</span>;</span><br><span class="line">    IPage&lt;Book&gt; <span class="title function_">getPage</span><span class="params">(<span class="type">int</span> currentPage,<span class="type">int</span> pageSize)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		业务层实现类如下，转调数据层即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">BookService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BookDao bookDao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Boolean <span class="title function_">save</span><span class="params">(Book book)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> bookDao.insert(book) &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Boolean <span class="title function_">update</span><span class="params">(Book book)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> bookDao.updateById(book) &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Boolean <span class="title function_">delete</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> bookDao.deleteById(id) &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Book <span class="title function_">getById</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> bookDao.selectById(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Book&gt; <span class="title function_">getAll</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> bookDao.selectList(<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> IPage&lt;Book&gt; <span class="title function_">getPage</span><span class="params">(<span class="type">int</span> currentPage, <span class="type">int</span> pageSize)</span> &#123;</span><br><span class="line">        <span class="type">IPage</span> <span class="variable">page</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Page</span>(currentPage,pageSize);</span><br><span class="line">        bookDao.selectPage(page,<span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">return</span> page;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		别忘了对业务层接口进行测试，测试类如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookServiceTest</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> IBookService bookService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testGetById</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(bookService.getById(<span class="number">4</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testSave</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Book</span> <span class="variable">book</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Book</span>();</span><br><span class="line">        book.setType(<span class="string">&quot;测试数据123&quot;</span>);</span><br><span class="line">        book.setName(<span class="string">&quot;测试数据123&quot;</span>);</span><br><span class="line">        book.setDescription(<span class="string">&quot;测试数据123&quot;</span>);</span><br><span class="line">        bookService.save(book);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testUpdate</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Book</span> <span class="variable">book</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Book</span>();</span><br><span class="line">        book.setId(<span class="number">17</span>);</span><br><span class="line">        book.setType(<span class="string">&quot;-----------------&quot;</span>);</span><br><span class="line">        book.setName(<span class="string">&quot;测试数据123&quot;</span>);</span><br><span class="line">        book.setDescription(<span class="string">&quot;测试数据123&quot;</span>);</span><br><span class="line">        bookService.updateById(book);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testDelete</span><span class="params">()</span>&#123;</span><br><span class="line">        bookService.removeById(<span class="number">18</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testGetAll</span><span class="params">()</span>&#123;</span><br><span class="line">        bookService.list();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testGetPage</span><span class="params">()</span>&#123;</span><br><span class="line">        IPage&lt;Book&gt; page = <span class="keyword">new</span> <span class="title class_">Page</span>&lt;Book&gt;(<span class="number">2</span>,<span class="number">5</span>);</span><br><span class="line">        bookService.page(page);</span><br><span class="line">        System.out.println(page.getCurrent());</span><br><span class="line">        System.out.println(page.getSize());</span><br><span class="line">        System.out.println(page.getTotal());</span><br><span class="line">        System.out.println(page.getPages());</span><br><span class="line">        System.out.println(page.getRecords());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结</strong></p>
<ol>
<li>Service接口名称定义成业务名称，并与Dao接口名称进行区分</li>
<li>制作测试类测试Service功能是否有效</li>
</ol>
<h5 id="业务层快速开发"><a href="#业务层快速开发" class="headerlink" title="业务层快速开发"></a>业务层快速开发</h5><p>​		其实MyBatisPlus技术不仅提供了数据层快速开发方案，业务层MyBatisPlus也给了一个通用接口，个人观点不推荐使用，凑合能用吧，其实就是一个封装+继承的思想，代码给出，实际开发慎用。</p>
<p>​		业务层接口快速开发</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IBookService</span> <span class="keyword">extends</span> <span class="title class_">IService</span>&lt;Book&gt; &#123;</span><br><span class="line">    <span class="comment">//添加非通用操作API接口</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		业务层接口实现类快速开发，关注继承的类需要传入两个泛型，一个是数据层接口，另一个是实体类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;BookDao, Book&gt; <span class="keyword">implements</span> <span class="title class_">IBookService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BookDao bookDao;</span><br><span class="line">	<span class="comment">//添加非通用操作API</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		如果感觉MyBatisPlus提供的功能不足以支撑你的使用需要（其实是一定不能支撑的，因为需求不可能是通用的），在原始接口基础上接着定义新的API接口就行了，此处不再说太多了，就是自定义自己的操作了，但是不要和已有的API接口名冲突即可。</p>
<p><strong>总结</strong></p>
<ol>
<li>使用通用接口（ISerivce<T>）快速开发Service</li>
<li>使用通用实现类（ServiceImpl&lt;M,T&gt;）快速开发ServiceImpl</li>
<li>可以在通用接口基础上做功能重载或功能追加</li>
<li>注意重载时不要覆盖原始操作，避免原始提供的功能丢失</li>
</ol>
<h4 id="6-表现层开发"><a href="#6-表现层开发" class="headerlink" title="6.表现层开发"></a>6.表现层开发</h4><p>​		终于做到表现层了，做了这么多都是基础工作。其实你现在回头看看，哪里还有什么SpringBoot的影子？前面1,2步就搞完了。继续完成表现层制作吧，咱们表现层的开发使用基于Restful的表现层接口开发，功能测试通过Postman工具进行。</p>
<p>​		表现层接口如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/books&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookController2</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> IBookService bookService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Book&gt; <span class="title function_">getAll</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bookService.list();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping</span></span><br><span class="line">    <span class="keyword">public</span> Boolean <span class="title function_">save</span><span class="params">(<span class="meta">@RequestBody</span> Book book)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bookService.save(book);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PutMapping</span></span><br><span class="line">    <span class="keyword">public</span> Boolean <span class="title function_">update</span><span class="params">(<span class="meta">@RequestBody</span> Book book)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bookService.modify(book);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@DeleteMapping(&quot;&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Boolean <span class="title function_">delete</span><span class="params">(<span class="meta">@PathVariable</span> Integer id)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bookService.delete(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Book <span class="title function_">getById</span><span class="params">(<span class="meta">@PathVariable</span> Integer id)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bookService.getById(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;&#123;currentPage&#125;/&#123;pageSize&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> IPage&lt;Book&gt; <span class="title function_">getPage</span><span class="params">(<span class="meta">@PathVariable</span> <span class="type">int</span> currentPage,<span class="meta">@PathVariable</span> <span class="type">int</span> pageSize)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bookService.getPage(currentPage,pageSize, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		在使用Postman测试时关注提交类型，对应上即可，不然就会报405的错误码了。</p>
<p><strong>普通GET请求</strong></p>
<p><img src="/2022/09/23/springboot%E5%9F%BA%E7%A1%80%E7%AF%87/image-20211129152237371.png" alt="image-20211129152237371"></p>
<p><strong>PUT请求传递json数据，后台实用@RequestBody接收数据</strong></p>
<p><img src="/2022/09/23/springboot%E5%9F%BA%E7%A1%80%E7%AF%87/image-20211129152300177.png" alt="image-20211129152300177"></p>
<p><strong>GET请求传递路径变量，后台实用@PathVariable接收数据</strong></p>
<p><img src="/2022/09/23/springboot%E5%9F%BA%E7%A1%80%E7%AF%87/image-20211129152320073.png" alt="image-20211129152320073"></p>
<p><strong>总结</strong></p>
<ol>
<li>基于Restful制作表现层接口<ul>
<li>新增：POST</li>
<li>删除：DELETE</li>
<li>修改：PUT</li>
<li>查询：GET</li>
</ul>
</li>
<li>接收参数<ul>
<li>实体数据：@RequestBody</li>
<li>路径变量：@PathVariable</li>
</ul>
</li>
</ol>
<h4 id="7-表现层消息一致性处理"><a href="#7-表现层消息一致性处理" class="headerlink" title="7.表现层消息一致性处理"></a>7.表现层消息一致性处理</h4><p>​		目前我们通过Postman测试后业务层接口功能是通的，但是这样的结果给到前端开发者会出现一个小问题。不同的操作结果所展示的数据格式差异化严重。</p>
<p>​	<strong>增删改操作结果</strong></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">true</span><br></pre></td></tr></table></figure>

<p>​	<strong>查询单个数据操作结果</strong></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;计算机理论&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Spring实战 第5版&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Spring入门经典教程&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>​	<strong>查询全部数据操作结果</strong></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;计算机理论&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Spring实战 第5版&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Spring入门经典教程&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;计算机理论&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Spring 5核心原理与30个类手写实战&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;十年沉淀之作&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>

<p>​		每种不同操作返回的数据格式都不一样，而且还不知道以后还会有什么格式，这样的结果让前端人员看了是很容易让人崩溃的，必须将所有操作的操作结果数据格式统一起来，需要设计表现层返回结果的模型类，用于后端与前端进行数据格式统一，也称为<strong>前后端数据协议</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">R</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Boolean flag;</span><br><span class="line">    <span class="keyword">private</span> Object data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		其中flag用于标识操作是否成功，data用于封装操作数据，现在的数据格式就变了</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;flag&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;data&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;计算机理论&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Spring实战 第5版&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Spring入门经典教程&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>​		表现层开发格式也需要转换一下</p>
<img src="image-20211129153301262.png" alt="image-20211129153301262" style="zoom:80%;" />

<img src="image-20211129153319052.png" alt="image-20211129153319052" style="zoom:80%;" />

<img src="image-20211129153332499.png" alt="image-20211129153332499" style="zoom:80%;" />

<p>​		结果这么一折腾，全格式统一，现在后端发送给前端的数据格式就统一了，免去了不少前端解析数据的烦恼。</p>
<p><strong>总结</strong></p>
<ol>
<li><p>设计统一的返回值结果类型便于前端开发读取数据</p>
</li>
<li><p>返回值结果类型可以根据需求自行设定，没有固定格式</p>
</li>
<li><p>返回值结果模型类用于后端与前端进行数据格式统一，也称为前后端数据协议</p>
</li>
</ol>
<h4 id="8-前后端联通性测试"><a href="#8-前后端联通性测试" class="headerlink" title="8.前后端联通性测试"></a>8.前后端联通性测试</h4><p>​		后端的表现层接口开发完毕，就可以进行前端的开发了。</p>
<p>​		将前端人员开发的页面保存到lresources目录下的static目录中，建议执行maven的clean生命周期，避免缓存的问题出现。</p>
<p>​	<img src="image-20211129153831990.png" alt="image-20211129153831990" style="zoom:67%;" /></p>
<p>​		在进行具体的功能开发之前，先做联通性的测试，通过页面发送异步提交（axios），这一步调试通过后再进行进一步的功能开发。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//列表</span></span><br><span class="line"><span class="title function_">getAll</span>(<span class="params"></span>) &#123;</span><br><span class="line">	axios.<span class="title function_">get</span>(<span class="string">&quot;/books&quot;</span>).<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;</span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(res.<span class="property">data</span>);</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>​		只要后台代码能够正常工作，前端能够在日志中接收到数据，就证明前后端是通的，也就可以进行下一步的功能开发了。</p>
<p><strong>总结</strong></p>
<ol>
<li>单体项目中页面放置在resources&#x2F;static目录下</li>
<li>created钩子函数用于初始化页面时发起调用</li>
<li>页面使用axios发送异步请求获取数据后确认前后端是否联通</li>
</ol>
<h4 id="9-页面基础功能开发"><a href="#9-页面基础功能开发" class="headerlink" title="9.页面基础功能开发"></a>9.页面基础功能开发</h4><h5 id="F-1-列表功能（非分页版）"><a href="#F-1-列表功能（非分页版）" class="headerlink" title="F-1.列表功能（非分页版）"></a>F-1.列表功能（非分页版）</h5><p>​		列表功能主要操作就是加载完数据，将数据展示到页面上，此处要利用VUE的数据模型绑定，发送请求得到数据，然后页面上读取指定数据即可。</p>
<p>​		<strong>页面数据模型定义</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">data</span>:&#123;</span><br><span class="line">	<span class="attr">dataList</span>: [],		<span class="comment">//当前页要展示的列表数据</span></span><br><span class="line">	...</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>​		异步请求获取数据</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//列表</span></span><br><span class="line"><span class="title function_">getAll</span>(<span class="params"></span>) &#123;</span><br><span class="line">    axios.<span class="title function_">get</span>(<span class="string">&quot;/books&quot;</span>).<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">dataList</span> = res.<span class="property">data</span>.<span class="property">data</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>​		这样在页面加载时就可以获取到数据，并且由VUE将数据展示到页面上了。</p>
<p>总结：</p>
<ol>
<li>将查询数据返回到页面，利用前端数据绑定进行数据展示</li>
</ol>
<h5 id="F-2-添加功能"><a href="#F-2-添加功能" class="headerlink" title="F-2.添加功能"></a>F-2.添加功能</h5><p>​		添加功能用于收集数据的表单是通过一个弹窗展示的，因此在添加操作前首先要进行弹窗的展示，添加后隐藏弹窗即可。因为这个弹窗一直存在，因此当页面加载时首先设置这个弹窗为不可显示状态，需要展示，切换状态即可。</p>
<p>​		<strong>默认状态</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">data</span>:&#123;</span><br><span class="line">	<span class="attr">dialogFormVisible</span>: <span class="literal">false</span>,	<span class="comment">//添加表单是否可见</span></span><br><span class="line">	...</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>​		<strong>切换为显示状态</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//弹出添加窗口</span></span><br><span class="line"><span class="title function_">handleCreate</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="variable language_">this</span>.<span class="property">dialogFormVisible</span> = <span class="literal">true</span>;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>​		由于每次添加数据都是使用同一个弹窗录入数据，所以每次操作的痕迹将在下一次操作时展示出来，需要在每次操作之前清理掉上次操作的痕迹。</p>
<p>​		<strong>定义清理数据操作</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//重置表单</span></span><br><span class="line"><span class="title function_">resetForm</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">formData</span> = &#123;&#125;;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>​		<strong>切换弹窗状态时清理数据</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//弹出添加窗口</span></span><br><span class="line"><span class="title function_">handleCreate</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">dialogFormVisible</span> = <span class="literal">true</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">resetForm</span>();</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>​		至此准备工作完成，下面就要调用后台完成添加操作了。</p>
<p>​		<strong>添加操作</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//添加</span></span><br><span class="line">handleAdd () &#123;</span><br><span class="line">    <span class="comment">//发送异步请求</span></span><br><span class="line">    axios.<span class="title function_">post</span>(<span class="string">&quot;/books&quot;</span>,<span class="variable language_">this</span>.<span class="property">formData</span>).<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="comment">//如果操作成功，关闭弹层，显示数据</span></span><br><span class="line">        <span class="keyword">if</span>(res.<span class="property">data</span>.<span class="property">flag</span>)&#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">dialogFormVisible</span> = <span class="literal">false</span>;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">$message</span>.<span class="title function_">success</span>(<span class="string">&quot;添加成功&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">$message</span>.<span class="title function_">error</span>(<span class="string">&quot;添加失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).<span class="title function_">finally</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">getAll</span>();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<ol>
<li>将要保存的数据传递到后台，通过post请求的第二个参数传递json数据到后台</li>
<li>根据返回的操作结果决定下一步操作<ul>
<li>如何是true就关闭添加窗口，显示添加成功的消息</li>
<li>如果是false保留添加窗口，显示添加失败的消息</li>
</ul>
</li>
<li>无论添加是否成功，页面均进行刷新，动态加载数据（对getAll操作发起调用）</li>
</ol>
<p>​		<strong>取消添加操作</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//取消</span></span><br><span class="line"><span class="title function_">cancel</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">dialogFormVisible</span> = <span class="literal">false</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">$message</span>.<span class="title function_">info</span>(<span class="string">&quot;操作取消&quot;</span>);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p><strong>总结</strong></p>
<ol>
<li>请求方式使用POST调用后台对应操作</li>
<li>添加操作结束后动态刷新页面加载数据</li>
<li>根据操作结果不同，显示对应的提示信息</li>
<li>弹出添加Div时清除表单数据</li>
</ol>
<h5 id="F-3-删除功能"><a href="#F-3-删除功能" class="headerlink" title="F-3.删除功能"></a>F-3.删除功能</h5><p>​		模仿添加操作制作删除功能，差别之处在于删除操作仅传递一个待删除的数据id到后台即可。</p>
<p>​		<strong>删除操作</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 删除</span></span><br><span class="line"><span class="title function_">handleDelete</span>(<span class="params">row</span>) &#123;</span><br><span class="line">    axios.<span class="title function_">delete</span>(<span class="string">&quot;/books/&quot;</span>+row.<span class="property">id</span>).<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(res.<span class="property">data</span>.<span class="property">flag</span>)&#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">$message</span>.<span class="title function_">success</span>(<span class="string">&quot;删除成功&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">$message</span>.<span class="title function_">error</span>(<span class="string">&quot;删除失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).<span class="title function_">finally</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">getAll</span>();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>​		<strong>删除操作提示信息</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 删除</span></span><br><span class="line"><span class="title function_">handleDelete</span>(<span class="params">row</span>) &#123;</span><br><span class="line">    <span class="comment">//1.弹出提示框</span></span><br><span class="line">    <span class="variable language_">this</span>.$confirm(<span class="string">&quot;此操作永久删除当前数据，是否继续？&quot;</span>,<span class="string">&quot;提示&quot;</span>,&#123;</span><br><span class="line">        <span class="attr">type</span>:<span class="string">&#x27;info&#x27;</span></span><br><span class="line">    &#125;).<span class="title function_">then</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="comment">//2.做删除业务</span></span><br><span class="line">        axios.<span class="title function_">delete</span>(<span class="string">&quot;/books/&quot;</span>+row.<span class="property">id</span>).<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;</span><br><span class="line">       		<span class="keyword">if</span>(res.<span class="property">data</span>.<span class="property">flag</span>)&#123;</span><br><span class="line">            	<span class="variable language_">this</span>.<span class="property">$message</span>.<span class="title function_">success</span>(<span class="string">&quot;删除成功&quot;</span>);</span><br><span class="line">        	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            	<span class="variable language_">this</span>.<span class="property">$message</span>.<span class="title function_">error</span>(<span class="string">&quot;删除失败&quot;</span>);</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;).<span class="title function_">finally</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="title function_">getAll</span>();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;).<span class="title function_">catch</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="comment">//3.取消删除</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">$message</span>.<span class="title function_">info</span>(<span class="string">&quot;取消删除操作&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;，	</span><br></pre></td></tr></table></figure>

<p><strong>总结</strong></p>
<ol>
<li>请求方式使用Delete调用后台对应操作</li>
<li>删除操作需要传递当前行数据对应的id值到后台</li>
<li>删除操作结束后动态刷新页面加载数据</li>
<li>根据操作结果不同，显示对应的提示信息</li>
<li>删除操作前弹出提示框避免误操作</li>
</ol>
<h5 id="F-4-修改功能"><a href="#F-4-修改功能" class="headerlink" title="F-4.修改功能"></a>F-4.修改功能</h5><p>​		修改功能可以说是列表功能、删除功能与添加功能的合体。几个相似点如下：</p>
<ol>
<li><p>页面也需要有一个弹窗用来加载修改的数据，这一点与添加相同，都是要弹窗</p>
</li>
<li><p>弹出窗口中要加载待修改的数据，而数据需要通过查询得到，这一点与查询全部相同，都是要查数据</p>
</li>
<li><p>查询操作需要将要修改的数据id发送到后台，这一点与删除相同，都是传递id到后台</p>
</li>
<li><p>查询得到数据后需要展示到弹窗中，这一点与查询全部相同，都是要通过数据模型绑定展示数据</p>
</li>
<li><p>修改数据时需要将被修改的数据传递到后台，这一点与添加相同，都是要传递数据</p>
<p>所以整体上来看，修改功能就是前面几个功能的大合体</p>
<p><strong>查询并展示数据</strong></p>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//弹出编辑窗口</span></span><br><span class="line"><span class="title function_">handleUpdate</span>(<span class="params">row</span>) &#123;</span><br><span class="line">    axios.<span class="title function_">get</span>(<span class="string">&quot;/books/&quot;</span>+row.<span class="property">id</span>).<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(res.<span class="property">data</span>.<span class="property">flag</span>)&#123;</span><br><span class="line">            <span class="comment">//展示弹层，加载数据</span></span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">formData</span> = res.<span class="property">data</span>.<span class="property">data</span>;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">dialogFormVisible4Edit</span> = <span class="literal">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">$message</span>.<span class="title function_">error</span>(<span class="string">&quot;数据同步失败，自动刷新&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>​		<strong>修改操作</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//修改</span></span><br><span class="line"><span class="title function_">handleEdit</span>(<span class="params"></span>) &#123;</span><br><span class="line">    axios.<span class="title function_">put</span>(<span class="string">&quot;/books&quot;</span>,<span class="variable language_">this</span>.<span class="property">formData</span>).<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="comment">//如果操作成功，关闭弹层并刷新页面</span></span><br><span class="line">        <span class="keyword">if</span>(res.<span class="property">data</span>.<span class="property">flag</span>)&#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">dialogFormVisible4Edit</span> = <span class="literal">false</span>;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">$message</span>.<span class="title function_">success</span>(<span class="string">&quot;修改成功&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">$message</span>.<span class="title function_">error</span>(<span class="string">&quot;修改失败，请重试&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).<span class="title function_">finally</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">getAll</span>();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p><strong>总结</strong></p>
<ol>
<li>加载要修改数据通过传递当前行数据对应的id值到后台查询数据（同删除与查询全部）</li>
<li>利用前端双向数据绑定将查询到的数据进行回显（同查询全部）</li>
<li>请求方式使用PUT调用后台对应操作（同新增传递数据）</li>
<li>修改操作结束后动态刷新页面加载数据（同新增）</li>
<li>根据操作结果不同，显示对应的提示信息（同新增）</li>
</ol>
<p>​	</p>
<h4 id="10-业务消息一致性处理"><a href="#10-业务消息一致性处理" class="headerlink" title="10.业务消息一致性处理"></a>10.业务消息一致性处理</h4><p>​		目前的功能制作基本上达成了正常使用的情况，什么叫正常使用呢？也就是这个程序不出BUG，如果我们搞一个BUG出来，你会发现程序马上崩溃掉。比如后台手工抛出一个异常，看看前端接收到的数据什么样子。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;timestamp&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2021-09-15T03:27:31.038+00:00&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;status&quot;</span><span class="punctuation">:</span> <span class="number">500</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;error&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Internal Server Error&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;path&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/books&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>​		面对这种情况，前端的同学又不会了，这又是什么格式？怎么和之前的格式不一样？</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;flag&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;data&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;计算机理论&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Spring实战 第5版&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Spring入门经典教程&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>​		看来不仅要对正确的操作数据格式做处理，还要对错误的操作数据格式做同样的格式处理。</p>
<p>​		首先在当前的数据结果中添加消息字段，用来兼容后台出现的操作消息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">R</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Boolean flag;</span><br><span class="line">    <span class="keyword">private</span> Object data;</span><br><span class="line">    <span class="keyword">private</span> String msg;		<span class="comment">//用于封装消息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		后台代码也要根据情况做处理，当前是模拟的错误。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span></span><br><span class="line"><span class="keyword">public</span> R <span class="title function_">save</span><span class="params">(<span class="meta">@RequestBody</span> Book book)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">Boolean</span> <span class="variable">flag</span> <span class="operator">=</span> bookService.insert(book);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">R</span>(flag , flag ? <span class="string">&quot;添加成功^_^&quot;</span> : <span class="string">&quot;添加失败-_-!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		然后在表现层做统一的异常处理，使用SpringMVC提供的异常处理器做统一的异常处理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProjectExceptionAdvice</span> &#123;</span><br><span class="line">    <span class="meta">@ExceptionHandler(Exception.class)</span></span><br><span class="line">    <span class="keyword">public</span> R <span class="title function_">doOtherException</span><span class="params">(Exception ex)</span>&#123;</span><br><span class="line">        <span class="comment">//记录日志</span></span><br><span class="line">        <span class="comment">//发送消息给运维</span></span><br><span class="line">        <span class="comment">//发送邮件给开发人员,ex对象发送给开发人员</span></span><br><span class="line">        ex.printStackTrace();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">R</span>(<span class="literal">false</span>,<span class="literal">null</span>,<span class="string">&quot;系统错误，请稍后再试！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		页面上得到数据后，先判定是否有后台传递过来的消息，标志就是当前操作是否成功，如果返回操作结果false，就读取后台传递的消息。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//添加</span></span><br><span class="line">handleAdd () &#123;</span><br><span class="line">	<span class="comment">//发送ajax请求</span></span><br><span class="line">    axios.<span class="title function_">post</span>(<span class="string">&quot;/books&quot;</span>,<span class="variable language_">this</span>.<span class="property">formData</span>).<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="comment">//如果操作成功，关闭弹层，显示数据</span></span><br><span class="line">        <span class="keyword">if</span>(res.<span class="property">data</span>.<span class="property">flag</span>)&#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">dialogFormVisible</span> = <span class="literal">false</span>;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">$message</span>.<span class="title function_">success</span>(<span class="string">&quot;添加成功&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">$message</span>.<span class="title function_">error</span>(res.<span class="property">data</span>.<span class="property">msg</span>);			<span class="comment">//消息来自于后台传递过来，而非固定内容</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).<span class="title function_">finally</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">getAll</span>();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p><strong>总结</strong></p>
<ol>
<li>使用注解@RestControllerAdvice定义SpringMVC异常处理器用来处理异常的</li>
<li>异常处理器必须被扫描加载，否则无法生效</li>
<li>表现层返回结果的模型类中添加消息属性用来传递消息到页面</li>
</ol>
<p>​	</p>
<h4 id="11-页面功能开发"><a href="#11-页面功能开发" class="headerlink" title="11.页面功能开发"></a>11.页面功能开发</h4><h5 id="F-5-分页功能"><a href="#F-5-分页功能" class="headerlink" title="F-5.分页功能"></a>F-5.分页功能</h5><p>​		分页功能的制作用于替换前面的查询全部，其中要使用到elementUI提供的分页组件。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;!--分页组件--&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;pagination-container&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">el-pagination</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">		<span class="attr">class</span>=<span class="string">&quot;pagiantion&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">		@<span class="attr">current-change</span>=<span class="string">&quot;handleCurrentChange&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">		<span class="attr">:current-page</span>=<span class="string">&quot;pagination.currentPage&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">		<span class="attr">:page-size</span>=<span class="string">&quot;pagination.pageSize&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">		<span class="attr">layout</span>=<span class="string">&quot;total, prev, pager, next, jumper&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">		<span class="attr">:total</span>=<span class="string">&quot;pagination.total&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">el-pagination</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>​		为了配合分页组件，封装分页对应的数据模型。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">data</span>:&#123;</span><br><span class="line">	<span class="attr">pagination</span>: &#123;	</span><br><span class="line">		<span class="comment">//分页相关模型数据</span></span><br><span class="line">		<span class="attr">currentPage</span>: <span class="number">1</span>,	<span class="comment">//当前页码</span></span><br><span class="line">		<span class="attr">pageSize</span>:<span class="number">10</span>,	<span class="comment">//每页显示的记录数</span></span><br><span class="line">		<span class="attr">total</span>:<span class="number">0</span>,		<span class="comment">//总记录数</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>​		修改查询全部功能为分页查询，通过路径变量传递页码信息参数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">getAll</span>(<span class="params"></span>) &#123;</span><br><span class="line">    axios.<span class="title function_">get</span>(<span class="string">&quot;/books/&quot;</span>+<span class="variable language_">this</span>.<span class="property">pagination</span>.<span class="property">currentPage</span>+<span class="string">&quot;/&quot;</span>+<span class="variable language_">this</span>.<span class="property">pagination</span>.<span class="property">pageSize</span>).<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>​		后台提供对应的分页功能。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/&#123;currentPage&#125;/&#123;pageSize&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> R <span class="title function_">getAll</span><span class="params">(<span class="meta">@PathVariable</span> Integer currentPage,<span class="meta">@PathVariable</span> Integer pageSize)</span>&#123;</span><br><span class="line">    IPage&lt;Book&gt; pageBook = bookService.getPage(currentPage, pageSize);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">R</span>(<span class="literal">null</span> != pageBook ,pageBook);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		页面根据分页操作结果读取对应数据，并进行数据模型绑定。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">getAll</span>(<span class="params"></span>) &#123;</span><br><span class="line">    axios.<span class="title function_">get</span>(<span class="string">&quot;/books/&quot;</span>+<span class="variable language_">this</span>.<span class="property">pagination</span>.<span class="property">currentPage</span>+<span class="string">&quot;/&quot;</span>+<span class="variable language_">this</span>.<span class="property">pagination</span>.<span class="property">pageSize</span>).<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">pagination</span>.<span class="property">total</span> = res.<span class="property">data</span>.<span class="property">data</span>.<span class="property">total</span>;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">pagination</span>.<span class="property">currentPage</span> = res.<span class="property">data</span>.<span class="property">data</span>.<span class="property">current</span>;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">pagination</span>.<span class="property">pagesize</span> = res.<span class="property">data</span>.<span class="property">data</span>.<span class="property">size</span>;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">dataList</span> = res.<span class="property">data</span>.<span class="property">data</span>.<span class="property">records</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>​		对切换页码操作设置调用当前分页操作。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//切换页码</span></span><br><span class="line"><span class="title function_">handleCurrentChange</span>(<span class="params">currentPage</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">pagination</span>.<span class="property">currentPage</span> = currentPage;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">getAll</span>();</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p><strong>总结</strong></p>
<ol>
<li>使用el分页组件</li>
<li>定义分页组件绑定的数据模型</li>
<li>异步调用获取分页数据</li>
<li>分页数据页面回显</li>
</ol>
<h5 id="F-6-删除功能维护"><a href="#F-6-删除功能维护" class="headerlink" title="F-6.删除功能维护"></a>F-6.删除功能维护</h5><p>​		由于使用了分页功能，当最后一页只有一条数据时，删除操作就会出现BUG，最后一页无数据但是独立展示，对分页查询功能进行后台功能维护，如果当前页码值大于最大页码值，重新执行查询。其实这个问题解决方案很多，这里给出比较简单的一种处理方案。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;&#123;currentPage&#125;/&#123;pageSize&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> R <span class="title function_">getPage</span><span class="params">(<span class="meta">@PathVariable</span> <span class="type">int</span> currentPage,<span class="meta">@PathVariable</span> <span class="type">int</span> pageSize)</span>&#123;</span><br><span class="line">    IPage&lt;Book&gt; page = bookService.getPage(currentPage, pageSize);</span><br><span class="line">    <span class="comment">//如果当前页码值大于了总页码值，那么重新执行查询操作，使用最大页码值作为当前页码值</span></span><br><span class="line">    <span class="keyword">if</span>( currentPage &gt; page.getPages())&#123;</span><br><span class="line">        page = bookService.getPage((<span class="type">int</span>)page.getPages(), pageSize);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">R</span>(<span class="literal">true</span>, page);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="F-7-条件查询功能"><a href="#F-7-条件查询功能" class="headerlink" title="F-7.条件查询功能"></a>F-7.条件查询功能</h5><p>​		最后一个功能来做条件查询，其实条件查询可以理解为分页查询的时候除了携带分页数据再多带几个数据的查询。这些多带的数据就是查询条件。比较一下不带条件的分页查询与带条件的分页查询差别之处，这个功能就好做了</p>
<ul>
<li><p>页面封装的数据：带不带条件影响的仅仅是一次性传递到后台的数据总量，由传递2个分页相关数据转换成2个分页数据加若干个条件</p>
</li>
<li><p>后台查询功能：查询时由不带条件，转换成带条件，反正不带条件的时候查询条件对象使用的是null，现在换成具体条件，差别不大</p>
</li>
<li><p>查询结果：不管带不带条件，出来的数据只是有数量上的差别，其他都差别，这个可以忽略</p>
<p>经过上述分析，看来需要在页面发送请求的格式方面做一定的修改，后台的调用数据层操作时发送修改，其他没有区别。</p>
<p>页面发送请求时，两个分页数据仍然使用路径变量，其他条件采用动态拼装url参数的形式传递。</p>
<p><strong>页面封装查询条件字段</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pagination: &#123;		</span><br><span class="line">//分页相关模型数据</span><br><span class="line">	currentPage: 1,		//当前页码</span><br><span class="line">	pageSize:10,		//每页显示的记录数</span><br><span class="line">	total:0,			//总记录数</span><br><span class="line">	name: &quot;&quot;,</span><br><span class="line">	type: &quot;&quot;,</span><br><span class="line">	description: &quot;&quot;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>页面添加查询条件字段对应的数据模型绑定名称</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;filter-container&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">el-input</span> <span class="attr">placeholder</span>=<span class="string">&quot;图书类别&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;pagination.type&quot;</span> <span class="attr">class</span>=<span class="string">&quot;filter-item&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">el-input</span> <span class="attr">placeholder</span>=<span class="string">&quot;图书名称&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;pagination.name&quot;</span> <span class="attr">class</span>=<span class="string">&quot;filter-item&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">el-input</span> <span class="attr">placeholder</span>=<span class="string">&quot;图书描述&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;pagination.description&quot;</span> <span class="attr">class</span>=<span class="string">&quot;filter-item&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">el-button</span> @<span class="attr">click</span>=<span class="string">&quot;getAll()&quot;</span> <span class="attr">class</span>=<span class="string">&quot;dalfBut&quot;</span>&gt;</span>查询<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">el-button</span> <span class="attr">type</span>=<span class="string">&quot;primary&quot;</span> <span class="attr">class</span>=<span class="string">&quot;butT&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;handleCreate()&quot;</span>&gt;</span>新建<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>将查询条件组织成url参数，添加到请求url地址中，这里可以借助其他类库快速开发，当前使用手工形式拼接，降低学习要求</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">getAll</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">//1.获取查询条件,拼接查询条件</span></span><br><span class="line">    param = <span class="string">&quot;?name=&quot;</span>+<span class="variable language_">this</span>.<span class="property">pagination</span>.<span class="property">name</span>;</span><br><span class="line">    param += <span class="string">&quot;&amp;type=&quot;</span>+<span class="variable language_">this</span>.<span class="property">pagination</span>.<span class="property">type</span>;</span><br><span class="line">    param += <span class="string">&quot;&amp;description=&quot;</span>+<span class="variable language_">this</span>.<span class="property">pagination</span>.<span class="property">description</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;-----------------&quot;</span>+ param);</span><br><span class="line">    axios.<span class="title function_">get</span>(<span class="string">&quot;/books/&quot;</span>+<span class="variable language_">this</span>.<span class="property">pagination</span>.<span class="property">currentPage</span>+<span class="string">&quot;/&quot;</span>+<span class="variable language_">this</span>.<span class="property">pagination</span>.<span class="property">pageSize</span>+param).<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">dataList</span> = res.<span class="property">data</span>.<span class="property">data</span>.<span class="property">records</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>后台代码中定义实体类封查询条件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;&#123;currentPage&#125;/&#123;pageSize&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> R <span class="title function_">getAll</span><span class="params">(<span class="meta">@PathVariable</span> <span class="type">int</span> currentPage,<span class="meta">@PathVariable</span> <span class="type">int</span> pageSize,Book book)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;参数=====&gt;&quot;</span>+book);</span><br><span class="line">    IPage&lt;Book&gt; pageBook = bookService.getPage(currentPage,pageSize);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">R</span>(<span class="literal">null</span> != pageBook ,pageBook);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对应业务层接口与实现类进行修正</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IBookService</span> <span class="keyword">extends</span> <span class="title class_">IService</span>&lt;Book&gt; &#123;</span><br><span class="line">    IPage&lt;Book&gt; <span class="title function_">getPage</span><span class="params">(Integer currentPage,Integer pageSize,Book queryBook)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookServiceImpl2</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;BookDao,Book&gt; <span class="keyword">implements</span> <span class="title class_">IBookService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> IPage&lt;Book&gt; <span class="title function_">getPage</span><span class="params">(Integer currentPage,Integer pageSize,Book queryBook)</span>&#123;</span><br><span class="line">        <span class="type">IPage</span> <span class="variable">page</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Page</span>(currentPage,pageSize);</span><br><span class="line">        LambdaQueryWrapper&lt;Book&gt; lqw = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;Book&gt;();</span><br><span class="line">        lqw.like(Strings.isNotEmpty(queryBook.getName()),Book::getName,queryBook.getName());</span><br><span class="line">        lqw.like(Strings.isNotEmpty(queryBook.getType()),Book::getType,queryBook.getType());</span><br><span class="line">        lqw.like(Strings.isNotEmpty(queryBook.getDescription()),Book::getDescription,queryBook.getDescription());</span><br><span class="line">        <span class="keyword">return</span> bookDao.selectPage(page,lqw);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>页面回显数据</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">getAll</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">//1.获取查询条件,拼接查询条件</span></span><br><span class="line">    param = <span class="string">&quot;?name=&quot;</span>+<span class="variable language_">this</span>.<span class="property">pagination</span>.<span class="property">name</span>;</span><br><span class="line">    param += <span class="string">&quot;&amp;type=&quot;</span>+<span class="variable language_">this</span>.<span class="property">pagination</span>.<span class="property">type</span>;</span><br><span class="line">    param += <span class="string">&quot;&amp;description=&quot;</span>+<span class="variable language_">this</span>.<span class="property">pagination</span>.<span class="property">description</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;-----------------&quot;</span>+ param);</span><br><span class="line">    axios.<span class="title function_">get</span>(<span class="string">&quot;/books/&quot;</span>+<span class="variable language_">this</span>.<span class="property">pagination</span>.<span class="property">currentPage</span>+<span class="string">&quot;/&quot;</span>+<span class="variable language_">this</span>.<span class="property">pagination</span>.<span class="property">pageSize</span>+param).<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">pagination</span>.<span class="property">total</span> = res.<span class="property">data</span>.<span class="property">data</span>.<span class="property">total</span>;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">pagination</span>.<span class="property">currentPage</span> = res.<span class="property">data</span>.<span class="property">data</span>.<span class="property">current</span>;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">pagination</span>.<span class="property">pagesize</span> = res.<span class="property">data</span>.<span class="property">data</span>.<span class="property">size</span>;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">dataList</span> = res.<span class="property">data</span>.<span class="property">data</span>.<span class="property">records</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>总结</strong></p>
<ol>
<li>定义查询条件数据模型（当前封装到分页数据模型中）</li>
<li>异步调用分页功能并通过请求参数传递数据到后台</li>
</ol>
<h2 id="基础篇完结"><a href="#基础篇完结" class="headerlink" title="基础篇完结"></a>基础篇完结</h2><p>​		基础篇到这里就全部结束了，在基础篇中带着大家学习了如何创建一个SpringBoot工程，然后学习了SpringBoot的基础配置语法格式，接下来对常见的市面上的实用技术做了整合，最后通过一个小的案例对前面学习的内容做了一个综合应用。整体来说就是一个最基本的入门，关于SpringBoot的实际开发其实接触的还是很少的，我们到实用篇和原理篇中继续吧，各位小伙伴，加油学习，再见。</p>
]]></content>
      <categories>
        <category>boot系列</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title>redis入门篇</title>
    <url>/2022/09/24/redis%E5%85%A5%E9%97%A8%E7%AF%87/</url>
    <content><![CDATA[<p>小伙伴们理想的课程一定是能够通过讲解的方式，得到如下这些启发，我们的课程会从基础到精通，从redis小白，到redis大牛，还在等什么，这套课程一定就是你最适合你的课程~</p>
<p><img src="/2022/09/24/redis%E5%85%A5%E9%97%A8%E7%AF%87/1652882458107.png" alt="1652882458107"></p>
<h2 id="1-Redis简单介绍"><a href="#1-Redis简单介绍" class="headerlink" title="1.Redis简单介绍"></a>1.Redis简单介绍</h2><p>Redis是一种键值型的NoSql数据库，这里有两个关键字：</p>
<ul>
<li>键值型</li>
<li>NoSql</li>
</ul>
<p>其中<strong>键值型</strong>，是指Redis中存储的数据都是以key.value对的形式存储，而value的形式多种多样，可以是字符串.数值.甚至json：</p>
<p><img src="/2022/09/24/redis%E5%85%A5%E9%97%A8%E7%AF%87/1652882668159.png" alt="1652882668159"></p>
<p>而NoSql则是相对于传统关系型数据库而言，有很大差异的一种数据库。</p>
<p>对于存储的数据，没有类似Mysql那么严格的约束，比如唯一性，是否可以为null等等，所以我们把这种松散结构的数据库，称之为NoSQL数据库。</p>
<h2 id="2-课程目录"><a href="#2-课程目录" class="headerlink" title="2.课程目录"></a>2.课程目录</h2><blockquote>
<ul>
<li>初始Redis</li>
<li>认识NoSQL</li>
<li>认识Redis</li>
<li>安装Redis</li>
<li>Redis常见命令</li>
<li>5种常见数据结构</li>
<li>通用命令</li>
<li>不同数据结构的操作命令</li>
<li>Redis的Java客户端</li>
<li>Jedis客户端</li>
<li>SpringDataRedis客户端</li>
</ul>
</blockquote>
<h2 id="3-初始Redis"><a href="#3-初始Redis" class="headerlink" title="3.初始Redis"></a>3.初始Redis</h2><h3 id="3-1-认识NoSQL"><a href="#3-1-认识NoSQL" class="headerlink" title="3.1.认识NoSQL"></a>3.1.认识NoSQL</h3><p><strong>NoSql</strong>可以翻译做Not Only Sql（不仅仅是SQL），或者是No Sql（非Sql的）数据库。是相对于传统关系型数据库而言，有很大差异的一种特殊的数据库，因此也称之为<strong>非关系型数据库</strong>。</p>
<h4 id="3-1-1-结构化与非结构化"><a href="#3-1-1-结构化与非结构化" class="headerlink" title="3.1.1.结构化与非结构化"></a>3.1.1.结构化与非结构化</h4><p>传统关系型数据库是结构化数据，每一张表都有严格的约束信息：字段名.字段数据类型.字段约束等等信息，插入的数据必须遵守这些约束：</p>
<p><img src="https://i.imgur.com/4tUgFo6.png"></p>
<p>而NoSql则对数据库格式没有严格约束，往往形式松散，自由。</p>
<p>可以是键值型：</p>
<p><img src="https://i.imgur.com/GdqOSsj.png"></p>
<p>也可以是文档型：</p>
<p><img src="https://i.imgur.com/zBBQfcc.png"></p>
<p>甚至可以是图格式：</p>
<p><img src="https://i.imgur.com/zBnKxWf.png"></p>
<h4 id="3-1-2-关联和非关联"><a href="#3-1-2-关联和非关联" class="headerlink" title="3.1.2.关联和非关联"></a>3.1.2.关联和非关联</h4><p>传统数据库的表与表之间往往存在关联，例如外键：</p>
<p><img src="https://i.imgur.com/tXYSl5x.png"></p>
<p>而非关系型数据库不存在关联关系，要维护关系要么靠代码中的业务逻辑，要么靠数据之间的耦合：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  id<span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">  name<span class="punctuation">:</span> <span class="string">&quot;张三&quot;</span><span class="punctuation">,</span></span><br><span class="line">  orders<span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">       id<span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">       item<span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">	 id<span class="punctuation">:</span> <span class="number">10</span><span class="punctuation">,</span> title<span class="punctuation">:</span> <span class="string">&quot;荣耀6&quot;</span><span class="punctuation">,</span> price<span class="punctuation">:</span> <span class="number">4999</span></span><br><span class="line">       <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">       id<span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">       item<span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">	 id<span class="punctuation">:</span> <span class="number">20</span><span class="punctuation">,</span> title<span class="punctuation">:</span> <span class="string">&quot;小米11&quot;</span><span class="punctuation">,</span> price<span class="punctuation">:</span> <span class="number">3999</span></span><br><span class="line">       <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>此处要维护“张三”的订单与商品“荣耀”和“小米11”的关系，不得不冗余的将这两个商品保存在张三的订单文档中，不够优雅。还是建议用业务来维护关联关系。</p>
<h4 id="3-1-3-查询方式"><a href="#3-1-3-查询方式" class="headerlink" title="3.1.3.查询方式"></a>3.1.3.查询方式</h4><p>传统关系型数据库会基于Sql语句做查询，语法有统一标准；</p>
<p>而不同的非关系数据库查询语法差异极大，五花八门各种各样。</p>
<p><img src="https://i.imgur.com/AzaHOTF.png"></p>
<h4 id="3-1-4-事务"><a href="#3-1-4-事务" class="headerlink" title="3.1.4.事务"></a>3.1.4.事务</h4><p>传统关系型数据库能满足事务ACID的原则。</p>
<p><img src="https://i.imgur.com/J1MqOJM.png"></p>
<p>而非关系型数据库往往不支持事务，或者不能严格保证ACID的特性，只能实现基本的一致性。</p>
<h4 id="3-1-5-总结"><a href="#3-1-5-总结" class="headerlink" title="3.1.5.总结"></a>3.1.5.总结</h4><p>除了上述四点以外，在存储方式.扩展性.查询性能上关系型与非关系型也都有着显著差异，总结如下：</p>
<p><img src="https://i.imgur.com/kZP40dQ.png"></p>
<ul>
<li>存储方式<ul>
<li>关系型数据库基于磁盘进行存储，会有大量的磁盘IO，对性能有一定影响</li>
<li>非关系型数据库，他们的操作更多的是依赖于内存来操作，内存的读写速度会非常快，性能自然会好一些</li>
</ul>
</li>
</ul>
<ul>
<li>扩展性<ul>
<li>关系型数据库集群模式一般是主从，主从数据一致，起到数据备份的作用，称为垂直扩展。</li>
<li>非关系型数据库可以将数据拆分，存储在不同机器上，可以保存海量数据，解决内存大小有限的问题。称为水平扩展。</li>
<li>关系型数据库因为表之间存在关联关系，如果做水平扩展会给数据查询带来很多麻烦</li>
</ul>
</li>
</ul>
<h3 id="3-2-认识Redis"><a href="#3-2-认识Redis" class="headerlink" title="3.2.认识Redis"></a>3.2.认识Redis</h3><p>Redis诞生于2009年全称是<strong>Re</strong>mote  <strong>D</strong>ictionary <strong>S</strong>erver 远程词典服务器，是一个基于内存的键值型NoSQL数据库。</p>
<p><strong>特征</strong>：</p>
<ul>
<li>键值（key-value）型，value支持多种不同数据结构，功能丰富</li>
<li>单线程，每个命令具备原子性</li>
<li>低延迟，速度快（基于内存.IO多路复用.良好的编码）。</li>
<li>支持数据持久化</li>
<li>支持主从集群.分片集群</li>
<li>支持多语言客户端</li>
</ul>
<p><strong>作者</strong>：Antirez</p>
<p>Redis的官方网站地址：<a href="https://redis.io/">https://redis.io/</a></p>
<h3 id="3-3-安装Redis"><a href="#3-3-安装Redis" class="headerlink" title="3.3.安装Redis"></a>3.3.安装Redis</h3><p>大多数企业都是基于Linux服务器来部署项目，而且Redis官方也没有提供Windows版本的安装包。因此课程中我们会基于Linux系统来安装Redis.</p>
<p>此处选择的Linux版本为CentOS 7.</p>
<h4 id="3-3-1-依赖库"><a href="#3-3-1-依赖库" class="headerlink" title="3.3.1.依赖库"></a>3.3.1.依赖库</h4><p>Redis是基于C语言编写的，因此首先需要安装Redis所需要的gcc依赖：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">yum install -y gcc tcl</span><br></pre></td></tr></table></figure>



<h4 id="3-3-2-上传安装包并解压"><a href="#3-3-2-上传安装包并解压" class="headerlink" title="3.3.2.上传安装包并解压"></a>3.3.2.上传安装包并解压</h4><p>然后将课前资料提供的Redis安装包上传到虚拟机的任意目录：</p>
<p><img src="https://i.imgur.com/SyjanS5.png"></p>
<p>例如，我放到了&#x2F;usr&#x2F;local&#x2F;src 目录：</p>
<p><img src="https://i.imgur.com/01DTNCf.png"></p>
<p>解压缩：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">tar -xzf redis-6.2.6.tar.gz</span><br></pre></td></tr></table></figure>

<p>解压后：</p>
<p><img src="https://i.imgur.com/8V6zvCD.png" alt="image-20211211080339076"></p>
<p>进入redis目录：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> redis-6.2.6</span><br></pre></td></tr></table></figure>



<p>运行编译命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure>

<p>如果没有出错，应该就安装成功了。</p>
<p>默认的安装路径是在 <code>/usr/local/bin</code>目录下：</p>
<p><img src="https://i.imgur.com/YSxkGm7.png"></p>
<p>该目录已经默认配置到环境变量，因此可以在任意目录下运行这些命令。其中：</p>
<ul>
<li>redis-cli：是redis提供的命令行客户端</li>
<li>redis-server：是redis的服务端启动脚本</li>
<li>redis-sentinel：是redis的哨兵启动脚本</li>
</ul>
<h4 id="3-3-3-启动"><a href="#3-3-3-启动" class="headerlink" title="3.3.3.启动"></a>3.3.3.启动</h4><p>redis的启动方式有很多种，例如：</p>
<ul>
<li>默认启动</li>
<li>指定配置启动</li>
<li>开机自启</li>
</ul>
<h4 id="3-3-4-默认启动"><a href="#3-3-4-默认启动" class="headerlink" title="3.3.4.默认启动"></a>3.3.4.默认启动</h4><p>安装完成后，在任意目录输入redis-server命令即可启动Redis：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">redis-server</span><br></pre></td></tr></table></figure>

<p>如图：</p>
<p><img src="https://i.imgur.com/v7xWsqC.png"></p>
<p>这种启动属于<code>前台启动</code>，会阻塞整个会话窗口，窗口关闭或者按下<code>CTRL + C</code>则Redis停止。不推荐使用。</p>
<h4 id="3-3-5-指定配置启动"><a href="#3-3-5-指定配置启动" class="headerlink" title="3.3.5.指定配置启动"></a>3.3.5.指定配置启动</h4><p>如果要让Redis以<code>后台</code>方式启动，则必须修改Redis配置文件，就在我们之前解压的redis安装包下（<code>/usr/local/src/redis-6.2.6</code>），名字叫redis.conf：</p>
<p><img src="/image-20211211082225509.png" alt="image-20211211082225509"></p>
<p>我们先将这个配置文件备份一份：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cp redis.conf redis.conf.bck</span><br></pre></td></tr></table></figure>



<p>然后修改redis.conf文件中的一些配置：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 允许访问的地址，默认是127.0.0.1，会导致只能在本地访问。修改为0.0.0.0则可以在任意IP访问，生产环境不要设置为0.0.0.0</span></span><br><span class="line"><span class="attr">bind</span> <span class="string">0.0.0.0</span></span><br><span class="line"><span class="comment"># 守护进程，修改为yes后即可后台运行</span></span><br><span class="line"><span class="attr">daemonize</span> <span class="string">yes </span></span><br><span class="line"><span class="comment"># 密码，设置后访问Redis必须输入密码</span></span><br><span class="line"><span class="attr">requirepass</span> <span class="string">123321</span></span><br></pre></td></tr></table></figure>



<p>Redis的其它常见配置：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 监听的端口</span></span><br><span class="line"><span class="attr">port</span> <span class="string">6379</span></span><br><span class="line"><span class="comment"># 工作目录，默认是当前目录，也就是运行redis-server时的命令，日志.持久化等文件会保存在这个目录</span></span><br><span class="line"><span class="attr">dir</span> <span class="string">.</span></span><br><span class="line"><span class="comment"># 数据库数量，设置为1，代表只使用1个库，默认有16个库，编号0~15</span></span><br><span class="line"><span class="attr">databases</span> <span class="string">1</span></span><br><span class="line"><span class="comment"># 设置redis能够使用的最大内存</span></span><br><span class="line"><span class="attr">maxmemory</span> <span class="string">512mb</span></span><br><span class="line"><span class="comment"># 日志文件，默认为空，不记录日志，可以指定日志文件名</span></span><br><span class="line"><span class="attr">logfile</span> <span class="string">&quot;redis.log&quot;</span></span><br></pre></td></tr></table></figure>



<p>启动Redis：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 进入redis安装目录 </span></span><br><span class="line"><span class="built_in">cd</span> /usr/local/src/redis-6.2.6</span><br><span class="line"><span class="comment"># 启动</span></span><br><span class="line">redis-server redis.conf</span><br></pre></td></tr></table></figure>



<p>停止服务：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 利用redis-cli来执行 shutdown 命令，即可停止 Redis 服务，</span></span><br><span class="line"><span class="comment"># 因为之前配置了密码，因此需要通过 -u 来指定密码</span></span><br><span class="line">redis-cli -u 123321 shutdown</span><br></pre></td></tr></table></figure>



<h4 id="3-3-6-开机自启"><a href="#3-3-6-开机自启" class="headerlink" title="3.3.6.开机自启"></a>3.3.6.开机自启</h4><p>我们也可以通过配置来实现开机自启。</p>
<p>首先，新建一个系统服务文件：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">vi /etc/systemd/system/redis.service</span><br></pre></td></tr></table></figure>

<p>内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=redis-server</span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=forking</span><br><span class="line">ExecStart=/usr/local/bin/redis-server /usr/local/src/redis-6.2.6/redis.conf</span><br><span class="line">PrivateTmp=true</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>



<p>然后重载系统服务：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">systemctl daemon-reload</span><br></pre></td></tr></table></figure>



<p>现在，我们可以用下面这组命令来操作redis了：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 启动</span></span><br><span class="line">systemctl start redis</span><br><span class="line"><span class="comment"># 停止</span></span><br><span class="line">systemctl stop redis</span><br><span class="line"><span class="comment"># 重启</span></span><br><span class="line">systemctl restart redis</span><br><span class="line"><span class="comment"># 查看状态</span></span><br><span class="line">systemctl status redis</span><br></pre></td></tr></table></figure>



<p>执行下面的命令，可以让redis开机自启：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">systemctl <span class="built_in">enable</span> redis</span><br></pre></td></tr></table></figure>



<h3 id="3-4-Redis桌面客户端"><a href="#3-4-Redis桌面客户端" class="headerlink" title="3.4.Redis桌面客户端"></a>3.4.Redis桌面客户端</h3><p>安装完成Redis，我们就可以操作Redis，实现数据的CRUD了。这需要用到Redis客户端，包括：</p>
<ul>
<li>命令行客户端</li>
<li>图形化桌面客户端</li>
<li>编程客户端</li>
</ul>
<h4 id="3-4-1-Redis命令行客户端"><a href="#3-4-1-Redis命令行客户端" class="headerlink" title="3.4.1.Redis命令行客户端"></a>3.4.1.Redis命令行客户端</h4><p>Redis安装完成后就自带了命令行客户端：redis-cli，使用方式如下：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">redis-cli [options] [commonds]</span><br></pre></td></tr></table></figure>

<p>其中常见的options有：</p>
<ul>
<li><code>-h 127.0.0.1</code>：指定要连接的redis节点的IP地址，默认是127.0.0.1</li>
<li><code>-p 6379</code>：指定要连接的redis节点的端口，默认是6379</li>
<li><code>-a 123321</code>：指定redis的访问密码</li>
</ul>
<p>其中的commonds就是Redis的操作命令，例如：</p>
<ul>
<li><code>ping</code>：与redis服务端做心跳测试，服务端正常会返回<code>pong</code></li>
</ul>
<p>不指定commond时，会进入<code>redis-cli</code>的交互控制台：</p>
<p><img src="https://i.imgur.com/OYYWPNo.png"></p>
<h4 id="3-4-2-图形化桌面客户端"><a href="#3-4-2-图形化桌面客户端" class="headerlink" title="3.4.2.图形化桌面客户端"></a>3.4.2.图形化桌面客户端</h4><p>GitHub上的大神编写了Redis的图形化桌面客户端，地址：<a href="https://github.com/uglide/RedisDesktopManager">https://github.com/uglide/RedisDesktopManager</a></p>
<p>不过该仓库提供的是RedisDesktopManager的源码，并未提供windows安装包。</p>
<p>在下面这个仓库可以找到安装包：<a href="https://github.com/lework/RedisDesktopManager-Windows/releases">https://github.com/lework/RedisDesktopManager-Windows/releases</a></p>
<h4 id="3-4-3-安装"><a href="#3-4-3-安装" class="headerlink" title="3.4.3.安装"></a>3.4.3.安装</h4><p>在课前资料中可以找到Redis的图形化桌面客户端：</p>
<p><img src="https://i.imgur.com/BZ4Agbi.png"></p>
<p>解压缩后，运行安装程序即可安装：</p>
<p><img src="https://i.imgur.com/hguGHbX.png"></p>
<p>安装完成后，在安装目录下找到rdm.exe文件：</p>
<p><img src="https://i.imgur.com/hwK5LQ8.png"></p>
<p>双击即可运行：</p>
<p><img src="https://i.imgur.com/6hUqslY.png"></p>
<h4 id="3-4-4-建立连接"><a href="#3-4-4-建立连接" class="headerlink" title="3.4.4.建立连接"></a>3.4.4.建立连接</h4><p>点击左上角的<code>连接到Redis服务器</code>按钮：</p>
<p><img src="https://i.imgur.com/9qTGyoN.png"></p>
<p>在弹出的窗口中填写Redis服务信息：</p>
<p><img src="https://i.imgur.com/DshNnKC.png"></p>
<p>点击确定后，在左侧菜单会出现这个链接：</p>
<p><img src="https://i.imgur.com/A2cOm7Q.png"></p>
<p>点击即可建立连接了。</p>
<p><img src="https://i.imgur.com/ja8Fd9s.png"></p>
<p>Redis默认有16个仓库，编号从0至15.  通过配置文件可以设置仓库数量，但是不超过16，并且不能自定义仓库名称。</p>
<p>如果是基于redis-cli连接Redis服务，可以通过select命令来选择数据库：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 选择 0号库</span></span><br><span class="line">select 0</span><br></pre></td></tr></table></figure>



<h2 id="4-Redis常见命令"><a href="#4-Redis常见命令" class="headerlink" title="4.Redis常见命令"></a>4.Redis常见命令</h2><h3 id="4-1-Redis数据结构介绍"><a href="#4-1-Redis数据结构介绍" class="headerlink" title="4.1 Redis数据结构介绍"></a>4.1 Redis数据结构介绍</h3><p>Redis是一个key-value的数据库，key一般是String类型，不过value的类型多种多样：</p>
<p><img src="/2022/09/24/redis%E5%85%A5%E9%97%A8%E7%AF%87/1652887393157.png" alt="1652887393157"></p>
<p><strong>贴心小建议：命令不要死记，学会查询就好啦</strong></p>
<p>Redis为了方便我们学习，将操作不同数据类型的命令也做了分组，在官网（ <a href="https://redis.io/commands">https://redis.io/commands</a> ）可以查看到不同的命令：</p>
<p><img src="/2022/09/24/redis%E5%85%A5%E9%97%A8%E7%AF%87/1652887648826.png" alt="1652887648826"></p>
<p>当然我们也可以通过Help命令来帮助我们去查看命令</p>
<p><img src="/2022/09/24/redis%E5%85%A5%E9%97%A8%E7%AF%87/1652887748279.png" alt="1652887748279"></p>
<h3 id="4-2-Redis-通用命令"><a href="#4-2-Redis-通用命令" class="headerlink" title="4.2 Redis 通用命令"></a>4.2 Redis 通用命令</h3><p>通用指令是部分数据类型的，都可以使用的指令，常见的有：</p>
<ul>
<li>KEYS：查看符合模板的所有key</li>
<li>DEL：删除一个指定的key</li>
<li>EXISTS：判断key是否存在</li>
<li>EXPIRE：给一个key设置有效期，有效期到期时该key会被自动删除</li>
<li>TTL：查看一个KEY的剩余有效期</li>
</ul>
<p>通过help [command] 可以查看一个命令的具体用法，例如：</p>
<p><img src="/2022/09/24/redis%E5%85%A5%E9%97%A8%E7%AF%87/1652887865189.png" alt="1652887865189"></p>
<p>课堂代码如下</p>
<ul>
<li>KEYS</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) <span class="string">&quot;name&quot;</span></span><br><span class="line">2) <span class="string">&quot;age&quot;</span></span><br><span class="line">127.0.0.1:6379&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查询以a开头的key</span></span><br><span class="line">127.0.0.1:6379&gt; keys a*</span><br><span class="line">1) <span class="string">&quot;age&quot;</span></span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure>

<p><strong>贴心小提示：在生产环境下，不推荐使用keys 命令，因为这个命令在key过多的情况下，效率不高</strong></p>
<ul>
<li>DEL</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">help</span> del</span><br><span class="line"></span><br><span class="line">  DEL key [key ...]</span><br><span class="line">  summary: Delete a key</span><br><span class="line">  since: 1.0.0</span><br><span class="line">  group: generic</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; del name <span class="comment">#删除单个</span></span><br><span class="line">(<span class="built_in">integer</span>) 1  <span class="comment">#成功删除1个</span></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) <span class="string">&quot;age&quot;</span></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; MSET k1 v1 k2 v2 k3 v3 <span class="comment">#批量添加数据</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) <span class="string">&quot;k3&quot;</span></span><br><span class="line">2) <span class="string">&quot;k2&quot;</span></span><br><span class="line">3) <span class="string">&quot;k1&quot;</span></span><br><span class="line">4) <span class="string">&quot;age&quot;</span></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; del k1 k2 k3 k4</span><br><span class="line">(<span class="built_in">integer</span>) 3   <span class="comment">#此处返回的是成功删除的key，由于redis中只有k1,k2,k3 所以只成功删除3个，最终返回</span></span><br><span class="line">127.0.0.1:6379&gt;</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; keys * <span class="comment">#再查询全部的key</span></span><br><span class="line">1) <span class="string">&quot;age&quot;</span>	<span class="comment">#只剩下一个了</span></span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure>

<p><strong>贴心小提示：同学们在拷贝代码的时候，只需要拷贝对应的命令哦~</strong></p>
<ul>
<li>EXISTS</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">help</span> EXISTS</span><br><span class="line"></span><br><span class="line">  EXISTS key [key ...]</span><br><span class="line">  summary: Determine <span class="keyword">if</span> a key exists</span><br><span class="line">  since: 1.0.0</span><br><span class="line">  group: generic</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; exists age</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; exists name</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br></pre></td></tr></table></figure>

<ul>
<li>EXPIRE</li>
</ul>
<p><strong>贴心小提示</strong>：内存非常宝贵，对于一些数据，我们应当给他一些过期时间，当过期时间到了之后，他就会自动被删除~</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; expire age 10</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; ttl age</span><br><span class="line">(<span class="built_in">integer</span>) 8</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; ttl age</span><br><span class="line">(<span class="built_in">integer</span>) 6</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; ttl age</span><br><span class="line">(<span class="built_in">integer</span>) -2</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; ttl age</span><br><span class="line">(<span class="built_in">integer</span>) -2  <span class="comment">#当这个key过期了，那么此时查询出来就是-2 </span></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">(empty list or <span class="built_in">set</span>)</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> age 10 <span class="comment">#如果没有设置过期时间</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; ttl age</span><br><span class="line">(<span class="built_in">integer</span>) -1  <span class="comment"># ttl的返回值就是-1</span></span><br></pre></td></tr></table></figure>



<h3 id="4-3-Redis命令-String命令"><a href="#4-3-Redis命令-String命令" class="headerlink" title="4.3 Redis命令-String命令"></a>4.3 Redis命令-String命令</h3><p>String类型，也就是字符串类型，是Redis中最简单的存储类型。</p>
<p>其value是字符串，不过根据字符串的格式不同，又可以分为3类：</p>
<ul>
<li>string：普通字符串</li>
<li>int：整数类型，可以做自增.自减操作</li>
<li>float：浮点类型，可以做自增.自减操作</li>
</ul>
<p><img src="/2022/09/24/redis%E5%85%A5%E9%97%A8%E7%AF%87/1652890121291.png" alt="1652890121291"></p>
<p>String的常见命令有：</p>
<ul>
<li>SET：添加或者修改已经存在的一个String类型的键值对</li>
<li>GET：根据key获取String类型的value</li>
<li>MSET：批量添加多个String类型的键值对</li>
<li>MGET：根据多个key获取多个String类型的value</li>
<li>INCR：让一个整型的key自增1</li>
<li>INCRBY:让一个整型的key自增并指定步长，例如：incrby num 2 让num值自增2</li>
<li>INCRBYFLOAT：让一个浮点类型的数字自增并指定步长</li>
<li>SETNX：添加一个String类型的键值对，前提是这个key不存在，否则不执行</li>
<li>SETEX：添加一个String类型的键值对，并且指定有效期</li>
</ul>
<p><strong>贴心小提示</strong>：以上命令除了INCRBYFLOAT 都是常用命令</p>
<ul>
<li>SET 和GET: 如果key不存在则是新增，如果存在则是修改</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; set name Rose  <span class="comment">//原来不存在</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; get name </span><br><span class="line"><span class="string">&quot;Rose&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; set name Jack <span class="comment">//原来存在，就是修改</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; get name</span><br><span class="line"><span class="string">&quot;Jack&quot;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>MSET和MGET</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; MSET k1 v1 k2 v2 k3 v3</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; MGET name age k1 k2 k3</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;Jack&quot;</span> <span class="comment">//之前存在的name</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;10&quot;</span>   <span class="comment">//之前存在的age</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;v1&quot;</span></span><br><span class="line"><span class="number">4</span>) <span class="string">&quot;v2&quot;</span></span><br><span class="line"><span class="number">5</span>) <span class="string">&quot;v3&quot;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>INCR和INCRBY和DECY</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; get age </span><br><span class="line"><span class="string">&quot;10&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; incr age <span class="comment">//增加1</span></span><br><span class="line">(integer) <span class="number">11</span></span><br><span class="line">    </span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; get age <span class="comment">//获得age</span></span><br><span class="line"><span class="string">&quot;11&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; incrby age <span class="number">2</span> <span class="comment">//一次增加2</span></span><br><span class="line">(integer) <span class="number">13</span> <span class="comment">//返回目前的age的值</span></span><br><span class="line">    </span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; incrby age <span class="number">2</span></span><br><span class="line">(integer) <span class="number">15</span></span><br><span class="line">    </span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; incrby age -<span class="number">1</span> <span class="comment">//也可以增加负数，相当于减</span></span><br><span class="line">(integer) <span class="number">14</span></span><br><span class="line">    </span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; incrby age -<span class="number">2</span> <span class="comment">//一次减少2个</span></span><br><span class="line">(integer) <span class="number">12</span></span><br><span class="line">    </span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; DECR age <span class="comment">//相当于 incr 负数，减少正常用法</span></span><br><span class="line">(integer) <span class="number">11</span></span><br><span class="line">    </span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; get age </span><br><span class="line"><span class="string">&quot;11&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>SETNX</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; help setnx</span><br><span class="line"></span><br><span class="line">  SETNX key value</span><br><span class="line">  summary: Set the value of a key, only <span class="keyword">if</span> the key does not exist</span><br><span class="line">  since: <span class="number">1.0</span><span class="number">.0</span></span><br><span class="line">  group: string</span><br><span class="line"></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; set name Jack  <span class="comment">//设置名称</span></span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; setnx name lisi <span class="comment">//如果key不存在，则添加成功</span></span><br><span class="line">(integer) <span class="number">0</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; get name <span class="comment">//由于name已经存在，所以lisi的操作失败</span></span><br><span class="line"><span class="string">&quot;Jack&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; setnx name2 lisi <span class="comment">//name2 不存在，所以操作成功</span></span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; get name2 </span><br><span class="line"><span class="string">&quot;lisi&quot;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>SETEX</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; setex name 10 jack</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; ttl name</span><br><span class="line">(<span class="built_in">integer</span>) 8</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; ttl name</span><br><span class="line">(<span class="built_in">integer</span>) 7</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; ttl name</span><br><span class="line">(<span class="built_in">integer</span>) 5</span><br></pre></td></tr></table></figure>



<h3 id="4-4-Redis命令-Key的层级结构"><a href="#4-4-Redis命令-Key的层级结构" class="headerlink" title="4.4 Redis命令-Key的层级结构"></a>4.4 Redis命令-Key的层级结构</h3><p>Redis没有类似MySQL中的Table的概念，我们该如何区分不同类型的key呢？</p>
<p>例如，需要存储用户.商品信息到redis，有一个用户id是1，有一个商品id恰好也是1，此时如果使用id作为key，那就会冲突了，该怎么办？</p>
<p>我们可以通过给key添加前缀加以区分，不过这个前缀不是随便加的，有一定的规范：</p>
<p>Redis的key允许有多个单词形成层级结构，多个单词之间用’:’隔开，格式如下：</p>
<p><img src="/2022/09/24/redis%E5%85%A5%E9%97%A8%E7%AF%87/1652941631682.png" alt="1652941631682"></p>
<p>这个格式并非固定，也可以根据自己的需求来删除或添加词条。</p>
<p>例如我们的项目名称叫 heima，有user和product两种不同类型的数据，我们可以这样定义key：</p>
<ul>
<li><p>user相关的key：<strong>heima:user:1</strong></p>
</li>
<li><p>product相关的key：<strong>heima:product:1</strong></p>
</li>
</ul>
<p>如果Value是一个Java对象，例如一个User对象，则可以将对象序列化为JSON字符串后存储：</p>
<table>
<thead>
<tr>
<th><strong>KEY</strong></th>
<th><strong>VALUE</strong></th>
</tr>
</thead>
<tbody><tr>
<td>heima:user:1</td>
<td>{“id”:1, “name”: “Jack”, “age”: 21}</td>
</tr>
<tr>
<td>heima:product:1</td>
<td>{“id”:1, “name”: “小米11”, “price”: 4999}</td>
</tr>
</tbody></table>
<p>一旦我们向redis采用这样的方式存储，那么在可视化界面中，redis会以层级结构来进行存储，形成类似于这样的结构，更加方便Redis获取数据</p>
<p><img src="/2022/09/24/redis%E5%85%A5%E9%97%A8%E7%AF%87/1652941883537.png" alt="1652941883537"></p>
<h3 id="4-5-Redis命令-Hash命令"><a href="#4-5-Redis命令-Hash命令" class="headerlink" title="4.5 Redis命令-Hash命令"></a>4.5 Redis命令-Hash命令</h3><p>Hash类型，也叫散列，其value是一个无序字典，类似于Java中的HashMap结构。</p>
<p>String结构是将对象序列化为JSON字符串后存储，当需要修改对象某个字段时很不方便：</p>
<p><img src="/2022/09/24/redis%E5%85%A5%E9%97%A8%E7%AF%87/1652941995945.png" alt="1652941995945"></p>
<p>Hash结构可以将对象中的每个字段独立存储，可以针对单个字段做CRUD：</p>
<p><img src="/2022/09/24/redis%E5%85%A5%E9%97%A8%E7%AF%87/1652942027719.png" alt="1652942027719"></p>
<p><strong>Hash类型的常见命令</strong></p>
<ul>
<li><p>HSET key field value：添加或者修改hash类型key的field的值</p>
</li>
<li><p>HGET key field：获取一个hash类型key的field的值</p>
</li>
<li><p>HMSET：批量添加多个hash类型key的field的值</p>
</li>
<li><p>HMGET：批量获取多个hash类型key的field的值</p>
</li>
<li><p>HGETALL：获取一个hash类型的key中的所有的field和value</p>
</li>
<li><p>HKEYS：获取一个hash类型的key中的所有的field</p>
</li>
<li><p>HINCRBY:让一个hash类型key的字段值自增并指定步长</p>
</li>
<li><p>HSETNX：添加一个hash类型的key的field值，前提是这个field不存在，否则不执行</p>
</li>
</ul>
<p><strong>贴心小提示</strong>：哈希结构也是我们以后实际开发中常用的命令哟</p>
<ul>
<li>HSET和HGET</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; HSET heima:user:<span class="number">3</span> name Lucy<span class="comment">//大key是 heima:user:3 小key是name，小value是Lucy</span></span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; HSET heima:user:<span class="number">3</span> age <span class="number">21</span><span class="comment">// 如果操作不存在的数据，则是新增</span></span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; HSET heima:user:<span class="number">3</span> age <span class="number">17</span> <span class="comment">//如果操作存在的数据，则是修改</span></span><br><span class="line">(integer) <span class="number">0</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; HGET heima:user:<span class="number">3</span> name </span><br><span class="line"><span class="string">&quot;Lucy&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; HGET heima:user:<span class="number">3</span> age</span><br><span class="line"><span class="string">&quot;17&quot;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>HMSET和HMGET</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; HMSET heima:user:<span class="number">4</span> name HanMeiMei</span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; HMSET heima:user:<span class="number">4</span> name LiLei age <span class="number">20</span> sex man</span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; HMGET heima:user:<span class="number">4</span> name age sex</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;LiLei&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;20&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;man&quot;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>HGETALL</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; HGETALL heima:user:<span class="number">4</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;name&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;LiLei&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;age&quot;</span></span><br><span class="line"><span class="number">4</span>) <span class="string">&quot;20&quot;</span></span><br><span class="line"><span class="number">5</span>) <span class="string">&quot;sex&quot;</span></span><br><span class="line"><span class="number">6</span>) <span class="string">&quot;man&quot;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>HKEYS和HVALS</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; HKEYS heima:user:<span class="number">4</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;name&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;age&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;sex&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; HVALS heima:user:<span class="number">4</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;LiLei&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;20&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;man&quot;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>HINCRBY</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; HINCRBY  heima:user:<span class="number">4</span> age <span class="number">2</span></span><br><span class="line">(integer) <span class="number">22</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; HVALS heima:user:<span class="number">4</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;LiLei&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;22&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;man&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; HINCRBY  heima:user:<span class="number">4</span> age -<span class="number">2</span></span><br><span class="line">(integer) <span class="number">20</span></span><br></pre></td></tr></table></figure>

<ul>
<li>HSETNX</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; HSETNX heima:user4 sex <span class="title function_">woman</span></span><br><span class="line"><span class="params">(integer)</span> <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; HGETALL heima:user:<span class="number">3</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;name&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;Lucy&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;age&quot;</span></span><br><span class="line"><span class="number">4</span>) <span class="string">&quot;17&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; HSETNX heima:user:<span class="number">3</span> sex <span class="title function_">woman</span></span><br><span class="line"><span class="params">(integer)</span> <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; HGETALL heima:user:<span class="number">3</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;name&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;Lucy&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;age&quot;</span></span><br><span class="line"><span class="number">4</span>) <span class="string">&quot;17&quot;</span></span><br><span class="line"><span class="number">5</span>) <span class="string">&quot;sex&quot;</span></span><br><span class="line"><span class="number">6</span>) <span class="string">&quot;woman&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="4-6-Redis命令-List命令"><a href="#4-6-Redis命令-List命令" class="headerlink" title="4.6 Redis命令-List命令"></a>4.6 Redis命令-List命令</h3><p>Redis中的List类型与Java中的LinkedList类似，可以看做是一个双向链表结构。既可以支持正向检索和也可以支持反向检索。</p>
<p>特征也与LinkedList类似：</p>
<ul>
<li>有序</li>
<li>元素可以重复</li>
<li>插入和删除快</li>
<li>查询速度一般</li>
</ul>
<p>常用来存储一个有序数据，例如：朋友圈点赞列表，评论列表等。</p>
<p><strong>List的常见命令有：</strong></p>
<ul>
<li>LPUSH key element … ：向列表左侧插入一个或多个元素</li>
<li>LPOP key：移除并返回列表左侧的第一个元素，没有则返回nil</li>
<li>RPUSH key element … ：向列表右侧插入一个或多个元素</li>
<li>RPOP key：移除并返回列表右侧的第一个元素</li>
<li>LRANGE key star end：返回一段角标范围内的所有元素</li>
<li>BLPOP和BRPOP：与LPOP和RPOP类似，只不过在没有元素时等待指定时间，而不是直接返回nil</li>
</ul>
<p><img src="F:/综合项目文件/学习资料/Redis-笔记资料/01-入门篇/讲义/Redis注释版/Redis.assets/1652943604992.png" alt="1652943604992"></p>
<ul>
<li>LPUSH和RPUSH</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; LPUSH users <span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line">(integer) <span class="number">3</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; RPUSH users <span class="number">4</span> <span class="number">5</span> <span class="number">6</span></span><br><span class="line">(integer) <span class="number">6</span></span><br></pre></td></tr></table></figure>

<ul>
<li>LPOP和RPOP</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; LPOP users</span><br><span class="line"><span class="string">&quot;3&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; RPOP users</span><br><span class="line"><span class="string">&quot;6&quot;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>LRANGE</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; LRANGE users <span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;1&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;4&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="4-7-Redis命令-Set命令"><a href="#4-7-Redis命令-Set命令" class="headerlink" title="4.7 Redis命令-Set命令"></a>4.7 Redis命令-Set命令</h3><p>Redis的Set结构与Java中的HashSet类似，可以看做是一个value为null的HashMap。因为也是一个hash表，因此具备与HashSet类似的特征：</p>
<ul>
<li>无序</li>
<li>元素不可重复</li>
<li>查找快</li>
<li>支持交集.并集.差集等功能</li>
</ul>
<p><strong>Set类型的常见命令</strong></p>
<ul>
<li>SADD key member … ：向set中添加一个或多个元素</li>
<li>SREM key member … : 移除set中的指定元素</li>
<li>SCARD key： 返回set中元素的个数</li>
<li>SISMEMBER key member：判断一个元素是否存在于set中</li>
<li>SMEMBERS：获取set中的所有元素</li>
<li>SINTER key1 key2 … ：求key1与key2的交集</li>
<li>SDIFF key1 key2 … ：求key1与key2的差集</li>
<li>SUNION key1 key2 ..：求key1和key2的并集</li>
</ul>
<p>例如两个集合：s1和s2:</p>
<p><img src="https://i.imgur.com/ha8x86R.png"></p>
<p>求交集：SINTER s1 s2</p>
<p>求s1与s2的不同：SDIFF s1 s2</p>
<p><img src="https://i.imgur.com/L9vTv2X.png"></p>
<p><strong>具体命令</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; sadd s1 a b <span class="title function_">c</span></span><br><span class="line"><span class="params">(integer)</span> <span class="number">3</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; smembers s1</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;c&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;b&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;a&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; srem s1 <span class="title function_">a</span></span><br><span class="line"><span class="params">(integer)</span> <span class="number">1</span></span><br><span class="line">    </span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; SISMEMBER s1 <span class="title function_">a</span></span><br><span class="line"><span class="params">(integer)</span> <span class="number">0</span></span><br><span class="line">    </span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; SISMEMBER s1 <span class="title function_">b</span></span><br><span class="line"><span class="params">(integer)</span> <span class="number">1</span></span><br><span class="line">    </span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; SCARD <span class="title function_">s1</span></span><br><span class="line"><span class="params">(integer)</span> <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p><strong>案例</strong></p>
<ul>
<li>将下列数据用Redis的Set集合来存储：</li>
<li>张三的好友有：李四.王五.赵六</li>
<li>李四的好友有：王五.麻子.二狗</li>
<li>利用Set的命令实现下列功能：</li>
<li>计算张三的好友有几人</li>
<li>计算张三和李四有哪些共同好友</li>
<li>查询哪些人是张三的好友却不是李四的好友</li>
<li>查询张三和李四的好友总共有哪些人</li>
<li>判断李四是否是张三的好友</li>
<li>判断张三是否是李四的好友</li>
<li>将李四从张三的好友列表中移除</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; SADD zs lisi wangwu <span class="title function_">zhaoliu</span></span><br><span class="line"><span class="params">(integer)</span> <span class="number">3</span></span><br><span class="line">    </span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; SADD ls wangwu mazi <span class="title function_">ergou</span></span><br><span class="line"><span class="params">(integer)</span> <span class="number">3</span></span><br><span class="line">    </span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; SCARD <span class="title function_">zs</span></span><br><span class="line"><span class="params">(integer)</span> <span class="number">3</span></span><br><span class="line">    </span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; SINTER zs ls</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;wangwu&quot;</span></span><br><span class="line">    </span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; SDIFF zs ls</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;zhaoliu&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;lisi&quot;</span></span><br><span class="line">    </span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; SUNION zs ls</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;wangwu&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;zhaoliu&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;lisi&quot;</span></span><br><span class="line"><span class="number">4</span>) <span class="string">&quot;mazi&quot;</span></span><br><span class="line"><span class="number">5</span>) <span class="string">&quot;ergou&quot;</span></span><br><span class="line">    </span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; SISMEMBER zs <span class="title function_">lisi</span></span><br><span class="line"><span class="params">(integer)</span> <span class="number">1</span></span><br><span class="line">    </span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; SISMEMBER ls <span class="title function_">zhangsan</span></span><br><span class="line"><span class="params">(integer)</span> <span class="number">0</span></span><br><span class="line">    </span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; SREM zs <span class="title function_">lisi</span></span><br><span class="line"><span class="params">(integer)</span> <span class="number">1</span></span><br><span class="line">    </span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; SMEMBERS zs</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;zhaoliu&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;wangwu&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="4-8-Redis命令-SortedSet类型"><a href="#4-8-Redis命令-SortedSet类型" class="headerlink" title="4.8 Redis命令-SortedSet类型"></a>4.8 Redis命令-SortedSet类型</h3><p>Redis的SortedSet是一个可排序的set集合，与Java中的TreeSet有些类似，但底层数据结构却差别很大。SortedSet中的每一个元素都带有一个score属性，可以基于score属性对元素排序，底层的实现是一个跳表（SkipList）加 hash表。</p>
<p>SortedSet具备下列特性：</p>
<ul>
<li>可排序</li>
<li>元素不重复</li>
<li>查询速度快</li>
</ul>
<p>因为SortedSet的可排序特性，经常被用来实现排行榜这样的功能。</p>
<p>SortedSet的常见命令有：</p>
<ul>
<li>ZADD key score member：添加一个或多个元素到sorted set ，如果已经存在则更新其score值</li>
<li>ZREM key member：删除sorted set中的一个指定元素</li>
<li>ZSCORE key member : 获取sorted set中的指定元素的score值</li>
<li>ZRANK key member：获取sorted set 中的指定元素的排名</li>
<li>ZCARD key：获取sorted set中的元素个数</li>
<li>ZCOUNT key min max：统计score值在给定范围内的所有元素的个数</li>
<li>ZINCRBY key increment member：让sorted set中的指定元素自增，步长为指定的increment值</li>
<li>ZRANGE key min max：按照score排序后，获取指定排名范围内的元素</li>
<li>ZRANGEBYSCORE key min max：按照score排序后，获取指定score范围内的元素</li>
<li>ZDIFF.ZINTER.ZUNION：求差集.交集.并集</li>
</ul>
<p>注意：所有的排名默认都是升序，如果要降序则在命令的Z后面添加REV即可，例如：</p>
<ul>
<li><strong>升序</strong>获取sorted set 中的指定元素的排名：ZRANK key member</li>
<li><strong>降序</strong>获取sorted set 中的指定元素的排名：ZREVRANK key memeber</li>
</ul>
<h2 id="5-Redis的Java客户端-Jedis"><a href="#5-Redis的Java客户端-Jedis" class="headerlink" title="5.Redis的Java客户端-Jedis"></a>5.Redis的Java客户端-Jedis</h2><p>在Redis官网中提供了各种语言的客户端，地址：<a href="https://redis.io/docs/clients/">https://redis.io/docs/clients/</a></p>
<p><img src="https://i.imgur.com/9f68ivq.png"></p>
<p>其中Java客户端也包含很多：</p>
<p><img src="/image-20220609102817435.png" alt="image-20220609102817435"></p>
<p>标记为❤的就是推荐使用的java客户端，包括：</p>
<ul>
<li>Jedis和Lettuce：这两个主要是提供了Redis命令对应的API，方便我们操作Redis，而SpringDataRedis又对这两种做了抽象和封装，因此我们后期会直接以SpringDataRedis来学习。</li>
<li>Redisson：是在Redis基础上实现了分布式的可伸缩的java数据结构，例如Map.Queue等，而且支持跨进程的同步机制：Lock.Semaphore等待，比较适合用来实现特殊的功能需求。</li>
</ul>
<h3 id="5-1-Jedis快速入门"><a href="#5-1-Jedis快速入门" class="headerlink" title="5.1 Jedis快速入门"></a>5.1 Jedis快速入门</h3><p><strong>入门案例详细步骤</strong></p>
<p>案例分析：</p>
<p>0）创建工程：</p>
<p><img src="/Redis.assets/1652959239813.png" alt="1652959239813"></p>
<p>1）引入依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--jedis--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.7.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--单元测试--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.jupiter<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-jupiter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.7.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>2）建立连接</p>
<p>新建一个单元测试类，内容如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Jedis jedis;</span><br><span class="line"></span><br><span class="line"><span class="meta">@BeforeEach</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">setUp</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1.建立连接</span></span><br><span class="line">    <span class="comment">// jedis = new Jedis(&quot;192.168.150.101&quot;, 6379);</span></span><br><span class="line">    jedis = JedisConnectionFactory.getJedis();</span><br><span class="line">    <span class="comment">// 2.设置密码</span></span><br><span class="line">    jedis.auth(<span class="string">&quot;123321&quot;</span>);</span><br><span class="line">    <span class="comment">// 3.选择库</span></span><br><span class="line">    jedis.select(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>3）测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testString</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 存入数据</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> jedis.set(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;虎哥&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;result = &quot;</span> + result);</span><br><span class="line">    <span class="comment">// 获取数据</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> jedis.get(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;name = &quot;</span> + name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testHash</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 插入hash数据</span></span><br><span class="line">    jedis.hset(<span class="string">&quot;user:1&quot;</span>, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;Jack&quot;</span>);</span><br><span class="line">    jedis.hset(<span class="string">&quot;user:1&quot;</span>, <span class="string">&quot;age&quot;</span>, <span class="string">&quot;21&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取</span></span><br><span class="line">    Map&lt;String, String&gt; map = jedis.hgetAll(<span class="string">&quot;user:1&quot;</span>);</span><br><span class="line">    System.out.println(map);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>4）释放资源</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@AfterEach</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">tearDown</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (jedis != <span class="literal">null</span>) &#123;</span><br><span class="line">        jedis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="5-2-Jedis连接池"><a href="#5-2-Jedis连接池" class="headerlink" title="5.2 Jedis连接池"></a>5.2 Jedis连接池</h3><p>Jedis本身是线程不安全的，并且频繁的创建和销毁连接会有性能损耗，因此我们推荐大家使用Jedis连接池代替Jedis的直连方式</p>
<p>有关池化思想，并不仅仅是这里会使用，很多地方都有，比如说我们的数据库连接池，比如我们tomcat中的线程池，这些都是池化思想的体现。</p>
<h4 id="5-2-1-创建Jedis的连接池"><a href="#5-2-1-创建Jedis的连接池" class="headerlink" title="5.2.1.创建Jedis的连接池"></a>5.2.1.创建Jedis的连接池</h4><p>- </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JedisConnectionFacotry</span> &#123;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> JedisPool jedisPool;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">static</span> &#123;</span><br><span class="line">         <span class="comment">//配置连接池</span></span><br><span class="line">         <span class="type">JedisPoolConfig</span> <span class="variable">poolConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JedisPoolConfig</span>();</span><br><span class="line">         poolConfig.setMaxTotal(<span class="number">8</span>);</span><br><span class="line">         poolConfig.setMaxIdle(<span class="number">8</span>);</span><br><span class="line">         poolConfig.setMinIdle(<span class="number">0</span>);</span><br><span class="line">         poolConfig.setMaxWaitMillis(<span class="number">1000</span>);</span><br><span class="line">         <span class="comment">//创建连接池对象</span></span><br><span class="line">         jedisPool = <span class="keyword">new</span> <span class="title class_">JedisPool</span>(poolConfig,</span><br><span class="line">                 <span class="string">&quot;192.168.150.101&quot;</span>,<span class="number">6379</span>,<span class="number">1000</span>,<span class="string">&quot;123321&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> Jedis <span class="title function_">getJedis</span><span class="params">()</span>&#123;</span><br><span class="line">          <span class="keyword">return</span> jedisPool.getResource();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>代码说明：</strong></p>
<ul>
<li><p>1） JedisConnectionFacotry：工厂设计模式是实际开发中非常常用的一种设计模式，我们可以使用工厂，去降低代的耦合，比如Spring中的Bean的创建，就用到了工厂设计模式</p>
</li>
<li><p>2）静态代码块：随着类的加载而加载，确保只能执行一次，我们在加载当前工厂类的时候，就可以执行static的操作完成对 连接池的初始化</p>
</li>
<li><p>3）最后提供返回连接池中连接的方法.</p>
</li>
</ul>
<h4 id="5-2-2-改造原始代码"><a href="#5-2-2-改造原始代码" class="headerlink" title="5.2.2.改造原始代码"></a>5.2.2.改造原始代码</h4><p><strong>代码说明:</strong></p>
<p>1.在我们完成了使用工厂设计模式来完成代码的编写之后，我们在获得连接时，就可以通过工厂来获得。</p>
<p>，而不用直接去new对象，降低耦合，并且使用的还是连接池对象。</p>
<p>2.当我们使用了连接池后，当我们关闭连接其实并不是关闭，而是将Jedis还回连接池的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="meta">@BeforeEach</span></span><br><span class="line"> <span class="keyword">void</span> <span class="title function_">setUp</span><span class="params">()</span>&#123;</span><br><span class="line">     <span class="comment">//建立连接</span></span><br><span class="line">     <span class="comment">/*jedis = new Jedis(&quot;127.0.0.1&quot;,6379);*/</span></span><br><span class="line">     jedis = JedisConnectionFacotry.getJedis();</span><br><span class="line">      <span class="comment">//选择库</span></span><br><span class="line">     jedis.select(<span class="number">0</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@AfterEach</span></span><br><span class="line"> <span class="keyword">void</span> <span class="title function_">tearDown</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="keyword">if</span> (jedis != <span class="literal">null</span>) &#123;</span><br><span class="line">         jedis.close();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>



<h2 id="6-Redis的Java客户端-SpringDataRedis"><a href="#6-Redis的Java客户端-SpringDataRedis" class="headerlink" title="6.Redis的Java客户端-SpringDataRedis"></a>6.Redis的Java客户端-SpringDataRedis</h2><p>SpringData是Spring中数据操作的模块，包含对各种数据库的集成，其中对Redis的集成模块就叫做SpringDataRedis，官网地址：<a href="https://spring.io/projects/spring-data-redis">https://spring.io/projects/spring-data-redis</a></p>
<ul>
<li>提供了对不同Redis客户端的整合（Lettuce和Jedis）</li>
<li>提供了RedisTemplate统一API来操作Redis</li>
<li>支持Redis的发布订阅模型</li>
<li>支持Redis哨兵和Redis集群</li>
<li>支持基于Lettuce的响应式编程</li>
<li>支持基于JDK.JSON.字符串.Spring对象的数据序列化及反序列化</li>
<li>支持基于Redis的JDKCollection实现</li>
</ul>
<p>SpringDataRedis中提供了RedisTemplate工具类，其中封装了各种对Redis的操作。并且将不同数据类型的操作API封装到了不同的类型中：</p>
<p><img src="F:/综合项目文件/学习资料/Redis-笔记资料/01-入门篇/讲义/Redis注释版/Redis.assets/1652976773295.png" alt="1652976773295"></p>
<h3 id="6-1-快速入门"><a href="#6-1-快速入门" class="headerlink" title="6.1.快速入门"></a>6.1.快速入门</h3><p>SpringBoot已经提供了对SpringDataRedis的支持，使用非常简单：</p>
<h4 id="6-1-1-导入pom坐标"><a href="#6-1-1-导入pom坐标" class="headerlink" title="6.1.1.导入pom坐标"></a>6.1.1.导入pom坐标</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.heima<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>redis-demo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>redis-demo<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>Demo project for Spring Boot<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--redis依赖--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--common-pool--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-pool2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--Jackson依赖--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">excludes</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">exclude</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">excludes</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="6-1-2-配置文件"><a href="#6-1-2-配置文件" class="headerlink" title="6.1.2 .配置文件"></a>6.1.2 .配置文件</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.150</span><span class="number">.101</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123321</span></span><br><span class="line">    <span class="attr">lettuce:</span></span><br><span class="line">      <span class="attr">pool:</span></span><br><span class="line">        <span class="attr">max-active:</span> <span class="number">8</span>  <span class="comment">#最大连接</span></span><br><span class="line">        <span class="attr">max-idle:</span> <span class="number">8</span>   <span class="comment">#最大空闲连接</span></span><br><span class="line">        <span class="attr">min-idle:</span> <span class="number">0</span>   <span class="comment">#最小空闲连接</span></span><br><span class="line">        <span class="attr">max-wait:</span> <span class="string">100ms</span> <span class="comment">#连接等待时间</span></span><br></pre></td></tr></table></figure>

<h4 id="6-1-3-测试代码"><a href="#6-1-3-测试代码" class="headerlink" title="6.1.3.测试代码"></a>6.1.3.测试代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RedisDemoApplicationTests</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate&lt;String, Object&gt; redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 写入一条String数据</span></span><br><span class="line">        redisTemplate.opsForValue().set(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;虎哥&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取string数据</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">name</span> <span class="operator">=</span> redisTemplate.opsForValue().get(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;name = &quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>贴心小提示：SpringDataJpa使用起来非常简单，记住如下几个步骤即可</strong></p>
<p>SpringDataRedis的使用步骤：</p>
<ul>
<li>引入spring-boot-starter-data-redis依赖</li>
<li>在application.yml配置Redis信息</li>
<li>注入RedisTemplate</li>
</ul>
<h3 id="6-2-数据序列化器"><a href="#6-2-数据序列化器" class="headerlink" title="6.2 .数据序列化器"></a>6.2 .数据序列化器</h3><p>RedisTemplate可以接收任意Object作为值写入Redis：</p>
<p><img src="https://i.imgur.com/OEMcbuu.png"></p>
<p>只不过写入前会把Object序列化为字节形式，默认是采用JDK序列化，得到的结果是这样的：</p>
<p><img src="https://i.imgur.com/5FjtWk5.png"></p>
<p>缺点：</p>
<ul>
<li>可读性差</li>
<li>内存占用较大</li>
</ul>
<p>我们可以自定义RedisTemplate的序列化方式，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title function_">redisTemplate</span><span class="params">(RedisConnectionFactory connectionFactory)</span>&#123;</span><br><span class="line">        <span class="comment">// 创建RedisTemplate对象</span></span><br><span class="line">        RedisTemplate&lt;String, Object&gt; template = <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 设置连接工厂</span></span><br><span class="line">        template.setConnectionFactory(connectionFactory);</span><br><span class="line">        <span class="comment">// 创建JSON序列化工具</span></span><br><span class="line">        <span class="type">GenericJackson2JsonRedisSerializer</span> <span class="variable">jsonRedisSerializer</span> <span class="operator">=</span> </span><br><span class="line">            							<span class="keyword">new</span> <span class="title class_">GenericJackson2JsonRedisSerializer</span>();</span><br><span class="line">        <span class="comment">// 设置Key的序列化</span></span><br><span class="line">        template.setKeySerializer(RedisSerializer.string());</span><br><span class="line">        template.setHashKeySerializer(RedisSerializer.string());</span><br><span class="line">        <span class="comment">// 设置Value的序列化</span></span><br><span class="line">        template.setValueSerializer(jsonRedisSerializer);</span><br><span class="line">        template.setHashValueSerializer(jsonRedisSerializer);</span><br><span class="line">        <span class="comment">// 返回</span></span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这里采用了JSON序列化来代替默认的JDK序列化方式。最终结果如图：</p>
<p><img src="https://i.imgur.com/XOAq3cN.png"></p>
<p>整体可读性有了很大提升，并且能将Java对象自动的序列化为JSON字符串，并且查询时能自动把JSON反序列化为Java对象。不过，其中记录了序列化时对应的class名称，目的是为了查询时实现自动反序列化。这会带来额外的内存开销。</p>
<h3 id="6-3-StringRedisTemplate"><a href="#6-3-StringRedisTemplate" class="headerlink" title="6.3 StringRedisTemplate"></a>6.3 StringRedisTemplate</h3><p>尽管JSON的序列化方式可以满足我们的需求，但依然存在一些问题，如图：</p>
<p><img src="F:/综合项目文件/学习资料/Redis-笔记资料/01-入门篇/讲义/Redis注释版/Redis.assets/1653054602930.png" alt="1653054602930"></p>
<p>为了在反序列化时知道对象的类型，JSON序列化器会将类的class类型写入json结果中，存入Redis，会带来额外的内存开销。</p>
<p>为了减少内存的消耗，我们可以采用手动序列化的方式，换句话说，就是不借助默认的序列化器，而是我们自己来控制序列化的动作，同时，我们只采用String的序列化器，这样，在存储value时，我们就不需要在内存中就不用多存储数据，从而节约我们的内存空间</p>
<p><img src="F:/综合项目文件/学习资料/Redis-笔记资料/01-入门篇/讲义/Redis注释版/Redis.assets/1653054744832.png" alt="1653054744832"></p>
<p>这种用法比较普遍，因此SpringDataRedis就提供了RedisTemplate的子类：StringRedisTemplate，它的key和value的序列化方式默认就是String方式。</p>
<p><img src="https://i.imgur.com/zXH6Qn6.png"></p>
<p>省去了我们自定义RedisTemplate的序列化方式的步骤，而是直接使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RedisStringTests</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 写入一条String数据</span></span><br><span class="line">        stringRedisTemplate.opsForValue().set(<span class="string">&quot;verify:phone:13600527634&quot;</span>, <span class="string">&quot;124143&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取string数据</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">name</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;name = &quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ObjectMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testSaveUser</span><span class="params">()</span> <span class="keyword">throws</span> JsonProcessingException &#123;</span><br><span class="line">        <span class="comment">// 创建对象</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;虎哥&quot;</span>, <span class="number">21</span>);</span><br><span class="line">        <span class="comment">// 手动序列化</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> mapper.writeValueAsString(user);</span><br><span class="line">        <span class="comment">// 写入数据</span></span><br><span class="line">        stringRedisTemplate.opsForValue().set(<span class="string">&quot;user:200&quot;</span>, json);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取数据</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">jsonUser</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(<span class="string">&quot;user:200&quot;</span>);</span><br><span class="line">        <span class="comment">// 手动反序列化</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user1</span> <span class="operator">=</span> mapper.readValue(jsonUser, User.class);</span><br><span class="line">        System.out.println(<span class="string">&quot;user1 = &quot;</span> + user1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时我们再来看一看存储的数据，小伙伴们就会发现那个class数据已经不在了，节约了我们的空间~</p>
<p><img src="F:/综合项目文件/学习资料/Redis-笔记资料/01-入门篇/讲义/Redis注释版/Redis.assets/1653054945211.png" alt="1653054945211"></p>
<p>最后小总结：</p>
<p>RedisTemplate的两种序列化实践方案：</p>
<ul>
<li><p>方案一：</p>
<ul>
<li>自定义RedisTemplate</li>
<li>修改RedisTemplate的序列化器为GenericJackson2JsonRedisSerializer</li>
</ul>
</li>
<li><p>方案二：</p>
<ul>
<li>使用StringRedisTemplate</li>
<li>写入Redis时，手动把对象序列化为JSON</li>
<li>读取Redis时，手动把读取到的JSON反序列化为对象</li>
</ul>
</li>
</ul>
<h3 id="6-4-Hash结构操作"><a href="#6-4-Hash结构操作" class="headerlink" title="6.4 Hash结构操作"></a>6.4 Hash结构操作</h3><p>在基础篇的最后，咱们对Hash结构操作一下，收一个小尾巴，这个代码咱们就不再解释啦</p>
<p>马上就开始新的篇章~~~进入到我们的Redis实战篇</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RedisStringTests</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testHash</span><span class="params">()</span> &#123;</span><br><span class="line">        stringRedisTemplate.opsForHash().put(<span class="string">&quot;user:400&quot;</span>, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;虎哥&quot;</span>);</span><br><span class="line">        stringRedisTemplate.opsForHash().put(<span class="string">&quot;user:400&quot;</span>, <span class="string">&quot;age&quot;</span>, <span class="string">&quot;21&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Map&lt;Object, Object&gt; entries = stringRedisTemplate.opsForHash().entries(<span class="string">&quot;user:400&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;entries = &quot;</span> + entries);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>redis系列</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title>redis实战篇</title>
    <url>/2022/09/24/redis%E5%AE%9E%E6%88%98%E7%AF%87/</url>
    <content><![CDATA[<p>亲爱的小伙伴们大家好，马上咱们就开始实战篇的内容了，相信通过本章的学习，小伙伴们就能理解各种redis的使用啦，接下来咱们来一起看看实战篇我们要学习一些什么样的内容</p>
<ul>
<li>短信登录</li>
</ul>
<p>这一块我们会使用redis共享session来实现</p>
<ul>
<li>商户查询缓存</li>
</ul>
<p>通过本章节，我们会理解缓存击穿，缓存穿透，缓存雪崩等问题，让小伙伴的对于这些概念的理解不仅仅是停留在概念上，更是能在代码中看到对应的内容</p>
<ul>
<li>优惠卷秒杀</li>
</ul>
<p>通过本章节，我们可以学会Redis的计数器功能， 结合Lua完成高性能的redis操作，同时学会Redis分布式锁的原理，包括Redis的三种消息队列</p>
<ul>
<li>附近的商户</li>
</ul>
<p>我们利用Redis的GEOHash来完成对于地理坐标的操作</p>
<ul>
<li>UV统计</li>
</ul>
<p>主要是使用Redis来完成统计功能</p>
<ul>
<li>用户签到</li>
</ul>
<p>使用Redis的BitMap数据统计功能</p>
<ul>
<li>好友关注</li>
</ul>
<p>基于Set集合的关注、取消关注，共同关注等等功能，这一块知识咱们之前就讲过，这次我们在项目中来使用一下</p>
<ul>
<li>打人探店</li>
</ul>
<p>基于List来完成点赞列表的操作，同时基于SortedSet来完成点赞的排行榜功能</p>
<p>以上这些内容咱们统统都会给小伙伴们讲解清楚，让大家充分理解如何使用Redis</p>
<p><img src="/2022/09/24/redis%E5%AE%9E%E6%88%98%E7%AF%87/1653056228879.png" alt="1653056228879"></p>
<h2 id="1、短信登录"><a href="#1、短信登录" class="headerlink" title="1、短信登录"></a>1、短信登录</h2><h3 id="1-1、导入黑马点评项目"><a href="#1-1、导入黑马点评项目" class="headerlink" title="1.1、导入黑马点评项目"></a>1.1、导入黑马点评项目</h3><h4 id="1-1-1-、导入SQL"><a href="#1-1-1-、导入SQL" class="headerlink" title="1.1.1 、导入SQL"></a>1.1.1 、导入SQL</h4><p><img src="/2022/09/24/redis%E5%AE%9E%E6%88%98%E7%AF%87/1653057872536.png" alt="1653057872536"></p>
<h4 id="1-1-2、有关当前模型"><a href="#1-1-2、有关当前模型" class="headerlink" title="1.1.2、有关当前模型"></a>1.1.2、有关当前模型</h4><p>手机或者app端发起请求，请求我们的nginx服务器，nginx基于七层模型走的事HTTP协议，可以实现基于Lua直接绕开tomcat访问redis，也可以作为静态资源服务器，轻松扛下上万并发， 负载均衡到下游tomcat服务器，打散流量，我们都知道一台4核8G的tomcat，在优化和处理简单业务的加持下，大不了就处理1000左右的并发， 经过nginx的负载均衡分流后，利用集群支撑起整个项目，同时nginx在部署了前端项目后，更是可以做到动静分离，进一步降低tomcat服务的压力，这些功能都得靠nginx起作用，所以nginx是整个项目中重要的一环。</p>
<p>在tomcat支撑起并发流量后，我们如果让tomcat直接去访问Mysql，根据经验Mysql企业级服务器只要上点并发，一般是16或32 核心cpu，32 或64G内存，像企业级mysql加上固态硬盘能够支撑的并发，大概就是4000起~7000左右，上万并发， 瞬间就会让Mysql服务器的cpu，硬盘全部打满，容易崩溃，所以我们在高并发场景下，会选择使用mysql集群，同时为了进一步降低Mysql的压力，同时增加访问的性能，我们也会加入Redis，同时使用Redis集群使得Redis对外提供更好的服务。</p>
<p><img src="/2022/09/24/redis%E5%AE%9E%E6%88%98%E7%AF%87/1653059409865.png" alt="1653059409865"></p>
<h4 id="1-1-3、导入后端项目"><a href="#1-1-3、导入后端项目" class="headerlink" title="1.1.3、导入后端项目"></a>1.1.3、导入后端项目</h4><p>在资料中提供了一个项目源码：</p>
<p><img src="/2022/09/24/redis%E5%AE%9E%E6%88%98%E7%AF%87/1653060237073.png" alt="1653060237073"></p>
<h4 id="1-1-4、导入前端工程"><a href="#1-1-4、导入前端工程" class="headerlink" title="1.1.4、导入前端工程"></a>1.1.4、导入前端工程</h4><p><img src="/2022/09/24/redis%E5%AE%9E%E6%88%98%E7%AF%87/1653060337562.png" alt="1653060337562"></p>
<h4 id="1-1-5-运行前端项目"><a href="#1-1-5-运行前端项目" class="headerlink" title="1.1.5 运行前端项目"></a>1.1.5 运行前端项目</h4><p><img src="/2022/09/24/redis%E5%AE%9E%E6%88%98%E7%AF%87/1653060588190.png" alt="1653060588190"></p>
<h3 id="1-2-、基于Session实现登录流程"><a href="#1-2-、基于Session实现登录流程" class="headerlink" title="1.2 、基于Session实现登录流程"></a>1.2 、基于Session实现登录流程</h3><p><strong>发送验证码：</strong></p>
<p>用户在提交手机号后，会校验手机号是否合法，如果不合法，则要求用户重新输入手机号</p>
<p>如果手机号合法，后台此时生成对应的验证码，同时将验证码进行保存，然后再通过短信的方式将验证码发送给用户</p>
<p><strong>短信验证码登录、注册：</strong></p>
<p>用户将验证码和手机号进行输入，后台从session中拿到当前验证码，然后和用户输入的验证码进行校验，如果不一致，则无法通过校验，如果一致，则后台根据手机号查询用户，如果用户不存在，则为用户创建账号信息，保存到数据库，无论是否存在，都会将用户信息保存到session中，方便后续获得当前登录信息</p>
<p><strong>校验登录状态:</strong></p>
<p>用户在请求时候，会从cookie中携带者JsessionId到后台，后台通过JsessionId从session中拿到用户信息，如果没有session信息，则进行拦截，如果有session信息，则将用户信息保存到threadLocal中，并且放行</p>
<p><img src="/2022/09/24/redis%E5%AE%9E%E6%88%98%E7%AF%87/1653066208144.png" alt="1653066208144"></p>
<h3 id="1-3-、实现发送短信验证码功能"><a href="#1-3-、实现发送短信验证码功能" class="headerlink" title="1.3 、实现发送短信验证码功能"></a>1.3 、实现发送短信验证码功能</h3><p><strong>页面流程</strong></p>
<p><img src="/2022/09/24/redis%E5%AE%9E%E6%88%98%E7%AF%87/1653067054461.png" alt="1653067054461"></p>
<p><strong>具体代码如下</strong></p>
<p><strong>贴心小提示：</strong></p>
<p>具体逻辑上文已经分析，我们仅仅只需要按照提示的逻辑写出代码即可。</p>
<ul>
<li>发送验证码</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">sendCode</span><span class="params">(String phone, HttpSession session)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.校验手机号</span></span><br><span class="line">    <span class="keyword">if</span> (RegexUtils.isPhoneInvalid(phone)) &#123;</span><br><span class="line">        <span class="comment">// 2.如果不符合，返回错误信息</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;手机号格式错误！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3.符合，生成验证码</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">code</span> <span class="operator">=</span> RandomUtil.randomNumbers(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.保存验证码到 session</span></span><br><span class="line">    session.setAttribute(<span class="string">&quot;code&quot;</span>,code);</span><br><span class="line">    <span class="comment">// 5.发送验证码</span></span><br><span class="line">    log.debug(<span class="string">&quot;发送短信验证码成功，验证码：&#123;&#125;&quot;</span>, code);</span><br><span class="line">    <span class="comment">// 返回ok</span></span><br><span class="line">    <span class="keyword">return</span> Result.ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>登录</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">login</span><span class="params">(LoginFormDTO loginForm, HttpSession session)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.校验手机号</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">phone</span> <span class="operator">=</span> loginForm.getPhone();</span><br><span class="line">    <span class="keyword">if</span> (RegexUtils.isPhoneInvalid(phone)) &#123;</span><br><span class="line">        <span class="comment">// 2.如果不符合，返回错误信息</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;手机号格式错误！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3.校验验证码</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">cacheCode</span> <span class="operator">=</span> session.getAttribute(<span class="string">&quot;code&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">code</span> <span class="operator">=</span> loginForm.getCode();</span><br><span class="line">    <span class="keyword">if</span>(cacheCode == <span class="literal">null</span> || !cacheCode.toString().equals(code))&#123;</span><br><span class="line">         <span class="comment">//3.不一致，报错</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;验证码错误&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//一致，根据手机号查询用户</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> query().eq(<span class="string">&quot;phone&quot;</span>, phone).one();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.判断用户是否存在</span></span><br><span class="line">    <span class="keyword">if</span>(user == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="comment">//不存在，则创建</span></span><br><span class="line">        user =  createUserWithPhone(phone);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//7.保存用户信息到session中</span></span><br><span class="line">    session.setAttribute(<span class="string">&quot;user&quot;</span>,user);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Result.ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-4、实现登录拦截功能"><a href="#1-4、实现登录拦截功能" class="headerlink" title="1.4、实现登录拦截功能"></a>1.4、实现登录拦截功能</h3><p><strong>温馨小贴士：tomcat的运行原理</strong></p>
<p><img src="/2022/09/24/redis%E5%AE%9E%E6%88%98%E7%AF%87/1653068196656.png" alt="1653068196656"></p>
<p>当用户发起请求时，会访问我们像tomcat注册的端口，任何程序想要运行，都需要有一个线程对当前端口号进行监听，tomcat也不例外，当监听线程知道用户想要和tomcat连接连接时，那会由监听线程创建socket连接，socket都是成对出现的，用户通过socket像互相传递数据，当tomcat端的socket接受到数据后，此时监听线程会从tomcat的线程池中取出一个线程执行用户请求，在我们的服务部署到tomcat后，线程会找到用户想要访问的工程，然后用这个线程转发到工程中的controller，service，dao中，并且访问对应的DB，在用户执行完请求后，再统一返回，再找到tomcat端的socket，再将数据写回到用户端的socket，完成请求和响应</p>
<p>通过以上讲解，我们可以得知 每个用户其实对应都是去找tomcat线程池中的一个线程来完成工作的， 使用完成后再进行回收，既然每个请求都是独立的，所以在每个用户去访问我们的工程时，我们可以使用threadlocal来做到线程隔离，每个线程操作自己的一份数据</p>
<p><strong>温馨小贴士：关于threadlocal</strong></p>
<p>如果小伙伴们看过threadLocal的源码，你会发现在threadLocal中，无论是他的put方法和他的get方法， 都是先从获得当前用户的线程，然后从线程中取出线程的成员变量map，只要线程不一样，map就不一样，所以可以通过这种方式来做到线程隔离</p>
<p><img src="/2022/09/24/redis%E5%AE%9E%E6%88%98%E7%AF%87/1653068874258.png" alt="1653068874258"></p>
<p>拦截器代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">       <span class="comment">//1.获取session</span></span><br><span class="line">        <span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> request.getSession();</span><br><span class="line">        <span class="comment">//2.获取session中的用户</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">user</span> <span class="operator">=</span> session.getAttribute(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">        <span class="comment">//3.判断用户是否存在</span></span><br><span class="line">        <span class="keyword">if</span>(user == <span class="literal">null</span>)&#123;</span><br><span class="line">              <span class="comment">//4.不存在，拦截，返回401状态码</span></span><br><span class="line">              response.setStatus(<span class="number">401</span>);</span><br><span class="line">              <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//5.存在，保存用户信息到Threadlocal</span></span><br><span class="line">        UserHolder.saveUser((User)user);</span><br><span class="line">        <span class="comment">//6.放行</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>让拦截器生效</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MvcConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">        <span class="comment">// 登录拦截器</span></span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">LoginInterceptor</span>())</span><br><span class="line">                .excludePathPatterns(</span><br><span class="line">                        <span class="string">&quot;/shop/**&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/voucher/**&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/shop-type/**&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/upload/**&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/blog/hot&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/user/code&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/user/login&quot;</span></span><br><span class="line">                ).order(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// token刷新的拦截器</span></span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">RefreshTokenInterceptor</span>(stringRedisTemplate)).addPathPatterns(<span class="string">&quot;/**&quot;</span>).order(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-5、隐藏用户敏感信息"><a href="#1-5、隐藏用户敏感信息" class="headerlink" title="1.5、隐藏用户敏感信息"></a>1.5、隐藏用户敏感信息</h3><p>我们通过浏览器观察到此时用户的全部信息都在，这样极为不靠谱，所以我们应当在返回用户信息之前，将用户的敏感信息进行隐藏，采用的核心思路就是书写一个UserDto对象，这个UserDto对象就没有敏感信息了，我们在返回前，将有用户敏感信息的User对象转化成没有敏感信息的UserDto对象，那么就能够避免这个尴尬的问题了</p>
<p><strong>在登录方法处修改</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//7.保存用户信息到session中</span></span><br><span class="line">session.setAttribute(<span class="string">&quot;user&quot;</span>, BeanUtils.copyProperties(user,UserDTO.class));</span><br></pre></td></tr></table></figure>

<p><strong>在拦截器处：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//5.存在，保存用户信息到Threadlocal</span></span><br><span class="line">UserHolder.saveUser((UserDTO) user);</span><br></pre></td></tr></table></figure>

<p><strong>在UserHolder处：将user对象换成UserDTO</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserHolder</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;UserDTO&gt; tl = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">saveUser</span><span class="params">(UserDTO user)</span>&#123;</span><br><span class="line">        tl.set(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> UserDTO <span class="title function_">getUser</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> tl.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">removeUser</span><span class="params">()</span>&#123;</span><br><span class="line">        tl.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-6、session共享问题"><a href="#1-6、session共享问题" class="headerlink" title="1.6、session共享问题"></a>1.6、session共享问题</h3><p><strong>核心思路分析：</strong></p>
<p>每个tomcat中都有一份属于自己的session,假设用户第一次访问第一台tomcat，并且把自己的信息存放到第一台服务器的session中，但是第二次这个用户访问到了第二台tomcat，那么在第二台服务器上，肯定没有第一台服务器存放的session，所以此时 整个登录拦截功能就会出现问题，我们能如何解决这个问题呢？早期的方案是session拷贝，就是说虽然每个tomcat上都有不同的session，但是每当任意一台服务器的session修改时，都会同步给其他的Tomcat服务器的session，这样的话，就可以实现session的共享了</p>
<p>但是这种方案具有两个大问题</p>
<p>1、每台服务器中都有完整的一份session数据，服务器压力过大。</p>
<p>2、session拷贝数据时，可能会出现延迟</p>
<p>所以咱们后来采用的方案都是基于redis来完成，我们把session换成redis，redis数据本身就是共享的，就可以避免session共享的问题了</p>
<p><img src="/2022/09/24/redis%E5%AE%9E%E6%88%98%E7%AF%87/1653069893050.png" alt="1653069893050"></p>
<h3 id="1-7-Redis代替session的业务流程"><a href="#1-7-Redis代替session的业务流程" class="headerlink" title="1.7 Redis代替session的业务流程"></a>1.7 Redis代替session的业务流程</h3><h4 id="1-7-1、设计key的结构"><a href="#1-7-1、设计key的结构" class="headerlink" title="1.7.1、设计key的结构"></a>1.7.1、设计key的结构</h4><p>首先我们要思考一下利用redis来存储数据，那么到底使用哪种结构呢？由于存入的数据比较简单，我们可以考虑使用String，或者是使用哈希，如下图，如果使用String，同学们注意他的value，用多占用一点空间，如果使用哈希，则他的value中只会存储他数据本身，如果不是特别在意内存，其实使用String就可以啦。</p>
<p><img src="/2022/09/24/redis%E5%AE%9E%E6%88%98%E7%AF%87/1653319261433.png" alt="1653319261433"></p>
<h4 id="1-7-2、设计key的具体细节"><a href="#1-7-2、设计key的具体细节" class="headerlink" title="1.7.2、设计key的具体细节"></a>1.7.2、设计key的具体细节</h4><p>所以我们可以使用String结构，就是一个简单的key，value键值对的方式，但是关于key的处理，session他是每个用户都有自己的session，但是redis的key是共享的，咱们就不能使用code了</p>
<p>在设计这个key的时候，我们之前讲过需要满足两点</p>
<p>1、key要具有唯一性</p>
<p>2、key要方便携带</p>
<p>如果我们采用phone：手机号这个的数据来存储当然是可以的，但是如果把这样的敏感数据存储到redis中并且从页面中带过来毕竟不太合适，所以我们在后台生成一个随机串token，然后让前端带来这个token就能完成我们的整体逻辑了</p>
<h4 id="1-7-3、整体访问流程"><a href="#1-7-3、整体访问流程" class="headerlink" title="1.7.3、整体访问流程"></a>1.7.3、整体访问流程</h4><p>当注册完成后，用户去登录会去校验用户提交的手机号和验证码，是否一致，如果一致，则根据手机号查询用户信息，不存在则新建，最后将用户数据保存到redis，并且生成token作为redis的key，当我们校验用户是否登录时，会去携带着token进行访问，从redis中取出token对应的value，判断是否存在这个数据，如果没有则拦截，如果存在则将其保存到threadLocal中，并且放行。</p>
<p><img src="/2022/09/24/redis%E5%AE%9E%E6%88%98%E7%AF%87/1653319474181.png" alt="1653319474181"></p>
<h3 id="1-8-基于Redis实现短信登录"><a href="#1-8-基于Redis实现短信登录" class="headerlink" title="1.8 基于Redis实现短信登录"></a>1.8 基于Redis实现短信登录</h3><p>这里具体逻辑就不分析了，之前咱们已经重点分析过这个逻辑啦。</p>
<p><strong>UserServiceImpl代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">login</span><span class="params">(LoginFormDTO loginForm, HttpSession session)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.校验手机号</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">phone</span> <span class="operator">=</span> loginForm.getPhone();</span><br><span class="line">    <span class="keyword">if</span> (RegexUtils.isPhoneInvalid(phone)) &#123;</span><br><span class="line">        <span class="comment">// 2.如果不符合，返回错误信息</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;手机号格式错误！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3.从redis获取验证码并校验</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">cacheCode</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(LOGIN_CODE_KEY + phone);</span><br><span class="line">    <span class="type">String</span> <span class="variable">code</span> <span class="operator">=</span> loginForm.getCode();</span><br><span class="line">    <span class="keyword">if</span> (cacheCode == <span class="literal">null</span> || !cacheCode.equals(code)) &#123;</span><br><span class="line">        <span class="comment">// 不一致，报错</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;验证码错误&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.一致，根据手机号查询用户 select * from tb_user where phone = ?</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> query().eq(<span class="string">&quot;phone&quot;</span>, phone).one();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5.判断用户是否存在</span></span><br><span class="line">    <span class="keyword">if</span> (user == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 6.不存在，创建新用户并保存</span></span><br><span class="line">        user = createUserWithPhone(phone);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 7.保存用户信息到 redis中</span></span><br><span class="line">    <span class="comment">// 7.1.随机生成token，作为登录令牌</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> UUID.randomUUID().toString(<span class="literal">true</span>);</span><br><span class="line">    <span class="comment">// 7.2.将User对象转为HashMap存储</span></span><br><span class="line">    <span class="type">UserDTO</span> <span class="variable">userDTO</span> <span class="operator">=</span> BeanUtil.copyProperties(user, UserDTO.class);</span><br><span class="line">    Map&lt;String, Object&gt; userMap = BeanUtil.beanToMap(userDTO, <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(),</span><br><span class="line">            CopyOptions.create()</span><br><span class="line">                    .setIgnoreNullValue(<span class="literal">true</span>)</span><br><span class="line">                    .setFieldValueEditor((fieldName, fieldValue) -&gt; fieldValue.toString()));</span><br><span class="line">    <span class="comment">// 7.3.存储</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">tokenKey</span> <span class="operator">=</span> LOGIN_USER_KEY + token;</span><br><span class="line">    stringRedisTemplate.opsForHash().putAll(tokenKey, userMap);</span><br><span class="line">    <span class="comment">// 7.4.设置token有效期</span></span><br><span class="line">    stringRedisTemplate.expire(tokenKey, LOGIN_USER_TTL, TimeUnit.MINUTES);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 8.返回token</span></span><br><span class="line">    <span class="keyword">return</span> Result.ok(token);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-9-解决状态登录刷新问题"><a href="#1-9-解决状态登录刷新问题" class="headerlink" title="1.9 解决状态登录刷新问题"></a>1.9 解决状态登录刷新问题</h3><h4 id="1-9-1-初始方案思路总结："><a href="#1-9-1-初始方案思路总结：" class="headerlink" title="1.9.1 初始方案思路总结："></a>1.9.1 初始方案思路总结：</h4><p>在这个方案中，他确实可以使用对应路径的拦截，同时刷新登录token令牌的存活时间，但是现在这个拦截器他只是拦截需要被拦截的路径，假设当前用户访问了一些不需要拦截的路径，那么这个拦截器就不会生效，所以此时令牌刷新的动作实际上就不会执行，所以这个方案他是存在问题的</p>
<p><img src="/2022/09/24/redis%E5%AE%9E%E6%88%98%E7%AF%87/1653320822964.png" alt="1653320822964"></p>
<h4 id="1-9-2-优化方案"><a href="#1-9-2-优化方案" class="headerlink" title="1.9.2 优化方案"></a>1.9.2 优化方案</h4><p>既然之前的拦截器无法对不需要拦截的路径生效，那么我们可以添加一个拦截器，在第一个拦截器中拦截所有的路径，把第二个拦截器做的事情放入到第一个拦截器中，同时刷新令牌，因为第一个拦截器有了threadLocal的数据，所以此时第二个拦截器只需要判断拦截器中的user对象是否存在即可，完成整体刷新功能。</p>
<p><img src="/2022/09/24/redis%E5%AE%9E%E6%88%98%E7%AF%87/1653320764547.png" alt="1653320764547"></p>
<h4 id="1-9-3-代码"><a href="#1-9-3-代码" class="headerlink" title="1.9.3 代码"></a>1.9.3 代码</h4><p><strong>RefreshTokenInterceptor</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RefreshTokenInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RefreshTokenInterceptor</span><span class="params">(StringRedisTemplate stringRedisTemplate)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.stringRedisTemplate = stringRedisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1.获取请求头中的token</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;authorization&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (StrUtil.isBlank(token)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2.基于TOKEN获取redis中的用户</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span>  <span class="operator">=</span> LOGIN_USER_KEY + token;</span><br><span class="line">        Map&lt;Object, Object&gt; userMap = stringRedisTemplate.opsForHash().entries(key);</span><br><span class="line">        <span class="comment">// 3.判断用户是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (userMap.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 5.将查询到的hash数据转为UserDTO</span></span><br><span class="line">        <span class="type">UserDTO</span> <span class="variable">userDTO</span> <span class="operator">=</span> BeanUtil.fillBeanWithMap(userMap, <span class="keyword">new</span> <span class="title class_">UserDTO</span>(), <span class="literal">false</span>);</span><br><span class="line">        <span class="comment">// 6.存在，保存用户信息到 ThreadLocal</span></span><br><span class="line">        UserHolder.saveUser(userDTO);</span><br><span class="line">        <span class="comment">// 7.刷新token有效期</span></span><br><span class="line">        stringRedisTemplate.expire(key, LOGIN_USER_TTL, TimeUnit.MINUTES);</span><br><span class="line">        <span class="comment">// 8.放行</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 移除用户</span></span><br><span class="line">        UserHolder.removeUser();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">	</span><br></pre></td></tr></table></figure>

<p><strong>LoginInterceptor</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1.判断是否需要拦截（ThreadLocal中是否有用户）</span></span><br><span class="line">        <span class="keyword">if</span> (UserHolder.getUser() == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 没有，需要拦截，设置状态码</span></span><br><span class="line">            response.setStatus(<span class="number">401</span>);</span><br><span class="line">            <span class="comment">// 拦截</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 有用户，则放行</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="2、商户查询缓存"><a href="#2、商户查询缓存" class="headerlink" title="2、商户查询缓存"></a>2、商户查询缓存</h2><h3 id="2-1-什么是缓存"><a href="#2-1-什么是缓存" class="headerlink" title="2.1 什么是缓存?"></a>2.1 什么是缓存?</h3><p><strong>前言</strong>:<strong>什么是缓存?</strong></p>
<p>就像自行车,越野车的避震器<img src="/2022/09/24/redis%E5%AE%9E%E6%88%98%E7%AF%87/%E9%81%BF%E9%9C%87%E5%99%A8.gif"></p>
<p>举个例子:越野车,山地自行车,都拥有”避震器”,<strong>防止</strong>车体加速后因惯性,在酷似”U”字母的地形上飞跃,硬着陆导致的<strong>损害</strong>,像个弹簧一样;</p>
<p>同样,实际开发中,系统也需要”避震器”,防止过高的数据访问猛冲系统,导致其操作线程无法及时处理信息而瘫痪;</p>
<p>这在实际开发中对企业讲,对产品口碑,用户评价都是致命的;所以企业非常重视缓存技术;</p>
<p><strong>缓存(<strong>Cache),就是数据交换的</strong>缓冲区</strong>,俗称的缓存就是<strong>缓冲区内的数据</strong>,一般从数据库中获取,存储于本地代码(例如:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">例<span class="number">1</span>:Static <span class="keyword">final</span> ConcurrentHashMap&lt;K,V&gt; map = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;(); 本地用于高并发</span><br><span class="line"></span><br><span class="line">例<span class="number">2</span>:<span class="keyword">static</span> <span class="keyword">final</span> Cache&lt;K,V&gt; USER_CACHE = CacheBuilder.newBuilder().build(); 用于redis等缓存</span><br><span class="line"></span><br><span class="line">例<span class="number">3</span>:Static <span class="keyword">final</span> Map&lt;K,V&gt; map =  <span class="keyword">new</span> <span class="title class_">HashMap</span>(); 本地缓存</span><br></pre></td></tr></table></figure>

<p>由于其被<strong>Static</strong>修饰,所以随着类的加载而被加载到<strong>内存之中</strong>,作为本地缓存,由于其又被<strong>final</strong>修饰,所以其引用(例3:map)和对象(例3:new HashMap())之间的关系是固定的,不能改变,因此不用担心赋值(&#x3D;)导致缓存失效;</p>
<h4 id="2-1-1-为什么要使用缓存"><a href="#2-1-1-为什么要使用缓存" class="headerlink" title="2.1.1 为什么要使用缓存"></a>2.1.1 为什么要使用缓存</h4><p>一句话:因为<strong>速度快,好用</strong></p>
<p>缓存数据存储于代码中,而代码运行在内存中,内存的读写性能远高于磁盘,缓存可以大大降低<strong>用户访问并发量带来的</strong>服务器读写压力</p>
<p>实际开发过程中,企业的数据量,少则几十万,多则几千万,这么大数据量,如果没有缓存来作为”避震器”,系统是几乎撑不住的,所以企业会大量运用到缓存技术;</p>
<p>但是缓存也会增加代码复杂度和运营的成本:</p>
<p><img src="/2022/09/24/redis%E5%AE%9E%E6%88%98%E7%AF%87/image-20220523214414123.png"></p>
<h4 id="2-1-2-如何使用缓存"><a href="#2-1-2-如何使用缓存" class="headerlink" title="2.1.2 如何使用缓存"></a>2.1.2 如何使用缓存</h4><p>实际开发中,会构筑多级缓存来使系统运行速度进一步提升,例如:本地缓存与redis中的缓存并发使用</p>
<p><strong>浏览器缓存</strong>：主要是存在于浏览器端的缓存</p>
<p><strong>应用层缓存：</strong>可以分为tomcat本地缓存，比如之前提到的map，或者是使用redis作为缓存</p>
<p><strong>数据库缓存：</strong>在数据库中有一片空间是 buffer pool，增改查数据都会先加载到mysql的缓存中</p>
<p><strong>CPU缓存：</strong>当代计算机最大的问题是 cpu性能提升了，但内存读写速度没有跟上，所以为了适应当下的情况，增加了cpu的L1，L2，L3级的缓存</p>
<p><img src="/2022/09/24/redis%E5%AE%9E%E6%88%98%E7%AF%87/image-20220523212915666.png"></p>
<h3 id="2-2-添加商户缓存"><a href="#2-2-添加商户缓存" class="headerlink" title="2.2 添加商户缓存"></a>2.2 添加商户缓存</h3><p>在我们查询商户信息时，我们是直接操作从数据库中去进行查询的，大致逻辑是这样，直接查询数据库那肯定慢咯，所以我们需要增加缓存</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@GetMapping(&quot;/&#123;id&#125;&quot;)</span><br><span class="line">public Result queryShopById(@PathVariable(&quot;id&quot;) Long id) &#123;</span><br><span class="line">    //这里是直接查询数据库</span><br><span class="line">    return shopService.queryById(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-2-1-、缓存模型和思路"><a href="#2-2-1-、缓存模型和思路" class="headerlink" title="2.2.1 、缓存模型和思路"></a>2.2.1 、缓存模型和思路</h4><p>标准的操作方式就是查询数据库之前先查询缓存，如果缓存数据存在，则直接从缓存中返回，如果缓存数据不存在，再查询数据库，然后将数据存入redis。</p>
<p><img src="/2022/09/24/redis%E5%AE%9E%E6%88%98%E7%AF%87/1653322097736.png" alt="1653322097736"></p>
<h4 id="2-1-2、代码如下"><a href="#2-1-2、代码如下" class="headerlink" title="2.1.2、代码如下"></a>2.1.2、代码如下</h4><p>代码思路：如果缓存有，则直接返回，如果缓存不存在，则查询数据库，然后存入redis。</p>
<p><img src="/2022/09/24/redis%E5%AE%9E%E6%88%98%E7%AF%87/1653322190155.png" alt="1653322190155"></p>
<h3 id="2-3-缓存更新策略"><a href="#2-3-缓存更新策略" class="headerlink" title="2.3 缓存更新策略"></a>2.3 缓存更新策略</h3><p>缓存更新是redis为了节约内存而设计出来的一个东西，主要是因为内存数据宝贵，当我们向redis插入太多数据，此时就可能会导致缓存中的数据过多，所以redis会对部分数据进行更新，或者把他叫为淘汰更合适。</p>
<p><strong>内存淘汰：</strong>redis自动进行，当redis内存达到咱们设定的max-memery的时候，会自动触发淘汰机制，淘汰掉一些不重要的数据(可以自己设置策略方式)</p>
<p><strong>超时剔除：</strong>当我们给redis设置了过期时间ttl之后，redis会将超时的数据进行删除，方便咱们继续使用缓存</p>
<p><strong>主动更新：</strong>我们可以手动调用方法把缓存删掉，通常用于解决缓存和数据库不一致问题</p>
<p><img src="/2022/09/24/redis%E5%AE%9E%E6%88%98%E7%AF%87/1653322506393.png" alt="1653322506393"></p>
<h4 id="2-3-1-、数据库缓存不一致解决方案："><a href="#2-3-1-、数据库缓存不一致解决方案：" class="headerlink" title="2.3.1 、数据库缓存不一致解决方案："></a>2.3.1 、数据库缓存不一致解决方案：</h4><p>由于我们的<strong>缓存的数据源来自于数据库</strong>,而数据库的<strong>数据是会发生变化的</strong>,因此,如果当数据库中<strong>数据发生变化,而缓存却没有同步</strong>,此时就会有<strong>一致性问题存在</strong>,其后果是:</p>
<p>用户使用缓存中的过时数据,就会产生类似多线程数据安全问题,从而影响业务,产品口碑等;怎么解决呢？有如下几种方案</p>
<p>Cache Aside Pattern 人工编码方式：缓存调用者在更新完数据库后再去更新缓存，也称之为双写方案</p>
<p>Read&#x2F;Write Through Pattern : 由系统本身完成，数据库与缓存的问题交由系统本身去处理</p>
<p>Write Behind Caching Pattern ：调用者只操作缓存，其他线程去异步处理数据库，实现最终一致</p>
<p><img src="/2022/09/24/redis%E5%AE%9E%E6%88%98%E7%AF%87/1653322857620.png" alt="1653322857620"></p>
<h4 id="2-3-2-、数据库和缓存不一致采用什么方案"><a href="#2-3-2-、数据库和缓存不一致采用什么方案" class="headerlink" title="2.3.2 、数据库和缓存不一致采用什么方案"></a>2.3.2 、数据库和缓存不一致采用什么方案</h4><p>综合考虑使用方案一，但是方案一调用者如何处理呢？这里有几个问题</p>
<p>操作缓存和数据库时有三个问题需要考虑：</p>
<p>如果采用第一个方案，那么假设我们每次操作数据库后，都操作缓存，但是中间如果没有人查询，那么这个更新动作实际上只有最后一次生效，中间的更新动作意义并不大，我们可以把缓存删除，等待再次查询时，将缓存中的数据加载出来</p>
<ul>
<li><p>删除缓存还是更新缓存？</p>
<ul>
<li>更新缓存：每次更新数据库都更新缓存，无效写操作较多</li>
<li>删除缓存：更新数据库时让缓存失效，查询时再更新缓存</li>
</ul>
</li>
<li><p>如何保证缓存与数据库的操作的同时成功或失败？</p>
<ul>
<li>单体系统，将缓存与数据库操作放在一个事务</li>
<li>分布式系统，利用TCC等分布式事务方案</li>
</ul>
</li>
</ul>
<p>应该具体操作缓存还是操作数据库，我们应当是先操作数据库，再删除缓存，原因在于，如果你选择第一种方案，在两个线程并发来访问时，假设线程1先来，他先把缓存删了，此时线程2过来，他查询缓存数据并不存在，此时他写入缓存，当他写入缓存后，线程1再执行更新动作时，实际上写入的就是旧的数据，新的数据被旧数据覆盖了。</p>
<ul>
<li>先操作缓存还是先操作数据库？<ul>
<li>先删除缓存，再操作数据库</li>
<li>先操作数据库，再删除缓存</li>
</ul>
</li>
</ul>
<p><img src="/2022/09/24/redis%E5%AE%9E%E6%88%98%E7%AF%87/1653323595206.png" alt="1653323595206"></p>
<h3 id="2-4-实现商铺和缓存与数据库双写一致"><a href="#2-4-实现商铺和缓存与数据库双写一致" class="headerlink" title="2.4 实现商铺和缓存与数据库双写一致"></a>2.4 实现商铺和缓存与数据库双写一致</h3><p>核心思路如下：</p>
<p>修改ShopController中的业务逻辑，满足下面的需求：</p>
<p>根据id查询店铺时，如果缓存未命中，则查询数据库，将数据库结果写入缓存，并设置超时时间</p>
<p>根据id修改店铺时，先修改数据库，再删除缓存</p>
<p><strong>修改重点代码1</strong>：修改<strong>ShopServiceImpl</strong>的queryById方法</p>
<p><strong>设置redis缓存时添加过期时间</strong></p>
<p><img src="/2022/09/24/redis%E5%AE%9E%E6%88%98%E7%AF%87/1653325871232.png" alt="1653325871232"></p>
<p><strong>修改重点代码2</strong></p>
<p>代码分析：通过之前的淘汰，我们确定了采用删除策略，来解决双写问题，当我们修改了数据之后，然后把缓存中的数据进行删除，查询时发现缓存中没有数据，则会从mysql中加载最新的数据，从而避免数据库和缓存不一致的问题</p>
<p><img src="/2022/09/24/redis%E5%AE%9E%E6%88%98%E7%AF%87/1653325929549.png" alt="1653325929549"></p>
<h3 id="2-5-缓存穿透问题的解决思路"><a href="#2-5-缓存穿透问题的解决思路" class="headerlink" title="2.5 缓存穿透问题的解决思路"></a>2.5 缓存穿透问题的解决思路</h3><p>缓存穿透 ：缓存穿透是指客户端请求的数据在缓存中和数据库中都不存在，这样缓存永远不会生效，这些请求都会打到数据库。</p>
<p>常见的解决方案有两种：</p>
<ul>
<li>缓存空对象<ul>
<li>优点：实现简单，维护方便</li>
<li>缺点：<ul>
<li>额外的内存消耗</li>
<li>可能造成短期的不一致</li>
</ul>
</li>
</ul>
</li>
<li>布隆过滤<ul>
<li>优点：内存占用较少，没有多余key</li>
<li>缺点：<ul>
<li>实现复杂</li>
<li>存在误判可能</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>缓存空对象思路分析：</strong>当我们客户端访问不存在的数据时，先请求redis，但是此时redis中没有数据，此时会访问到数据库，但是数据库中也没有数据，这个数据穿透了缓存，直击数据库，我们都知道数据库能够承载的并发不如redis这么高，如果大量的请求同时过来访问这种不存在的数据，这些请求就都会访问到数据库，简单的解决方案就是哪怕这个数据在数据库中也不存在，我们也把这个数据存入到redis中去，这样，下次用户过来访问这个不存在的数据，那么在redis中也能找到这个数据就不会进入到缓存了</p>
<p><strong>布隆过滤：</strong>布隆过滤器其实采用的是哈希思想来解决这个问题，通过一个庞大的二进制数组，走哈希思想去判断当前这个要查询的这个数据是否存在，如果布隆过滤器判断存在，则放行，这个请求会去访问redis，哪怕此时redis中的数据过期了，但是数据库中一定存在这个数据，在数据库中查询出来这个数据后，再将其放入到redis中，</p>
<p>假设布隆过滤器判断这个数据不存在，则直接返回</p>
<p>这种方式优点在于节约内存空间，存在误判，误判原因在于：布隆过滤器走的是哈希思想，只要哈希思想，就可能存在哈希冲突</p>
<p><img src="/2022/09/24/redis%E5%AE%9E%E6%88%98%E7%AF%87/1653326156516.png" alt="1653326156516"></p>
<h3 id="2-6-编码解决商品查询的缓存穿透问题："><a href="#2-6-编码解决商品查询的缓存穿透问题：" class="headerlink" title="2.6 编码解决商品查询的缓存穿透问题："></a>2.6 编码解决商品查询的缓存穿透问题：</h3><p>核心思路如下：</p>
<p>在原来的逻辑中，我们如果发现这个数据在mysql中不存在，直接就返回404了，这样是会存在缓存穿透问题的</p>
<p>现在的逻辑中：如果这个数据不存在，我们不会返回404 ，还是会把这个数据写入到Redis中，并且将value设置为空，欧当再次发起查询时，我们如果发现命中之后，判断这个value是否是null，如果是null，则是之前写入的数据，证明是缓存穿透数据，如果不是，则直接返回数据。</p>
<p><img src="/2022/09/24/redis%E5%AE%9E%E6%88%98%E7%AF%87/1653327124561.png" alt="1653327124561"></p>
<p><strong>小总结：</strong></p>
<p>缓存穿透产生的原因是什么？</p>
<ul>
<li>用户请求的数据在缓存中和数据库中都不存在，不断发起这样的请求，给数据库带来巨大压力</li>
</ul>
<p>缓存穿透的解决方案有哪些？</p>
<ul>
<li>缓存null值</li>
<li>布隆过滤</li>
<li>增强id的复杂度，避免被猜测id规律</li>
<li>做好数据的基础格式校验</li>
<li>加强用户权限校验</li>
<li>做好热点参数的限流</li>
</ul>
<h3 id="2-7-缓存雪崩问题及解决思路"><a href="#2-7-缓存雪崩问题及解决思路" class="headerlink" title="2.7 缓存雪崩问题及解决思路"></a>2.7 缓存雪崩问题及解决思路</h3><p>缓存雪崩是指在同一时段大量的缓存key同时失效或者Redis服务宕机，导致大量请求到达数据库，带来巨大压力。</p>
<p>解决方案：</p>
<ul>
<li>给不同的Key的TTL添加随机值</li>
<li>利用Redis集群提高服务的可用性</li>
<li>给缓存业务添加降级限流策略</li>
<li>给业务添加多级缓存</li>
</ul>
<p><img src="/2022/09/24/redis%E5%AE%9E%E6%88%98%E7%AF%87/1653327884526.png" alt="1653327884526"></p>
<h3 id="2-8-缓存击穿问题及解决思路"><a href="#2-8-缓存击穿问题及解决思路" class="headerlink" title="2.8 缓存击穿问题及解决思路"></a>2.8 缓存击穿问题及解决思路</h3><p>缓存击穿问题也叫热点Key问题，就是一个被高并发访问并且缓存重建业务较复杂的key突然失效了，无数的请求访问会在瞬间给数据库带来巨大的冲击。</p>
<p>常见的解决方案有两种：</p>
<ul>
<li>互斥锁</li>
<li>逻辑过期</li>
</ul>
<p>逻辑分析：假设线程1在查询缓存之后，本来应该去查询数据库，然后把这个数据重新加载到缓存的，此时只要线程1走完这个逻辑，其他线程就都能从缓存中加载这些数据了，但是假设在线程1没有走完的时候，后续的线程2，线程3，线程4同时过来访问当前这个方法， 那么这些线程都不能从缓存中查询到数据，那么他们就会同一时刻来访问查询缓存，都没查到，接着同一时间去访问数据库，同时的去执行数据库代码，对数据库访问压力过大</p>
<p><img src="/2022/09/24/redis%E5%AE%9E%E6%88%98%E7%AF%87/1653328022622.png" alt="1653328022622"></p>
<p>解决方案一、使用锁来解决：</p>
<p>因为锁能实现互斥性。假设线程过来，只能一个人一个人的来访问数据库，从而避免对于数据库访问压力过大，但这也会影响查询的性能，因为此时会让查询的性能从并行变成了串行，我们可以采用tryLock方法 + double check来解决这样的问题。</p>
<p>假设现在线程1过来访问，他查询缓存没有命中，但是此时他获得到了锁的资源，那么线程1就会一个人去执行逻辑，假设现在线程2过来，线程2在执行过程中，并没有获得到锁，那么线程2就可以进行到休眠，直到线程1把锁释放后，线程2获得到锁，然后再来执行逻辑，此时就能够从缓存中拿到数据了。</p>
<p><img src="/2022/09/24/redis%E5%AE%9E%E6%88%98%E7%AF%87/1653328288627.png" alt="1653328288627"></p>
<p>解决方案二、逻辑过期方案</p>
<p>方案分析：我们之所以会出现这个缓存击穿问题，主要原因是在于我们对key设置了过期时间，假设我们不设置过期时间，其实就不会有缓存击穿的问题，但是不设置过期时间，这样数据不就一直占用我们内存了吗，我们可以采用逻辑过期方案。</p>
<p>我们把过期时间设置在 redis的value中，注意：这个过期时间并不会直接作用于redis，而是我们后续通过逻辑去处理。假设线程1去查询缓存，然后从value中判断出来当前的数据已经过期了，此时线程1去获得互斥锁，那么其他线程会进行阻塞，获得了锁的线程他会开启一个 线程去进行 以前的重构数据的逻辑，直到新开的线程完成这个逻辑后，才释放锁， 而线程1直接进行返回，假设现在线程3过来访问，由于线程线程2持有着锁，所以线程3无法获得锁，线程3也直接返回数据，只有等到新开的线程2把重建数据构建完后，其他线程才能走返回正确的数据。</p>
<p>这种方案巧妙在于，异步的构建缓存，缺点在于在构建完缓存之前，返回的都是脏数据。</p>
<p><img src="/2022/09/24/redis%E5%AE%9E%E6%88%98%E7%AF%87/1653328663897.png" alt="1653328663897"></p>
<p>进行对比</p>
<p><strong>互斥锁方案：</strong>由于保证了互斥性，所以数据一致，且实现简单，因为仅仅只需要加一把锁而已，也没其他的事情需要操心，所以没有额外的内存消耗，缺点在于有锁就有死锁问题的发生，且只能串行执行性能肯定受到影响</p>
<p><strong>逻辑过期方案：</strong> 线程读取过程中不需要等待，性能好，有一个额外的线程持有锁去进行重构数据，但是在重构数据完成前，其他的线程只能返回之前的数据，且实现起来麻烦</p>
<p><img src="/2022/09/24/redis%E5%AE%9E%E6%88%98%E7%AF%87/1653357522914.png" alt="1653357522914"></p>
<h3 id="2-9-利用互斥锁解决缓存击穿问题"><a href="#2-9-利用互斥锁解决缓存击穿问题" class="headerlink" title="2.9 利用互斥锁解决缓存击穿问题"></a>2.9 利用互斥锁解决缓存击穿问题</h3><p>核心思路：相较于原来从缓存中查询不到数据后直接查询数据库而言，现在的方案是 进行查询之后，如果从缓存没有查询到数据，则进行互斥锁的获取，获取互斥锁后，判断是否获得到了锁，如果没有获得到，则休眠，过一会再进行尝试，直到获取到锁为止，才能进行查询</p>
<p>如果获取到了锁的线程，再去进行查询，查询后将数据写入redis，再释放锁，返回数据，利用互斥锁就能保证只有一个线程去执行操作数据库的逻辑，防止缓存击穿</p>
<p><img src="/2022/09/24/redis%E5%AE%9E%E6%88%98%E7%AF%87/1653357860001.png" alt="1653357860001"></p>
<p><strong>操作锁的代码：</strong></p>
<p>核心思路就是利用redis的setnx方法来表示获取锁，该方法含义是redis中如果没有这个key，则插入成功，返回1，在stringRedisTemplate中返回true，  如果有这个key则插入失败，则返回0，在stringRedisTemplate返回false，我们可以通过true，或者是false，来表示是否有线程成功插入key，成功插入的key的线程我们认为他就是获得到锁的线程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(String key)</span> &#123;</span><br><span class="line">    <span class="type">Boolean</span> <span class="variable">flag</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().setIfAbsent(key, <span class="string">&quot;1&quot;</span>, <span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">    <span class="keyword">return</span> BooleanUtil.isTrue(flag);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">(String key)</span> &#123;</span><br><span class="line">    stringRedisTemplate.delete(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>操作代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Shop <span class="title function_">queryWithMutex</span><span class="params">(Long id)</span>  &#123;</span><br><span class="line">       <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> CACHE_SHOP_KEY + id;</span><br><span class="line">       <span class="comment">// 1、从redis中查询商铺缓存</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">shopJson</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(<span class="string">&quot;key&quot;</span>);</span><br><span class="line">       <span class="comment">// 2、判断是否存在</span></span><br><span class="line">       <span class="keyword">if</span> (StrUtil.isNotBlank(shopJson)) &#123;</span><br><span class="line">           <span class="comment">// 存在,直接返回</span></span><br><span class="line">           <span class="keyword">return</span> JSONUtil.toBean(shopJson, Shop.class);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//判断命中的值是否是空值</span></span><br><span class="line">       <span class="keyword">if</span> (shopJson != <span class="literal">null</span>) &#123;</span><br><span class="line">           <span class="comment">//返回一个错误信息</span></span><br><span class="line">           <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 4.实现缓存重构</span></span><br><span class="line">       <span class="comment">//4.1 获取互斥锁</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">lockKey</span> <span class="operator">=</span> <span class="string">&quot;lock:shop:&quot;</span> + id;</span><br><span class="line">       <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> tryLock(lockKey);</span><br><span class="line">           <span class="comment">// 4.2 判断否获取成功</span></span><br><span class="line">           <span class="keyword">if</span>(!isLock)&#123;</span><br><span class="line">               <span class="comment">//4.3 失败，则休眠重试</span></span><br><span class="line">               Thread.sleep(<span class="number">50</span>);</span><br><span class="line">               <span class="keyword">return</span> queryWithMutex(id);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//4.4 成功，根据id查询数据库</span></span><br><span class="line">            shop = getById(id);</span><br><span class="line">           <span class="comment">// 5.不存在，返回错误</span></span><br><span class="line">           <span class="keyword">if</span>(shop == <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="comment">//将空值写入redis</span></span><br><span class="line">               stringRedisTemplate.opsForValue().set(key,<span class="string">&quot;&quot;</span>,CACHE_NULL_TTL,TimeUnit.MINUTES);</span><br><span class="line">               <span class="comment">//返回错误信息</span></span><br><span class="line">               <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//6.写入redis</span></span><br><span class="line">           stringRedisTemplate.opsForValue().set(key,JSONUtil.toJsonStr(shop),CACHE_NULL_TTL,TimeUnit.MINUTES);</span><br><span class="line"></span><br><span class="line">       &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">finally</span> &#123;</span><br><span class="line">           <span class="comment">//7.释放互斥锁</span></span><br><span class="line">           unlock(lockKey);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> shop;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-0-、利用逻辑过期解决缓存击穿问题"><a href="#3-0-、利用逻辑过期解决缓存击穿问题" class="headerlink" title="3.0 、利用逻辑过期解决缓存击穿问题"></a>3.0 、利用逻辑过期解决缓存击穿问题</h3><p><strong>需求：修改根据id查询商铺的业务，基于逻辑过期方式来解决缓存击穿问题</strong></p>
<p>思路分析：当用户开始查询redis时，判断是否命中，如果没有命中则直接返回空数据，不查询数据库，而一旦命中后，将value取出，判断value中的过期时间是否满足，如果没有过期，则直接返回redis中的数据，如果过期，则在开启独立线程后直接返回之前的数据，独立线程去重构数据，重构完成后释放互斥锁。</p>
<p><img src="/2022/09/24/redis%E5%AE%9E%E6%88%98%E7%AF%87/1653360308731.png" alt="1653360308731"></p>
<p>如果封装数据：因为现在redis中存储的数据的value需要带上过期时间，此时要么你去修改原来的实体类，要么你</p>
<p><strong>步骤一、</strong></p>
<p>新建一个实体类，我们采用第二个方案，这个方案，对原来代码没有侵入性。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Data</span><br><span class="line">public class RedisData &#123;</span><br><span class="line">    private LocalDateTime expireTime;</span><br><span class="line">    private Object data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>步骤二、</strong></p>
<p>在<strong>ShopServiceImpl</strong> 新增此方法，利用单元测试进行缓存预热</p>
<p><img src="/2022/09/24/redis%E5%AE%9E%E6%88%98%E7%AF%87/1653360807133.png" alt="1653360807133"></p>
<p><strong>在测试类中</strong></p>
<p><img src="/2022/09/24/redis%E5%AE%9E%E6%88%98%E7%AF%87/1653360864839.png" alt="1653360864839"></p>
<p>步骤三：正式代码</p>
<p><strong>ShopServiceImpl</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ExecutorService</span> <span class="variable">CACHE_REBUILD_EXECUTOR</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">public</span> Shop <span class="title function_">queryWithLogicalExpire</span><span class="params">( Long id )</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> CACHE_SHOP_KEY + id;</span><br><span class="line">    <span class="comment">// 1.从redis查询商铺缓存</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">    <span class="comment">// 2.判断是否存在</span></span><br><span class="line">    <span class="keyword">if</span> (StrUtil.isBlank(json)) &#123;</span><br><span class="line">        <span class="comment">// 3.存在，直接返回</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4.命中，需要先把json反序列化为对象</span></span><br><span class="line">    <span class="type">RedisData</span> <span class="variable">redisData</span> <span class="operator">=</span> JSONUtil.toBean(json, RedisData.class);</span><br><span class="line">    <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> JSONUtil.toBean((JSONObject) redisData.getData(), Shop.class);</span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">expireTime</span> <span class="operator">=</span> redisData.getExpireTime();</span><br><span class="line">    <span class="comment">// 5.判断是否过期</span></span><br><span class="line">    <span class="keyword">if</span>(expireTime.isAfter(LocalDateTime.now())) &#123;</span><br><span class="line">        <span class="comment">// 5.1.未过期，直接返回店铺信息</span></span><br><span class="line">        <span class="keyword">return</span> shop;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 5.2.已过期，需要缓存重建</span></span><br><span class="line">    <span class="comment">// 6.缓存重建</span></span><br><span class="line">    <span class="comment">// 6.1.获取互斥锁</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">lockKey</span> <span class="operator">=</span> LOCK_SHOP_KEY + id;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> tryLock(lockKey);</span><br><span class="line">    <span class="comment">// 6.2.判断是否获取锁成功</span></span><br><span class="line">    <span class="keyword">if</span> (isLock)&#123;</span><br><span class="line">        CACHE_REBUILD_EXECUTOR.submit( ()-&gt;&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="comment">//重建缓存</span></span><br><span class="line">                <span class="built_in">this</span>.saveShop2Redis(id,<span class="number">20L</span>);</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                unlock(lockKey);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 6.4.返回过期的商铺信息</span></span><br><span class="line">    <span class="keyword">return</span> shop;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-1、封装Redis工具类"><a href="#3-1、封装Redis工具类" class="headerlink" title="3.1、封装Redis工具类"></a>3.1、封装Redis工具类</h3><p>基于StringRedisTemplate封装一个缓存工具类，满足下列需求：</p>
<ul>
<li>方法1：将任意Java对象序列化为json并存储在string类型的key中，并且可以设置TTL过期时间</li>
<li>方法2：将任意Java对象序列化为json并存储在string类型的key中，并且可以设置逻辑过期时间，用于处理缓</li>
</ul>
<p>存击穿问题</p>
<ul>
<li>方法3：根据指定的key查询缓存，并反序列化为指定类型，利用缓存空值的方式解决缓存穿透问题</li>
<li>方法4：根据指定的key查询缓存，并反序列化为指定类型，需要利用逻辑过期解决缓存击穿问题</li>
</ul>
<p>将逻辑进行封装</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CacheClient</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ExecutorService</span> <span class="variable">CACHE_REBUILD_EXECUTOR</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CacheClient</span><span class="params">(StringRedisTemplate stringRedisTemplate)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.stringRedisTemplate = stringRedisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(String key, Object value, Long time, TimeUnit unit)</span> &#123;</span><br><span class="line">        stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(value), time, unit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setWithLogicalExpire</span><span class="params">(String key, Object value, Long time, TimeUnit unit)</span> &#123;</span><br><span class="line">        <span class="comment">// 设置逻辑过期</span></span><br><span class="line">        <span class="type">RedisData</span> <span class="variable">redisData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RedisData</span>();</span><br><span class="line">        redisData.setData(value);</span><br><span class="line">        redisData.setExpireTime(LocalDateTime.now().plusSeconds(unit.toSeconds(time)));</span><br><span class="line">        <span class="comment">// 写入Redis</span></span><br><span class="line">        stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(redisData));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;R,ID&gt; R <span class="title function_">queryWithPassThrough</span><span class="params">(</span></span><br><span class="line"><span class="params">            String keyPrefix, ID id, Class&lt;R&gt; type, Function&lt;ID, R&gt; dbFallback, Long time, TimeUnit unit)</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> keyPrefix + id;</span><br><span class="line">        <span class="comment">// 1.从redis查询商铺缓存</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">        <span class="comment">// 2.判断是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (StrUtil.isNotBlank(json)) &#123;</span><br><span class="line">            <span class="comment">// 3.存在，直接返回</span></span><br><span class="line">            <span class="keyword">return</span> JSONUtil.toBean(json, type);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断命中的是否是空值</span></span><br><span class="line">        <span class="keyword">if</span> (json != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 返回一个错误信息</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.不存在，根据id查询数据库</span></span><br><span class="line">        <span class="type">R</span> <span class="variable">r</span> <span class="operator">=</span> dbFallback.apply(id);</span><br><span class="line">        <span class="comment">// 5.不存在，返回错误</span></span><br><span class="line">        <span class="keyword">if</span> (r == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 将空值写入redis</span></span><br><span class="line">            stringRedisTemplate.opsForValue().set(key, <span class="string">&quot;&quot;</span>, CACHE_NULL_TTL, TimeUnit.MINUTES);</span><br><span class="line">            <span class="comment">// 返回错误信息</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 6.存在，写入redis</span></span><br><span class="line">        <span class="built_in">this</span>.set(key, r, time, unit);</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;R, ID&gt; R <span class="title function_">queryWithLogicalExpire</span><span class="params">(</span></span><br><span class="line"><span class="params">            String keyPrefix, ID id, Class&lt;R&gt; type, Function&lt;ID, R&gt; dbFallback, Long time, TimeUnit unit)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> keyPrefix + id;</span><br><span class="line">        <span class="comment">// 1.从redis查询商铺缓存</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">        <span class="comment">// 2.判断是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (StrUtil.isBlank(json)) &#123;</span><br><span class="line">            <span class="comment">// 3.存在，直接返回</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 4.命中，需要先把json反序列化为对象</span></span><br><span class="line">        <span class="type">RedisData</span> <span class="variable">redisData</span> <span class="operator">=</span> JSONUtil.toBean(json, RedisData.class);</span><br><span class="line">        <span class="type">R</span> <span class="variable">r</span> <span class="operator">=</span> JSONUtil.toBean((JSONObject) redisData.getData(), type);</span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">expireTime</span> <span class="operator">=</span> redisData.getExpireTime();</span><br><span class="line">        <span class="comment">// 5.判断是否过期</span></span><br><span class="line">        <span class="keyword">if</span>(expireTime.isAfter(LocalDateTime.now())) &#123;</span><br><span class="line">            <span class="comment">// 5.1.未过期，直接返回店铺信息</span></span><br><span class="line">            <span class="keyword">return</span> r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 5.2.已过期，需要缓存重建</span></span><br><span class="line">        <span class="comment">// 6.缓存重建</span></span><br><span class="line">        <span class="comment">// 6.1.获取互斥锁</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">lockKey</span> <span class="operator">=</span> LOCK_SHOP_KEY + id;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> tryLock(lockKey);</span><br><span class="line">        <span class="comment">// 6.2.判断是否获取锁成功</span></span><br><span class="line">        <span class="keyword">if</span> (isLock)&#123;</span><br><span class="line">            <span class="comment">// 6.3.成功，开启独立线程，实现缓存重建</span></span><br><span class="line">            CACHE_REBUILD_EXECUTOR.submit(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 查询数据库</span></span><br><span class="line">                    <span class="type">R</span> <span class="variable">newR</span> <span class="operator">=</span> dbFallback.apply(id);</span><br><span class="line">                    <span class="comment">// 重建缓存</span></span><br><span class="line">                    <span class="built_in">this</span>.setWithLogicalExpire(key, newR, time, unit);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">// 释放锁</span></span><br><span class="line">                    unlock(lockKey);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 6.4.返回过期的商铺信息</span></span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;R, ID&gt; R <span class="title function_">queryWithMutex</span><span class="params">(</span></span><br><span class="line"><span class="params">            String keyPrefix, ID id, Class&lt;R&gt; type, Function&lt;ID, R&gt; dbFallback, Long time, TimeUnit unit)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> keyPrefix + id;</span><br><span class="line">        <span class="comment">// 1.从redis查询商铺缓存</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">shopJson</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">        <span class="comment">// 2.判断是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (StrUtil.isNotBlank(shopJson)) &#123;</span><br><span class="line">            <span class="comment">// 3.存在，直接返回</span></span><br><span class="line">            <span class="keyword">return</span> JSONUtil.toBean(shopJson, type);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断命中的是否是空值</span></span><br><span class="line">        <span class="keyword">if</span> (shopJson != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 返回一个错误信息</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.实现缓存重建</span></span><br><span class="line">        <span class="comment">// 4.1.获取互斥锁</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">lockKey</span> <span class="operator">=</span> LOCK_SHOP_KEY + id;</span><br><span class="line">        <span class="type">R</span> <span class="variable">r</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> tryLock(lockKey);</span><br><span class="line">            <span class="comment">// 4.2.判断是否获取成功</span></span><br><span class="line">            <span class="keyword">if</span> (!isLock) &#123;</span><br><span class="line">                <span class="comment">// 4.3.获取锁失败，休眠并重试</span></span><br><span class="line">                Thread.sleep(<span class="number">50</span>);</span><br><span class="line">                <span class="keyword">return</span> queryWithMutex(keyPrefix, id, type, dbFallback, time, unit);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 4.4.获取锁成功，根据id查询数据库</span></span><br><span class="line">            r = dbFallback.apply(id);</span><br><span class="line">            <span class="comment">// 5.不存在，返回错误</span></span><br><span class="line">            <span class="keyword">if</span> (r == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 将空值写入redis</span></span><br><span class="line">                stringRedisTemplate.opsForValue().set(key, <span class="string">&quot;&quot;</span>, CACHE_NULL_TTL, TimeUnit.MINUTES);</span><br><span class="line">                <span class="comment">// 返回错误信息</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 6.存在，写入redis</span></span><br><span class="line">            <span class="built_in">this</span>.set(key, r, time, unit);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 7.释放锁</span></span><br><span class="line">            unlock(lockKey);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 8.返回</span></span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="type">Boolean</span> <span class="variable">flag</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().setIfAbsent(key, <span class="string">&quot;1&quot;</span>, <span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">        <span class="keyword">return</span> BooleanUtil.isTrue(flag);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        stringRedisTemplate.delete(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在ShopServiceImpl 中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> CacheClient cacheClient;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">queryById</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">        <span class="comment">// 解决缓存穿透</span></span><br><span class="line">        <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> cacheClient</span><br><span class="line">                .queryWithPassThrough(CACHE_SHOP_KEY, id, Shop.class, <span class="built_in">this</span>::getById, CACHE_SHOP_TTL, TimeUnit.MINUTES);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 互斥锁解决缓存击穿</span></span><br><span class="line">        <span class="comment">// Shop shop = cacheClient</span></span><br><span class="line">        <span class="comment">//         .queryWithMutex(CACHE_SHOP_KEY, id, Shop.class, this::getById, CACHE_SHOP_TTL, TimeUnit.MINUTES);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 逻辑过期解决缓存击穿</span></span><br><span class="line">        <span class="comment">// Shop shop = cacheClient</span></span><br><span class="line">        <span class="comment">//         .queryWithLogicalExpire(CACHE_SHOP_KEY, id, Shop.class, this::getById, 20L, TimeUnit.SECONDS);</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (shop == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;店铺不存在！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 7.返回</span></span><br><span class="line">        <span class="keyword">return</span> Result.ok(shop);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="3、优惠卷秒杀"><a href="#3、优惠卷秒杀" class="headerlink" title="3、优惠卷秒杀"></a>3、优惠卷秒杀</h2><h3 id="3-1-全局唯一ID"><a href="#3-1-全局唯一ID" class="headerlink" title="3.1 -全局唯一ID"></a>3.1 -全局唯一ID</h3><p>每个店铺都可以发布优惠券：</p>
<p><img src="/2022/09/24/redis%E5%AE%9E%E6%88%98%E7%AF%87/1653362612286.png" alt="1653362612286"></p>
<p>当用户抢购时，就会生成订单并保存到tb_voucher_order这张表中，而订单表如果使用数据库自增ID就存在一些问题：</p>
<ul>
<li>id的规律性太明显</li>
<li>受单表数据量的限制</li>
</ul>
<p>场景分析：如果我们的id具有太明显的规则，用户或者说商业对手很容易猜测出来我们的一些敏感信息，比如商城在一天时间内，卖出了多少单，这明显不合适。</p>
<p>场景分析二：随着我们商城规模越来越大，mysql的单表的容量不宜超过500W，数据量过大之后，我们要进行拆库拆表，但拆分表了之后，他们从逻辑上讲他们是同一张表，所以他们的id是不能一样的， 于是乎我们需要保证id的唯一性。</p>
<p><strong>全局ID生成器</strong>，是一种在分布式系统下用来生成全局唯一ID的工具，一般要满足下列特性：</p>
<p><img src="/2022/09/24/redis%E5%AE%9E%E6%88%98%E7%AF%87/1653363100502.png" alt="1653363100502"></p>
<p>为了增加ID的安全性，我们可以不直接使用Redis自增的数值，而是拼接一些其它信息：</p>
<p><img src="/2022/09/24/redis%E5%AE%9E%E6%88%98%E7%AF%87/1653363172079.png" alt="1653363172079">ID的组成部分：符号位：1bit，永远为0</p>
<p>时间戳：31bit，以秒为单位，可以使用69年</p>
<p>序列号：32bit，秒内的计数器，支持每秒产生2^32个不同ID</p>
<h3 id="3-2-Redis实现全局唯一Id"><a href="#3-2-Redis实现全局唯一Id" class="headerlink" title="3.2 -Redis实现全局唯一Id"></a>3.2 -Redis实现全局唯一Id</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisIdWorker</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 开始时间戳</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">BEGIN_TIMESTAMP</span> <span class="operator">=</span> <span class="number">1640995200L</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 序列号的位数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">COUNT_BITS</span> <span class="operator">=</span> <span class="number">32</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RedisIdWorker</span><span class="params">(StringRedisTemplate stringRedisTemplate)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.stringRedisTemplate = stringRedisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">nextId</span><span class="params">(String keyPrefix)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.生成时间戳</span></span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">        <span class="type">long</span> <span class="variable">nowSecond</span> <span class="operator">=</span> now.toEpochSecond(ZoneOffset.UTC);</span><br><span class="line">        <span class="type">long</span> <span class="variable">timestamp</span> <span class="operator">=</span> nowSecond - BEGIN_TIMESTAMP;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.生成序列号</span></span><br><span class="line">        <span class="comment">// 2.1.获取当前日期，精确到天</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">date</span> <span class="operator">=</span> now.format(DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy:MM:dd&quot;</span>));</span><br><span class="line">        <span class="comment">// 2.2.自增长</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().increment(<span class="string">&quot;icr:&quot;</span> + keyPrefix + <span class="string">&quot;:&quot;</span> + date);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.拼接并返回</span></span><br><span class="line">        <span class="keyword">return</span> timestamp &lt;&lt; COUNT_BITS | count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试类</p>
<p>知识小贴士：关于countdownlatch</p>
<p>countdownlatch名为信号枪：主要的作用是同步协调在多线程的等待于唤醒问题</p>
<p>我们如果没有CountDownLatch ，那么由于程序是异步的，当异步程序没有执行完时，主线程就已经执行完了，然后我们期望的是分线程全部走完之后，主线程再走，所以我们此时需要使用到CountDownLatch</p>
<p>CountDownLatch 中有两个最重要的方法</p>
<p>1、countDown</p>
<p>2、await</p>
<p>await 方法 是阻塞方法，我们担心分线程没有执行完时，main线程就先执行，所以使用await可以让main线程阻塞，那么什么时候main线程不再阻塞呢？当CountDownLatch  内部维护的 变量变为0时，就不再阻塞，直接放行，那么什么时候CountDownLatch   维护的变量变为0 呢，我们只需要调用一次countDown ，内部变量就减少1，我们让分线程和变量绑定， 执行完一个分线程就减少一个变量，当分线程全部走完，CountDownLatch 维护的变量就是0，此时await就不再阻塞，统计出来的时间也就是所有分线程执行完后的时间。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testIdWorker</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">CountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">300</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">id</span> <span class="operator">=</span> redisIdWorker.nextId(<span class="string">&quot;order&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;id = &quot;</span> + id);</span><br><span class="line">        &#125;</span><br><span class="line">        latch.countDown();</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">long</span> <span class="variable">begin</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">300</span>; i++) &#123;</span><br><span class="line">        es.submit(task);</span><br><span class="line">    &#125;</span><br><span class="line">    latch.await();</span><br><span class="line">    <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">&quot;time = &quot;</span> + (end - begin));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-3-添加优惠卷"><a href="#3-3-添加优惠卷" class="headerlink" title="3.3 添加优惠卷"></a>3.3 添加优惠卷</h3><p>每个店铺都可以发布优惠券，分为平价券和特价券。平价券可以任意购买，而特价券需要秒杀抢购：</p>
<p><img src="/2022/09/24/redis%E5%AE%9E%E6%88%98%E7%AF%87/1653365145124.png" alt="1653365145124"></p>
<p>tb_voucher：优惠券的基本信息，优惠金额、使用规则等<br>tb_seckill_voucher：优惠券的库存、开始抢购时间，结束抢购时间。特价优惠券才需要填写这些信息</p>
<p>平价卷由于优惠力度并不是很大，所以是可以任意领取</p>
<p>而代金券由于优惠力度大，所以像第二种卷，就得限制数量，从表结构上也能看出，特价卷除了具有优惠卷的基本信息以外，还具有库存，抢购时间，结束时间等等字段</p>
<p>**新增普通卷代码：  **VoucherController</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">addVoucher</span><span class="params">(<span class="meta">@RequestBody</span> Voucher voucher)</span> &#123;</span><br><span class="line">    voucherService.save(voucher);</span><br><span class="line">    <span class="keyword">return</span> Result.ok(voucher.getId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>新增秒杀卷代码：</strong></p>
<p><strong>VoucherController</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;seckill&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">addSeckillVoucher</span><span class="params">(<span class="meta">@RequestBody</span> Voucher voucher)</span> &#123;</span><br><span class="line">    voucherService.addSeckillVoucher(voucher);</span><br><span class="line">    <span class="keyword">return</span> Result.ok(voucher.getId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>VoucherServiceImpl</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addSeckillVoucher</span><span class="params">(Voucher voucher)</span> &#123;</span><br><span class="line">    <span class="comment">// 保存优惠券</span></span><br><span class="line">    save(voucher);</span><br><span class="line">    <span class="comment">// 保存秒杀信息</span></span><br><span class="line">    <span class="type">SeckillVoucher</span> <span class="variable">seckillVoucher</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SeckillVoucher</span>();</span><br><span class="line">    seckillVoucher.setVoucherId(voucher.getId());</span><br><span class="line">    seckillVoucher.setStock(voucher.getStock());</span><br><span class="line">    seckillVoucher.setBeginTime(voucher.getBeginTime());</span><br><span class="line">    seckillVoucher.setEndTime(voucher.getEndTime());</span><br><span class="line">    seckillVoucherService.save(seckillVoucher);</span><br><span class="line">    <span class="comment">// 保存秒杀库存到Redis中</span></span><br><span class="line">    stringRedisTemplate.opsForValue().set(SECKILL_STOCK_KEY + voucher.getId(), voucher.getStock().toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-4-实现秒杀下单"><a href="#3-4-实现秒杀下单" class="headerlink" title="3.4 实现秒杀下单"></a>3.4 实现秒杀下单</h3><p>下单核心思路：当我们点击抢购时，会触发右侧的请求，我们只需要编写对应的controller即可</p>
<p><img src="/2022/09/24/redis%E5%AE%9E%E6%88%98%E7%AF%87/1653365839526.png" alt="1653365839526"></p>
<p>秒杀下单应该思考的内容：</p>
<p>下单时需要判断两点：</p>
<ul>
<li>秒杀是否开始或结束，如果尚未开始或已经结束则无法下单</li>
<li>库存是否充足，不足则无法下单</li>
</ul>
<p>下单核心逻辑分析：</p>
<p>当用户开始进行下单，我们应当去查询优惠卷信息，查询到优惠卷信息，判断是否满足秒杀条件</p>
<p>比如时间是否充足，如果时间充足，则进一步判断库存是否足够，如果两者都满足，则扣减库存，创建订单，然后返回订单id，如果有一个条件不满足则直接结束。</p>
<p><img src="/2022/09/24/redis%E5%AE%9E%E6%88%98%E7%AF%87/1653366238564.png" alt="1653366238564"></p>
<p>VoucherOrderServiceImpl</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">seckillVoucher</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.查询优惠券</span></span><br><span class="line">    <span class="type">SeckillVoucher</span> <span class="variable">voucher</span> <span class="operator">=</span> seckillVoucherService.getById(voucherId);</span><br><span class="line">    <span class="comment">// 2.判断秒杀是否开始</span></span><br><span class="line">    <span class="keyword">if</span> (voucher.getBeginTime().isAfter(LocalDateTime.now())) &#123;</span><br><span class="line">        <span class="comment">// 尚未开始</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;秒杀尚未开始！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3.判断秒杀是否已经结束</span></span><br><span class="line">    <span class="keyword">if</span> (voucher.getEndTime().isBefore(LocalDateTime.now())) &#123;</span><br><span class="line">        <span class="comment">// 尚未开始</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;秒杀已经结束！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4.判断库存是否充足</span></span><br><span class="line">    <span class="keyword">if</span> (voucher.getStock() &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 库存不足</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;库存不足！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//5，扣减库存</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> seckillVoucherService.update()</span><br><span class="line">            .setSql(<span class="string">&quot;stock= stock -1&quot;</span>)</span><br><span class="line">            .eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId).update();</span><br><span class="line">    <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">        <span class="comment">//扣减库存</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;库存不足！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//6.创建订单</span></span><br><span class="line">    <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>();</span><br><span class="line">    <span class="comment">// 6.1.订单id</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">orderId</span> <span class="operator">=</span> redisIdWorker.nextId(<span class="string">&quot;order&quot;</span>);</span><br><span class="line">    voucherOrder.setId(orderId);</span><br><span class="line">    <span class="comment">// 6.2.用户id</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">    voucherOrder.setUserId(userId);</span><br><span class="line">    <span class="comment">// 6.3.代金券id</span></span><br><span class="line">    voucherOrder.setVoucherId(voucherId);</span><br><span class="line">    save(voucherOrder);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Result.ok(orderId);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-5-库存超卖问题分析"><a href="#3-5-库存超卖问题分析" class="headerlink" title="3.5 库存超卖问题分析"></a>3.5 库存超卖问题分析</h3><p>有关超卖问题分析：在我们原有代码中是这么写的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (voucher.getStock() &lt; <span class="number">1</span>) &#123;</span><br><span class="line">       <span class="comment">// 库存不足</span></span><br><span class="line">       <span class="keyword">return</span> Result.fail(<span class="string">&quot;库存不足！&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//5，扣减库存</span></span><br><span class="line">   <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> seckillVoucherService.update()</span><br><span class="line">           .setSql(<span class="string">&quot;stock= stock -1&quot;</span>)</span><br><span class="line">           .eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId).update();</span><br><span class="line">   <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">       <span class="comment">//扣减库存</span></span><br><span class="line">       <span class="keyword">return</span> Result.fail(<span class="string">&quot;库存不足！&quot;</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>假设线程1过来查询库存，判断出来库存大于1，正准备去扣减库存，但是还没有来得及去扣减，此时线程2过来，线程2也去查询库存，发现这个数量一定也大于1，那么这两个线程都会去扣减库存，最终多个线程相当于一起去扣减库存，此时就会出现库存的超卖问题。</p>
<p><img src="/2022/09/24/redis%E5%AE%9E%E6%88%98%E7%AF%87/1653368335155.png" alt="1653368335155"></p>
<p>超卖问题是典型的多线程安全问题，针对这一问题的常见解决方案就是加锁：而对于加锁，我们通常有两种解决方案：见下图：</p>
<p><img src="/2022/09/24/redis%E5%AE%9E%E6%88%98%E7%AF%87/1653368562591.png" alt="1653368562591"></p>
<p><strong>悲观锁：</strong></p>
<p> 悲观锁可以实现对于数据的串行化执行，比如syn，和lock都是悲观锁的代表，同时，悲观锁中又可以再细分为公平锁，非公平锁，可重入锁，等等</p>
<p><strong>乐观锁：</strong></p>
<p>  乐观锁：会有一个版本号，每次操作数据会对版本号+1，再提交回数据时，会去校验是否比之前的版本大1 ，如果大1 ，则进行操作成功，这套机制的核心逻辑在于，如果在操作过程中，版本号只比原来大1 ，那么就意味着操作过程中没有人对他进行过修改，他的操作就是安全的，如果不大1，则数据被修改过，当然乐观锁还有一些变种的处理方式比如cas</p>
<p>  乐观锁的典型代表：就是cas，利用cas进行无锁化机制加锁，var5 是操作前读取的内存值，while中的var1+var2 是预估值，如果预估值 &#x3D;&#x3D; 内存值，则代表中间没有被人修改过，此时就将新值去替换 内存值</p>
<p>  其中do while 是为了在操作失败时，再次进行自旋操作，即把之前的逻辑再操作一次。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> var5;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    var5 = <span class="built_in">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">&#125; <span class="keyword">while</span>(!<span class="built_in">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> var5;</span><br></pre></td></tr></table></figure>

<p><strong>课程中的使用方式：</strong></p>
<p>课程中的使用方式是没有像cas一样带自旋的操作，也没有对version的版本号+1 ，他的操作逻辑是在操作时，对版本号进行+1 操作，然后要求version 如果是1 的情况下，才能操作，那么第一个线程在操作后，数据库中的version变成了2，但是他自己满足version&#x3D;1 ，所以没有问题，此时线程2执行，线程2 最后也需要加上条件version &#x3D;1 ，但是现在由于线程1已经操作过了，所以线程2，操作时就不满足version&#x3D;1 的条件了，所以线程2无法执行成功</p>
<p><img src="/2022/09/24/redis%E5%AE%9E%E6%88%98%E7%AF%87/1653369268550.png" alt="1653369268550"></p>
<h3 id="3-6-乐观锁解决超卖问题"><a href="#3-6-乐观锁解决超卖问题" class="headerlink" title="3.6 乐观锁解决超卖问题"></a>3.6 乐观锁解决超卖问题</h3><p><strong>修改代码方案一、</strong></p>
<p>VoucherOrderServiceImpl 在扣减库存时，改为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> seckillVoucherService.update()</span><br><span class="line">            .setSql(<span class="string">&quot;stock= stock -1&quot;</span>) <span class="comment">//set stock = stock -1</span></span><br><span class="line">            .eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId).eq(<span class="string">&quot;stock&quot;</span>,voucher.getStock()).update(); <span class="comment">//where id = ？ and stock = ?</span></span><br></pre></td></tr></table></figure>

<p>以上逻辑的核心含义是：只要我扣减库存时的库存和之前我查询到的库存是一样的，就意味着没有人在中间修改过库存，那么此时就是安全的，但是以上这种方式通过测试发现会有很多失败的情况，失败的原因在于：在使用乐观锁过程中假设100个线程同时都拿到了100的库存，然后大家一起去进行扣减，但是100个人中只有1个人能扣减成功，其他的人在处理时，他们在扣减时，库存已经被修改过了，所以此时其他线程都会失败</p>
<p><strong>修改代码方案二、</strong></p>
<p>之前的方式要修改前后都保持一致，但是这样我们分析过，成功的概率太低，所以我们的乐观锁需要变一下，改成stock大于0 即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> seckillVoucherService.update()</span><br><span class="line">            .setSql(<span class="string">&quot;stock= stock -1&quot;</span>)</span><br><span class="line">            .eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId).update().gt(<span class="string">&quot;stock&quot;</span>,<span class="number">0</span>); <span class="comment">//where id = ? and stock &gt; 0</span></span><br></pre></td></tr></table></figure>

<p><strong>知识小扩展：</strong></p>
<p>针对cas中的自旋压力过大，我们可以使用Longaddr这个类去解决</p>
<p>Java8 提供的一个对AtomicLong改进后的一个类，LongAdder</p>
<p>大量线程并发更新一个原子性的时候，天然的问题就是自旋，会导致并发性问题，当然这也比我们直接使用syn来的好</p>
<p>所以利用这么一个类，LongAdder来进行优化</p>
<p>如果获取某个值，则会对cell和base的值进行递增，最后返回一个完整的值</p>
<p><img src="/2022/09/24/redis%E5%AE%9E%E6%88%98%E7%AF%87/1653370271627.png" alt="1653370271627"></p>
<h3 id="3-6-优惠券秒杀-一人一单"><a href="#3-6-优惠券秒杀-一人一单" class="headerlink" title="3.6 优惠券秒杀-一人一单"></a>3.6 优惠券秒杀-一人一单</h3><p>需求：修改秒杀业务，要求同一个优惠券，一个用户只能下一单</p>
<p><strong>现在的问题在于：</strong></p>
<p>优惠卷是为了引流，但是目前的情况是，一个人可以无限制的抢这个优惠卷，所以我们应当增加一层逻辑，让一个用户只能下一个单，而不是让一个用户下多个单</p>
<p>具体操作逻辑如下：比如时间是否充足，如果时间充足，则进一步判断库存是否足够，然后再根据优惠卷id和用户id查询是否已经下过这个订单，如果下过这个订单，则不再下单，否则进行下单</p>
<p><img src="/2022/09/24/redis%E5%AE%9E%E6%88%98%E7%AF%87/1653371854389.png" alt="1653371854389"></p>
<p>VoucherOrderServiceImpl  </p>
<p><strong>初步代码：增加一人一单逻辑</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">seckillVoucher</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.查询优惠券</span></span><br><span class="line">    <span class="type">SeckillVoucher</span> <span class="variable">voucher</span> <span class="operator">=</span> seckillVoucherService.getById(voucherId);</span><br><span class="line">    <span class="comment">// 2.判断秒杀是否开始</span></span><br><span class="line">    <span class="keyword">if</span> (voucher.getBeginTime().isAfter(LocalDateTime.now())) &#123;</span><br><span class="line">        <span class="comment">// 尚未开始</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;秒杀尚未开始！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3.判断秒杀是否已经结束</span></span><br><span class="line">    <span class="keyword">if</span> (voucher.getEndTime().isBefore(LocalDateTime.now())) &#123;</span><br><span class="line">        <span class="comment">// 尚未开始</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;秒杀已经结束！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4.判断库存是否充足</span></span><br><span class="line">    <span class="keyword">if</span> (voucher.getStock() &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 库存不足</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;库存不足！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 5.一人一单逻辑</span></span><br><span class="line">    <span class="comment">// 5.1.用户id</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> query().eq(<span class="string">&quot;user_id&quot;</span>, userId).eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId).count();</span><br><span class="line">    <span class="comment">// 5.2.判断是否存在</span></span><br><span class="line">    <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 用户已经购买过了</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;用户已经购买过一次！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//6，扣减库存</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> seckillVoucherService.update()</span><br><span class="line">            .setSql(<span class="string">&quot;stock= stock -1&quot;</span>)</span><br><span class="line">            .eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId).update();</span><br><span class="line">    <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">        <span class="comment">//扣减库存</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;库存不足！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//7.创建订单</span></span><br><span class="line">    <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>();</span><br><span class="line">    <span class="comment">// 7.1.订单id</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">orderId</span> <span class="operator">=</span> redisIdWorker.nextId(<span class="string">&quot;order&quot;</span>);</span><br><span class="line">    voucherOrder.setId(orderId);</span><br><span class="line"></span><br><span class="line">    voucherOrder.setUserId(userId);</span><br><span class="line">    <span class="comment">// 7.3.代金券id</span></span><br><span class="line">    voucherOrder.setVoucherId(voucherId);</span><br><span class="line">    save(voucherOrder);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Result.ok(orderId);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>存在问题：</strong>现在的问题还是和之前一样，并发过来，查询数据库，都不存在订单，所以我们还是需要加锁，但是乐观锁比较适合更新数据，而现在是插入数据，所以我们需要使用悲观锁操作</p>
<p><strong>注意：</strong>在这里提到了非常多的问题，我们需要慢慢的来思考，首先我们的初始方案是封装了一个createVoucherOrder方法，同时为了确保他线程安全，在方法上添加了一把synchronized 锁</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> Result <span class="title function_">createVoucherOrder</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">         <span class="comment">// 5.1.查询订单</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> query().eq(<span class="string">&quot;user_id&quot;</span>, userId).eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId).count();</span><br><span class="line">        <span class="comment">// 5.2.判断是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 用户已经购买过了</span></span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;用户已经购买过一次！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6.扣减库存</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> seckillVoucherService.update()</span><br><span class="line">                .setSql(<span class="string">&quot;stock = stock - 1&quot;</span>) <span class="comment">// set stock = stock - 1</span></span><br><span class="line">                .eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId).gt(<span class="string">&quot;stock&quot;</span>, <span class="number">0</span>) <span class="comment">// where id = ? and stock &gt; 0</span></span><br><span class="line">                .update();</span><br><span class="line">        <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">            <span class="comment">// 扣减失败</span></span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;库存不足！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 7.创建订单</span></span><br><span class="line">        <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>();</span><br><span class="line">        <span class="comment">// 7.1.订单id</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">orderId</span> <span class="operator">=</span> redisIdWorker.nextId(<span class="string">&quot;order&quot;</span>);</span><br><span class="line">        voucherOrder.setId(orderId);</span><br><span class="line">        <span class="comment">// 7.2.用户id</span></span><br><span class="line">        voucherOrder.setUserId(userId);</span><br><span class="line">        <span class="comment">// 7.3.代金券id</span></span><br><span class="line">        voucherOrder.setVoucherId(voucherId);</span><br><span class="line">        save(voucherOrder);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 7.返回订单id</span></span><br><span class="line">        <span class="keyword">return</span> Result.ok(orderId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>，但是这样添加锁，锁的粒度太粗了，在使用锁过程中，控制<strong>锁粒度</strong> 是一个非常重要的事情，因为如果锁的粒度太大，会导致每个线程进来都会锁住，所以我们需要去控制锁的粒度，以下这段代码需要修改为：<br>intern() 这个方法是从常量池中拿到数据，如果我们直接使用userId.toString() 他拿到的对象实际上是不同的对象，new出来的对象，我们使用锁必须保证锁必须是同一把，所以我们需要使用intern()方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span>  Result <span class="title function_">createVoucherOrder</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line">	<span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">	<span class="keyword">synchronized</span>(userId.toString().intern())&#123;</span><br><span class="line">         <span class="comment">// 5.1.查询订单</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> query().eq(<span class="string">&quot;user_id&quot;</span>, userId).eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId).count();</span><br><span class="line">        <span class="comment">// 5.2.判断是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 用户已经购买过了</span></span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;用户已经购买过一次！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6.扣减库存</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> seckillVoucherService.update()</span><br><span class="line">                .setSql(<span class="string">&quot;stock = stock - 1&quot;</span>) <span class="comment">// set stock = stock - 1</span></span><br><span class="line">                .eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId).gt(<span class="string">&quot;stock&quot;</span>, <span class="number">0</span>) <span class="comment">// where id = ? and stock &gt; 0</span></span><br><span class="line">                .update();</span><br><span class="line">        <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">            <span class="comment">// 扣减失败</span></span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;库存不足！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 7.创建订单</span></span><br><span class="line">        <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>();</span><br><span class="line">        <span class="comment">// 7.1.订单id</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">orderId</span> <span class="operator">=</span> redisIdWorker.nextId(<span class="string">&quot;order&quot;</span>);</span><br><span class="line">        voucherOrder.setId(orderId);</span><br><span class="line">        <span class="comment">// 7.2.用户id</span></span><br><span class="line">        voucherOrder.setUserId(userId);</span><br><span class="line">        <span class="comment">// 7.3.代金券id</span></span><br><span class="line">        voucherOrder.setVoucherId(voucherId);</span><br><span class="line">        save(voucherOrder);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 7.返回订单id</span></span><br><span class="line">        <span class="keyword">return</span> Result.ok(orderId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是以上代码还是存在问题，问题的原因在于当前方法被spring的事务控制，如果你在方法内部加锁，可能会导致当前方法事务还没有提交，但是锁已经释放也会导致问题，所以我们选择将当前方法整体包裹起来，确保事务不会出现问题：如下：</p>
<p>在seckillVoucher 方法中，添加以下逻辑，这样就能保证事务的特性，同时也控制了锁的粒度</p>
<p><img src="/2022/09/24/redis%E5%AE%9E%E6%88%98%E7%AF%87/1653373434815.png" alt="1653373434815"></p>
<p>但是以上做法依然有问题，因为你调用的方法，其实是this.的方式调用的，事务想要生效，还得利用代理来生效，所以这个地方，我们需要获得原始的事务对象， 来操作事务</p>
<p><img src="/2022/09/24/redis%E5%AE%9E%E6%88%98%E7%AF%87/1653383810643.png" alt="1653383810643"></p>
<h3 id="3-7-集群环境下的并发问题"><a href="#3-7-集群环境下的并发问题" class="headerlink" title="3.7 集群环境下的并发问题"></a>3.7 集群环境下的并发问题</h3><p>通过加锁可以解决在单机情况下的一人一单安全问题，但是在集群模式下就不行了。</p>
<p>1、我们将服务启动两份，端口分别为8081和8082：</p>
<p><img src="/2022/09/24/redis%E5%AE%9E%E6%88%98%E7%AF%87/1653373887844.png" alt="1653373887844"></p>
<p>2、然后修改nginx的conf目录下的nginx.conf文件，配置反向代理和负载均衡：</p>
<p><img src="/2022/09/24/redis%E5%AE%9E%E6%88%98%E7%AF%87/1653373908620.png" alt="1653373908620"></p>
<p><strong>具体操作(略)</strong></p>
<p><strong>有关锁失效原因分析</strong></p>
<p>由于现在我们部署了多个tomcat，每个tomcat都有一个属于自己的jvm，那么假设在服务器A的tomcat内部，有两个线程，这两个线程由于使用的是同一份代码，那么他们的锁对象是同一个，是可以实现互斥的，但是如果现在是服务器B的tomcat内部，又有两个线程，但是他们的锁对象写的虽然和服务器A一样，但是锁对象却不是同一个，所以线程3和线程4可以实现互斥，但是却无法和线程1和线程2实现互斥，这就是 集群环境下，syn锁失效的原因，在这种情况下，我们就需要使用分布式锁来解决这个问题。</p>
<p><img src="/2022/09/24/redis%E5%AE%9E%E6%88%98%E7%AF%87/1653374044740.png" alt="1653374044740"></p>
<h2 id="4、分布式锁"><a href="#4、分布式锁" class="headerlink" title="4、分布式锁"></a>4、分布式锁</h2><h3 id="4-1-、基本原理和实现方式对比"><a href="#4-1-、基本原理和实现方式对比" class="headerlink" title="4.1 、基本原理和实现方式对比"></a>4.1 、基本原理和实现方式对比</h3><p>分布式锁：满足分布式系统或集群模式下多进程可见并且互斥的锁。</p>
<p>分布式锁的核心思想就是让大家都使用同一把锁，只要大家使用的是同一把锁，那么我们就能锁住线程，不让线程进行，让程序串行执行，这就是分布式锁的核心思路</p>
<p><img src="/2022/09/24/redis%E5%AE%9E%E6%88%98%E7%AF%87/1653374296906.png" alt="1653374296906"></p>
<p>那么分布式锁他应该满足一些什么样的条件呢？</p>
<p>可见性：多个线程都能看到相同的结果，注意：这个地方说的可见性并不是并发编程中指的内存可见性，只是说多个进程之间都能感知到变化的意思</p>
<p>互斥：互斥是分布式锁的最基本的条件，使得程序串行执行</p>
<p>高可用：程序不易崩溃，时时刻刻都保证较高的可用性</p>
<p>高性能：由于加锁本身就让性能降低，所有对于分布式锁本身需要他就较高的加锁性能和释放锁性能</p>
<p>安全性：安全也是程序中必不可少的一环</p>
<p><img src="/2022/09/24/redis%E5%AE%9E%E6%88%98%E7%AF%87/1653381992018.png" alt="1653381992018"></p>
<p>常见的分布式锁有三种</p>
<p>Mysql：mysql本身就带有锁机制，但是由于mysql性能本身一般，所以采用分布式锁的情况下，其实使用mysql作为分布式锁比较少见</p>
<p>Redis：redis作为分布式锁是非常常见的一种使用方式，现在企业级开发中基本都使用redis或者zookeeper作为分布式锁，利用setnx这个方法，如果插入key成功，则表示获得到了锁，如果有人插入成功，其他人插入失败则表示无法获得到锁，利用这套逻辑来实现分布式锁</p>
<p>Zookeeper：zookeeper也是企业级开发中较好的一个实现分布式锁的方案，由于本套视频并不讲解zookeeper的原理和分布式锁的实现，所以不过多阐述</p>
<p><img src="/2022/09/24/redis%E5%AE%9E%E6%88%98%E7%AF%87/1653382219377.png" alt="1653382219377"></p>
<h3 id="4-2-、Redis分布式锁的实现核心思路"><a href="#4-2-、Redis分布式锁的实现核心思路" class="headerlink" title="4.2 、Redis分布式锁的实现核心思路"></a>4.2 、Redis分布式锁的实现核心思路</h3><p>实现分布式锁时需要实现的两个基本方法：</p>
<ul>
<li><p>获取锁：</p>
<ul>
<li>互斥：确保只能有一个线程获取锁</li>
<li>非阻塞：尝试一次，成功返回true，失败返回false</li>
</ul>
</li>
<li><p>释放锁：</p>
<ul>
<li>手动释放</li>
<li>超时释放：获取锁时添加一个超时时间</li>
</ul>
<p><img src="/2022/09/24/redis%E5%AE%9E%E6%88%98%E7%AF%87/1653382669900.png" alt="1653382669900"></p>
</li>
</ul>
<p>核心思路：</p>
<p>我们利用redis 的setNx 方法，当有多个线程进入时，我们就利用该方法，第一个线程进入时，redis 中就有这个key 了，返回了1，如果结果是1，则表示他抢到了锁，那么他去执行业务，然后再删除锁，退出锁逻辑，没有抢到锁的哥们，等待一定时间后重试即可</p>
<p> <img src="/2022/09/24/redis%E5%AE%9E%E6%88%98%E7%AF%87/1653382830810.png" alt="1653382830810"></p>
<h3 id="4-3-实现分布式锁版本一"><a href="#4-3-实现分布式锁版本一" class="headerlink" title="4.3 实现分布式锁版本一"></a>4.3 实现分布式锁版本一</h3><ul>
<li>加锁逻辑</li>
</ul>
<p><strong>锁的基本接口</strong></p>
<p><img src="/2022/09/24/redis%E5%AE%9E%E6%88%98%E7%AF%87/1656079017728.png" alt="1656079017728"></p>
<p><strong>SimpleRedisLock</strong></p>
<p>利用setnx方法进行加锁，同时增加过期时间，防止死锁，此方法可以保证加锁和增加过期时间具有原子性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String KEY_PREFIX=<span class="string">&quot;lock:&quot;</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> timeoutSec)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取线程标示</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">threadId</span> <span class="operator">=</span> Thread.currentThread().getId()</span><br><span class="line">    <span class="comment">// 获取锁</span></span><br><span class="line">    <span class="type">Boolean</span> <span class="variable">success</span> <span class="operator">=</span> stringRedisTemplate.opsForValue()</span><br><span class="line">            .setIfAbsent(KEY_PREFIX + name, threadId + <span class="string">&quot;&quot;</span>, timeoutSec, TimeUnit.SECONDS);</span><br><span class="line">    <span class="keyword">return</span> Boolean.TRUE.equals(success);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>释放锁逻辑</li>
</ul>
<p>SimpleRedisLock</p>
<p>释放锁，防止删除别人的锁</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//通过del删除锁</span></span><br><span class="line">    stringRedisTemplate.delete(KEY_PREFIX + name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>修改业务代码</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> Result <span class="title function_">seckillVoucher</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line">      <span class="comment">// 1.查询优惠券</span></span><br><span class="line">      <span class="type">SeckillVoucher</span> <span class="variable">voucher</span> <span class="operator">=</span> seckillVoucherService.getById(voucherId);</span><br><span class="line">      <span class="comment">// 2.判断秒杀是否开始</span></span><br><span class="line">      <span class="keyword">if</span> (voucher.getBeginTime().isAfter(LocalDateTime.now())) &#123;</span><br><span class="line">          <span class="comment">// 尚未开始</span></span><br><span class="line">          <span class="keyword">return</span> Result.fail(<span class="string">&quot;秒杀尚未开始！&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 3.判断秒杀是否已经结束</span></span><br><span class="line">      <span class="keyword">if</span> (voucher.getEndTime().isBefore(LocalDateTime.now())) &#123;</span><br><span class="line">          <span class="comment">// 尚未开始</span></span><br><span class="line">          <span class="keyword">return</span> Result.fail(<span class="string">&quot;秒杀已经结束！&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 4.判断库存是否充足</span></span><br><span class="line">      <span class="keyword">if</span> (voucher.getStock() &lt; <span class="number">1</span>) &#123;</span><br><span class="line">          <span class="comment">// 库存不足</span></span><br><span class="line">          <span class="keyword">return</span> Result.fail(<span class="string">&quot;库存不足！&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">      <span class="comment">//创建锁对象(新增代码)</span></span><br><span class="line">      <span class="type">SimpleRedisLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleRedisLock</span>(<span class="string">&quot;order:&quot;</span> + userId, stringRedisTemplate);</span><br><span class="line">      <span class="comment">//获取锁对象</span></span><br><span class="line">      <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> lock.tryLock(<span class="number">1200</span>);</span><br><span class="line"><span class="comment">//加锁失败</span></span><br><span class="line">      <span class="keyword">if</span> (!isLock) &#123;</span><br><span class="line">          <span class="keyword">return</span> Result.fail(<span class="string">&quot;不允许重复下单&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">//获取代理对象(事务)</span></span><br><span class="line">          <span class="type">IVoucherOrderService</span> <span class="variable">proxy</span> <span class="operator">=</span> (IVoucherOrderService) AopContext.currentProxy();</span><br><span class="line">          <span class="keyword">return</span> proxy.createVoucherOrder(voucherId);</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          <span class="comment">//释放锁</span></span><br><span class="line">          lock.unlock();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-4-Redis分布式锁误删情况说明"><a href="#4-4-Redis分布式锁误删情况说明" class="headerlink" title="4.4 Redis分布式锁误删情况说明"></a>4.4 Redis分布式锁误删情况说明</h3><p>逻辑说明：</p>
<p>持有锁的线程在锁的内部出现了阻塞，导致他的锁自动释放，这时其他线程，线程2来尝试获得锁，就拿到了这把锁，然后线程2在持有锁执行过程中，线程1反应过来，继续执行，而线程1执行过程中，走到了删除锁逻辑，此时就会把本应该属于线程2的锁进行删除，这就是误删别人锁的情况说明</p>
<p>解决方案：解决方案就是在每个线程释放锁的时候，去判断一下当前这把锁是否属于自己，如果属于自己，则不进行锁的删除，假设还是上边的情况，线程1卡顿，锁自动释放，线程2进入到锁的内部执行逻辑，此时线程1反应过来，然后删除锁，但是线程1，一看当前这把锁不是属于自己，于是不进行删除锁逻辑，当线程2走到删除锁逻辑时，如果没有卡过自动释放锁的时间点，则判断当前这把锁是属于自己的，于是删除这把锁。</p>
<p><img src="/2022/09/24/redis%E5%AE%9E%E6%88%98%E7%AF%87/1653385920025.png" alt="1653385920025"></p>
<h3 id="4-5-解决Redis分布式锁误删问题"><a href="#4-5-解决Redis分布式锁误删问题" class="headerlink" title="4.5 解决Redis分布式锁误删问题"></a>4.5 解决Redis分布式锁误删问题</h3><p>需求：修改之前的分布式锁实现，满足：在获取锁时存入线程标示（可以用UUID表示）<br>在释放锁时先获取锁中的线程标示，判断是否与当前线程标示一致</p>
<ul>
<li>如果一致则释放锁</li>
<li>如果不一致则不释放锁</li>
</ul>
<p>核心逻辑：在存入锁时，放入自己线程的标识，在删除锁时，判断当前这把锁的标识是不是自己存入的，如果是，则进行删除，如果不是，则不进行删除。</p>
<p><img src="/2022/09/24/redis%E5%AE%9E%E6%88%98%E7%AF%87/1653387398820.png" alt="1653387398820"></p>
<p>具体代码如下：加锁</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">ID_PREFIX</span> <span class="operator">=</span> UUID.randomUUID().toString(<span class="literal">true</span>) + <span class="string">&quot;-&quot;</span>;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> timeoutSec)</span> &#123;</span><br><span class="line">   <span class="comment">// 获取线程标示</span></span><br><span class="line">   <span class="type">String</span> <span class="variable">threadId</span> <span class="operator">=</span> ID_PREFIX + Thread.currentThread().getId();</span><br><span class="line">   <span class="comment">// 获取锁</span></span><br><span class="line">   <span class="type">Boolean</span> <span class="variable">success</span> <span class="operator">=</span> stringRedisTemplate.opsForValue()</span><br><span class="line">                .setIfAbsent(KEY_PREFIX + name, threadId, timeoutSec, TimeUnit.SECONDS);</span><br><span class="line">   <span class="keyword">return</span> Boolean.TRUE.equals(success);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>释放锁</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 获取线程标示</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">threadId</span> <span class="operator">=</span> ID_PREFIX + Thread.currentThread().getId();</span><br><span class="line">    <span class="comment">// 获取锁中的标示</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">id</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(KEY_PREFIX + name);</span><br><span class="line">    <span class="comment">// 判断标示是否一致</span></span><br><span class="line">    <span class="keyword">if</span>(threadId.equals(id)) &#123;</span><br><span class="line">        <span class="comment">// 释放锁</span></span><br><span class="line">        stringRedisTemplate.delete(KEY_PREFIX + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>有关代码实操说明：</strong></p>
<p>在我们修改完此处代码后，我们重启工程，然后启动两个线程，第一个线程持有锁后，手动释放锁，第二个线程 此时进入到锁内部，再放行第一个线程，此时第一个线程由于锁的value值并非是自己，所以不能释放锁，也就无法删除别人的锁，此时第二个线程能够正确释放锁，通过这个案例初步说明我们解决了锁误删的问题。</p>
<h3 id="4-6-分布式锁的原子性问题"><a href="#4-6-分布式锁的原子性问题" class="headerlink" title="4.6 分布式锁的原子性问题"></a>4.6 分布式锁的原子性问题</h3><p>更为极端的误删逻辑说明：</p>
<p>线程1现在持有锁之后，在执行业务逻辑过程中，他正准备删除锁，而且已经走到了条件判断的过程中，比如他已经拿到了当前这把锁确实是属于他自己的，正准备删除锁，但是此时他的锁到期了，那么此时线程2进来，但是线程1他会接着往后执行，当他卡顿结束后，他直接就会执行删除锁那行代码，相当于条件判断并没有起到作用，这就是删锁时的原子性问题，之所以有这个问题，是因为线程1的拿锁，比锁，删锁，实际上并不是原子性的，我们要防止刚才的情况发生，</p>
<p><img src="/2022/09/24/redis%E5%AE%9E%E6%88%98%E7%AF%87/1653387764938.png" alt="1653387764938"></p>
<h3 id="4-7-Lua脚本解决多条命令原子性问题"><a href="#4-7-Lua脚本解决多条命令原子性问题" class="headerlink" title="4.7 Lua脚本解决多条命令原子性问题"></a>4.7 Lua脚本解决多条命令原子性问题</h3><p>Redis提供了Lua脚本功能，在一个脚本中编写多条Redis命令，确保多条命令执行时的原子性。Lua是一种编程语言，它的基本语法大家可以参考网站：<a href="https://www.runoob.com/lua/lua-tutorial.html%EF%BC%8C%E8%BF%99%E9%87%8C%E9%87%8D%E7%82%B9%E4%BB%8B%E7%BB%8DRedis%E6%8F%90%E4%BE%9B%E7%9A%84%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0%EF%BC%8C%E6%88%91%E4%BB%AC%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8lua%E5%8E%BB%E6%93%8D%E4%BD%9Credis%EF%BC%8C%E5%8F%88%E8%83%BD%E4%BF%9D%E8%AF%81%E4%BB%96%E7%9A%84%E5%8E%9F%E5%AD%90%E6%80%A7%EF%BC%8C%E8%BF%99%E6%A0%B7%E5%B0%B1%E5%8F%AF%E4%BB%A5%E5%AE%9E%E7%8E%B0%E6%8B%BF%E9%94%81%E6%AF%94%E9%94%81%E5%88%A0%E9%94%81%E6%98%AF%E4%B8%80%E4%B8%AA%E5%8E%9F%E5%AD%90%E6%80%A7%E5%8A%A8%E4%BD%9C%E4%BA%86%EF%BC%8C%E4%BD%9C%E4%B8%BAJava%E7%A8%8B%E5%BA%8F%E5%91%98%E8%BF%99%E4%B8%80%E5%9D%97%E5%B9%B6%E4%B8%8D%E4%BD%9C%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E8%A6%81%E6%B1%82%EF%BC%8C%E5%B9%B6%E4%B8%8D%E9%9C%80%E8%A6%81%E5%A4%A7%E5%AE%B6%E8%BF%87%E4%BA%8E%E7%B2%BE%E9%80%9A%EF%BC%8C%E5%8F%AA%E9%9C%80%E8%A6%81%E7%9F%A5%E9%81%93%E4%BB%96%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%E5%8D%B3%E5%8F%AF%E3%80%82">https://www.runoob.com/lua/lua-tutorial.html，这里重点介绍Redis提供的调用函数，我们可以使用lua去操作redis，又能保证他的原子性，这样就可以实现拿锁比锁删锁是一个原子性动作了，作为Java程序员这一块并不作一个简单要求，并不需要大家过于精通，只需要知道他有什么作用即可。</a></p>
<p>这里重点介绍Redis提供的调用函数，语法如下：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">redis.call(<span class="string">&#x27;命令名称&#x27;</span>, <span class="string">&#x27;key&#x27;</span>, <span class="string">&#x27;其它参数&#x27;</span>, ...)</span><br></pre></td></tr></table></figure>

<p>例如，我们要执行set name jack，则脚本是这样：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"># 执行 set name jack</span><br><span class="line">redis.call(<span class="string">&#x27;set&#x27;</span>, <span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;jack&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>例如，我们要先执行set name Rose，再执行get name，则脚本如下：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"># 先执行 set name jack</span><br><span class="line">redis.call(<span class="string">&#x27;set&#x27;</span>, <span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;Rose&#x27;</span>)</span><br><span class="line"># 再执行 get name</span><br><span class="line"><span class="keyword">local</span> name = redis.call(<span class="string">&#x27;get&#x27;</span>, <span class="string">&#x27;name&#x27;</span>)</span><br><span class="line"># 返回</span><br><span class="line"><span class="keyword">return</span> name</span><br></pre></td></tr></table></figure>

<p>写好脚本以后，需要用Redis命令来调用脚本，调用脚本的常见命令如下：</p>
<p><img src="/2022/09/24/redis%E5%AE%9E%E6%88%98%E7%AF%87/1653392181413.png" alt="1653392181413"></p>
<p>例如，我们要执行 redis.call(‘set’, ‘name’, ‘jack’) 这个脚本，语法如下：</p>
<p><img src="/2022/09/24/redis%E5%AE%9E%E6%88%98%E7%AF%87/1653392218531.png" alt="1653392218531"></p>
<p>如果脚本中的key、value不想写死，可以作为参数传递。key类型参数会放入KEYS数组，其它参数会放入ARGV数组，在脚本中可以从KEYS和ARGV数组获取这些参数：</p>
<p><img src="/2022/09/24/redis%E5%AE%9E%E6%88%98%E7%AF%87/1653392438917.png" alt="1653392438917"></p>
<p>接下来我们来回一下我们释放锁的逻辑：</p>
<p>释放锁的业务流程是这样的</p>
<p>​	1、获取锁中的线程标示</p>
<p>​	2、判断是否与指定的标示（当前线程标示）一致</p>
<p>​	3、如果一致则释放锁（删除）</p>
<p>​	4、如果不一致则什么都不做</p>
<p>如果用Lua脚本来表示则是这样的：</p>
<p>最终我们操作redis的拿锁比锁删锁的lua脚本就会变成这样</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 这里的 KEYS[1] 就是锁的key，这里的ARGV[1] 就是当前线程标示</span></span><br><span class="line"><span class="comment">-- 获取锁中的标示，判断是否与当前线程标示一致</span></span><br><span class="line"><span class="keyword">if</span> (redis.call(<span class="string">&#x27;GET&#x27;</span>, KEYS[<span class="number">1</span>]) == ARGV[<span class="number">1</span>]) <span class="keyword">then</span></span><br><span class="line">  <span class="comment">-- 一致，则删除锁</span></span><br><span class="line">  <span class="keyword">return</span> redis.call(<span class="string">&#x27;DEL&#x27;</span>, KEYS[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">-- 不一致，则直接返回</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>



<h3 id="4-8-利用Java代码调用Lua脚本改造分布式锁"><a href="#4-8-利用Java代码调用Lua脚本改造分布式锁" class="headerlink" title="4.8 利用Java代码调用Lua脚本改造分布式锁"></a>4.8 利用Java代码调用Lua脚本改造分布式锁</h3><p>lua脚本本身并不需要大家花费太多时间去研究，只需要知道如何调用，大致是什么意思即可，所以在笔记中并不会详细的去解释这些lua表达式的含义。</p>
<p>我们的RedisTemplate中，可以利用execute方法去执行lua脚本，参数对应关系就如下图股</p>
<p><img src="/2022/09/24/redis%E5%AE%9E%E6%88%98%E7%AF%87/1653393304844.png" alt="1653393304844"></p>
<p><strong>Java代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> DefaultRedisScript&lt;Long&gt; UNLOCK_SCRIPT;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        UNLOCK_SCRIPT = <span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span>&lt;&gt;();</span><br><span class="line">        UNLOCK_SCRIPT.setLocation(<span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;unlock.lua&quot;</span>));</span><br><span class="line">        UNLOCK_SCRIPT.setResultType(Long.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 调用lua脚本</span></span><br><span class="line">    stringRedisTemplate.execute(</span><br><span class="line">            UNLOCK_SCRIPT,</span><br><span class="line">            Collections.singletonList(KEY_PREFIX + name),</span><br><span class="line">            ID_PREFIX + Thread.currentThread().getId());</span><br><span class="line">&#125;</span><br><span class="line">经过以上代码改造后，我们就能够实现 拿锁比锁删锁的原子性动作了~</span><br></pre></td></tr></table></figure>

<p>小总结：</p>
<p>基于Redis的分布式锁实现思路：</p>
<ul>
<li>利用set nx ex获取锁，并设置过期时间，保存线程标示</li>
<li>释放锁时先判断线程标示是否与自己一致，一致则删除锁<ul>
<li>特性：<ul>
<li>利用set nx满足互斥性</li>
<li>利用set ex保证故障时锁依然能释放，避免死锁，提高安全性</li>
<li>利用Redis集群保证高可用和高并发特性</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>笔者总结：我们一路走来，利用添加过期时间，防止死锁问题的发生，但是有了过期时间之后，可能出现误删别人锁的问题，这个问题我们开始是利用删之前 通过拿锁，比锁，删锁这个逻辑来解决的，也就是删之前判断一下当前这把锁是否是属于自己的，但是现在还有原子性问题，也就是我们没法保证拿锁比锁删锁是一个原子性的动作，最后通过lua表达式来解决这个问题</p>
<p>但是目前还剩下一个问题锁不住，什么是锁不住呢，你想一想，如果当过期时间到了之后，我们可以给他续期一下，比如续个30s，就好像是网吧上网， 网费到了之后，然后说，来，网管，再给我来10块的，是不是后边的问题都不会发生了，那么续期问题怎么解决呢，可以依赖于我们接下来要学习redission啦</p>
<p><strong>测试逻辑：</strong></p>
<p>第一个线程进来，得到了锁，手动删除锁，模拟锁超时了，其他线程会执行lua来抢锁，当第一天线程利用lua删除锁时，lua能保证他不能删除他的锁，第二个线程删除锁时，利用lua同样可以保证不会删除别人的锁，同时还能保证原子性。</p>
<h2 id="5、分布式锁-redission"><a href="#5、分布式锁-redission" class="headerlink" title="5、分布式锁-redission"></a>5、分布式锁-redission</h2><h3 id="5-1-分布式锁-redission功能介绍"><a href="#5-1-分布式锁-redission功能介绍" class="headerlink" title="5.1 分布式锁-redission功能介绍"></a>5.1 分布式锁-redission功能介绍</h3><p>基于setnx实现的分布式锁存在下面的问题：</p>
<p><strong>重入问题</strong>：重入问题是指 获得锁的线程可以再次进入到相同的锁的代码块中，可重入锁的意义在于防止死锁，比如HashTable这样的代码中，他的方法都是使用synchronized修饰的，假如他在一个方法内，调用另一个方法，那么此时如果是不可重入的，不就死锁了吗？所以可重入锁他的主要意义是防止死锁，我们的synchronized和Lock锁都是可重入的。</p>
<p><strong>不可重试</strong>：是指目前的分布式只能尝试一次，我们认为合理的情况是：当线程在获得锁失败后，他应该能再次尝试获得锁。</p>
<p><strong>超时释放：</strong>我们在加锁时增加了过期时间，这样的我们可以防止死锁，但是如果卡顿的时间超长，虽然我们采用了lua表达式防止删锁的时候，误删别人的锁，但是毕竟没有锁住，有安全隐患</p>
<p><strong>主从一致性：</strong> 如果Redis提供了主从集群，当我们向集群写数据时，主机需要异步的将数据同步给从机，而万一在同步过去之前，主机宕机了，就会出现死锁问题。</p>
<p><img src="/2022/09/24/redis%E5%AE%9E%E6%88%98%E7%AF%87/1653546070602.png" alt="1653546070602"></p>
<p>那么什么是Redission呢</p>
<p>Redisson是一个在Redis的基础上实现的Java驻内存数据网格（In-Memory Data Grid）。它不仅提供了一系列的分布式的Java常用对象，还提供了许多分布式服务，其中就包含了各种分布式锁的实现。</p>
<p>Redission提供了分布式锁的多种多样的功能</p>
<p><img src="/2022/09/24/redis%E5%AE%9E%E6%88%98%E7%AF%87/1653546736063.png" alt="1653546736063"></p>
<h3 id="5-2-分布式锁-Redission快速入门"><a href="#5-2-分布式锁-Redission快速入门" class="headerlink" title="5.2 分布式锁-Redission快速入门"></a>5.2 分布式锁-Redission快速入门</h3><p>引入依赖：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;org.redisson&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;redisson&lt;/artifactId&gt;</span><br><span class="line">	&lt;version&gt;<span class="number">3.13</span><span class="number">.6</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>配置Redisson客户端：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedissonConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedissonClient <span class="title function_">redissonClient</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// 配置</span></span><br><span class="line">        <span class="type">Config</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Config</span>();</span><br><span class="line">        config.useSingleServer().setAddress(<span class="string">&quot;redis://192.168.150.101:6379&quot;</span>)</span><br><span class="line">            .setPassword(<span class="string">&quot;123321&quot;</span>);</span><br><span class="line">        <span class="comment">// 创建RedissonClient对象</span></span><br><span class="line">        <span class="keyword">return</span> Redisson.create(config);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如何使用Redission的分布式锁</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> RedissionClient redissonClient;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testRedisson</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">    <span class="comment">//获取锁(可重入)，指定锁的名称</span></span><br><span class="line">    <span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> redissonClient.getLock(<span class="string">&quot;anyLock&quot;</span>);</span><br><span class="line">    <span class="comment">//尝试获取锁，参数分别是：获取锁的最大等待时间(期间会重试)，锁自动释放时间，时间单位</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> lock.tryLock(<span class="number">1</span>,<span class="number">10</span>,TimeUnit.SECONDS);</span><br><span class="line">    <span class="comment">//判断获取锁成功</span></span><br><span class="line">    <span class="keyword">if</span>(isLock)&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;执行业务&quot;</span>);          </span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            <span class="comment">//释放锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 VoucherOrderServiceImpl</p>
<p>注入RedissonClient</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> RedissonClient redissonClient;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">seckillVoucher</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.查询优惠券</span></span><br><span class="line">        <span class="type">SeckillVoucher</span> <span class="variable">voucher</span> <span class="operator">=</span> seckillVoucherService.getById(voucherId);</span><br><span class="line">        <span class="comment">// 2.判断秒杀是否开始</span></span><br><span class="line">        <span class="keyword">if</span> (voucher.getBeginTime().isAfter(LocalDateTime.now())) &#123;</span><br><span class="line">            <span class="comment">// 尚未开始</span></span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;秒杀尚未开始！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3.判断秒杀是否已经结束</span></span><br><span class="line">        <span class="keyword">if</span> (voucher.getEndTime().isBefore(LocalDateTime.now())) &#123;</span><br><span class="line">            <span class="comment">// 尚未开始</span></span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;秒杀已经结束！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 4.判断库存是否充足</span></span><br><span class="line">        <span class="keyword">if</span> (voucher.getStock() &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 库存不足</span></span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;库存不足！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">        <span class="comment">//创建锁对象 这个代码不用了，因为我们现在要使用分布式锁</span></span><br><span class="line">        <span class="comment">//SimpleRedisLock lock = new SimpleRedisLock(&quot;order:&quot; + userId, stringRedisTemplate);</span></span><br><span class="line">        <span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> redissonClient.getLock(<span class="string">&quot;lock:order:&quot;</span> + userId);</span><br><span class="line">        <span class="comment">//获取锁对象</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> lock.tryLock();</span><br><span class="line">       </span><br><span class="line">		<span class="comment">//加锁失败</span></span><br><span class="line">        <span class="keyword">if</span> (!isLock) &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;不允许重复下单&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//获取代理对象(事务)</span></span><br><span class="line">            <span class="type">IVoucherOrderService</span> <span class="variable">proxy</span> <span class="operator">=</span> (IVoucherOrderService) AopContext.currentProxy();</span><br><span class="line">            <span class="keyword">return</span> proxy.createVoucherOrder(voucherId);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//释放锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-3-分布式锁-redission可重入锁原理"><a href="#5-3-分布式锁-redission可重入锁原理" class="headerlink" title="5.3 分布式锁-redission可重入锁原理"></a>5.3 分布式锁-redission可重入锁原理</h3><p>在Lock锁中，他是借助于底层的一个voaltile的一个state变量来记录重入的状态的，比如当前没有人持有这把锁，那么state&#x3D;0，假如有人持有这把锁，那么state&#x3D;1，如果持有这把锁的人再次持有这把锁，那么state就会+1 ，如果是对于synchronized而言，他在c语言代码中会有一个count，原理和state类似，也是重入一次就加一，释放一次就-1 ，直到减少成0 时，表示当前这把锁没有被人持有。  </p>
<p>在redission中，我们的也支持支持可重入锁</p>
<p>在分布式锁中，他采用hash结构用来存储锁，其中大key表示表示这把锁是否存在，用小key表示当前这把锁被哪个线程持有，所以接下来我们一起分析一下当前的这个lua表达式</p>
<p>这个地方一共有3个参数</p>
<p><strong>KEYS[1] ： 锁名称</strong></p>
<p><strong>ARGV[1]：  锁失效时间</strong></p>
<p><strong>ARGV[2]：  id + “:” + threadId; 锁的小key</strong></p>
<p>exists: 判断数据是否存在  name：是lock是否存在,如果&#x3D;&#x3D;0，就表示当前这把锁不存在</p>
<p>redis.call(‘hset’, KEYS[1], ARGV[2], 1);此时他就开始往redis里边去写数据 ，写成一个hash结构</p>
<p>Lock{</p>
<p>​    id + <strong>“:”</strong> + threadId :  1</p>
<p>}</p>
<p>如果当前这把锁存在，则第一个条件不满足，再判断</p>
<p>redis.call(‘hexists’, KEYS[1], ARGV[2]) &#x3D;&#x3D; 1</p>
<p>此时需要通过大key+小key判断当前这把锁是否是属于自己的，如果是自己的，则进行</p>
<p>redis.call(‘hincrby’, KEYS[1], ARGV[2], 1)</p>
<p>将当前这个锁的value进行+1 ，redis.call(‘pexpire’, KEYS[1], ARGV[1]); 然后再对其设置过期时间，如果以上两个条件都不满足，则表示当前这把锁抢锁失败，最后返回pttl，即为当前这把锁的失效时间</p>
<p>如果小伙帮们看了前边的源码， 你会发现他会去判断当前这个方法的返回值是否为null，如果是null，则对应则前两个if对应的条件，退出抢锁逻辑，如果返回的不是null，即走了第三个分支，在源码处会进行while(true)的自旋抢锁。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;if (redis.call(&#x27;exists&#x27;, KEYS[1]) == 0) then &quot;</span> +</span><br><span class="line">                  <span class="string">&quot;redis.call(&#x27;hset&#x27;, KEYS[1], ARGV[2], 1); &quot;</span> +</span><br><span class="line">                  <span class="string">&quot;redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[1]); &quot;</span> +</span><br><span class="line">                  <span class="string">&quot;return nil; &quot;</span> +</span><br><span class="line">              <span class="string">&quot;end; &quot;</span> +</span><br><span class="line">              <span class="string">&quot;if (redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[2]) == 1) then &quot;</span> +</span><br><span class="line">                  <span class="string">&quot;redis.call(&#x27;hincrby&#x27;, KEYS[1], ARGV[2], 1); &quot;</span> +</span><br><span class="line">                  <span class="string">&quot;redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[1]); &quot;</span> +</span><br><span class="line">                  <span class="string">&quot;return nil; &quot;</span> +</span><br><span class="line">              <span class="string">&quot;end; &quot;</span> +</span><br><span class="line">              <span class="string">&quot;return redis.call(&#x27;pttl&#x27;, KEYS[1]);&quot;</span></span><br></pre></td></tr></table></figure>

<p><img src="/2022/09/24/redis%E5%AE%9E%E6%88%98%E7%AF%87/1653548087334.png" alt="1653548087334"></p>
<h3 id="5-4-分布式锁-redission锁重试和WatchDog机制"><a href="#5-4-分布式锁-redission锁重试和WatchDog机制" class="headerlink" title="5.4 分布式锁-redission锁重试和WatchDog机制"></a>5.4 分布式锁-redission锁重试和WatchDog机制</h3><p><strong>说明</strong>：由于课程中已经说明了有关tryLock的源码解析以及其看门狗原理，所以笔者在这里给大家分析lock()方法的源码解析，希望大家在学习过程中，能够掌握更多的知识</p>
<p>抢锁过程中，获得当前线程，通过tryAcquire进行抢锁，该抢锁逻辑和之前逻辑相同</p>
<p>1、先判断当前这把锁是否存在，如果不存在，插入一把锁，返回null</p>
<p>2、判断当前这把锁是否是属于当前线程，如果是，则返回null</p>
<p>所以如果返回是null，则代表着当前这哥们已经抢锁完毕，或者可重入完毕，但是如果以上两个条件都不满足，则进入到第三个条件，返回的是锁的失效时间，同学们可以自行往下翻一点点，你能发现有个while( true) 再次进行tryAcquire进行抢锁</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">threadId</span> <span class="operator">=</span> Thread.currentThread().getId();</span><br><span class="line"><span class="type">Long</span> <span class="variable">ttl</span> <span class="operator">=</span> tryAcquire(-<span class="number">1</span>, leaseTime, unit, threadId);</span><br><span class="line"><span class="comment">// lock acquired</span></span><br><span class="line"><span class="keyword">if</span> (ttl == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来会有一个条件分支，因为lock方法有重载方法，一个是带参数，一个是不带参数，如果带带参数传入的值是-1，如果传入参数，则leaseTime是他本身，所以如果传入了参数，此时leaseTime !&#x3D; -1 则会进去抢锁，抢锁的逻辑就是之前说的那三个逻辑</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (leaseTime != -<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> tryLockInnerAsync(waitTime, leaseTime, unit, threadId, RedisCommands.EVAL_LONG);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果是没有传入时间，则此时也会进行抢锁， 而且抢锁时间是默认看门狗时间 commandExecutor.getConnectionManager().getCfg().getLockWatchdogTimeout()</p>
<p>ttlRemainingFuture.onComplete((ttlRemaining, e) 这句话相当于对以上抢锁进行了监听，也就是说当上边抢锁完毕后，此方法会被调用，具体调用的逻辑就是去后台开启一个线程，进行续约逻辑，也就是看门狗线程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">RFuture&lt;Long&gt; ttlRemainingFuture = tryLockInnerAsync(waitTime,</span><br><span class="line">                                        commandExecutor.getConnectionManager().getCfg().getLockWatchdogTimeout(),</span><br><span class="line">                                        TimeUnit.MILLISECONDS, threadId, RedisCommands.EVAL_LONG);</span><br><span class="line">ttlRemainingFuture.onComplete((ttlRemaining, e) -&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// lock acquired</span></span><br><span class="line">    <span class="keyword">if</span> (ttlRemaining == <span class="literal">null</span>) &#123;</span><br><span class="line">        scheduleExpirationRenewal(threadId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">return</span> ttlRemainingFuture;</span><br></pre></td></tr></table></figure>

<p>此逻辑就是续约逻辑，注意看commandExecutor.getConnectionManager().newTimeout（） 此方法</p>
<p>Method(  <strong>new</strong> TimerTask() {},参数2 ，参数3  )</p>
<p>指的是：通过参数2，参数3 去描述什么时候去做参数1的事情，现在的情况是：10s之后去做参数一的事情</p>
<p>因为锁的失效时间是30s，当10s之后，此时这个timeTask 就触发了，他就去进行续约，把当前这把锁续约成30s，如果操作成功，那么此时就会递归调用自己，再重新设置一个timeTask()，于是再过10s后又再设置一个timerTask，完成不停的续约</p>
<p>那么大家可以想一想，假设我们的线程出现了宕机他还会续约吗？当然不会，因为没有人再去调用renewExpiration这个方法，所以等到时间之后自然就释放了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">renewExpiration</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">ExpirationEntry</span> <span class="variable">ee</span> <span class="operator">=</span> EXPIRATION_RENEWAL_MAP.get(getEntryName());</span><br><span class="line">    <span class="keyword">if</span> (ee == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">Timeout</span> <span class="variable">task</span> <span class="operator">=</span> commandExecutor.getConnectionManager().newTimeout(<span class="keyword">new</span> <span class="title class_">TimerTask</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(Timeout timeout)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            <span class="type">ExpirationEntry</span> <span class="variable">ent</span> <span class="operator">=</span> EXPIRATION_RENEWAL_MAP.get(getEntryName());</span><br><span class="line">            <span class="keyword">if</span> (ent == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">Long</span> <span class="variable">threadId</span> <span class="operator">=</span> ent.getFirstThreadId();</span><br><span class="line">            <span class="keyword">if</span> (threadId == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            RFuture&lt;Boolean&gt; future = renewExpirationAsync(threadId);</span><br><span class="line">            future.onComplete((res, e) -&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">                    log.error(<span class="string">&quot;Can&#x27;t update lock &quot;</span> + getName() + <span class="string">&quot; expiration&quot;</span>, e);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (res) &#123;</span><br><span class="line">                    <span class="comment">// reschedule itself</span></span><br><span class="line">                    renewExpiration();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, internalLockLeaseTime / <span class="number">3</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">    </span><br><span class="line">    ee.setTimeout(task);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-5-分布式锁-redission锁的MutiLock原理"><a href="#5-5-分布式锁-redission锁的MutiLock原理" class="headerlink" title="5.5 分布式锁-redission锁的MutiLock原理"></a>5.5 分布式锁-redission锁的MutiLock原理</h3><p>为了提高redis的可用性，我们会搭建集群或者主从，现在以主从为例</p>
<p>此时我们去写命令，写在主机上， 主机会将数据同步给从机，但是假设在主机还没有来得及把数据写入到从机去的时候，此时主机宕机，哨兵会发现主机宕机，并且选举一个slave变成master，而此时新的master中实际上并没有锁信息，此时锁信息就已经丢掉了。</p>
<p><img src="/2022/09/24/redis%E5%AE%9E%E6%88%98%E7%AF%87/1653553998403.png" alt="1653553998403"></p>
<p>为了解决这个问题，redission提出来了MutiLock锁，使用这把锁咱们就不使用主从了，每个节点的地位都是一样的， 这把锁加锁的逻辑需要写入到每一个主丛节点上，只有所有的服务器都写入成功，此时才是加锁成功，假设现在某个节点挂了，那么他去获得锁的时候，只要有一个节点拿不到，都不能算是加锁成功，就保证了加锁的可靠性。</p>
<p><img src="/2022/09/24/redis%E5%AE%9E%E6%88%98%E7%AF%87/1653554055048.png" alt="1653554055048"></p>
<p>那么MutiLock 加锁原理是什么呢？笔者画了一幅图来说明</p>
<p>当我们去设置了多个锁时，redission会将多个锁添加到一个集合中，然后用while循环去不停去尝试拿锁，但是会有一个总共的加锁时间，这个时间是用需要加锁的个数 * 1500ms ，假设有3个锁，那么时间就是4500ms，假设在这4500ms内，所有的锁都加锁成功， 那么此时才算是加锁成功，如果在4500ms有线程加锁失败，则会再次去进行重试.</p>
<p><img src="/2022/09/24/redis%E5%AE%9E%E6%88%98%E7%AF%87/1653553093967.png" alt="1653553093967"></p>
<h2 id="6、秒杀优化"><a href="#6、秒杀优化" class="headerlink" title="6、秒杀优化"></a>6、秒杀优化</h2><h3 id="6-1-秒杀优化-异步秒杀思路"><a href="#6-1-秒杀优化-异步秒杀思路" class="headerlink" title="6.1 秒杀优化-异步秒杀思路"></a>6.1 秒杀优化-异步秒杀思路</h3><p>我们来回顾一下下单流程</p>
<p>当用户发起请求，此时会请求nginx，nginx会访问到tomcat，而tomcat中的程序，会进行串行操作，分成如下几个步骤</p>
<p>1、查询优惠卷</p>
<p>2、判断秒杀库存是否足够</p>
<p>3、查询订单</p>
<p>4、校验是否是一人一单</p>
<p>5、扣减库存</p>
<p>6、创建订单</p>
<p>在这六步操作中，又有很多操作是要去操作数据库的，而且还是一个线程串行执行， 这样就会导致我们的程序执行的很慢，所以我们需要异步程序执行，那么如何加速呢？</p>
<p>在这里笔者想给大家分享一下课程内没有的思路，看看有没有小伙伴这么想，比如，我们可以不可以使用异步编排来做，或者说我开启N多线程，N多个线程，一个线程执行查询优惠卷，一个执行判断扣减库存，一个去创建订单等等，然后再统一做返回，这种做法和课程中有哪种好呢？答案是课程中的好，因为如果你采用我刚说的方式，如果访问的人很多，那么线程池中的线程可能一下子就被消耗完了，而且你使用上述方案，最大的特点在于，你觉得时效性会非常重要，但是你想想是吗？并不是，比如我只要确定他能做这件事，然后我后边慢慢做就可以了，我并不需要他一口气做完这件事，所以我们应当采用的是课程中，类似消息队列的方式来完成我们的需求，而不是使用线程池或者是异步编排的方式来完成这个需求</p>
<p><img src="/2022/09/24/redis%E5%AE%9E%E6%88%98%E7%AF%87/1653560986599.png" alt="1653560986599"></p>
<p>优化方案：我们将耗时比较短的逻辑判断放入到redis中，比如是否库存足够，比如是否一人一单，这样的操作，只要这种逻辑可以完成，就意味着我们是一定可以下单完成的，我们只需要进行快速的逻辑判断，根本就不用等下单逻辑走完，我们直接给用户返回成功， 再在后台开一个线程，后台线程慢慢的去执行queue里边的消息，这样程序不就超级快了吗？而且也不用担心线程池消耗殆尽的问题，因为这里我们的程序中并没有手动使用任何线程池，当然这里边有两个难点</p>
<p>第一个难点是我们怎么在redis中去快速校验一人一单，还有库存判断</p>
<p>第二个难点是由于我们校验和tomct下单是两个线程，那么我们如何知道到底哪个单他最后是否成功，或者是下单完成，为了完成这件事我们在redis操作完之后，我们会将一些信息返回给前端，同时也会把这些信息丢到异步queue中去，后续操作中，可以通过这个id来查询我们tomcat中的下单逻辑是否完成了。</p>
<p><img src="/2022/09/24/redis%E5%AE%9E%E6%88%98%E7%AF%87/1653561657295.png" alt="1653561657295"></p>
<p>我们现在来看看整体思路：当用户下单之后，判断库存是否充足只需要导redis中去根据key找对应的value是否大于0即可，如果不充足，则直接结束，如果充足，继续在redis中判断用户是否可以下单，如果set集合中没有这条数据，说明他可以下单，如果set集合中没有这条记录，则将userId和优惠卷存入到redis中，并且返回0，整个过程需要保证是原子性的，我们可以使用lua来操作</p>
<p>当以上判断逻辑走完之后，我们可以判断当前redis中返回的结果是否是0 ，如果是0，则表示可以下单，则将之前说的信息存入到到queue中去，然后返回，然后再来个线程异步的下单，前端可以通过返回的订单id来判断是否下单成功。</p>
<p><img src="/2022/09/24/redis%E5%AE%9E%E6%88%98%E7%AF%87/1653562234886.png" alt="1653562234886"></p>
<h3 id="6-2-秒杀优化-Redis完成秒杀资格判断"><a href="#6-2-秒杀优化-Redis完成秒杀资格判断" class="headerlink" title="6.2 秒杀优化-Redis完成秒杀资格判断"></a>6.2 秒杀优化-Redis完成秒杀资格判断</h3><p>需求：</p>
<ul>
<li><p>新增秒杀优惠券的同时，将优惠券信息保存到Redis中</p>
</li>
<li><p>基于Lua脚本，判断秒杀库存、一人一单，决定用户是否抢购成功</p>
</li>
<li><p>如果抢购成功，将优惠券id和用户id封装后存入阻塞队列</p>
</li>
<li><p>开启线程任务，不断从阻塞队列中获取信息，实现异步下单功能</p>
<p><img src="/2022/09/24/redis%E5%AE%9E%E6%88%98%E7%AF%87/1656080546603.png" alt="1656080546603"></p>
</li>
</ul>
<p>VoucherServiceImpl</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addSeckillVoucher</span><span class="params">(Voucher voucher)</span> &#123;</span><br><span class="line">    <span class="comment">// 保存优惠券</span></span><br><span class="line">    save(voucher);</span><br><span class="line">    <span class="comment">// 保存秒杀信息</span></span><br><span class="line">    <span class="type">SeckillVoucher</span> <span class="variable">seckillVoucher</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SeckillVoucher</span>();</span><br><span class="line">    seckillVoucher.setVoucherId(voucher.getId());</span><br><span class="line">    seckillVoucher.setStock(voucher.getStock());</span><br><span class="line">    seckillVoucher.setBeginTime(voucher.getBeginTime());</span><br><span class="line">    seckillVoucher.setEndTime(voucher.getEndTime());</span><br><span class="line">    seckillVoucherService.save(seckillVoucher);</span><br><span class="line">    <span class="comment">// 保存秒杀库存到Redis中</span></span><br><span class="line">    <span class="comment">//SECKILL_STOCK_KEY 这个变量定义在RedisConstans中</span></span><br><span class="line">    <span class="comment">//private static final String SECKILL_STOCK_KEY =&quot;seckill:stock:&quot;</span></span><br><span class="line">    stringRedisTemplate.opsForValue().set(SECKILL_STOCK_KEY + voucher.getId(), voucher.getStock().toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>完整lua表达式</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 1.参数列表</span></span><br><span class="line"><span class="comment">-- 1.1.优惠券id</span></span><br><span class="line"><span class="keyword">local</span> voucherId = ARGV[<span class="number">1</span>]</span><br><span class="line"><span class="comment">-- 1.2.用户id</span></span><br><span class="line"><span class="keyword">local</span> userId = ARGV[<span class="number">2</span>]</span><br><span class="line"><span class="comment">-- 1.3.订单id</span></span><br><span class="line"><span class="keyword">local</span> orderId = ARGV[<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2.数据key</span></span><br><span class="line"><span class="comment">-- 2.1.库存key</span></span><br><span class="line"><span class="keyword">local</span> stockKey = <span class="string">&#x27;seckill:stock:&#x27;</span> .. voucherId</span><br><span class="line"><span class="comment">-- 2.2.订单key</span></span><br><span class="line"><span class="keyword">local</span> orderKey = <span class="string">&#x27;seckill:order:&#x27;</span> .. voucherId</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 3.脚本业务</span></span><br><span class="line"><span class="comment">-- 3.1.判断库存是否充足 get stockKey</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">tonumber</span>(redis.call(<span class="string">&#x27;get&#x27;</span>, stockKey)) &lt;= <span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">    <span class="comment">-- 3.2.库存不足，返回1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">-- 3.2.判断用户是否下单 SISMEMBER orderKey userId</span></span><br><span class="line"><span class="keyword">if</span>(redis.call(<span class="string">&#x27;sismember&#x27;</span>, orderKey, userId) == <span class="number">1</span>) <span class="keyword">then</span></span><br><span class="line">    <span class="comment">-- 3.3.存在，说明是重复下单，返回2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">-- 3.4.扣库存 incrby stockKey -1</span></span><br><span class="line">redis.call(<span class="string">&#x27;incrby&#x27;</span>, stockKey, <span class="number">-1</span>)</span><br><span class="line"><span class="comment">-- 3.5.下单（保存用户）sadd orderKey userId</span></span><br><span class="line">redis.call(<span class="string">&#x27;sadd&#x27;</span>, orderKey, userId)</span><br><span class="line"><span class="comment">-- 3.6.发送消息到队列中， XADD stream.orders * k1 v1 k2 v2 ...</span></span><br><span class="line">redis.call(<span class="string">&#x27;xadd&#x27;</span>, <span class="string">&#x27;stream.orders&#x27;</span>, <span class="string">&#x27;*&#x27;</span>, <span class="string">&#x27;userId&#x27;</span>, userId, <span class="string">&#x27;voucherId&#x27;</span>, voucherId, <span class="string">&#x27;id&#x27;</span>, orderId)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>当以上lua表达式执行完毕后，剩下的就是根据步骤3,4来执行我们接下来的任务了</p>
<p>VoucherOrderServiceImpl</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">seckillVoucher</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line">    <span class="comment">//获取用户</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">    <span class="type">long</span> <span class="variable">orderId</span> <span class="operator">=</span> redisIdWorker.nextId(<span class="string">&quot;order&quot;</span>);</span><br><span class="line">    <span class="comment">// 1.执行lua脚本</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">result</span> <span class="operator">=</span> stringRedisTemplate.execute(</span><br><span class="line">            SECKILL_SCRIPT,</span><br><span class="line">            Collections.emptyList(),</span><br><span class="line">            voucherId.toString(), userId.toString(), String.valueOf(orderId)</span><br><span class="line">    );</span><br><span class="line">    <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> result.intValue();</span><br><span class="line">    <span class="comment">// 2.判断结果是否为0</span></span><br><span class="line">    <span class="keyword">if</span> (r != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 2.1.不为0 ，代表没有购买资格</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(r == <span class="number">1</span> ? <span class="string">&quot;库存不足&quot;</span> : <span class="string">&quot;不能重复下单&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//TODO 保存阻塞队列</span></span><br><span class="line">    <span class="comment">// 3.返回订单id</span></span><br><span class="line">    <span class="keyword">return</span> Result.ok(orderId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-3-秒杀优化-基于阻塞队列实现秒杀优化"><a href="#6-3-秒杀优化-基于阻塞队列实现秒杀优化" class="headerlink" title="6.3 秒杀优化-基于阻塞队列实现秒杀优化"></a>6.3 秒杀优化-基于阻塞队列实现秒杀优化</h3><p>VoucherOrderServiceImpl</p>
<p>修改下单动作，现在我们去下单时，是通过lua表达式去原子执行判断逻辑，如果判断我出来不为0 ，则要么是库存不足，要么是重复下单，返回错误信息，如果是0，则把下单的逻辑保存到队列中去，然后异步执行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//异步处理线程池</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ExecutorService</span> <span class="variable">SECKILL_ORDER_EXECUTOR</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line"></span><br><span class="line"><span class="comment">//在类初始化之后执行，因为当这个类初始化好了之后，随时都是有可能要执行的</span></span><br><span class="line"><span class="meta">@PostConstruct</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">   SECKILL_ORDER_EXECUTOR.submit(<span class="keyword">new</span> <span class="title class_">VoucherOrderHandler</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 用于线程池处理的任务</span></span><br><span class="line"><span class="comment">// 当初始化完毕后，就会去从对列中去拿信息</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">VoucherOrderHandler</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 1.获取队列中的订单信息</span></span><br><span class="line">                    <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> orderTasks.take();</span><br><span class="line">                    <span class="comment">// 2.创建订单</span></span><br><span class="line">                    handleVoucherOrder(voucherOrder);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    log.error(<span class="string">&quot;处理订单异常&quot;</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">          	 &#125;</span><br><span class="line">        &#125;</span><br><span class="line">     </span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handleVoucherOrder</span><span class="params">(VoucherOrder voucherOrder)</span> &#123;</span><br><span class="line">            <span class="comment">//1.获取用户</span></span><br><span class="line">            <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> voucherOrder.getUserId();</span><br><span class="line">            <span class="comment">// 2.创建锁对象</span></span><br><span class="line">            <span class="type">RLock</span> <span class="variable">redisLock</span> <span class="operator">=</span> redissonClient.getLock(<span class="string">&quot;lock:order:&quot;</span> + userId);</span><br><span class="line">            <span class="comment">// 3.尝试获取锁</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> redisLock.lock();</span><br><span class="line">            <span class="comment">// 4.判断是否获得锁成功</span></span><br><span class="line">            <span class="keyword">if</span> (!isLock) &#123;</span><br><span class="line">                <span class="comment">// 获取锁失败，直接返回失败或者重试</span></span><br><span class="line">                log.error(<span class="string">&quot;不允许重复下单！&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="comment">//注意：由于是spring的事务是放在threadLocal中，此时的是多线程，事务会失效</span></span><br><span class="line">                proxy.createVoucherOrder(voucherOrder);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// 释放锁</span></span><br><span class="line">                redisLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="comment">//a</span></span><br><span class="line">	<span class="keyword">private</span> BlockingQueue&lt;VoucherOrder&gt; orderTasks =<span class="keyword">new</span>  <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">1024</span> * <span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">seckillVoucher</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line">        <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">        <span class="type">long</span> <span class="variable">orderId</span> <span class="operator">=</span> redisIdWorker.nextId(<span class="string">&quot;order&quot;</span>);</span><br><span class="line">        <span class="comment">// 1.执行lua脚本</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">result</span> <span class="operator">=</span> stringRedisTemplate.execute(</span><br><span class="line">                SECKILL_SCRIPT,</span><br><span class="line">                Collections.emptyList(),</span><br><span class="line">                voucherId.toString(), userId.toString(), String.valueOf(orderId)</span><br><span class="line">        );</span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> result.intValue();</span><br><span class="line">        <span class="comment">// 2.判断结果是否为0</span></span><br><span class="line">        <span class="keyword">if</span> (r != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 2.1.不为0 ，代表没有购买资格</span></span><br><span class="line">            <span class="keyword">return</span> Result.fail(r == <span class="number">1</span> ? <span class="string">&quot;库存不足&quot;</span> : <span class="string">&quot;不能重复下单&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>();</span><br><span class="line">        <span class="comment">// 2.3.订单id</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">orderId</span> <span class="operator">=</span> redisIdWorker.nextId(<span class="string">&quot;order&quot;</span>);</span><br><span class="line">        voucherOrder.setId(orderId);</span><br><span class="line">        <span class="comment">// 2.4.用户id</span></span><br><span class="line">        voucherOrder.setUserId(userId);</span><br><span class="line">        <span class="comment">// 2.5.代金券id</span></span><br><span class="line">        voucherOrder.setVoucherId(voucherId);</span><br><span class="line">        <span class="comment">// 2.6.放入阻塞队列</span></span><br><span class="line">        orderTasks.add(voucherOrder);</span><br><span class="line">        <span class="comment">//3.获取代理对象</span></span><br><span class="line">         proxy = (IVoucherOrderService)AopContext.currentProxy();</span><br><span class="line">        <span class="comment">//4.返回订单id</span></span><br><span class="line">        <span class="keyword">return</span> Result.ok(orderId);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">      <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">void</span> <span class="title function_">createVoucherOrder</span><span class="params">(VoucherOrder voucherOrder)</span> &#123;</span><br><span class="line">        <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> voucherOrder.getUserId();</span><br><span class="line">        <span class="comment">// 5.1.查询订单</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> query().eq(<span class="string">&quot;user_id&quot;</span>, userId).eq(<span class="string">&quot;voucher_id&quot;</span>, voucherOrder.getVoucherId()).count();</span><br><span class="line">        <span class="comment">// 5.2.判断是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 用户已经购买过了</span></span><br><span class="line">           log.error(<span class="string">&quot;用户已经购买过了&quot;</span>);</span><br><span class="line">           <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6.扣减库存</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> seckillVoucherService.update()</span><br><span class="line">                .setSql(<span class="string">&quot;stock = stock - 1&quot;</span>) <span class="comment">// set stock = stock - 1</span></span><br><span class="line">                .eq(<span class="string">&quot;voucher_id&quot;</span>, voucherOrder.getVoucherId()).gt(<span class="string">&quot;stock&quot;</span>, <span class="number">0</span>) <span class="comment">// where id = ? and stock &gt; 0</span></span><br><span class="line">                .update();</span><br><span class="line">        <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">            <span class="comment">// 扣减失败</span></span><br><span class="line">            log.error(<span class="string">&quot;库存不足&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        save(voucherOrder);</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>小总结：</strong></p>
<p>秒杀业务的优化思路是什么？</p>
<ul>
<li>先利用Redis完成库存余量、一人一单判断，完成抢单业务</li>
<li>再将下单业务放入阻塞队列，利用独立线程异步下单</li>
<li>基于阻塞队列的异步秒杀存在哪些问题？<ul>
<li>内存限制问题</li>
<li>数据安全问题</li>
</ul>
</li>
</ul>
<h2 id="7、Redis消息队列"><a href="#7、Redis消息队列" class="headerlink" title="7、Redis消息队列"></a>7、Redis消息队列</h2><h3 id="7-1-Redis消息队列-认识消息队列"><a href="#7-1-Redis消息队列-认识消息队列" class="headerlink" title="7.1 Redis消息队列-认识消息队列"></a>7.1 Redis消息队列-认识消息队列</h3><p>什么是消息队列：字面意思就是存放消息的队列。最简单的消息队列模型包括3个角色：</p>
<ul>
<li>消息队列：存储和管理消息，也被称为消息代理（Message Broker）</li>
<li>生产者：发送消息到消息队列</li>
<li>消费者：从消息队列获取消息并处理消息</li>
</ul>
<p><img src="/2022/09/24/redis%E5%AE%9E%E6%88%98%E7%AF%87/1653574849336.png" alt="1653574849336"></p>
<p>使用队列的好处在于 <strong>解耦：</strong>所谓解耦，举一个生活中的例子就是：快递员(生产者)把快递放到快递柜里边(Message Queue)去，我们(消费者)从快递柜里边去拿东西，这就是一个异步，如果耦合，那么这个快递员相当于直接把快递交给你，这事固然好，但是万一你不在家，那么快递员就会一直等你，这就浪费了快递员的时间，所以这种思想在我们日常开发中，是非常有必要的。</p>
<p>这种场景在我们秒杀中就变成了：我们下单之后，利用redis去进行校验下单条件，再通过队列把消息发送出去，然后再启动一个线程去消费这个消息，完成解耦，同时也加快我们的响应速度。</p>
<p>这里我们可以使用一些现成的mq，比如kafka，rabbitmq等等，但是呢，如果没有安装mq，我们也可以直接使用redis提供的mq方案，降低我们的部署和学习成本。</p>
<h3 id="7-2-Redis消息队列-基于List实现消息队列"><a href="#7-2-Redis消息队列-基于List实现消息队列" class="headerlink" title="7.2 Redis消息队列-基于List实现消息队列"></a>7.2 Redis消息队列-基于List实现消息队列</h3><p><strong>基于List结构模拟消息队列</strong></p>
<p>消息队列（Message Queue），字面意思就是存放消息的队列。而Redis的list数据结构是一个双向链表，很容易模拟出队列效果。</p>
<p>队列是入口和出口不在一边，因此我们可以利用：LPUSH 结合 RPOP、或者 RPUSH 结合 LPOP来实现。<br>不过要注意的是，当队列中没有消息时RPOP或LPOP操作会返回null，并不像JVM的阻塞队列那样会阻塞并等待消息。因此这里应该使用BRPOP或者BLPOP来实现阻塞效果。</p>
<p><img src="/2022/09/24/redis%E5%AE%9E%E6%88%98%E7%AF%87/1653575176451.png" alt="1653575176451"></p>
<p>基于List的消息队列有哪些优缺点？<br>优点：</p>
<ul>
<li>利用Redis存储，不受限于JVM内存上限</li>
<li>基于Redis的持久化机制，数据安全性有保证</li>
<li>可以满足消息有序性</li>
</ul>
<p>缺点：</p>
<ul>
<li>无法避免消息丢失</li>
<li>只支持单消费者</li>
</ul>
<h3 id="7-3-Redis消息队列-基于PubSub的消息队列"><a href="#7-3-Redis消息队列-基于PubSub的消息队列" class="headerlink" title="7.3 Redis消息队列-基于PubSub的消息队列"></a>7.3 Redis消息队列-基于PubSub的消息队列</h3><p>PubSub（发布订阅）是Redis2.0版本引入的消息传递模型。顾名思义，消费者可以订阅一个或多个channel，生产者向对应channel发送消息后，所有订阅者都能收到相关消息。</p>
<p> SUBSCRIBE channel [channel] ：订阅一个或多个频道<br> PUBLISH channel msg ：向一个频道发送消息<br> PSUBSCRIBE pattern[pattern] ：订阅与pattern格式匹配的所有频道</p>
<p><img src="/2022/09/24/redis%E5%AE%9E%E6%88%98%E7%AF%87/1653575506373.png" alt="1653575506373"></p>
<p>基于PubSub的消息队列有哪些优缺点？<br>优点：</p>
<ul>
<li>采用发布订阅模型，支持多生产、多消费</li>
</ul>
<p>缺点：</p>
<ul>
<li>不支持数据持久化</li>
<li>无法避免消息丢失</li>
<li>消息堆积有上限，超出时数据丢失</li>
</ul>
<h3 id="7-4-Redis消息队列-基于Stream的消息队列"><a href="#7-4-Redis消息队列-基于Stream的消息队列" class="headerlink" title="7.4 Redis消息队列-基于Stream的消息队列"></a>7.4 Redis消息队列-基于Stream的消息队列</h3><p>Stream 是 Redis 5.0 引入的一种新数据类型，可以实现一个功能非常完善的消息队列。</p>
<p>发送消息的命令：</p>
<p><img src="/2022/09/24/redis%E5%AE%9E%E6%88%98%E7%AF%87/1653577301737.png" alt="1653577301737"></p>
<p>例如：</p>
<p><img src="/2022/09/24/redis%E5%AE%9E%E6%88%98%E7%AF%87/1653577349691.png" alt="1653577349691"></p>
<p>读取消息的方式之一：XREAD</p>
<p><img src="/2022/09/24/redis%E5%AE%9E%E6%88%98%E7%AF%87/1653577445413.png" alt="1653577445413"></p>
<p>例如，使用XREAD读取第一个消息：</p>
<p><img src="/2022/09/24/redis%E5%AE%9E%E6%88%98%E7%AF%87/1653577643629.png" alt="1653577643629"></p>
<p>XREAD阻塞方式，读取最新的消息：</p>
<p><img src="/2022/09/24/redis%E5%AE%9E%E6%88%98%E7%AF%87/1653577659166.png" alt="1653577659166"></p>
<p>在业务开发中，我们可以循环的调用XREAD阻塞方式来查询最新消息，从而实现持续监听队列的效果，伪代码如下</p>
<p><img src="/2022/09/24/redis%E5%AE%9E%E6%88%98%E7%AF%87/1653577689129.png" alt="1653577689129"></p>
<p>注意：当我们指定起始ID为$时，代表读取最新的消息，如果我们处理一条消息的过程中，又有超过1条以上的消息到达队列，则下次获取时也只能获取到最新的一条，会出现漏读消息的问题</p>
<p>STREAM类型消息队列的XREAD命令特点：</p>
<ul>
<li>消息可回溯</li>
<li>一个消息可以被多个消费者读取</li>
<li>可以阻塞读取</li>
<li>有消息漏读的风险</li>
</ul>
<h3 id="7-5-Redis消息队列-基于Stream的消息队列-消费者组"><a href="#7-5-Redis消息队列-基于Stream的消息队列-消费者组" class="headerlink" title="7.5 Redis消息队列-基于Stream的消息队列-消费者组"></a>7.5 Redis消息队列-基于Stream的消息队列-消费者组</h3><p>消费者组（Consumer Group）：将多个消费者划分到一个组中，监听同一个队列。具备下列特点：</p>
<p><img src="/2022/09/24/redis%E5%AE%9E%E6%88%98%E7%AF%87/1653577801668.png" alt="1653577801668"></p>
<p>创建消费者组：<br><img src="/2022/09/24/redis%E5%AE%9E%E6%88%98%E7%AF%87/1653577984924.png" alt="1653577984924"><br>key：队列名称<br>groupName：消费者组名称<br>ID：起始ID标示，$代表队列中最后一个消息，0则代表队列中第一个消息<br>MKSTREAM：队列不存在时自动创建队列<br>其它常见命令：</p>
<p> <strong>删除指定的消费者组</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">XGROUP DESTORY key groupName</span><br></pre></td></tr></table></figure>

<p> <strong>给指定的消费者组添加消费者</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">XGROUP CREATECONSUMER key groupname consumername</span><br></pre></td></tr></table></figure>

<p> <strong>删除消费者组中的指定消费者</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">XGROUP DELCONSUMER key groupname consumername</span><br></pre></td></tr></table></figure>

<p>从消费者组读取消息：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">XREADGROUP GROUP group consumer [COUNT count] [BLOCK milliseconds] [NOACK] STREAMS key [key ...] ID [ID ...]</span><br></pre></td></tr></table></figure>

<ul>
<li>group：消费组名称</li>
<li>consumer：消费者名称，如果消费者不存在，会自动创建一个消费者</li>
<li>count：本次查询的最大数量</li>
<li>BLOCK milliseconds：当没有消息时最长等待时间</li>
<li>NOACK：无需手动ACK，获取到消息后自动确认</li>
<li>STREAMS key：指定队列名称</li>
<li>ID：获取消息的起始ID：</li>
</ul>
<p>“&gt;”：从下一个未消费的消息开始<br>其它：根据指定id从pending-list中获取已消费但未确认的消息，例如0，是从pending-list中的第一个消息开始</p>
<p>消费者监听消息的基本思路：</p>
<p><img src="/2022/09/24/redis%E5%AE%9E%E6%88%98%E7%AF%87/1653578211854.png" alt="1653578211854">STREAM类型消息队列的XREADGROUP命令特点：</p>
<ul>
<li>消息可回溯</li>
<li>可以多消费者争抢消息，加快消费速度</li>
<li>可以阻塞读取</li>
<li>没有消息漏读的风险</li>
<li>有消息确认机制，保证消息至少被消费一次</li>
</ul>
<p>最后我们来个小对比</p>
<p><img src="/2022/09/24/redis%E5%AE%9E%E6%88%98%E7%AF%87/1653578560691.png" alt="1653578560691"></p>
<h3 id="7-6-基于Redis的Stream结构作为消息队列，实现异步秒杀下单"><a href="#7-6-基于Redis的Stream结构作为消息队列，实现异步秒杀下单" class="headerlink" title="7.6 基于Redis的Stream结构作为消息队列，实现异步秒杀下单"></a>7.6 基于Redis的Stream结构作为消息队列，实现异步秒杀下单</h3><p>需求：</p>
<ul>
<li>创建一个Stream类型的消息队列，名为stream.orders</li>
<li>修改之前的秒杀下单Lua脚本，在认定有抢购资格后，直接向stream.orders中添加消息，内容包含voucherId、userId、orderId</li>
<li>项目启动时，开启一个线程任务，尝试获取stream.orders中的消息，完成下单\</li>
</ul>
<p>修改lua表达式,新增3.6 </p>
<p><img src="/2022/09/24/redis%E5%AE%9E%E6%88%98%E7%AF%87/1656082824939.png" alt="1656082824939"></p>
<p>VoucherOrderServiceImpl</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">VoucherOrderHandler</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 1.获取消息队列中的订单信息 XREADGROUP GROUP g1 c1 COUNT 1 BLOCK 2000 STREAMS s1 &gt;</span></span><br><span class="line">                List&lt;MapRecord&lt;String, Object, Object&gt;&gt; list = stringRedisTemplate.opsForStream().read(</span><br><span class="line">                    Consumer.from(<span class="string">&quot;g1&quot;</span>, <span class="string">&quot;c1&quot;</span>),</span><br><span class="line">                    StreamReadOptions.empty().count(<span class="number">1</span>).block(Duration.ofSeconds(<span class="number">2</span>)),</span><br><span class="line">                    StreamOffset.create(<span class="string">&quot;stream.orders&quot;</span>, ReadOffset.lastConsumed())</span><br><span class="line">                );</span><br><span class="line">                <span class="comment">// 2.判断订单信息是否为空</span></span><br><span class="line">                <span class="keyword">if</span> (list == <span class="literal">null</span> || list.isEmpty()) &#123;</span><br><span class="line">                    <span class="comment">// 如果为null，说明没有消息，继续下一次循环</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 解析数据</span></span><br><span class="line">                MapRecord&lt;String, Object, Object&gt; record = list.get(<span class="number">0</span>);</span><br><span class="line">                Map&lt;Object, Object&gt; value = record.getValue();</span><br><span class="line">                <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> BeanUtil.fillBeanWithMap(value, <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>(), <span class="literal">true</span>);</span><br><span class="line">                <span class="comment">// 3.创建订单</span></span><br><span class="line">                createVoucherOrder(voucherOrder);</span><br><span class="line">                <span class="comment">// 4.确认消息 XACK</span></span><br><span class="line">                stringRedisTemplate.opsForStream().acknowledge(<span class="string">&quot;s1&quot;</span>, <span class="string">&quot;g1&quot;</span>, record.getId());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                log.error(<span class="string">&quot;处理订单异常&quot;</span>, e);</span><br><span class="line">                <span class="comment">//处理异常消息</span></span><br><span class="line">                handlePendingList();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handlePendingList</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 1.获取pending-list中的订单信息 XREADGROUP GROUP g1 c1 COUNT 1 BLOCK 2000 STREAMS s1 0</span></span><br><span class="line">                List&lt;MapRecord&lt;String, Object, Object&gt;&gt; list = stringRedisTemplate.opsForStream().read(</span><br><span class="line">                    Consumer.from(<span class="string">&quot;g1&quot;</span>, <span class="string">&quot;c1&quot;</span>),</span><br><span class="line">                    StreamReadOptions.empty().count(<span class="number">1</span>),</span><br><span class="line">                    StreamOffset.create(<span class="string">&quot;stream.orders&quot;</span>, ReadOffset.from(<span class="string">&quot;0&quot;</span>))</span><br><span class="line">                );</span><br><span class="line">                <span class="comment">// 2.判断订单信息是否为空</span></span><br><span class="line">                <span class="keyword">if</span> (list == <span class="literal">null</span> || list.isEmpty()) &#123;</span><br><span class="line">                    <span class="comment">// 如果为null，说明没有异常消息，结束循环</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 解析数据</span></span><br><span class="line">                MapRecord&lt;String, Object, Object&gt; record = list.get(<span class="number">0</span>);</span><br><span class="line">                Map&lt;Object, Object&gt; value = record.getValue();</span><br><span class="line">                <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> BeanUtil.fillBeanWithMap(value, <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>(), <span class="literal">true</span>);</span><br><span class="line">                <span class="comment">// 3.创建订单</span></span><br><span class="line">                createVoucherOrder(voucherOrder);</span><br><span class="line">                <span class="comment">// 4.确认消息 XACK</span></span><br><span class="line">                stringRedisTemplate.opsForStream().acknowledge(<span class="string">&quot;s1&quot;</span>, <span class="string">&quot;g1&quot;</span>, record.getId());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                log.error(<span class="string">&quot;处理pendding订单异常&quot;</span>, e);</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    Thread.sleep(<span class="number">20</span>);</span><br><span class="line">                &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="8、达人探店"><a href="#8、达人探店" class="headerlink" title="8、达人探店"></a>8、达人探店</h2><h3 id="8-1、达人探店-发布探店笔记"><a href="#8-1、达人探店-发布探店笔记" class="headerlink" title="8.1、达人探店-发布探店笔记"></a>8.1、达人探店-发布探店笔记</h3><p>发布探店笔记</p>
<p>探店笔记类似点评网站的评价，往往是图文结合。对应的表有两个：<br>tb_blog：探店笔记表，包含笔记中的标题、文字、图片等<br>tb_blog_comments：其他用户对探店笔记的评价</p>
<p><strong>具体发布流程</strong></p>
<p><img src="/2022/09/24/redis%E5%AE%9E%E6%88%98%E7%AF%87/1653578992639.png" alt="1653578992639"></p>
<p>上传接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;upload&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UploadController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;blog&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">uploadImage</span><span class="params">(<span class="meta">@RequestParam(&quot;file&quot;)</span> MultipartFile image)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取原始文件名称</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">originalFilename</span> <span class="operator">=</span> image.getOriginalFilename();</span><br><span class="line">            <span class="comment">// 生成新文件名</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> createNewFileName(originalFilename);</span><br><span class="line">            <span class="comment">// 保存文件</span></span><br><span class="line">            image.transferTo(<span class="keyword">new</span> <span class="title class_">File</span>(SystemConstants.IMAGE_UPLOAD_DIR, fileName));</span><br><span class="line">            <span class="comment">// 返回结果</span></span><br><span class="line">            log.debug(<span class="string">&quot;文件上传成功，&#123;&#125;&quot;</span>, fileName);</span><br><span class="line">            <span class="keyword">return</span> Result.ok(fileName);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;文件上传失败&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：同学们在操作时，需要修改SystemConstants.IMAGE_UPLOAD_DIR 自己图片所在的地址，在实际开发中图片一般会放在nginx上或者是云存储上。</p>
<p>BlogController</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/blog&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BlogController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> IBlogService blogService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">saveBlog</span><span class="params">(<span class="meta">@RequestBody</span> Blog blog)</span> &#123;</span><br><span class="line">        <span class="comment">//获取登录用户</span></span><br><span class="line">        <span class="type">UserDTO</span> <span class="variable">user</span> <span class="operator">=</span> UserHolder.getUser();</span><br><span class="line">        blog.setUpdateTime(user.getId());</span><br><span class="line">        <span class="comment">//保存探店博文</span></span><br><span class="line">        blogService.saveBlog(blog);</span><br><span class="line">        <span class="comment">//返回id</span></span><br><span class="line">        <span class="keyword">return</span> Result.ok(blog.getId());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8-2-达人探店-查看探店笔记"><a href="#8-2-达人探店-查看探店笔记" class="headerlink" title="8.2 达人探店-查看探店笔记"></a>8.2 达人探店-查看探店笔记</h3><p>实现查看发布探店笔记的接口</p>
<p><img src="/2022/09/24/redis%E5%AE%9E%E6%88%98%E7%AF%87/1653579931626.png" alt="1653579931626"></p>
<p>实现代码：</p>
<p>BlogServiceImpl</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryBlogById</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.查询blog</span></span><br><span class="line">    <span class="type">Blog</span> <span class="variable">blog</span> <span class="operator">=</span> getById(id);</span><br><span class="line">    <span class="keyword">if</span> (blog == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;笔记不存在！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2.查询blog有关的用户</span></span><br><span class="line">    queryBlogUser(blog);</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> Result.ok(blog);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8-3-达人探店-点赞功能"><a href="#8-3-达人探店-点赞功能" class="headerlink" title="8.3 达人探店-点赞功能"></a>8.3 达人探店-点赞功能</h3><p>初始代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/likes/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryBlogLikes</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span> &#123;</span><br><span class="line">    <span class="comment">//修改点赞数量</span></span><br><span class="line">    blogService.update().setSql(<span class="string">&quot;liked = liked +1 &quot;</span>).eq(<span class="string">&quot;id&quot;</span>,id).update();</span><br><span class="line">    <span class="keyword">return</span> Result.ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>问题分析：这种方式会导致一个用户无限点赞，明显是不合理的</p>
<p>造成这个问题的原因是，我们现在的逻辑，发起请求只是给数据库+1，所以才会出现这个问题</p>
<p><img src="/2022/09/24/redis%E5%AE%9E%E6%88%98%E7%AF%87/1653581590453.png" alt="1653581590453"></p>
<p>完善点赞功能</p>
<p>需求：</p>
<ul>
<li>同一个用户只能点赞一次，再次点击则取消点赞</li>
<li>如果当前用户已经点赞，则点赞按钮高亮显示（前端已实现，判断字段Blog类的isLike属性）</li>
</ul>
<p>实现步骤：</p>
<ul>
<li>给Blog类中添加一个isLike字段，标示是否被当前用户点赞</li>
<li>修改点赞功能，利用Redis的set集合判断是否点赞过，未点赞过则点赞数+1，已点赞过则点赞数-1</li>
<li>修改根据id查询Blog的业务，判断当前登录用户是否点赞过，赋值给isLike字段</li>
<li>修改分页查询Blog业务，判断当前登录用户是否点赞过，赋值给isLike字段</li>
</ul>
<p>为什么采用set集合：</p>
<p>因为我们的数据是不能重复的，当用户操作过之后，无论他怎么操作，都是</p>
<p>具体步骤：</p>
<p>1、在Blog 添加一个字段</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@TableField(exist = false)</span></span><br><span class="line"><span class="keyword">private</span> Boolean isLike;</span><br></pre></td></tr></table></figure>

<p>2、修改代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> Result <span class="title function_">likeBlog</span><span class="params">(Long id)</span>&#123;</span><br><span class="line">       <span class="comment">// 1.获取登录用户</span></span><br><span class="line">       <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">       <span class="comment">// 2.判断当前登录用户是否已经点赞</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> BLOG_LIKED_KEY + id;</span><br><span class="line">       <span class="type">Boolean</span> <span class="variable">isMember</span> <span class="operator">=</span> stringRedisTemplate.opsForSet().isMember(key, userId.toString());</span><br><span class="line">       <span class="keyword">if</span>(BooleanUtil.isFalse(isMember))&#123;</span><br><span class="line">            <span class="comment">//3.如果未点赞，可以点赞</span></span><br><span class="line">           <span class="comment">//3.1 数据库点赞数+1</span></span><br><span class="line">           <span class="type">boolean</span> <span class="variable">isSuccess</span> <span class="operator">=</span> update().setSql(<span class="string">&quot;liked = liked + 1&quot;</span>).eq(<span class="string">&quot;id&quot;</span>, id).update();</span><br><span class="line">           <span class="comment">//3.2 保存用户到Redis的set集合</span></span><br><span class="line">           <span class="keyword">if</span>(isSuccess)&#123;</span><br><span class="line">               stringRedisTemplate.opsForSet().add(key,userId.toString());</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//4.如果已点赞，取消点赞</span></span><br><span class="line">           <span class="comment">//4.1 数据库点赞数-1</span></span><br><span class="line">           <span class="type">boolean</span> <span class="variable">isSuccess</span> <span class="operator">=</span> update().setSql(<span class="string">&quot;liked = liked - 1&quot;</span>).eq(<span class="string">&quot;id&quot;</span>, id).update();</span><br><span class="line">           <span class="comment">//4.2 把用户从Redis的set集合移除</span></span><br><span class="line">           <span class="keyword">if</span>(isSuccess)&#123;</span><br><span class="line">               stringRedisTemplate.opsForSet().remove(key,userId.toString());</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<h3 id="8-4-达人探店-点赞排行榜"><a href="#8-4-达人探店-点赞排行榜" class="headerlink" title="8.4 达人探店-点赞排行榜"></a>8.4 达人探店-点赞排行榜</h3><p>在探店笔记的详情页面，应该把给该笔记点赞的人显示出来，比如最早点赞的TOP5，形成点赞排行榜：</p>
<p>之前的点赞是放到set集合，但是set集合是不能排序的，所以这个时候，咱们可以采用一个可以排序的set集合，就是咱们的sortedSet</p>
<p><img src="/2022/09/24/redis%E5%AE%9E%E6%88%98%E7%AF%87/1653805077118.png" alt="1653805077118"></p>
<p>我们接下来来对比一下这些集合的区别是什么</p>
<p>所有点赞的人，需要是唯一的，所以我们应当使用set或者是sortedSet</p>
<p>其次我们需要排序，就可以直接锁定使用sortedSet啦</p>
<p><img src="/2022/09/24/redis%E5%AE%9E%E6%88%98%E7%AF%87/1653805203758.png" alt="1653805203758"></p>
<p>修改代码</p>
<p>BlogServiceImpl</p>
<p>点赞逻辑代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> Result <span class="title function_">likeBlog</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">     <span class="comment">// 1.获取登录用户</span></span><br><span class="line">     <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">     <span class="comment">// 2.判断当前登录用户是否已经点赞</span></span><br><span class="line">     <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> BLOG_LIKED_KEY + id;</span><br><span class="line">     <span class="type">Double</span> <span class="variable">score</span> <span class="operator">=</span> stringRedisTemplate.opsForZSet().score(key, userId.toString());</span><br><span class="line">     <span class="keyword">if</span> (score == <span class="literal">null</span>) &#123;</span><br><span class="line">         <span class="comment">// 3.如果未点赞，可以点赞</span></span><br><span class="line">         <span class="comment">// 3.1.数据库点赞数 + 1</span></span><br><span class="line">         <span class="type">boolean</span> <span class="variable">isSuccess</span> <span class="operator">=</span> update().setSql(<span class="string">&quot;liked = liked + 1&quot;</span>).eq(<span class="string">&quot;id&quot;</span>, id).update();</span><br><span class="line">         <span class="comment">// 3.2.保存用户到Redis的set集合  zadd key value score</span></span><br><span class="line">         <span class="keyword">if</span> (isSuccess) &#123;</span><br><span class="line">             stringRedisTemplate.opsForZSet().add(key, userId.toString(), System.currentTimeMillis());</span><br><span class="line">         &#125;</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// 4.如果已点赞，取消点赞</span></span><br><span class="line">         <span class="comment">// 4.1.数据库点赞数 -1</span></span><br><span class="line">         <span class="type">boolean</span> <span class="variable">isSuccess</span> <span class="operator">=</span> update().setSql(<span class="string">&quot;liked = liked - 1&quot;</span>).eq(<span class="string">&quot;id&quot;</span>, id).update();</span><br><span class="line">         <span class="comment">// 4.2.把用户从Redis的set集合移除</span></span><br><span class="line">         <span class="keyword">if</span> (isSuccess) &#123;</span><br><span class="line">             stringRedisTemplate.opsForZSet().remove(key, userId.toString());</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> Result.ok();</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">isBlogLiked</span><span class="params">(Blog blog)</span> &#123;</span><br><span class="line">     <span class="comment">// 1.获取登录用户</span></span><br><span class="line">     <span class="type">UserDTO</span> <span class="variable">user</span> <span class="operator">=</span> UserHolder.getUser();</span><br><span class="line">     <span class="keyword">if</span> (user == <span class="literal">null</span>) &#123;</span><br><span class="line">         <span class="comment">// 用户未登录，无需查询是否点赞</span></span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> user.getId();</span><br><span class="line">     <span class="comment">// 2.判断当前登录用户是否已经点赞</span></span><br><span class="line">     <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;blog:liked:&quot;</span> + blog.getId();</span><br><span class="line">     <span class="type">Double</span> <span class="variable">score</span> <span class="operator">=</span> stringRedisTemplate.opsForZSet().score(key, userId.toString());</span><br><span class="line">     blog.setIsLike(score != <span class="literal">null</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>点赞列表查询列表</p>
<p>BlogController</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/likes/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryBlogLikes</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> blogService.queryBlogLikes(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>BlogService</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryBlogLikes</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> BLOG_LIKED_KEY + id;</span><br><span class="line">    <span class="comment">// 1.查询top5的点赞用户 zrange key 0 4</span></span><br><span class="line">    Set&lt;String&gt; top5 = stringRedisTemplate.opsForZSet().range(key, <span class="number">0</span>, <span class="number">4</span>);</span><br><span class="line">    <span class="keyword">if</span> (top5 == <span class="literal">null</span> || top5.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.ok(Collections.emptyList());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2.解析出其中的用户id</span></span><br><span class="line">    List&lt;Long&gt; ids = top5.stream().map(Long::valueOf).collect(Collectors.toList());</span><br><span class="line">    <span class="type">String</span> <span class="variable">idStr</span> <span class="operator">=</span> StrUtil.join(<span class="string">&quot;,&quot;</span>, ids);</span><br><span class="line">    <span class="comment">// 3.根据用户id查询用户 WHERE id IN ( 5 , 1 ) ORDER BY FIELD(id, 5, 1)</span></span><br><span class="line">    List&lt;UserDTO&gt; userDTOS = userService.query()</span><br><span class="line">            .in(<span class="string">&quot;id&quot;</span>, ids).last(<span class="string">&quot;ORDER BY FIELD(id,&quot;</span> + idStr + <span class="string">&quot;)&quot;</span>).list()</span><br><span class="line">            .stream()</span><br><span class="line">            .map(user -&gt; BeanUtil.copyProperties(user, UserDTO.class))</span><br><span class="line">            .collect(Collectors.toList());</span><br><span class="line">    <span class="comment">// 4.返回</span></span><br><span class="line">    <span class="keyword">return</span> Result.ok(userDTOS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="9、好友关注"><a href="#9、好友关注" class="headerlink" title="9、好友关注"></a>9、好友关注</h2><h3 id="9-1-好友关注-关注和取消关注"><a href="#9-1-好友关注-关注和取消关注" class="headerlink" title="9.1 好友关注-关注和取消关注"></a>9.1 好友关注-关注和取消关注</h3><p>针对用户的操作：可以对用户进行关注和取消关注功能。</p>
<p><img src="/2022/09/24/redis%E5%AE%9E%E6%88%98%E7%AF%87/1653806140822.png" alt="1653806140822"></p>
<p>实现思路：</p>
<p>需求：基于该表数据结构，实现两个接口：</p>
<ul>
<li>关注和取关接口</li>
<li>判断是否关注的接口</li>
</ul>
<p>关注是User之间的关系，是博主与粉丝的关系，数据库中有一张tb_follow表来标示：</p>
<p><img src="/2022/09/24/redis%E5%AE%9E%E6%88%98%E7%AF%87/1653806253817.png" alt="1653806253817"></p>
<p>注意: 这里需要把主键修改为自增长，简化开发。</p>
<p>FollowController</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//关注</span></span><br><span class="line"><span class="meta">@PutMapping(&quot;/&#123;id&#125;/&#123;isFollow&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">follow</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long followUserId, <span class="meta">@PathVariable(&quot;isFollow&quot;)</span> Boolean isFollow)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> followService.follow(followUserId, isFollow);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//取消关注</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/or/not/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">isFollow</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long followUserId)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> followService.isFollow(followUserId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>FollowService</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">取消关注service</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">isFollow</span><span class="params">(Long followUserId)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.获取登录用户</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">        <span class="comment">// 2.查询是否关注 select count(*) from tb_follow where user_id = ? and follow_user_id = ?</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">count</span> <span class="operator">=</span> query().eq(<span class="string">&quot;user_id&quot;</span>, userId).eq(<span class="string">&quot;follow_user_id&quot;</span>, followUserId).count();</span><br><span class="line">        <span class="comment">// 3.判断</span></span><br><span class="line">        <span class="keyword">return</span> Result.ok(count &gt; <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> 关注service</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">follow</span><span class="params">(Long followUserId, Boolean isFollow)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.获取登录用户</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;follows:&quot;</span> + userId;</span><br><span class="line">        <span class="comment">// 1.判断到底是关注还是取关</span></span><br><span class="line">        <span class="keyword">if</span> (isFollow) &#123;</span><br><span class="line">            <span class="comment">// 2.关注，新增数据</span></span><br><span class="line">            <span class="type">Follow</span> <span class="variable">follow</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Follow</span>();</span><br><span class="line">            follow.setUserId(userId);</span><br><span class="line">            follow.setFollowUserId(followUserId);</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">isSuccess</span> <span class="operator">=</span> save(follow);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 3.取关，删除 delete from tb_follow where user_id = ? and follow_user_id = ?</span></span><br><span class="line">            remove(<span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;Follow&gt;()</span><br><span class="line">                    .eq(<span class="string">&quot;user_id&quot;</span>, userId).eq(<span class="string">&quot;follow_user_id&quot;</span>, followUserId));</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Result.ok();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="9-2-好友关注-共同关注"><a href="#9-2-好友关注-共同关注" class="headerlink" title="9.2 好友关注-共同关注"></a>9.2 好友关注-共同关注</h3><p>想要去看共同关注的好友，需要首先进入到这个页面，这个页面会发起两个请求</p>
<p>1、去查询用户的详情</p>
<p>2、去查询用户的笔记</p>
<p>以上两个功能和共同关注没有什么关系，大家可以自行将笔记中的代码拷贝到idea中就可以实现这两个功能了，我们的重点在于共同关注功能。</p>
<p><img src="/2022/09/24/redis%E5%AE%9E%E6%88%98%E7%AF%87/1653806706296.png" alt="1653806706296"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// UserController 根据id查询用户</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryUserById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long userId)</span>&#123;</span><br><span class="line">	<span class="comment">// 查询详情</span></span><br><span class="line">	<span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userService.getById(userId);</span><br><span class="line">	<span class="keyword">if</span> (user == <span class="literal">null</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> Result.ok();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">UserDTO</span> <span class="variable">userDTO</span> <span class="operator">=</span> BeanUtil.copyProperties(user, UserDTO.class);</span><br><span class="line">	<span class="comment">// 返回</span></span><br><span class="line">	<span class="keyword">return</span> Result.ok(userDTO);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// BlogController  根据id查询博主的探店笔记</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/of/user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryBlogByUserId</span><span class="params">(</span></span><br><span class="line"><span class="params">		<span class="meta">@RequestParam(value = &quot;current&quot;, defaultValue = &quot;1&quot;)</span> Integer current,</span></span><br><span class="line"><span class="params">		<span class="meta">@RequestParam(&quot;id&quot;)</span> Long id)</span> &#123;</span><br><span class="line">	<span class="comment">// 根据用户查询</span></span><br><span class="line">	Page&lt;Blog&gt; page = blogService.query()</span><br><span class="line">			.eq(<span class="string">&quot;user_id&quot;</span>, id).page(<span class="keyword">new</span> <span class="title class_">Page</span>&lt;&gt;(current, SystemConstants.MAX_PAGE_SIZE));</span><br><span class="line">	<span class="comment">// 获取当前页数据</span></span><br><span class="line">	List&lt;Blog&gt; records = page.getRecords();</span><br><span class="line">	<span class="keyword">return</span> Result.ok(records);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来我们来看看共同关注如何实现：</p>
<p>需求：利用Redis中恰当的数据结构，实现共同关注功能。在博主个人页面展示出当前用户与博主的共同关注呢。</p>
<p>当然是使用我们之前学习过的set集合咯，在set集合中，有交集并集补集的api，我们可以把两人的关注的人分别放入到一个set集合中，然后再通过api去查看这两个set集合中的交集数据。</p>
<p><img src="/2022/09/24/redis%E5%AE%9E%E6%88%98%E7%AF%87/1653806973212.png" alt="1653806973212"></p>
<p>我们先来改造当前的关注列表</p>
<p>改造原因是因为我们需要在用户关注了某位用户后，需要将数据放入到set集合中，方便后续进行共同关注，同时当取消关注时，也需要从set集合中进行删除</p>
<p>FollowServiceImpl</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">follow</span><span class="params">(Long followUserId, Boolean isFollow)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.获取登录用户</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;follows:&quot;</span> + userId;</span><br><span class="line">    <span class="comment">// 1.判断到底是关注还是取关</span></span><br><span class="line">    <span class="keyword">if</span> (isFollow) &#123;</span><br><span class="line">        <span class="comment">// 2.关注，新增数据</span></span><br><span class="line">        <span class="type">Follow</span> <span class="variable">follow</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Follow</span>();</span><br><span class="line">        follow.setUserId(userId);</span><br><span class="line">        follow.setFollowUserId(followUserId);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isSuccess</span> <span class="operator">=</span> save(follow);</span><br><span class="line">        <span class="keyword">if</span> (isSuccess) &#123;</span><br><span class="line">            <span class="comment">// 把关注用户的id，放入redis的set集合 sadd userId followerUserId</span></span><br><span class="line">            stringRedisTemplate.opsForSet().add(key, followUserId.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 3.取关，删除 delete from tb_follow where user_id = ? and follow_user_id = ?</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isSuccess</span> <span class="operator">=</span> remove(<span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;Follow&gt;()</span><br><span class="line">                .eq(<span class="string">&quot;user_id&quot;</span>, userId).eq(<span class="string">&quot;follow_user_id&quot;</span>, followUserId));</span><br><span class="line">        <span class="keyword">if</span> (isSuccess) &#123;</span><br><span class="line">            <span class="comment">// 把关注用户的id从Redis集合中移除</span></span><br><span class="line">            stringRedisTemplate.opsForSet().remove(key, followUserId.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Result.ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>具体的关注代码：</strong></p>
<p>FollowServiceImpl</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">followCommons</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.获取当前用户</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;follows:&quot;</span> + userId;</span><br><span class="line">    <span class="comment">// 2.求交集</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">key2</span> <span class="operator">=</span> <span class="string">&quot;follows:&quot;</span> + id;</span><br><span class="line">    Set&lt;String&gt; intersect = stringRedisTemplate.opsForSet().intersect(key, key2);</span><br><span class="line">    <span class="keyword">if</span> (intersect == <span class="literal">null</span> || intersect.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// 无交集</span></span><br><span class="line">        <span class="keyword">return</span> Result.ok(Collections.emptyList());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3.解析id集合</span></span><br><span class="line">    List&lt;Long&gt; ids = intersect.stream().map(Long::valueOf).collect(Collectors.toList());</span><br><span class="line">    <span class="comment">// 4.查询用户</span></span><br><span class="line">    List&lt;UserDTO&gt; users = userService.listByIds(ids)</span><br><span class="line">            .stream()</span><br><span class="line">            .map(user -&gt; BeanUtil.copyProperties(user, UserDTO.class))</span><br><span class="line">            .collect(Collectors.toList());</span><br><span class="line">    <span class="keyword">return</span> Result.ok(users);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="9-3-好友关注-Feed流实现方案"><a href="#9-3-好友关注-Feed流实现方案" class="headerlink" title="9.3 好友关注-Feed流实现方案"></a>9.3 好友关注-Feed流实现方案</h3><p>当我们关注了用户后，这个用户发了动态，那么我们应该把这些数据推送给用户，这个需求，其实我们又把他叫做Feed流，关注推送也叫做Feed流，直译为投喂。为用户持续的提供“沉浸式”的体验，通过无限下拉刷新获取新的信息。</p>
<p>对于传统的模式的内容解锁：我们是需要用户去通过搜索引擎或者是其他的方式去解锁想要看的内容</p>
<p><img src="/2022/09/24/redis%E5%AE%9E%E6%88%98%E7%AF%87/1653808641260.png" alt="1653808641260"></p>
<p>对于新型的Feed流的的效果：不需要我们用户再去推送信息，而是系统分析用户到底想要什么，然后直接把内容推送给用户，从而使用户能够更加的节约时间，不用主动去寻找。</p>
<p><img src="/2022/09/24/redis%E5%AE%9E%E6%88%98%E7%AF%87/1653808993693.png" alt="1653808993693"></p>
<p>Feed流的实现有两种模式：</p>
<p>Feed流产品有两种常见模式：<br>Timeline：不做内容筛选，简单的按照内容发布时间排序，常用于好友或关注。例如朋友圈</p>
<ul>
<li>优点：信息全面，不会有缺失。并且实现也相对简单</li>
<li>缺点：信息噪音较多，用户不一定感兴趣，内容获取效率低</li>
</ul>
<p>智能排序：利用智能算法屏蔽掉违规的、用户不感兴趣的内容。推送用户感兴趣信息来吸引用户</p>
<ul>
<li>优点：投喂用户感兴趣信息，用户粘度很高，容易沉迷</li>
<li>缺点：如果算法不精准，可能起到反作用<br>本例中的个人页面，是基于关注的好友来做Feed流，因此采用Timeline的模式。该模式的实现方案有三种：</li>
</ul>
<p>我们本次针对好友的操作，采用的就是Timeline的方式，只需要拿到我们关注用户的信息，然后按照时间排序即可</p>
<p>，因此采用Timeline的模式。该模式的实现方案有三种：</p>
<ul>
<li>拉模式</li>
<li>推模式</li>
<li>推拉结合</li>
</ul>
<p><strong>拉模式</strong>：也叫做读扩散</p>
<p>该模式的核心含义就是：当张三和李四和王五发了消息后，都会保存在自己的邮箱中，假设赵六要读取信息，那么他会从读取他自己的收件箱，此时系统会从他关注的人群中，把他关注人的信息全部都进行拉取，然后在进行排序</p>
<p>优点：比较节约空间，因为赵六在读信息时，并没有重复读取，而且读取完之后可以把他的收件箱进行清楚。</p>
<p>缺点：比较延迟，当用户读取数据时才去关注的人里边去读取数据，假设用户关注了大量的用户，那么此时就会拉取海量的内容，对服务器压力巨大。</p>
<p><img src="/2022/09/24/redis%E5%AE%9E%E6%88%98%E7%AF%87/1653809450816.png" alt="1653809450816"></p>
<p><strong>推模式</strong>：也叫做写扩散。</p>
<p>推模式是没有写邮箱的，当张三写了一个内容，此时会主动的把张三写的内容发送到他的粉丝收件箱中去，假设此时李四再来读取，就不用再去临时拉取了</p>
<p>优点：时效快，不用临时拉取</p>
<p>缺点：内存压力大，假设一个大V写信息，很多人关注他， 就会写很多分数据到粉丝那边去</p>
<p><img src="/2022/09/24/redis%E5%AE%9E%E6%88%98%E7%AF%87/1653809875208.png" alt="1653809875208"></p>
<p><strong>推拉结合模式</strong>：也叫做读写混合，兼具推和拉两种模式的优点。</p>
<p>推拉模式是一个折中的方案，站在发件人这一段，如果是个普通的人，那么我们采用写扩散的方式，直接把数据写入到他的粉丝中去，因为普通的人他的粉丝关注量比较小，所以这样做没有压力，如果是大V，那么他是直接将数据先写入到一份到发件箱里边去，然后再直接写一份到活跃粉丝收件箱里边去，现在站在收件人这端来看，如果是活跃粉丝，那么大V和普通的人发的都会直接写入到自己收件箱里边来，而如果是普通的粉丝，由于他们上线不是很频繁，所以等他们上线时，再从发件箱里边去拉信息。</p>
<p><img src="/2022/09/24/redis%E5%AE%9E%E6%88%98%E7%AF%87/1653812346852.png" alt="1653812346852"></p>
<h3 id="9-4-好友关注-推送到粉丝收件箱"><a href="#9-4-好友关注-推送到粉丝收件箱" class="headerlink" title="9.4 好友关注-推送到粉丝收件箱"></a>9.4 好友关注-推送到粉丝收件箱</h3><p>需求：</p>
<ul>
<li>修改新增探店笔记的业务，在保存blog到数据库的同时，推送到粉丝的收件箱</li>
<li>收件箱满足可以根据时间戳排序，必须用Redis的数据结构实现</li>
<li>查询收件箱数据时，可以实现分页查询</li>
</ul>
<p>Feed流中的数据会不断更新，所以数据的角标也在变化，因此不能采用传统的分页模式。</p>
<p>传统了分页在feed流是不适用的，因为我们的数据会随时发生变化</p>
<p>假设在t1 时刻，我们去读取第一页，此时page &#x3D; 1 ，size &#x3D; 5 ，那么我们拿到的就是10<del>6 这几条记录，假设现在t2时候又发布了一条记录，此时t3 时刻，我们来读取第二页，读取第二页传入的参数是page&#x3D;2 ，size&#x3D;5 ，那么此时读取到的第二页实际上是从6 开始，然后是6</del>2 ，那么我们就读取到了重复的数据，所以feed流的分页，不能采用原始方案来做。</p>
<p><img src="/2022/09/24/redis%E5%AE%9E%E6%88%98%E7%AF%87/1653813047671.png" alt="1653813047671"></p>
<p>Feed流的滚动分页</p>
<p>我们需要记录每次操作的最后一条，然后从这个位置开始去读取数据</p>
<p>举个例子：我们从t1时刻开始，拿第一页数据，拿到了10~6，然后记录下当前最后一次拿取的记录，就是6，t2时刻发布了新的记录，此时这个11放到最顶上，但是不会影响我们之前记录的6，此时t3时刻来拿第二页，第二页这个时候拿数据，还是从6后一点的5去拿，就拿到了5-1的记录。我们这个地方可以采用sortedSet来做，可以进行范围查询，并且还可以记录当前获取数据时间戳最小值，就可以实现滚动分页了</p>
<p><img src="/2022/09/24/redis%E5%AE%9E%E6%88%98%E7%AF%87/1653813462834.png" alt="1653813462834"></p>
<p>核心的意思：就是我们在保存完探店笔记后，获得到当前笔记的粉丝，然后把数据推送到粉丝的redis中去。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">saveBlog</span><span class="params">(Blog blog)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.获取登录用户</span></span><br><span class="line">    <span class="type">UserDTO</span> <span class="variable">user</span> <span class="operator">=</span> UserHolder.getUser();</span><br><span class="line">    blog.setUserId(user.getId());</span><br><span class="line">    <span class="comment">// 2.保存探店笔记</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isSuccess</span> <span class="operator">=</span> save(blog);</span><br><span class="line">    <span class="keyword">if</span>(!isSuccess)&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;新增笔记失败!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3.查询笔记作者的所有粉丝 select * from tb_follow where follow_user_id = ?</span></span><br><span class="line">    List&lt;Follow&gt; follows = followService.query().eq(<span class="string">&quot;follow_user_id&quot;</span>, user.getId()).list();</span><br><span class="line">    <span class="comment">// 4.推送笔记id给所有粉丝</span></span><br><span class="line">    <span class="keyword">for</span> (Follow follow : follows) &#123;</span><br><span class="line">        <span class="comment">// 4.1.获取粉丝id</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> follow.getUserId();</span><br><span class="line">        <span class="comment">// 4.2.推送</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> FEED_KEY + userId;</span><br><span class="line">        stringRedisTemplate.opsForZSet().add(key, blog.getId().toString(), System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 5.返回id</span></span><br><span class="line">    <span class="keyword">return</span> Result.ok(blog.getId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="9-5好友关注-实现分页查询收邮箱"><a href="#9-5好友关注-实现分页查询收邮箱" class="headerlink" title="9.5好友关注-实现分页查询收邮箱"></a>9.5好友关注-实现分页查询收邮箱</h3><p>需求：在个人主页的“关注”卡片中，查询并展示推送的Blog信息：</p>
<p>具体操作如下：</p>
<p>1、每次查询完成后，我们要分析出查询出数据的最小时间戳，这个值会作为下一次查询的条件</p>
<p>2、我们需要找到与上一次查询相同的查询个数作为偏移量，下次查询时，跳过这些查询过的数据，拿到我们需要的数据</p>
<p>综上：我们的请求参数中就需要携带 lastId：上一次查询的最小时间戳 和偏移量这两个参数。</p>
<p>这两个参数第一次会由前端来指定，以后的查询就根据后台结果作为条件，再次传递到后台。</p>
<p><img src="/2022/09/24/redis%E5%AE%9E%E6%88%98%E7%AF%87/1653819821591.png" alt="1653819821591"></p>
<p>一、定义出来具体的返回值实体类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScrollResult</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;?&gt; list;</span><br><span class="line">    <span class="keyword">private</span> Long minTime;</span><br><span class="line">    <span class="keyword">private</span> Integer offset;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>BlogController</p>
<p>注意：RequestParam 表示接受url地址栏传参的注解，当方法上参数的名称和url地址栏不相同时，可以通过RequestParam 来进行指定</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/of/follow&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryBlogOfFollow</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="meta">@RequestParam(&quot;lastId&quot;)</span> Long max, <span class="meta">@RequestParam(value = &quot;offset&quot;, defaultValue = &quot;0&quot;)</span> Integer offset)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> blogService.queryBlogOfFollow(max, offset);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>BlogServiceImpl</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryBlogOfFollow</span><span class="params">(Long max, Integer offset)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.获取当前用户</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">    <span class="comment">// 2.查询收件箱 ZREVRANGEBYSCORE key Max Min LIMIT offset count</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> FEED_KEY + userId;</span><br><span class="line">    Set&lt;ZSetOperations.TypedTuple&lt;String&gt;&gt; typedTuples = stringRedisTemplate.opsForZSet()</span><br><span class="line">        .reverseRangeByScoreWithScores(key, <span class="number">0</span>, max, offset, <span class="number">2</span>);</span><br><span class="line">    <span class="comment">// 3.非空判断</span></span><br><span class="line">    <span class="keyword">if</span> (typedTuples == <span class="literal">null</span> || typedTuples.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.ok();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4.解析数据：blogId、minTime（时间戳）、offset</span></span><br><span class="line">    List&lt;Long&gt; ids = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(typedTuples.size());</span><br><span class="line">    <span class="type">long</span> <span class="variable">minTime</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 2</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">os</span> <span class="operator">=</span> <span class="number">1</span>; <span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">for</span> (ZSetOperations.TypedTuple&lt;String&gt; tuple : typedTuples) &#123; <span class="comment">// 5 4 4 2 2</span></span><br><span class="line">        <span class="comment">// 4.1.获取id</span></span><br><span class="line">        ids.add(Long.valueOf(tuple.getValue()));</span><br><span class="line">        <span class="comment">// 4.2.获取分数(时间戳）</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">time</span> <span class="operator">=</span> tuple.getScore().longValue();</span><br><span class="line">        <span class="keyword">if</span>(time == minTime)&#123;</span><br><span class="line">            os++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            minTime = time;</span><br><span class="line">            os = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	os = minTime == max ? os : os + offset;</span><br><span class="line">    <span class="comment">// 5.根据id查询blog</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">idStr</span> <span class="operator">=</span> StrUtil.join(<span class="string">&quot;,&quot;</span>, ids);</span><br><span class="line">    List&lt;Blog&gt; blogs = query().in(<span class="string">&quot;id&quot;</span>, ids).last(<span class="string">&quot;ORDER BY FIELD(id,&quot;</span> + idStr + <span class="string">&quot;)&quot;</span>).list();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Blog blog : blogs) &#123;</span><br><span class="line">        <span class="comment">// 5.1.查询blog有关的用户</span></span><br><span class="line">        queryBlogUser(blog);</span><br><span class="line">        <span class="comment">// 5.2.查询blog是否被点赞</span></span><br><span class="line">        isBlogLiked(blog);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6.封装并返回</span></span><br><span class="line">    <span class="type">ScrollResult</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ScrollResult</span>();</span><br><span class="line">    r.setList(blogs);</span><br><span class="line">    r.setOffset(os);</span><br><span class="line">    r.setMinTime(minTime);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Result.ok(r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="10、附近商户"><a href="#10、附近商户" class="headerlink" title="10、附近商户"></a>10、附近商户</h2><h3 id="10-1、附近商户-GEO数据结构的基本用法"><a href="#10-1、附近商户-GEO数据结构的基本用法" class="headerlink" title="10.1、附近商户-GEO数据结构的基本用法"></a>10.1、附近商户-GEO数据结构的基本用法</h3><p>GEO就是Geolocation的简写形式，代表地理坐标。Redis在3.2版本中加入了对GEO的支持，允许存储地理坐标信息，帮助我们根据经纬度来检索数据。常见的命令有：</p>
<ul>
<li>GEOADD：添加一个地理空间信息，包含：经度（longitude）、纬度（latitude）、值（member）</li>
<li>GEODIST：计算指定的两个点之间的距离并返回</li>
<li>GEOHASH：将指定member的坐标转为hash字符串形式并返回</li>
<li>GEOPOS：返回指定member的坐标</li>
<li>GEORADIUS：指定圆心、半径，找到该圆内包含的所有member，并按照与圆心之间的距离排序后返回。6.以后已废弃</li>
<li>GEOSEARCH：在指定范围内搜索member，并按照与指定点之间的距离排序后返回。范围可以是圆形或矩形。6.2.新功能</li>
<li>GEOSEARCHSTORE：与GEOSEARCH功能一致，不过可以把结果存储到一个指定的key。 6.2.新功能</li>
</ul>
<h3 id="10-2、-附近商户-导入店铺数据到GEO"><a href="#10-2、-附近商户-导入店铺数据到GEO" class="headerlink" title="10.2、 附近商户-导入店铺数据到GEO"></a>10.2、 附近商户-导入店铺数据到GEO</h3><p>具体场景说明：</p>
<p><img src="/2022/09/24/redis%E5%AE%9E%E6%88%98%E7%AF%87/1653822036941.png" alt="1653822036941"></p>
<p>当我们点击美食之后，会出现一系列的商家，商家中可以按照多种排序方式，我们此时关注的是距离，这个地方就需要使用到我们的GEO，向后台传入当前app收集的地址(我们此处是写死的) ，以当前坐标作为圆心，同时绑定相同的店家类型type，以及分页信息，把这几个条件传入后台，后台查询出对应的数据再返回。</p>
<p><img src="/2022/09/24/redis%E5%AE%9E%E6%88%98%E7%AF%87/1653822021827.png" alt="1653822021827"></p>
<p>我们要做的事情是：将数据库表中的数据导入到redis中去，redis中的GEO，GEO在redis中就一个menber和一个经纬度，我们把x和y轴传入到redis做的经纬度位置去，但我们不能把所有的数据都放入到menber中去，毕竟作为redis是一个内存级数据库，如果存海量数据，redis还是力不从心，所以我们在这个地方存储他的id即可。</p>
<p>但是这个时候还有一个问题，就是在redis中并没有存储type，所以我们无法根据type来对数据进行筛选，所以我们可以按照商户类型做分组，类型相同的商户作为同一组，以typeId为key存入同一个GEO集合中即可</p>
<p>代码</p>
<p>HmDianPingApplicationTests</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">loadShopData</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1.查询店铺信息</span></span><br><span class="line">    List&lt;Shop&gt; list = shopService.list();</span><br><span class="line">    <span class="comment">// 2.把店铺分组，按照typeId分组，typeId一致的放到一个集合</span></span><br><span class="line">    Map&lt;Long, List&lt;Shop&gt;&gt; map = list.stream().collect(Collectors.groupingBy(Shop::getTypeId));</span><br><span class="line">    <span class="comment">// 3.分批完成写入Redis</span></span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;Long, List&lt;Shop&gt;&gt; entry : map.entrySet()) &#123;</span><br><span class="line">        <span class="comment">// 3.1.获取类型id</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">typeId</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> SHOP_GEO_KEY + typeId;</span><br><span class="line">        <span class="comment">// 3.2.获取同类型的店铺的集合</span></span><br><span class="line">        List&lt;Shop&gt; value = entry.getValue();</span><br><span class="line">        List&lt;RedisGeoCommands.GeoLocation&lt;String&gt;&gt; locations = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(value.size());</span><br><span class="line">        <span class="comment">// 3.3.写入redis GEOADD key 经度 纬度 member</span></span><br><span class="line">        <span class="keyword">for</span> (Shop shop : value) &#123;</span><br><span class="line">            <span class="comment">// stringRedisTemplate.opsForGeo().add(key, new Point(shop.getX(), shop.getY()), shop.getId().toString());</span></span><br><span class="line">            locations.add(<span class="keyword">new</span> <span class="title class_">RedisGeoCommands</span>.GeoLocation&lt;&gt;(</span><br><span class="line">                    shop.getId().toString(),</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">Point</span>(shop.getX(), shop.getY())</span><br><span class="line">            ));</span><br><span class="line">        &#125;</span><br><span class="line">        stringRedisTemplate.opsForGeo().add(key, locations);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="10-3-附近商户-实现附近商户功能"><a href="#10-3-附近商户-实现附近商户功能" class="headerlink" title="10.3 附近商户-实现附近商户功能"></a>10.3 附近商户-实现附近商户功能</h3><p>SpringDataRedis的2.3.9版本并不支持Redis 6.2提供的GEOSEARCH命令，因此我们需要提示其版本，修改自己的POM</p>
<p>第一步：导入pom</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;</span><br><span class="line">    &lt;exclusions&gt;</span><br><span class="line">        &lt;exclusion&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-data-redis&lt;/artifactId&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.data&lt;/groupId&gt;</span><br><span class="line">        &lt;/exclusion&gt;</span><br><span class="line">        &lt;exclusion&gt;</span><br><span class="line">            &lt;artifactId&gt;lettuce-core&lt;/artifactId&gt;</span><br><span class="line">            &lt;groupId&gt;io.lettuce&lt;/groupId&gt;</span><br><span class="line">        &lt;/exclusion&gt;</span><br><span class="line">    &lt;/exclusions&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.data&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-data-redis&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">2.6</span><span class="number">.2</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;io.lettuce&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;lettuce-core&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">6.1</span><span class="number">.6</span>.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>第二步：</p>
<p>ShopController</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/of/type&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryShopByType</span><span class="params">(</span></span><br><span class="line"><span class="params">        <span class="meta">@RequestParam(&quot;typeId&quot;)</span> Integer typeId,</span></span><br><span class="line"><span class="params">        <span class="meta">@RequestParam(value = &quot;current&quot;, defaultValue = &quot;1&quot;)</span> Integer current,</span></span><br><span class="line"><span class="params">        <span class="meta">@RequestParam(value = &quot;x&quot;, required = false)</span> Double x,</span></span><br><span class="line"><span class="params">        <span class="meta">@RequestParam(value = &quot;y&quot;, required = false)</span> Double y</span></span><br><span class="line"><span class="params">)</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> shopService.queryShopByType(typeId, current, x, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ShopServiceImpl</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">queryShopByType</span><span class="params">(Integer typeId, Integer current, Double x, Double y)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.判断是否需要根据坐标查询</span></span><br><span class="line">        <span class="keyword">if</span> (x == <span class="literal">null</span> || y == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 不需要坐标查询，按数据库查询</span></span><br><span class="line">            Page&lt;Shop&gt; page = query()</span><br><span class="line">                    .eq(<span class="string">&quot;type_id&quot;</span>, typeId)</span><br><span class="line">                    .page(<span class="keyword">new</span> <span class="title class_">Page</span>&lt;&gt;(current, SystemConstants.DEFAULT_PAGE_SIZE));</span><br><span class="line">            <span class="comment">// 返回数据</span></span><br><span class="line">            <span class="keyword">return</span> Result.ok(page.getRecords());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.计算分页参数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">from</span> <span class="operator">=</span> (current - <span class="number">1</span>) * SystemConstants.DEFAULT_PAGE_SIZE;</span><br><span class="line">        <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> current * SystemConstants.DEFAULT_PAGE_SIZE;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.查询redis、按照距离排序、分页。结果：shopId、distance</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> SHOP_GEO_KEY + typeId;</span><br><span class="line">        GeoResults&lt;RedisGeoCommands.GeoLocation&lt;String&gt;&gt; results = stringRedisTemplate.opsForGeo() <span class="comment">// GEOSEARCH key BYLONLAT x y BYRADIUS 10 WITHDISTANCE</span></span><br><span class="line">                .search(</span><br><span class="line">                        key,</span><br><span class="line">                        GeoReference.fromCoordinate(x, y),</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Distance</span>(<span class="number">5000</span>),</span><br><span class="line">                        RedisGeoCommands.GeoSearchCommandArgs.newGeoSearchArgs().includeDistance().limit(end)</span><br><span class="line">                );</span><br><span class="line">        <span class="comment">// 4.解析出id</span></span><br><span class="line">        <span class="keyword">if</span> (results == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.ok(Collections.emptyList());</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;GeoResult&lt;RedisGeoCommands.GeoLocation&lt;String&gt;&gt;&gt; list = results.getContent();</span><br><span class="line">        <span class="keyword">if</span> (list.size() &lt;= from) &#123;</span><br><span class="line">            <span class="comment">// 没有下一页了，结束</span></span><br><span class="line">            <span class="keyword">return</span> Result.ok(Collections.emptyList());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 4.1.截取 from ~ end的部分</span></span><br><span class="line">        List&lt;Long&gt; ids = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(list.size());</span><br><span class="line">        Map&lt;String, Distance&gt; distanceMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(list.size());</span><br><span class="line">        list.stream().skip(from).forEach(result -&gt; &#123;</span><br><span class="line">            <span class="comment">// 4.2.获取店铺id</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">shopIdStr</span> <span class="operator">=</span> result.getContent().getName();</span><br><span class="line">            ids.add(Long.valueOf(shopIdStr));</span><br><span class="line">            <span class="comment">// 4.3.获取距离</span></span><br><span class="line">            <span class="type">Distance</span> <span class="variable">distance</span> <span class="operator">=</span> result.getDistance();</span><br><span class="line">            distanceMap.put(shopIdStr, distance);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 5.根据id查询Shop</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">idStr</span> <span class="operator">=</span> StrUtil.join(<span class="string">&quot;,&quot;</span>, ids);</span><br><span class="line">        List&lt;Shop&gt; shops = query().in(<span class="string">&quot;id&quot;</span>, ids).last(<span class="string">&quot;ORDER BY FIELD(id,&quot;</span> + idStr + <span class="string">&quot;)&quot;</span>).list();</span><br><span class="line">        <span class="keyword">for</span> (Shop shop : shops) &#123;</span><br><span class="line">            shop.setDistance(distanceMap.get(shop.getId().toString()).getValue());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 6.返回</span></span><br><span class="line">        <span class="keyword">return</span> Result.ok(shops);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h2 id="11、用户签到"><a href="#11、用户签到" class="headerlink" title="11、用户签到"></a>11、用户签到</h2><h4 id="11-1、用户签到-BitMap功能演示"><a href="#11-1、用户签到-BitMap功能演示" class="headerlink" title="11.1、用户签到-BitMap功能演示"></a>11.1、用户签到-BitMap功能演示</h4><p>我们针对签到功能完全可以通过mysql来完成，比如说以下这张表</p>
<p><img src="/2022/09/24/redis%E5%AE%9E%E6%88%98%E7%AF%87/1653823145495.png" alt="1653823145495"></p>
<p>用户一次签到，就是一条记录，假如有1000万用户，平均每人每年签到次数为10次，则这张表一年的数据量为 1亿条</p>
<p>每签到一次需要使用（8 + 8 + 1 + 1 + 3 + 1）共22 字节的内存，一个月则最多需要600多字节</p>
<p>我们如何能够简化一点呢？其实可以考虑小时候一个挺常见的方案，就是小时候，咱们准备一张小小的卡片，你只要签到就打上一个勾，我最后判断你是否签到，其实只需要到小卡片上看一看就知道了</p>
<p>我们可以采用类似这样的方案来实现我们的签到需求。</p>
<p>我们按月来统计用户签到信息，签到记录为1，未签到则记录为0.</p>
<p>把每一个bit位对应当月的每一天，形成了映射关系。用0和1标示业务状态，这种思路就称为位图（BitMap）。这样我们就用极小的空间，来实现了大量数据的表示</p>
<p>Redis中是利用string类型数据结构实现BitMap，因此最大上限是512M，转换为bit则是 2^32个bit位。</p>
<p><img src="/2022/09/24/redis%E5%AE%9E%E6%88%98%E7%AF%87/1653824498278.png" alt="1653824498278"></p>
<p>BitMap的操作命令有：</p>
<ul>
<li>SETBIT：向指定位置（offset）存入一个0或1</li>
<li>GETBIT ：获取指定位置（offset）的bit值</li>
<li>BITCOUNT ：统计BitMap中值为1的bit位的数量</li>
<li>BITFIELD ：操作（查询、修改、自增）BitMap中bit数组中的指定位置（offset）的值</li>
<li>BITFIELD_RO ：获取BitMap中bit数组，并以十进制形式返回</li>
<li>BITOP ：将多个BitMap的结果做位运算（与 、或、异或）</li>
<li>BITPOS ：查找bit数组中指定范围内第一个0或1出现的位置</li>
</ul>
<h4 id="11-2-、用户签到-实现签到功能"><a href="#11-2-、用户签到-实现签到功能" class="headerlink" title="11.2 、用户签到-实现签到功能"></a>11.2 、用户签到-实现签到功能</h4><p>需求：实现签到接口，将当前用户当天签到信息保存到Redis中</p>
<p>思路：我们可以把年和月作为bitMap的key，然后保存到一个bitMap中，每次签到就到对应的位上把数字从0变成1，只要对应是1，就表明说明这一天已经签到了，反之则没有签到。</p>
<p>我们通过接口文档发现，此接口并没有传递任何的参数，没有参数怎么确实是哪一天签到呢？这个很容易，可以通过后台代码直接获取即可，然后到对应的地址上去修改bitMap。</p>
<p><img src="/2022/09/24/redis%E5%AE%9E%E6%88%98%E7%AF%87/1653833970361.png" alt="1653833970361"></p>
<p><strong>代码</strong></p>
<p>UserController</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/sign&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">sign</span><span class="params">()</span>&#123;</span><br><span class="line">   <span class="keyword">return</span> userService.sign();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>UserServiceImpl</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">sign</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1.获取当前登录用户</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">    <span class="comment">// 2.获取日期</span></span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">    <span class="comment">// 3.拼接key</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">keySuffix</span> <span class="operator">=</span> now.format(DateTimeFormatter.ofPattern(<span class="string">&quot;:yyyyMM&quot;</span>));</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> USER_SIGN_KEY + userId + keySuffix;</span><br><span class="line">    <span class="comment">// 4.获取今天是本月的第几天</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">dayOfMonth</span> <span class="operator">=</span> now.getDayOfMonth();</span><br><span class="line">    <span class="comment">// 5.写入Redis SETBIT key offset 1</span></span><br><span class="line">    stringRedisTemplate.opsForValue().setBit(key, dayOfMonth - <span class="number">1</span>, <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">return</span> Result.ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="11-3-用户签到-签到统计"><a href="#11-3-用户签到-签到统计" class="headerlink" title="11.3 用户签到-签到统计"></a>11.3 用户签到-签到统计</h4><p><strong>问题1：</strong>什么叫做连续签到天数？<br>从最后一次签到开始向前统计，直到遇到第一次未签到为止，计算总的签到次数，就是连续签到天数。</p>
<p><img src="/2022/09/24/redis%E5%AE%9E%E6%88%98%E7%AF%87/1653834455899.png" alt="1653834455899"></p>
<p>Java逻辑代码：获得当前这个月的最后一次签到数据，定义一个计数器，然后不停的向前统计，直到获得第一个非0的数字即可，每得到一个非0的数字计数器+1，直到遍历完所有的数据，就可以获得当前月的签到总天数了</p>
<p><strong>问题2：</strong>如何得到本月到今天为止的所有签到数据？</p>
<p>  BITFIELD key GET u[dayOfMonth] 0</p>
<p>假设今天是10号，那么我们就可以从当前月的第一天开始，获得到当前这一天的位数，是10号，那么就是10位，去拿这段时间的数据，就能拿到所有的数据了，那么这10天里边签到了多少次呢？统计有多少个1即可。</p>
<p><strong>问题3：如何从后向前遍历每个bit位？</strong></p>
<p>注意：bitMap返回的数据是10进制，哪假如说返回一个数字8，那么我哪儿知道到底哪些是0，哪些是1呢？我们只需要让得到的10进制数字和1做与运算就可以了，因为1只有遇见1 才是1，其他数字都是0 ，我们把签到结果和1进行与操作，每与一次，就把签到结果向右移动一位，依次内推，我们就能完成逐个遍历的效果了。</p>
<p>需求：实现下面接口，统计当前用户截止当前时间在本月的连续签到天数</p>
<p>有用户有时间我们就可以组织出对应的key，此时就能找到这个用户截止这天的所有签到记录，再根据这套算法，就能统计出来他连续签到的次数了</p>
<p><img src="/2022/09/24/redis%E5%AE%9E%E6%88%98%E7%AF%87/1653835784444.png" alt="1653835784444"></p>
<p>代码</p>
<p><strong>UserController</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/sign/count&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">signCount</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> userService.signCount();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>UserServiceImpl</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">signCount</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1.获取当前登录用户</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">    <span class="comment">// 2.获取日期</span></span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">    <span class="comment">// 3.拼接key</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">keySuffix</span> <span class="operator">=</span> now.format(DateTimeFormatter.ofPattern(<span class="string">&quot;:yyyyMM&quot;</span>));</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> USER_SIGN_KEY + userId + keySuffix;</span><br><span class="line">    <span class="comment">// 4.获取今天是本月的第几天</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">dayOfMonth</span> <span class="operator">=</span> now.getDayOfMonth();</span><br><span class="line">    <span class="comment">// 5.获取本月截止今天为止的所有的签到记录，返回的是一个十进制的数字 BITFIELD sign:5:202203 GET u14 0</span></span><br><span class="line">    List&lt;Long&gt; result = stringRedisTemplate.opsForValue().bitField(</span><br><span class="line">            key,</span><br><span class="line">            BitFieldSubCommands.create()</span><br><span class="line">                    .get(BitFieldSubCommands.BitFieldType.unsigned(dayOfMonth)).valueAt(<span class="number">0</span>)</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="literal">null</span> || result.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// 没有任何签到结果</span></span><br><span class="line">        <span class="keyword">return</span> Result.ok(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Long</span> <span class="variable">num</span> <span class="operator">=</span> result.get(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (num == <span class="literal">null</span> || num == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.ok(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 6.循环遍历</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 6.1.让这个数字与1做与运算，得到数字的最后一个bit位  // 判断这个bit位是否为0</span></span><br><span class="line">        <span class="keyword">if</span> ((num &amp; <span class="number">1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果为0，说明未签到，结束</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果不为0，说明已签到，计数器+1</span></span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 把数字右移一位，抛弃最后一个bit位，继续下一个bit位</span></span><br><span class="line">        num &gt;&gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Result.ok(count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="11-4-额外加餐-关于使用bitmap来解决缓存穿透的方案"><a href="#11-4-额外加餐-关于使用bitmap来解决缓存穿透的方案" class="headerlink" title="11.4 额外加餐-关于使用bitmap来解决缓存穿透的方案"></a>11.4 额外加餐-关于使用bitmap来解决缓存穿透的方案</h4><p>回顾<strong>缓存穿透</strong>：</p>
<p>发起了一个数据库不存在的，redis里边也不存在的数据，通常你可以把他看成一个攻击</p>
<p>解决方案：</p>
<ul>
<li><p>判断id&lt;0</p>
</li>
<li><p>如果数据库是空，那么就可以直接往redis里边把这个空数据缓存起来</p>
</li>
</ul>
<p>第一种解决方案：遇到的问题是如果用户访问的是id不存在的数据，则此时就无法生效</p>
<p>第二种解决方案：遇到的问题是：如果是不同的id那就可以防止下次过来直击数据</p>
<p>所以我们如何解决呢？</p>
<p>我们可以将数据库的数据，所对应的id写入到一个list集合中，当用户过来访问的时候，我们直接去判断list中是否包含当前的要查询的数据，如果说用户要查询的id数据并不在list集合中，则直接返回，如果list中包含对应查询的id数据，则说明不是一次缓存穿透数据，则直接放行。</p>
<p><img src="/2022/09/24/redis%E5%AE%9E%E6%88%98%E7%AF%87/1653836416586.png" alt="1653836416586"></p>
<p>现在的问题是这个主键其实并没有那么短，而是很长的一个 主键</p>
<p>哪怕你单独去提取这个主键，但是在11年左右，淘宝的商品总量就已经超过10亿个</p>
<p>所以如果采用以上方案，这个list也会很大，所以我们可以使用bitmap来减少list的存储空间</p>
<p>我们可以把list数据抽象成一个非常大的bitmap，我们不再使用list，而是将db中的id数据利用哈希思想，比如：</p>
<p>id % bitmap.size  &#x3D; 算出当前这个id对应应该落在bitmap的哪个索引上，然后将这个值从0变成1，然后当用户来查询数据时，此时已经没有了list，让用户用他查询的id去用相同的哈希算法， 算出来当前这个id应当落在bitmap的哪一位，然后判断这一位是0，还是1，如果是0则表明这一位上的数据一定不存在，  采用这种方式来处理，需要重点考虑一个事情，就是误差率，所谓的误差率就是指当发生哈希冲突的时候，产生的误差。</p>
<p><img src="/2022/09/24/redis%E5%AE%9E%E6%88%98%E7%AF%87/1653836578970.png" alt="1653836578970"></p>
<h2 id="12、UV统计"><a href="#12、UV统计" class="headerlink" title="12、UV统计"></a>12、UV统计</h2><h3 id="12-1-、UV统计-HyperLogLog"><a href="#12-1-、UV统计-HyperLogLog" class="headerlink" title="12.1 、UV统计-HyperLogLog"></a>12.1 、UV统计-HyperLogLog</h3><p>首先我们搞懂两个概念：</p>
<ul>
<li>UV：全称Unique Visitor，也叫独立访客量，是指通过互联网访问、浏览这个网页的自然人。1天内同一个用户多次访问该网站，只记录1次。</li>
<li>PV：全称Page View，也叫页面访问量或点击量，用户每访问网站的一个页面，记录1次PV，用户多次打开页面，则记录多次PV。往往用来衡量网站的流量。</li>
</ul>
<p>通常来说UV会比PV大很多，所以衡量同一个网站的访问量，我们需要综合考虑很多因素，所以我们只是单纯的把这两个值作为一个参考值</p>
<p>UV统计在服务端做会比较麻烦，因为要判断该用户是否已经统计过了，需要将统计过的用户信息保存。但是如果每个访问的用户都保存到Redis中，数据量会非常恐怖，那怎么处理呢？</p>
<p>Hyperloglog(HLL)是从Loglog算法派生的概率算法，用于确定非常大的集合的基数，而不需要存储其所有值。相关算法原理大家可以参考：<a href="https://juejin.cn/post/6844903785744056333#heading-0">https://juejin.cn/post/6844903785744056333#heading-0</a><br>Redis中的HLL是基于string结构实现的，单个HLL的内存<strong>永远小于16kb</strong>，<strong>内存占用低</strong>的令人发指！作为代价，其测量结果是概率性的，<strong>有小于0.81％的误差</strong>。不过对于UV统计来说，这完全可以忽略。</p>
<p><img src="/2022/09/24/redis%E5%AE%9E%E6%88%98%E7%AF%87/1653837988985.png" alt="1653837988985"></p>
<h3 id="12-2-UV统计-测试百万数据的统计"><a href="#12-2-UV统计-测试百万数据的统计" class="headerlink" title="12.2 UV统计-测试百万数据的统计"></a>12.2 UV统计-测试百万数据的统计</h3><p>测试思路：我们直接利用单元测试，向HyperLogLog中添加100万条数据，看看内存占用和统计效果如何</p>
<p><img src="/2022/09/24/redis%E5%AE%9E%E6%88%98%E7%AF%87/1653838053608.png" alt="1653838053608"></p>
<p>经过测试：我们会发生他的误差是在允许范围内，并且内存占用极小</p>
]]></content>
      <categories>
        <category>redis系列</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title>redis高级篇</title>
    <url>/2022/09/24/redis%E9%AB%98%E7%BA%A7%E7%AF%87/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>redis原理篇</title>
    <url>/2022/09/24/redis%E5%8E%9F%E7%90%86%E7%AF%87/</url>
    <content><![CDATA[<h2 id="1、原理篇-Redis数据结构"><a href="#1、原理篇-Redis数据结构" class="headerlink" title="1、原理篇-Redis数据结构"></a>1、原理篇-Redis数据结构</h2><h3 id="1-1-Redis数据结构-动态字符串"><a href="#1-1-Redis数据结构-动态字符串" class="headerlink" title="1.1 Redis数据结构-动态字符串"></a>1.1 Redis数据结构-动态字符串</h3><p>我们都知道Redis中保存的Key是字符串，value往往是字符串或者字符串的集合。可见字符串是Redis中最常用的一种数据结构。</p>
<p>不过Redis没有直接使用C语言中的字符串，因为C语言字符串存在很多问题：<br>获取字符串长度的需要通过运算<br>非二进制安全<br>不可修改<br>Redis构建了一种新的字符串结构，称为简单动态字符串（Simple Dynamic String），简称SDS。<br>例如，我们执行命令：</p>
<p><img src="/2022/09/24/redis%E5%8E%9F%E7%90%86%E7%AF%87/1653984583289.png" alt="1653984583289"></p>
<p>那么Redis将在底层创建两个SDS，其中一个是包含“name”的SDS，另一个是包含“虎哥”的SDS。</p>
<p>Redis是C语言实现的，其中SDS是一个结构体，源码如下：</p>
<p><img src="/2022/09/24/redis%E5%8E%9F%E7%90%86%E7%AF%87/1653984624671.png" alt="1653984624671"></p>
<p>例如，一个包含字符串“name”的sds结构如下：</p>
<p><img src="/2022/09/24/redis%E5%8E%9F%E7%90%86%E7%AF%87/1653984648404.png" alt="1653984648404"></p>
<p>SDS之所以叫做动态字符串，是因为它具备动态扩容的能力，例如一个内容为“hi”的SDS：</p>
<p><img src="/2022/09/24/redis%E5%8E%9F%E7%90%86%E7%AF%87/1653984787383.png" alt="1653984787383"></p>
<p>假如我们要给SDS追加一段字符串“,Amy”，这里首先会申请新内存空间：</p>
<p>如果新字符串小于1M，则新空间为扩展后字符串长度的两倍+1；</p>
<p>如果新字符串大于1M，则新空间为扩展后字符串长度+1M+1。称为内存预分配。</p>
<p><img src="/2022/09/24/redis%E5%8E%9F%E7%90%86%E7%AF%87/1653984822363.png" alt="1653984822363"></p>
<p><img src="/2022/09/24/redis%E5%8E%9F%E7%90%86%E7%AF%87/1653984838306.png" alt="1653984838306"></p>
<h3 id="1-2-Redis数据结构-intset"><a href="#1-2-Redis数据结构-intset" class="headerlink" title="1.2 Redis数据结构-intset"></a>1.2 Redis数据结构-intset</h3><p>IntSet是Redis中set集合的一种实现方式，基于整数数组来实现，并且具备长度可变、有序等特征。<br>结构如下：</p>
<p><img src="/2022/09/24/redis%E5%8E%9F%E7%90%86%E7%AF%87/1653984923322.png" alt="1653984923322"></p>
<p>其中的encoding包含三种模式，表示存储的整数大小不同：</p>
<p><img src="/2022/09/24/redis%E5%8E%9F%E7%90%86%E7%AF%87/1653984942385.png" alt="1653984942385"></p>
<p>为了方便查找，Redis会将intset中所有的整数按照升序依次保存在contents数组中，结构如图：</p>
<p><img src="/2022/09/24/redis%E5%8E%9F%E7%90%86%E7%AF%87/1653985149557.png" alt="1653985149557"></p>
<p>现在，数组中每个数字都在int16_t的范围内，因此采用的编码方式是INTSET_ENC_INT16，每部分占用的字节大小为：<br>encoding：4字节<br>length：4字节<br>contents：2字节 * 3  &#x3D; 6字节</p>
<p><img src="/2022/09/24/redis%E5%8E%9F%E7%90%86%E7%AF%87/1653985197214.png" alt="1653985197214"></p>
<p>我们向该其中添加一个数字：50000，这个数字超出了int16_t的范围，intset会自动升级编码方式到合适的大小。<br>以当前案例来说流程如下：</p>
<ul>
<li>升级编码为INTSET_ENC_INT32, 每个整数占4字节，并按照新的编码方式及元素个数扩容数组</li>
<li>倒序依次将数组中的元素拷贝到扩容后的正确位置</li>
<li>将待添加的元素放入数组末尾</li>
<li>最后，将inset的encoding属性改为INTSET_ENC_INT32，将length属性改为4</li>
</ul>
<p><img src="/2022/09/24/redis%E5%8E%9F%E7%90%86%E7%AF%87/1653985276621.png" alt="1653985276621"></p>
<p>源码如下：</p>
<p><img src="/2022/09/24/redis%E5%8E%9F%E7%90%86%E7%AF%87/1653985304075.png" alt="1653985304075"></p>
<p><img src="/2022/09/24/redis%E5%8E%9F%E7%90%86%E7%AF%87/1653985327653.png" alt="1653985327653"></p>
<p>小总结：</p>
<p>Intset可以看做是特殊的整数数组，具备一些特点：</p>
<ul>
<li>Redis会确保Intset中的元素唯一、有序</li>
<li>具备类型升级机制，可以节省内存空间</li>
<li>底层采用二分查找方式来查询</li>
</ul>
<h3 id="1-3-Redis数据结构-Dict"><a href="#1-3-Redis数据结构-Dict" class="headerlink" title="1.3 Redis数据结构-Dict"></a>1.3 Redis数据结构-Dict</h3><p>我们知道Redis是一个键值型（Key-Value Pair）的数据库，我们可以根据键实现快速的增删改查。而键与值的映射关系正是通过Dict来实现的。<br>Dict由三部分组成，分别是：哈希表（DictHashTable）、哈希节点（DictEntry）、字典（Dict）</p>
<p><img src="/2022/09/24/redis%E5%8E%9F%E7%90%86%E7%AF%87/1653985396560.png" alt="1653985396560"></p>
<p>当我们向Dict添加键值对时，Redis首先根据key计算出hash值（h），然后利用 h &amp; sizemask来计算元素应该存储到数组中的哪个索引位置。我们存储k1&#x3D;v1，假设k1的哈希值h &#x3D;1，则1&amp;3 &#x3D;1，因此k1&#x3D;v1要存储到数组角标1位置。</p>
<p><img src="/2022/09/24/redis%E5%8E%9F%E7%90%86%E7%AF%87/1653985497735.png" alt="1653985497735"></p>
<p>Dict由三部分组成，分别是：哈希表（DictHashTable）、哈希节点（DictEntry）、字典（Dict）</p>
<p><img src="/2022/09/24/redis%E5%8E%9F%E7%90%86%E7%AF%87/1653985570612.png" alt="1653985570612"></p>
<p><img src="/2022/09/24/redis%E5%8E%9F%E7%90%86%E7%AF%87/1653985586543.png" alt="1653985586543"></p>
<p><img src="/2022/09/24/redis%E5%8E%9F%E7%90%86%E7%AF%87/1653985640422.png" alt="1653985640422"></p>
<p><strong>Dict的扩容</strong></p>
<p>Dict中的HashTable就是数组结合单向链表的实现，当集合中元素较多时，必然导致哈希冲突增多，链表过长，则查询效率会大大降低。<br>Dict在每次新增键值对时都会检查负载因子（LoadFactor &#x3D; used&#x2F;size） ，满足以下两种情况时会触发哈希表扩容：<br>哈希表的 LoadFactor &gt;&#x3D; 1，并且服务器没有执行 BGSAVE 或者 BGREWRITEAOF 等后台进程；<br>哈希表的 LoadFactor &gt; 5 ；</p>
<p><img src="/2022/09/24/redis%E5%8E%9F%E7%90%86%E7%AF%87/1653985716275.png" alt="1653985716275"></p>
<p><img src="/2022/09/24/redis%E5%8E%9F%E7%90%86%E7%AF%87/1653985743412.png" alt="1653985743412"></p>
<p><strong>Dict的rehash</strong></p>
<p>不管是扩容还是收缩，必定会创建新的哈希表，导致哈希表的size和sizemask变化，而key的查询与sizemask有关。因此必须对哈希表中的每一个key重新计算索引，插入新的哈希表，这个过程称为rehash。过程是这样的：</p>
<ul>
<li><p>计算新hash表的realeSize，值取决于当前要做的是扩容还是收缩：</p>
<ul>
<li>如果是扩容，则新size为第一个大于等于dict.ht[0].used + 1的2^n</li>
<li>如果是收缩，则新size为第一个大于等于dict.ht[0].used的2^n （不得小于4）</li>
</ul>
</li>
<li><p>按照新的realeSize申请内存空间，创建dictht，并赋值给dict.ht[1]</p>
</li>
<li><p>设置dict.rehashidx &#x3D; 0，标示开始rehash</p>
</li>
<li><p>将dict.ht[0]中的每一个dictEntry都rehash到dict.ht[1]</p>
</li>
<li><p>将dict.ht[1]赋值给dict.ht[0]，给dict.ht[1]初始化为空哈希表，释放原来的dict.ht[0]的内存</p>
</li>
<li><p>将rehashidx赋值为-1，代表rehash结束</p>
</li>
<li><p>在rehash过程中，新增操作，则直接写入ht[1]，查询、修改和删除则会在dict.ht[0]和dict.ht[1]依次查找并执行。这样可以确保ht[0]的数据只减不增，随着rehash最终为空</p>
</li>
</ul>
<p>整个过程可以描述成：</p>
<p><img src="/2022/09/24/redis%E5%8E%9F%E7%90%86%E7%AF%87/1653985824540.png" alt="1653985824540"></p>
<p>小总结：</p>
<p>Dict的结构：</p>
<ul>
<li>类似java的HashTable，底层是数组加链表来解决哈希冲突</li>
<li>Dict包含两个哈希表，ht[0]平常用，ht[1]用来rehash</li>
</ul>
<p>Dict的伸缩：</p>
<ul>
<li>当LoadFactor大于5或者LoadFactor大于1并且没有子进程任务时，Dict扩容</li>
<li>当LoadFactor小于0.1时，Dict收缩</li>
<li>扩容大小为第一个大于等于used + 1的2^n</li>
<li>收缩大小为第一个大于等于used 的2^n</li>
<li>Dict采用渐进式rehash，每次访问Dict时执行一次rehash</li>
<li>rehash时ht[0]只减不增，新增操作只在ht[1]执行，其它操作在两个哈希表</li>
</ul>
<h3 id="1-4-Redis数据结构-ZipList"><a href="#1-4-Redis数据结构-ZipList" class="headerlink" title="1.4 Redis数据结构-ZipList"></a>1.4 Redis数据结构-ZipList</h3><p>ZipList 是一种特殊的“双端链表” ，由一系列特殊编码的连续内存块组成。可以在任意一端进行压入&#x2F;弹出操作, 并且该操作的时间复杂度为 O(1)。</p>
<p><img src="/2022/09/24/redis%E5%8E%9F%E7%90%86%E7%AF%87/1653985987327.png" alt="1653985987327"></p>
<p><img src="/2022/09/24/redis%E5%8E%9F%E7%90%86%E7%AF%87/1653986020491.png" alt="1653986020491"></p>
<table>
<thead>
<tr>
<th><strong>属性</strong></th>
<th><strong>类型</strong></th>
<th><strong>长度</strong></th>
<th><strong>用途</strong></th>
</tr>
</thead>
<tbody><tr>
<td>zlbytes</td>
<td>uint32_t</td>
<td>4 字节</td>
<td>记录整个压缩列表占用的内存字节数</td>
</tr>
<tr>
<td>zltail</td>
<td>uint32_t</td>
<td>4 字节</td>
<td>记录压缩列表表尾节点距离压缩列表的起始地址有多少字节，通过这个偏移量，可以确定表尾节点的地址。</td>
</tr>
<tr>
<td>zllen</td>
<td>uint16_t</td>
<td>2 字节</td>
<td>记录了压缩列表包含的节点数量。 最大值为UINT16_MAX （65534），如果超过这个值，此处会记录为65535，但节点的真实数量需要遍历整个压缩列表才能计算得出。</td>
</tr>
<tr>
<td>entry</td>
<td>列表节点</td>
<td>不定</td>
<td>压缩列表包含的各个节点，节点的长度由节点保存的内容决定。</td>
</tr>
<tr>
<td>zlend</td>
<td>uint8_t</td>
<td>1 字节</td>
<td>特殊值 0xFF （十进制 255 ），用于标记压缩列表的末端。</td>
</tr>
</tbody></table>
<p><strong>ZipListEntry</strong></p>
<p>ZipList 中的Entry并不像普通链表那样记录前后节点的指针，因为记录两个指针要占用16个字节，浪费内存。而是采用了下面的结构：</p>
<p><img src="/2022/09/24/redis%E5%8E%9F%E7%90%86%E7%AF%87/1653986055253.png" alt="1653986055253"></p>
<ul>
<li><p>previous_entry_length：前一节点的长度，占1个或5个字节。</p>
<ul>
<li>如果前一节点的长度小于254字节，则采用1个字节来保存这个长度值</li>
<li>如果前一节点的长度大于254字节，则采用5个字节来保存这个长度值，第一个字节为0xfe，后四个字节才是真实长度数据</li>
</ul>
</li>
<li><p>encoding：编码属性，记录content的数据类型（字符串还是整数）以及长度，占用1个、2个或5个字节</p>
</li>
<li><p>contents：负责保存节点的数据，可以是字符串或整数</p>
</li>
</ul>
<p>ZipList中所有存储长度的数值均采用小端字节序，即低位字节在前，高位字节在后。例如：数值0x1234，采用小端字节序后实际存储值为：0x3412</p>
<p><strong>Encoding编码</strong></p>
<p>ZipListEntry中的encoding编码分为字符串和整数两种：<br>字符串：如果encoding是以“00”、“01”或者“10”开头，则证明content是字符串</p>
<table>
<thead>
<tr>
<th><strong>编码</strong></th>
<th><strong>编码长度</strong></th>
<th><strong>字符串大小</strong></th>
</tr>
</thead>
<tbody><tr>
<td>|00pppppp|</td>
<td>1 bytes</td>
<td>&lt;&#x3D; 63 bytes</td>
</tr>
<tr>
<td>|01pppppp|qqqqqqqq|</td>
<td>2 bytes</td>
<td>&lt;&#x3D; 16383 bytes</td>
</tr>
<tr>
<td>|10000000|qqqqqqqq|rrrrrrrr|ssssssss|tttttttt|</td>
<td>5 bytes</td>
<td>&lt;&#x3D; 4294967295 bytes</td>
</tr>
</tbody></table>
<p>例如，我们要保存字符串：“ab”和 “bc”</p>
<p><img src="/2022/09/24/redis%E5%8E%9F%E7%90%86%E7%AF%87/1653986172002.png" alt="1653986172002"></p>
<p> ZipListEntry中的encoding编码分为字符串和整数两种：</p>
<ul>
<li>整数：如果encoding是以“11”开始，则证明content是整数，且encoding固定只占用1个字节</li>
</ul>
<table>
<thead>
<tr>
<th><strong>编码</strong></th>
<th><strong>编码长度</strong></th>
<th><strong>整数类型</strong></th>
</tr>
</thead>
<tbody><tr>
<td>11000000</td>
<td>1</td>
<td>int16_t（2 bytes）</td>
</tr>
<tr>
<td>11010000</td>
<td>1</td>
<td>int32_t（4 bytes）</td>
</tr>
<tr>
<td>11100000</td>
<td>1</td>
<td>int64_t（8 bytes）</td>
</tr>
<tr>
<td>11110000</td>
<td>1</td>
<td>24位有符整数(3 bytes)</td>
</tr>
<tr>
<td>11111110</td>
<td>1</td>
<td>8位有符整数(1 bytes)</td>
</tr>
<tr>
<td>1111xxxx</td>
<td>1</td>
<td>直接在xxxx位置保存数值，范围从0001~1101，减1后结果为实际值</td>
</tr>
</tbody></table>
<p><img src="/2022/09/24/redis%E5%8E%9F%E7%90%86%E7%AF%87/1653986282879.png" alt="1653986282879"></p>
<p><img src="/2022/09/24/redis%E5%8E%9F%E7%90%86%E7%AF%87/1653986217182.png" alt="1653986217182"></p>
<h3 id="1-5-Redis数据结构-ZipList的连锁更新问题"><a href="#1-5-Redis数据结构-ZipList的连锁更新问题" class="headerlink" title="1.5 Redis数据结构-ZipList的连锁更新问题"></a>1.5 Redis数据结构-ZipList的连锁更新问题</h3><p>ZipList的每个Entry都包含previous_entry_length来记录上一个节点的大小，长度是1个或5个字节：<br>如果前一节点的长度小于254字节，则采用1个字节来保存这个长度值<br>如果前一节点的长度大于等于254字节，则采用5个字节来保存这个长度值，第一个字节为0xfe，后四个字节才是真实长度数据<br>现在，假设我们有N个连续的、长度为250~253字节之间的entry，因此entry的previous_entry_length属性用1个字节即可表示，如图所示：</p>
<p><img src="/2022/09/24/redis%E5%8E%9F%E7%90%86%E7%AF%87/1653986328124.png" alt="1653986328124"></p>
<p>ZipList这种特殊情况下产生的连续多次空间扩展操作称之为连锁更新（Cascade Update）。新增、删除都可能导致连锁更新的发生。</p>
<p><strong>小总结：</strong></p>
<p><strong>ZipList特性：</strong></p>
<ul>
<li>压缩列表的可以看做一种连续内存空间的”双向链表”</li>
<li>列表的节点之间不是通过指针连接，而是记录上一节点和本节点长度来寻址，内存占用较低</li>
<li>如果列表数据过多，导致链表过长，可能影响查询性能</li>
<li>增或删较大数据时有可能发生连续更新问题</li>
</ul>
<h3 id="1-6-Redis数据结构-QuickList"><a href="#1-6-Redis数据结构-QuickList" class="headerlink" title="1.6 Redis数据结构-QuickList"></a>1.6 Redis数据结构-QuickList</h3><p>问题1：ZipList虽然节省内存，但申请内存必须是连续空间，如果内存占用较多，申请内存效率很低。怎么办？</p>
<p>​	答：为了缓解这个问题，我们必须限制ZipList的长度和entry大小。</p>
<p>问题2：但是我们要存储大量数据，超出了ZipList最佳的上限该怎么办？</p>
<p>​	答：我们可以创建多个ZipList来分片存储数据。</p>
<p>问题3：数据拆分后比较分散，不方便管理和查找，这多个ZipList如何建立联系？</p>
<p>​	答：Redis在3.2版本引入了新的数据结构QuickList，它是一个双端链表，只不过链表中的每个节点都是一个ZipList。</p>
<p><img src="/2022/09/24/redis%E5%8E%9F%E7%90%86%E7%AF%87/1653986474927.png" alt="1653986474927"></p>
<p>为了避免QuickList中的每个ZipList中entry过多，Redis提供了一个配置项：list-max-ziplist-size来限制。<br>如果值为正，则代表ZipList的允许的entry个数的最大值<br>如果值为负，则代表ZipList的最大内存大小，分5种情况：</p>
<ul>
<li>-1：每个ZipList的内存占用不能超过4kb</li>
<li>-2：每个ZipList的内存占用不能超过8kb</li>
<li>-3：每个ZipList的内存占用不能超过16kb</li>
<li>-4：每个ZipList的内存占用不能超过32kb</li>
<li>-5：每个ZipList的内存占用不能超过64kb</li>
</ul>
<p>其默认值为 -2：</p>
<p><img src="/2022/09/24/redis%E5%8E%9F%E7%90%86%E7%AF%87/1653986642777.png" alt="1653986642777"></p>
<p>以下是QuickList的和QuickListNode的结构源码：</p>
<p><img src="/2022/09/24/redis%E5%8E%9F%E7%90%86%E7%AF%87/1653986667228.png" alt="1653986667228"></p>
<p>我们接下来用一段流程图来描述当前的这个结构</p>
<p><img src="/2022/09/24/redis%E5%8E%9F%E7%90%86%E7%AF%87/1653986718554.png" alt="1653986718554"></p>
<p>总结：</p>
<p>QuickList的特点：</p>
<ul>
<li>是一个节点为ZipList的双端链表</li>
<li>节点采用ZipList，解决了传统链表的内存占用问题</li>
<li>控制了ZipList大小，解决连续内存空间申请效率问题</li>
<li>中间节点可以压缩，进一步节省了内存</li>
</ul>
<p>1.7 Redis数据结构-SkipList</p>
<p>SkipList（跳表）首先是链表，但与传统链表相比有几点差异：<br>元素按照升序排列存储<br>节点可能包含多个指针，指针跨度不同。</p>
<p><img src="/2022/09/24/redis%E5%8E%9F%E7%90%86%E7%AF%87/1653986771309.png" alt="1653986771309"></p>
<p>SkipList（跳表）首先是链表，但与传统链表相比有几点差异：<br>元素按照升序排列存储<br>节点可能包含多个指针，指针跨度不同。</p>
<p><img src="/2022/09/24/redis%E5%8E%9F%E7%90%86%E7%AF%87/1653986813240.png" alt="1653986813240"></p>
<p>SkipList（跳表）首先是链表，但与传统链表相比有几点差异：<br>元素按照升序排列存储<br>节点可能包含多个指针，指针跨度不同。</p>
<p><img src="/2022/09/24/redis%E5%8E%9F%E7%90%86%E7%AF%87/1653986877620.png" alt="1653986877620"></p>
<p>小总结：</p>
<p>SkipList的特点：</p>
<ul>
<li>跳跃表是一个双向链表，每个节点都包含score和ele值</li>
<li>节点按照score值排序，score值一样则按照ele字典排序</li>
<li>每个节点都可以包含多层指针，层数是1到32之间的随机数</li>
<li>不同层指针到下一个节点的跨度不同，层级越高，跨度越大</li>
<li>增删改查效率与红黑树基本一致，实现却更简单</li>
</ul>
<h3 id="1-7-Redis数据结构-RedisObject"><a href="#1-7-Redis数据结构-RedisObject" class="headerlink" title="1.7 Redis数据结构-RedisObject"></a>1.7 Redis数据结构-RedisObject</h3><p>Redis中的任意数据类型的键和值都会被封装为一个RedisObject，也叫做Redis对象，源码如下：</p>
<p>1、什么是redisObject：<br>从Redis的使用者的角度来看，⼀个Redis节点包含多个database（非cluster模式下默认是16个，cluster模式下只能是1个），而一个database维护了从key space到object space的映射关系。这个映射关系的key是string类型，⽽value可以是多种数据类型，比如：<br>string, list, hash、set、sorted set等。我们可以看到，key的类型固定是string，而value可能的类型是多个。<br>⽽从Redis内部实现的⾓度来看，database内的这个映射关系是用⼀个dict来维护的。dict的key固定用⼀种数据结构来表达就够了，这就是动态字符串sds。而value则比较复杂，为了在同⼀个dict内能够存储不同类型的value，这就需要⼀个通⽤的数据结构，这个通用的数据结构就是robj，全名是redisObject。</p>
<p><img src="/2022/09/24/redis%E5%8E%9F%E7%90%86%E7%AF%87/1653986956618.png" alt="1653986956618"></p>
<p>Redis的编码方式</p>
<p>Redis中会根据存储的数据类型不同，选择不同的编码方式，共包含11种不同类型：</p>
<table>
<thead>
<tr>
<th><strong>编号</strong></th>
<th><strong>编码方式</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>OBJ_ENCODING_RAW</td>
<td>raw编码动态字符串</td>
</tr>
<tr>
<td>1</td>
<td>OBJ_ENCODING_INT</td>
<td>long类型的整数的字符串</td>
</tr>
<tr>
<td>2</td>
<td>OBJ_ENCODING_HT</td>
<td>hash表（字典dict）</td>
</tr>
<tr>
<td>3</td>
<td>OBJ_ENCODING_ZIPMAP</td>
<td>已废弃</td>
</tr>
<tr>
<td>4</td>
<td>OBJ_ENCODING_LINKEDLIST</td>
<td>双端链表</td>
</tr>
<tr>
<td>5</td>
<td>OBJ_ENCODING_ZIPLIST</td>
<td>压缩列表</td>
</tr>
<tr>
<td>6</td>
<td>OBJ_ENCODING_INTSET</td>
<td>整数集合</td>
</tr>
<tr>
<td>7</td>
<td>OBJ_ENCODING_SKIPLIST</td>
<td>跳表</td>
</tr>
<tr>
<td>8</td>
<td>OBJ_ENCODING_EMBSTR</td>
<td>embstr的动态字符串</td>
</tr>
<tr>
<td>9</td>
<td>OBJ_ENCODING_QUICKLIST</td>
<td>快速列表</td>
</tr>
<tr>
<td>10</td>
<td>OBJ_ENCODING_STREAM</td>
<td>Stream流</td>
</tr>
</tbody></table>
<p>五种数据结构</p>
<p>Redis中会根据存储的数据类型不同，选择不同的编码方式。每种数据类型的使用的编码方式如下：</p>
<table>
<thead>
<tr>
<th><strong>数据类型</strong></th>
<th><strong>编码方式</strong></th>
</tr>
</thead>
<tbody><tr>
<td>OBJ_STRING</td>
<td>int、embstr、raw</td>
</tr>
<tr>
<td>OBJ_LIST</td>
<td>LinkedList和ZipList(3.2以前)、QuickList（3.2以后）</td>
</tr>
<tr>
<td>OBJ_SET</td>
<td>intset、HT</td>
</tr>
<tr>
<td>OBJ_ZSET</td>
<td>ZipList、HT、SkipList</td>
</tr>
<tr>
<td>OBJ_HASH</td>
<td>ZipList、HT</td>
</tr>
</tbody></table>
<h3 id="1-8-Redis数据结构-String"><a href="#1-8-Redis数据结构-String" class="headerlink" title="1.8 Redis数据结构-String"></a>1.8 Redis数据结构-String</h3><p>String是Redis中最常见的数据存储类型：</p>
<p>其基本编码方式是RAW，基于简单动态字符串（SDS）实现，存储上限为512mb。</p>
<p>如果存储的SDS长度小于44字节，则会采用EMBSTR编码，此时object head与SDS是一段连续空间。申请内存时</p>
<p>只需要调用一次内存分配函数，效率更高。</p>
<p>（1）底层实现⽅式：动态字符串sds 或者 long<br>String的内部存储结构⼀般是sds（Simple Dynamic String，可以动态扩展内存），但是如果⼀个String类型的value的值是数字，那么Redis内部会把它转成long类型来存储，从⽽减少内存的使用。</p>
<p><img src="/2022/09/24/redis%E5%8E%9F%E7%90%86%E7%AF%87/1653987103450.png" alt="1653987103450"></p>
<p>如果存储的字符串是整数值，并且大小在LONG_MAX范围内，则会采用INT编码：直接将数据保存在RedisObject的ptr指针位置（刚好8字节），不再需要SDS了。</p>
<p><img src="/2022/09/24/redis%E5%8E%9F%E7%90%86%E7%AF%87/1653987159575.png" alt="1653987159575"></p>
<p><img src="/2022/09/24/redis%E5%8E%9F%E7%90%86%E7%AF%87/1653987172764.png" alt="1653987172764"></p>
<p><img src="/2022/09/24/redis%E5%8E%9F%E7%90%86%E7%AF%87/1653987202522.png" alt="1653987202522"></p>
<p>确切地说，String在Redis中是⽤⼀个robj来表示的。</p>
<p>用来表示String的robj可能编码成3种内部表⽰：OBJ_ENCODING_RAW，OBJ_ENCODING_EMBSTR，OBJ_ENCODING_INT。<br>其中前两种编码使⽤的是sds来存储，最后⼀种OBJ_ENCODING_INT编码直接把string存成了long型。<br>在对string进行incr, decr等操作的时候，如果它内部是OBJ_ENCODING_INT编码，那么可以直接行加减操作；如果它内部是OBJ_ENCODING_RAW或OBJ_ENCODING_EMBSTR编码，那么Redis会先试图把sds存储的字符串转成long型，如果能转成功，再进行加减操作。对⼀个内部表示成long型的string执行append, setbit, getrange这些命令，针对的仍然是string的值（即⼗进制表示的字符串），而不是针对内部表⽰的long型进⾏操作。比如字符串”32”，如果按照字符数组来解释，它包含两个字符，它们的ASCII码分别是0x33和0x32。当我们执行命令setbit key 7 0的时候，相当于把字符0x33变成了0x32，这样字符串的值就变成了”22”。⽽如果将字符串”32”按照内部的64位long型来解释，那么它是0x0000000000000020，在这个基础上执⾏setbit位操作，结果就完全不对了。因此，在这些命令的实现中，会把long型先转成字符串再进行相应的操作。</p>
<h3 id="1-9-Redis数据结构-List"><a href="#1-9-Redis数据结构-List" class="headerlink" title="1.9 Redis数据结构-List"></a>1.9 Redis数据结构-List</h3><p>Redis的List类型可以从首、尾操作列表中的元素：</p>
<p><img src="/2022/09/24/redis%E5%8E%9F%E7%90%86%E7%AF%87/1653987240622.png" alt="1653987240622"></p>
<p>哪一个数据结构能满足上述特征？</p>
<ul>
<li>LinkedList ：普通链表，可以从双端访问，内存占用较高，内存碎片较多</li>
<li>ZipList ：压缩列表，可以从双端访问，内存占用低，存储上限低</li>
<li>QuickList：LinkedList + ZipList，可以从双端访问，内存占用较低，包含多个ZipList，存储上限高</li>
</ul>
<p>Redis的List结构类似一个双端链表，可以从首、尾操作列表中的元素：</p>
<p>在3.2版本之前，Redis采用ZipList和LinkedList来实现List，当元素数量小于512并且元素大小小于64字节时采用ZipList编码，超过则采用LinkedList编码。</p>
<p>在3.2版本之后，Redis统一采用QuickList来实现List：</p>
<p><img src="/2022/09/24/redis%E5%8E%9F%E7%90%86%E7%AF%87/1653987313461.png" alt="1653987313461"></p>
<h3 id="2-0-Redis数据结构-Set结构"><a href="#2-0-Redis数据结构-Set结构" class="headerlink" title="2.0 Redis数据结构-Set结构"></a>2.0 Redis数据结构-Set结构</h3><p>Set是Redis中的单列集合，满足下列特点：</p>
<ul>
<li>不保证有序性</li>
<li>保证元素唯一</li>
<li>求交集、并集、差集</li>
</ul>
<p><img src="/2022/09/24/redis%E5%8E%9F%E7%90%86%E7%AF%87/1653987342550.png" alt="1653987342550"></p>
<p>可以看出，Set对查询元素的效率要求非常高，思考一下，什么样的数据结构可以满足？<br>HashTable，也就是Redis中的Dict，不过Dict是双列集合（可以存键、值对）</p>
<p>Set是Redis中的集合，不一定确保元素有序，可以满足元素唯一、查询效率要求极高。<br>为了查询效率和唯一性，set采用HT编码（Dict）。Dict中的key用来存储元素，value统一为null。<br>当存储的所有数据都是整数，并且元素数量不超过set-max-intset-entries时，Set会采用IntSet编码，以节省内存</p>
<p><img src="/2022/09/24/redis%E5%8E%9F%E7%90%86%E7%AF%87/1653987388177.png" alt="1653987388177"></p>
<p>结构如下：</p>
<p>​	<img src="/2022/09/24/redis%E5%8E%9F%E7%90%86%E7%AF%87/1653987454403.png" alt="1653987454403"></p>
<h3 id="2-1、Redis数据结构-ZSET"><a href="#2-1、Redis数据结构-ZSET" class="headerlink" title="2.1、Redis数据结构-ZSET"></a>2.1、Redis数据结构-ZSET</h3><p>ZSet也就是SortedSet，其中每一个元素都需要指定一个score值和member值：</p>
<ul>
<li>可以根据score值排序后</li>
<li>member必须唯一</li>
<li>可以根据member查询分数</li>
</ul>
<p><img src="/2022/09/24/redis%E5%8E%9F%E7%90%86%E7%AF%87/1653992091967.png" alt="1653992091967"></p>
<p>因此，zset底层数据结构必须满足键值存储、键必须唯一、可排序这几个需求。之前学习的哪种编码结构可以满足？</p>
<ul>
<li>SkipList：可以排序，并且可以同时存储score和ele值（member）</li>
<li>HT（Dict）：可以键值存储，并且可以根据key找value</li>
</ul>
<p><img src="/2022/09/24/redis%E5%8E%9F%E7%90%86%E7%AF%87/1653992121692.png" alt="1653992121692"></p>
<p><img src="/2022/09/24/redis%E5%8E%9F%E7%90%86%E7%AF%87/1653992172526.png" alt="1653992172526"></p>
<p>当元素数量不多时，HT和SkipList的优势不明显，而且更耗内存。因此zset还会采用ZipList结构来节省内存，不过需要同时满足两个条件：</p>
<ul>
<li>元素数量小于zset_max_ziplist_entries，默认值128</li>
<li>每个元素都小于zset_max_ziplist_value字节，默认值64</li>
</ul>
<p>ziplist本身没有排序功能，而且没有键值对的概念，因此需要有zset通过编码实现：</p>
<ul>
<li>ZipList是连续内存，因此score和element是紧挨在一起的两个entry， element在前，score在后</li>
<li>score越小越接近队首，score越大越接近队尾，按照score值升序排列</li>
</ul>
<p><img src="/2022/09/24/redis%E5%8E%9F%E7%90%86%E7%AF%87/1653992238097.png" alt="1653992238097"></p>
<p><img src="/2022/09/24/redis%E5%8E%9F%E7%90%86%E7%AF%87/1653992299740.png" alt="1653992299740"></p>
<h3 id="2-2-、Redis数据结构-Hash"><a href="#2-2-、Redis数据结构-Hash" class="headerlink" title="2.2 、Redis数据结构-Hash"></a>2.2 、Redis数据结构-Hash</h3><p>Hash结构与Redis中的Zset非常类似：</p>
<ul>
<li>都是键值存储</li>
<li>都需求根据键获取值</li>
<li>键必须唯一</li>
</ul>
<p>区别如下：</p>
<ul>
<li>zset的键是member，值是score；hash的键和值都是任意值</li>
<li>zset要根据score排序；hash则无需排序</li>
</ul>
<p>（1）底层实现方式：压缩列表ziplist 或者 字典dict<br>当Hash中数据项比较少的情况下，Hash底层才⽤压缩列表ziplist进⾏存储数据，随着数据的增加，底层的ziplist就可能会转成dict，具体配置如下：</p>
<p>hash-max-ziplist-entries 512</p>
<p>hash-max-ziplist-value 64</p>
<p>当满足上面两个条件其中之⼀的时候，Redis就使⽤dict字典来实现hash。<br>Redis的hash之所以这样设计，是因为当ziplist变得很⼤的时候，它有如下几个缺点：</p>
<ul>
<li>每次插⼊或修改引发的realloc操作会有更⼤的概率造成内存拷贝，从而降低性能。</li>
<li>⼀旦发生内存拷贝，内存拷贝的成本也相应增加，因为要拷贝更⼤的⼀块数据。</li>
<li>当ziplist数据项过多的时候，在它上⾯查找指定的数据项就会性能变得很低，因为ziplist上的查找需要进行遍历。</li>
</ul>
<p>总之，ziplist本来就设计为各个数据项挨在⼀起组成连续的内存空间，这种结构并不擅长做修改操作。⼀旦数据发⽣改动，就会引发内存realloc，可能导致内存拷贝。</p>
<p>hash结构如下：</p>
<p><img src="/2022/09/24/redis%E5%8E%9F%E7%90%86%E7%AF%87/1653992339937.png" alt="1653992339937"></p>
<p>zset集合如下：</p>
<p><img src="/2022/09/24/redis%E5%8E%9F%E7%90%86%E7%AF%87/1653992360355.png" alt="1653992360355"></p>
<p>因此，Hash底层采用的编码与Zset也基本一致，只需要把排序有关的SkipList去掉即可：</p>
<p>Hash结构默认采用ZipList编码，用以节省内存。 ZipList中相邻的两个entry 分别保存field和value</p>
<p>当数据量较大时，Hash结构会转为HT编码，也就是Dict，触发条件有两个：</p>
<ul>
<li>ZipList中的元素数量超过了hash-max-ziplist-entries（默认512）</li>
<li>ZipList中的任意entry大小超过了hash-max-ziplist-value（默认64字节）</li>
</ul>
<p><img src="/2022/09/24/redis%E5%8E%9F%E7%90%86%E7%AF%87/1653992413406.png" alt="1653992413406"></p>
<h2 id="2、原理篇-Redis网络模型"><a href="#2、原理篇-Redis网络模型" class="headerlink" title="2、原理篇-Redis网络模型"></a>2、原理篇-Redis网络模型</h2><h3 id="2-1-用户空间和内核态空间"><a href="#2-1-用户空间和内核态空间" class="headerlink" title="2.1 用户空间和内核态空间"></a>2.1 用户空间和内核态空间</h3><p>服务器大多都采用Linux系统，这里我们以Linux为例来讲解:</p>
<p>ubuntu和Centos 都是Linux的发行版，发行版可以看成对linux包了一层壳，任何Linux发行版，其系统内核都是Linux。我们的应用都需要通过Linux内核与硬件交互</p>
<p><img src="/2022/09/24/redis%E5%8E%9F%E7%90%86%E7%AF%87/1653844970346.png" alt="1653844970346"></p>
<p>用户的应用，比如redis，mysql等其实是没有办法去执行访问我们操作系统的硬件的，所以我们可以通过发行版的这个壳子去访问内核，再通过内核去访问计算机硬件</p>
<p><img src="/2022/09/24/redis%E5%8E%9F%E7%90%86%E7%AF%87/1653845147190.png" alt="1653845147190"></p>
<p>计算机硬件包括，如cpu，内存，网卡等等，内核（通过寻址空间）可以操作硬件的，但是内核需要不同设备的驱动，有了这些驱动之后，内核就可以去对计算机硬件去进行 内存管理，文件系统的管理，进程的管理等等</p>
<p><img src="/2022/09/24/redis%E5%8E%9F%E7%90%86%E7%AF%87/1653896065386.png" alt="1653896065386"></p>
<p>我们想要用户的应用来访问，计算机就必须要通过对外暴露的一些接口，才能访问到，从而简介的实现对内核的操控，但是内核本身上来说也是一个应用，所以他本身也需要一些内存，cpu等设备资源，用户应用本身也在消耗这些资源，如果不加任何限制，用户去操作随意的去操作我们的资源，就有可能导致一些冲突，甚至有可能导致我们的系统出现无法运行的问题，因此我们需要把用户和<strong>内核隔离开</strong></p>
<p>进程的寻址空间划分成两部分：<strong>内核空间、用户空间</strong></p>
<p>什么是寻址空间呢？我们的应用程序也好，还是内核空间也好，都是没有办法直接去物理内存的，而是通过分配一些虚拟内存映射到物理内存中，我们的内核和应用程序去访问虚拟内存的时候，就需要一个虚拟地址，这个地址是一个无符号的整数，比如一个32位的操作系统，他的带宽就是32，他的虚拟地址就是2的32次方，也就是说他寻址的范围就是0~2的32次方， 这片寻址空间对应的就是2的32个字节，就是4GB，这个4GB，会有3个GB分给用户空间，会有1GB给内核系统</p>
<p><img src="/2022/09/24/redis%E5%8E%9F%E7%90%86%E7%AF%87/1653896377259.png" alt="1653896377259"></p>
<p>在linux中，他们权限分成两个等级，0和3，用户空间只能执行受限的命令（Ring3），而且不能直接调用系统资源，必须通过内核提供的接口来访问内核空间可以执行特权命令（Ring0），调用一切系统资源，所以一般情况下，用户的操作是运行在用户空间，而内核运行的数据是在内核空间的，而有的情况下，一个应用程序需要去调用一些特权资源，去调用一些内核空间的操作，所以此时他俩需要在用户态和内核态之间进行切换。</p>
<p>比如：</p>
<p>Linux系统为了提高IO效率，会在用户空间和内核空间都加入缓冲区：</p>
<p>写数据时，要把用户缓冲数据拷贝到内核缓冲区，然后写入设备</p>
<p>读数据时，要从设备读取数据到内核缓冲区，然后拷贝到用户缓冲区</p>
<p>针对这个操作：我们的用户在写读数据时，会去向内核态申请，想要读取内核的数据，而内核数据要去等待驱动程序从硬件上读取数据，当从磁盘上加载到数据之后，内核会将数据写入到内核的缓冲区中，然后再将数据拷贝到用户态的buffer中，然后再返回给应用程序，整体而言，速度慢，就是这个原因，为了加速，我们希望read也好，还是wait for data也最好都不要等待，或者时间尽量的短。</p>
<p><img src="/2022/09/24/redis%E5%8E%9F%E7%90%86%E7%AF%87/1653896687354.png" alt="1653896687354"></p>
<h3 id="2-2-网络模型-阻塞IO"><a href="#2-2-网络模型-阻塞IO" class="headerlink" title="2.2.网络模型-阻塞IO"></a>2.2.网络模型-阻塞IO</h3><p>在《UNIX网络编程》一书中，总结归纳了5种IO模型：</p>
<ul>
<li>阻塞IO（Blocking IO）</li>
<li>非阻塞IO（Nonblocking IO）</li>
<li>IO多路复用（IO Multiplexing）</li>
<li>信号驱动IO（Signal Driven IO）</li>
<li>异步IO（Asynchronous IO）</li>
</ul>
<p>应用程序想要去读取数据，他是无法直接去读取磁盘数据的，他需要先到内核里边去等待内核操作硬件拿到数据，这个过程就是1，是需要等待的，等到内核从磁盘上把数据加载出来之后，再把这个数据写给用户的缓存区，这个过程是2，如果是阻塞IO，那么整个过程中，用户从发起读请求开始，一直到读取到数据，都是一个阻塞状态。</p>
<p><img src="/2022/09/24/redis%E5%8E%9F%E7%90%86%E7%AF%87/1653897115346.png" alt="1653897115346"></p>
<p>具体流程如下图：</p>
<p>用户去读取数据时，会去先发起recvform一个命令，去尝试从内核上加载数据，如果内核没有数据，那么用户就会等待，此时内核会去从硬件上读取数据，内核读取数据之后，会把数据拷贝到用户态，并且返回ok，整个过程，都是阻塞等待的，这就是阻塞IO</p>
<p>总结如下：</p>
<p>顾名思义，阻塞IO就是两个阶段都必须阻塞等待：</p>
<p><strong>阶段一：</strong></p>
<ul>
<li>用户进程尝试读取数据（比如网卡数据）</li>
<li>此时数据尚未到达，内核需要等待数据</li>
<li>此时用户进程也处于阻塞状态</li>
</ul>
<p>阶段二：</p>
<ul>
<li>数据到达并拷贝到内核缓冲区，代表已就绪</li>
<li>将内核数据拷贝到用户缓冲区</li>
<li>拷贝过程中，用户进程依然阻塞等待</li>
<li>拷贝完成，用户进程解除阻塞，处理数据</li>
</ul>
<p>可以看到，阻塞IO模型中，用户进程在两个阶段都是阻塞状态。</p>
<p><img src="/2022/09/24/redis%E5%8E%9F%E7%90%86%E7%AF%87/1653897270074.png" alt="1653897270074"></p>
<h3 id="2-3-网络模型-非阻塞IO"><a href="#2-3-网络模型-非阻塞IO" class="headerlink" title="2.3 网络模型-非阻塞IO"></a>2.3 网络模型-非阻塞IO</h3><p>顾名思义，非阻塞IO的recvfrom操作会立即返回结果而不是阻塞用户进程。</p>
<p>阶段一：</p>
<ul>
<li>用户进程尝试读取数据（比如网卡数据）</li>
<li>此时数据尚未到达，内核需要等待数据</li>
<li>返回异常给用户进程</li>
<li>用户进程拿到error后，再次尝试读取</li>
<li>循环往复，直到数据就绪</li>
</ul>
<p>阶段二：</p>
<ul>
<li>将内核数据拷贝到用户缓冲区</li>
<li>拷贝过程中，用户进程依然阻塞等待</li>
<li>拷贝完成，用户进程解除阻塞，处理数据</li>
<li>可以看到，非阻塞IO模型中，用户进程在第一个阶段是非阻塞，第二个阶段是阻塞状态。虽然是非阻塞，但性能并没有得到提高。而且忙等机制会导致CPU空转，CPU使用率暴增。</li>
</ul>
<p><img src="/2022/09/24/redis%E5%8E%9F%E7%90%86%E7%AF%87/1653897490116.png" alt="1653897490116"></p>
<h3 id="2-4-网络模型-IO多路复用"><a href="#2-4-网络模型-IO多路复用" class="headerlink" title="2.4 网络模型-IO多路复用"></a>2.4 网络模型-IO多路复用</h3><p>无论是阻塞IO还是非阻塞IO，用户应用在一阶段都需要调用recvfrom来获取数据，差别在于无数据时的处理方案：</p>
<p>如果调用recvfrom时，恰好没有数据，阻塞IO会使CPU阻塞，非阻塞IO使CPU空转，都不能充分发挥CPU的作用。<br>如果调用recvfrom时，恰好有数据，则用户进程可以直接进入第二阶段，读取并处理数据</p>
<p>所以怎么看起来以上两种方式性能都不好</p>
<p>而在单线程情况下，只能依次处理IO事件，如果正在处理的IO事件恰好未就绪（数据不可读或不可写），线程就会被阻塞，所有IO事件都必须等待，性能自然会很差。</p>
<p>就比如服务员给顾客点餐，<strong>分两步</strong>：</p>
<ul>
<li>顾客思考要吃什么（等待数据就绪）</li>
<li>顾客想好了，开始点餐（读取数据）</li>
</ul>
<p>要提高效率有几种办法？</p>
<p>方案一：增加更多服务员（多线程）<br>方案二：不排队，谁想好了吃什么（数据就绪了），服务员就给谁点餐（用户应用就去读取数据）</p>
<p>那么问题来了：用户进程如何知道内核中数据是否就绪呢？</p>
<p>所以接下来就需要详细的来解决多路复用模型是如何知道到底怎么知道内核数据是否就绪的问题了</p>
<p>这个问题的解决依赖于提出的</p>
<p>文件描述符（File Descriptor）：简称FD，是一个从0 开始的无符号整数，用来关联Linux中的一个文件。在Linux中，一切皆文件，例如常规文件、视频、硬件设备等，当然也包括网络套接字（Socket）。</p>
<p>通过FD，我们的网络模型可以利用一个线程监听多个FD，并在某个FD可读、可写时得到通知，从而避免无效的等待，充分利用CPU资源。</p>
<p>阶段一：</p>
<ul>
<li>用户进程调用select，指定要监听的FD集合</li>
<li>核监听FD对应的多个socket</li>
<li>任意一个或多个socket数据就绪则返回readable</li>
<li>此过程中用户进程阻塞</li>
</ul>
<p>阶段二：</p>
<ul>
<li>用户进程找到就绪的socket</li>
<li>依次调用recvfrom读取数据</li>
<li>内核将数据拷贝到用户空间</li>
<li>用户进程处理数据</li>
</ul>
<p>当用户去读取数据的时候，不再去直接调用recvfrom了，而是调用select的函数，select函数会将需要监听的数据交给内核，由内核去检查这些数据是否就绪了，如果说这个数据就绪了，就会通知应用程序数据就绪，然后来读取数据，再从内核中把数据拷贝给用户态，完成数据处理，如果N多个FD一个都没处理完，此时就进行等待。</p>
<p>用IO复用模式，可以确保去读数据的时候，数据是一定存在的，他的效率比原来的阻塞IO和非阻塞IO性能都要高</p>
<p><img src="/2022/09/24/redis%E5%8E%9F%E7%90%86%E7%AF%87/1653898691736.png" alt="1653898691736"></p>
<p>IO多路复用是利用单个线程来同时监听多个FD，并在某个FD可读、可写时得到通知，从而避免无效的等待，充分利用CPU资源。不过监听FD的方式、通知的方式又有多种实现，常见的有：</p>
<ul>
<li>select</li>
<li>poll</li>
<li>epoll</li>
</ul>
<p>其中select和pool相当于是当被监听的数据准备好之后，他会把你监听的FD整个数据都发给你，你需要到整个FD中去找，哪些是处理好了的，需要通过遍历的方式，所以性能也并不是那么好</p>
<p>而epoll，则相当于内核准备好了之后，他会把准备好的数据，直接发给你，咱们就省去了遍历的动作。</p>
<h3 id="2-5-网络模型-IO多路复用-select方式"><a href="#2-5-网络模型-IO多路复用-select方式" class="headerlink" title="2.5 网络模型-IO多路复用-select方式"></a>2.5 网络模型-IO多路复用-select方式</h3><p>select是Linux最早是由的I&#x2F;O多路复用技术：</p>
<p>简单说，就是我们把需要处理的数据封装成FD，然后在用户态时创建一个fd的集合（这个集合的大小是要监听的那个FD的最大值+1，但是大小整体是有限制的 ），这个集合的长度大小是有限制的，同时在这个集合中，标明出来我们要控制哪些数据，</p>
<p>比如要监听的数据，是1,2,5三个数据，此时会执行select函数，然后将整个fd发给内核态，内核态会去遍历用户态传递过来的数据，如果发现这里边都数据都没有就绪，就休眠，直到有数据准备好时，就会被唤醒，唤醒之后，再次遍历一遍，看看谁准备好了，然后再将处理掉没有准备好的数据，最后再将这个FD集合写回到用户态中去，此时用户态就知道了，奥，有人准备好了，但是对于用户态而言，并不知道谁处理好了，所以用户态也需要去进行遍历，然后找到对应准备好数据的节点，再去发起读请求，我们会发现，这种模式下他虽然比阻塞IO和非阻塞IO好，但是依然有些麻烦的事情， 比如说频繁的传递fd集合，频繁的去遍历FD等问题</p>
<p><img src="/2022/09/24/redis%E5%8E%9F%E7%90%86%E7%AF%87/1653900022580.png" alt="1653900022580"></p>
<h3 id="2-6-网络模型-IO多路复用模型-poll模式"><a href="#2-6-网络模型-IO多路复用模型-poll模式" class="headerlink" title="2.6 网络模型-IO多路复用模型-poll模式"></a>2.6 网络模型-IO多路复用模型-poll模式</h3><p>poll模式对select模式做了简单改进，但性能提升不明显，部分关键代码如下：</p>
<p>IO流程：</p>
<ul>
<li>创建pollfd数组，向其中添加关注的fd信息，数组大小自定义</li>
<li>调用poll函数，将pollfd数组拷贝到内核空间，转链表存储，无上限</li>
<li>内核遍历fd，判断是否就绪</li>
<li>数据就绪或超时后，拷贝pollfd数组到用户空间，返回就绪fd数量n</li>
<li>用户进程判断n是否大于0,大于0则遍历pollfd数组，找到就绪的fd</li>
</ul>
<p><strong>与select对比：</strong></p>
<ul>
<li>select模式中的fd_set大小固定为1024，而pollfd在内核中采用链表，理论上无上限</li>
<li>监听FD越多，每次遍历消耗时间也越久，性能反而会下降</li>
</ul>
<p><img src="/2022/09/24/redis%E5%8E%9F%E7%90%86%E7%AF%87/1653900721427.png" alt="1653900721427"></p>
<h3 id="2-7-网络模型-IO多路复用模型-epoll函数"><a href="#2-7-网络模型-IO多路复用模型-epoll函数" class="headerlink" title="2.7 网络模型-IO多路复用模型-epoll函数"></a>2.7 网络模型-IO多路复用模型-epoll函数</h3><p>epoll模式是对select和poll的改进，它提供了三个函数：</p>
<p>第一个是：eventpoll的函数，他内部包含两个东西</p>
<p>一个是：</p>
<p>1、红黑树-&gt; 记录的事要监听的FD</p>
<p>2、一个是链表-&gt;一个链表，记录的是就绪的FD</p>
<p>紧接着调用epoll_ctl操作，将要监听的数据添加到红黑树上去，并且给每个fd设置一个监听函数，这个函数会在fd数据就绪时触发，就是准备好了，现在就把fd把数据添加到list_head中去</p>
<p>3、调用epoll_wait函数</p>
<p>就去等待，在用户态创建一个空的events数组，当就绪之后，我们的回调函数会把数据添加到list_head中去，当调用这个函数的时候，会去检查list_head，当然这个过程需要参考配置的等待时间，可以等一定时间，也可以一直等， 如果在此过程中，检查到了list_head中有数据会将数据添加到链表中，此时将数据放入到events数组中，并且返回对应的操作的数量，用户态的此时收到响应后，从events中拿到对应准备好的数据的节点，再去调用方法去拿数据。</p>
<p>小总结：</p>
<p>select模式存在的三个问题：</p>
<ul>
<li>能监听的FD最大不超过1024</li>
<li>每次select都需要把所有要监听的FD都拷贝到内核空间</li>
<li>每次都要遍历所有FD来判断就绪状态</li>
</ul>
<p>poll模式的问题：</p>
<ul>
<li>poll利用链表解决了select中监听FD上限的问题，但依然要遍历所有FD，如果监听较多，性能会下降</li>
</ul>
<p>epoll模式中如何解决这些问题的？</p>
<ul>
<li>基于epoll实例中的红黑树保存要监听的FD，理论上无上限，而且增删改查效率都非常高</li>
<li>每个FD只需要执行一次epoll_ctl添加到红黑树，以后每次epol_wait无需传递任何参数，无需重复拷贝FD到内核空间</li>
<li>利用ep_poll_callback机制来监听FD状态，无需遍历所有FD，因此性能不会随监听的FD数量增多而下降</li>
</ul>
<h3 id="2-8、网络模型-epoll中的ET和LT"><a href="#2-8、网络模型-epoll中的ET和LT" class="headerlink" title="2.8、网络模型-epoll中的ET和LT"></a>2.8、网络模型-epoll中的ET和LT</h3><p>当FD有数据可读时，我们调用epoll_wait（或者select、poll）可以得到通知。但是事件通知的模式有两种：</p>
<ul>
<li>LevelTriggered：简称LT，也叫做水平触发。只要某个FD中有数据可读，每次调用epoll_wait都会得到通知。</li>
<li>EdgeTriggered：简称ET，也叫做边沿触发。只有在某个FD有状态变化时，调用epoll_wait才会被通知。</li>
</ul>
<p>举个栗子：</p>
<ul>
<li>假设一个客户端socket对应的FD已经注册到了epoll实例中</li>
<li>客户端socket发送了2kb的数据</li>
<li>服务端调用epoll_wait，得到通知说FD就绪</li>
<li>服务端从FD读取了1kb数据回到步骤3（再次调用epoll_wait，形成循环）</li>
</ul>
<p>结论</p>
<p>如果我们采用LT模式，因为FD中仍有1kb数据，则第⑤步依然会返回结果，并且得到通知<br>如果我们采用ET模式，因为第③步已经消费了FD可读事件，第⑤步FD状态没有变化，因此epoll_wait不会返回，数据无法读取，客户端响应超时。</p>
<h3 id="2-9-网络模型-基于epoll的服务器端流程"><a href="#2-9-网络模型-基于epoll的服务器端流程" class="headerlink" title="2.9 网络模型-基于epoll的服务器端流程"></a>2.9 网络模型-基于epoll的服务器端流程</h3><p>我们来梳理一下这张图</p>
<p>服务器启动以后，服务端会去调用epoll_create，创建一个epoll实例，epoll实例中包含两个数据</p>
<p>1、红黑树（为空）：rb_root 用来去记录需要被监听的FD</p>
<p>2、链表（为空）：list_head，用来存放已经就绪的FD</p>
<p>创建好了之后，会去调用epoll_ctl函数，此函数会会将需要监听的数据添加到rb_root中去，并且对当前这些存在于红黑树的节点设置回调函数，当这些被监听的数据一旦准备完成，就会被调用，而调用的结果就是将红黑树的fd添加到list_head中去(但是此时并没有完成)</p>
<p>3、当第二步完成后，就会调用epoll_wait函数，这个函数会去校验是否有数据准备完毕（因为数据一旦准备就绪，就会被回调函数添加到list_head中），在等待了一段时间后(可以进行配置)，如果等够了超时时间，则返回没有数据，如果有，则进一步判断当前是什么事件，如果是建立连接时间，则调用accept() 接受客户端socket，拿到建立连接的socket，然后建立起来连接，如果是其他事件，则把数据进行写出</p>
<p><img src="/2022/09/24/redis%E5%8E%9F%E7%90%86%E7%AF%87/1653902845082.png" alt="1653902845082"></p>
<h3 id="3-0-、网络模型-信号驱动"><a href="#3-0-、网络模型-信号驱动" class="headerlink" title="3.0 、网络模型-信号驱动"></a>3.0 、网络模型-信号驱动</h3><p>信号驱动IO是与内核建立SIGIO的信号关联并设置回调，当内核有FD就绪时，会发出SIGIO信号通知用户，期间用户应用可以执行其它业务，无需阻塞等待。</p>
<p>阶段一：</p>
<ul>
<li>用户进程调用sigaction，注册信号处理函数</li>
<li>内核返回成功，开始监听FD</li>
<li>用户进程不阻塞等待，可以执行其它业务</li>
<li>当内核数据就绪后，回调用户进程的SIGIO处理函数</li>
</ul>
<p>阶段二：</p>
<ul>
<li>收到SIGIO回调信号</li>
<li>调用recvfrom，读取</li>
<li>内核将数据拷贝到用户空间</li>
<li>用户进程处理数据</li>
</ul>
<p><img src="/2022/09/24/redis%E5%8E%9F%E7%90%86%E7%AF%87/1653911776583.png" alt="1653911776583"></p>
<p>当有大量IO操作时，信号较多，SIGIO处理函数不能及时处理可能导致信号队列溢出，而且内核空间与用户空间的频繁信号交互性能也较低。</p>
<h4 id="3-0-1-异步IO"><a href="#3-0-1-异步IO" class="headerlink" title="3.0.1 异步IO"></a>3.0.1 异步IO</h4><p>这种方式，不仅仅是用户态在试图读取数据后，不阻塞，而且当内核的数据准备完成后，也不会阻塞</p>
<p>他会由内核将所有数据处理完成后，由内核将数据写入到用户态中，然后才算完成，所以性能极高，不会有任何阻塞，全部都由内核完成，可以看到，异步IO模型中，用户进程在两个阶段都是非阻塞状态。</p>
<p><img src="/2022/09/24/redis%E5%8E%9F%E7%90%86%E7%AF%87/1653911877542.png" alt="1653911877542"></p>
<h4 id="3-0-2-对比"><a href="#3-0-2-对比" class="headerlink" title="3.0.2 对比"></a>3.0.2 对比</h4><p>最后用一幅图，来说明他们之间的区别</p>
<p><img src="/2022/09/24/redis%E5%8E%9F%E7%90%86%E7%AF%87/1653912219712.png" alt="1653912219712"></p>
<h3 id="3-1-、网络模型-Redis是单线程的吗？为什么使用单线程"><a href="#3-1-、网络模型-Redis是单线程的吗？为什么使用单线程" class="headerlink" title="3.1 、网络模型-Redis是单线程的吗？为什么使用单线程"></a>3.1 、网络模型-Redis是单线程的吗？为什么使用单线程</h3><p><strong>Redis到底是单线程还是多线程？</strong></p>
<ul>
<li>如果仅仅聊Redis的核心业务部分（命令处理），答案是单线程</li>
<li>如果是聊整个Redis，那么答案就是多线程</li>
</ul>
<p>在Redis版本迭代过程中，在两个重要的时间节点上引入了多线程的支持：</p>
<ul>
<li>Redis v4.0：引入多线程异步处理一些耗时较旧的任务，例如异步删除命令unlink</li>
<li>Redis v6.0：在核心网络模型中引入 多线程，进一步提高对于多核CPU的利用率</li>
</ul>
<p>因此，对于Redis的核心网络模型，在Redis 6.0之前确实都是单线程。是利用epoll（Linux系统）这样的IO多路复用技术在事件循环中不断处理客户端情况。</p>
<p><strong>为什么Redis要选择单线程？</strong></p>
<ul>
<li>抛开持久化不谈，Redis是纯  内存操作，执行速度非常快，它的性能瓶颈是网络延迟而不是执行速度，因此多线程并不会带来巨大的性能提升。</li>
<li>多线程会导致过多的上下文切换，带来不必要的开销</li>
<li>引入多线程会面临线程安全问题，必然要引入线程锁这样的安全手段，实现复杂度增高，而且性能也会大打折扣</li>
</ul>
<h3 id="3-2-、Redis的单线程模型-Redis单线程和多线程网络模型变更"><a href="#3-2-、Redis的单线程模型-Redis单线程和多线程网络模型变更" class="headerlink" title="3.2 、Redis的单线程模型-Redis单线程和多线程网络模型变更"></a>3.2 、Redis的单线程模型-Redis单线程和多线程网络模型变更</h3><p><img src="/2022/09/24/redis%E5%8E%9F%E7%90%86%E7%AF%87/1653982278727.png" alt="1653982278727"></p>
<p>当我们的客户端想要去连接我们服务器，会去先到IO多路复用模型去进行排队，会有一个连接应答处理器，他会去接受读请求，然后又把读请求注册到具体模型中去，此时这些建立起来的连接，如果是客户端请求处理器去进行执行命令时，他会去把数据读取出来，然后把数据放入到client中， clinet去解析当前的命令转化为redis认识的命令，接下来就开始处理这些命令，从redis中的command中找到这些命令，然后就真正的去操作对应的数据了，当数据操作完成后，会去找到命令回复处理器，再由他将数据写出。</p>
<h2 id="3、Redis通信协议-RESP协议"><a href="#3、Redis通信协议-RESP协议" class="headerlink" title="3、Redis通信协议-RESP协议"></a>3、Redis通信协议-RESP协议</h2><p>Redis是一个CS架构的软件，通信一般分两步（不包括pipeline和PubSub）：</p>
<p>客户端（client）向服务端（server）发送一条命令</p>
<p>服务端解析并执行命令，返回响应结果给客户端</p>
<p>因此客户端发送命令的格式、服务端响应结果的格式必须有一个规范，这个规范就是通信协议。</p>
<p>而在Redis中采用的是RESP（Redis Serialization Protocol）协议：</p>
<p>Redis 1.2版本引入了RESP协议</p>
<p>Redis 2.0版本中成为与Redis服务端通信的标准，称为RESP2</p>
<p>Redis 6.0版本中，从RESP2升级到了RESP3协议，增加了更多数据类型并且支持6.0的新特性–客户端缓存</p>
<p>但目前，默认使用的依然是RESP2协议，也是我们要学习的协议版本（以下简称RESP）。</p>
<p>在RESP中，通过首字节的字符来区分不同数据类型，常用的数据类型包括5种：</p>
<p>单行字符串：首字节是 ‘+’ ，后面跟上单行字符串，以CRLF（ “\r\n” ）结尾。例如返回”OK”： “+OK\r\n”</p>
<p>错误（Errors）：首字节是 ‘-’ ，与单行字符串格式一样，只是字符串是异常信息，例如：”-Error message\r\n”</p>
<p>数值：首字节是 ‘:’ ，后面跟上数字格式的字符串，以CRLF结尾。例如：”:10\r\n”</p>
<p>多行字符串：首字节是 ‘$’ ，表示二进制安全的字符串，最大支持512MB：</p>
<p>如果大小为0，则代表空字符串：”$0\r\n\r\n”</p>
<p>如果大小为-1，则代表不存在：”$-1\r\n”</p>
<p>数组：首字节是 ‘*’，后面跟上数组元素个数，再跟上元素，元素数据类型不限:</p>
<p><img src="/2022/09/24/redis%E5%8E%9F%E7%90%86%E7%AF%87/1653982993020.png" alt="1653982993020"></p>
<h3 id="3-1、Redis通信协议-基于Socket自定义Redis的客户端"><a href="#3-1、Redis通信协议-基于Socket自定义Redis的客户端" class="headerlink" title="3.1、Redis通信协议-基于Socket自定义Redis的客户端"></a>3.1、Redis通信协议-基于Socket自定义Redis的客户端</h3><p>Redis支持TCP通信，因此我们可以使用Socket来模拟客户端，与Redis服务端建立连接：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> Socket s;</span><br><span class="line">    <span class="keyword">static</span> PrintWriter writer;</span><br><span class="line">    <span class="keyword">static</span> BufferedReader reader;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 1.建立连接</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">host</span> <span class="operator">=</span> <span class="string">&quot;192.168.150.101&quot;</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">port</span> <span class="operator">=</span> <span class="number">6379</span>;</span><br><span class="line">            s = <span class="keyword">new</span> <span class="title class_">Socket</span>(host, port);</span><br><span class="line">            <span class="comment">// 2.获取输出流、输入流</span></span><br><span class="line">            writer = <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(<span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(s.getOutputStream(), StandardCharsets.UTF_8));</span><br><span class="line">            reader = <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(s.getInputStream(), StandardCharsets.UTF_8));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3.发出请求</span></span><br><span class="line">            <span class="comment">// 3.1.获取授权 auth 123321</span></span><br><span class="line">            sendRequest(<span class="string">&quot;auth&quot;</span>, <span class="string">&quot;123321&quot;</span>);</span><br><span class="line">            <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> handleResponse();</span><br><span class="line">            System.out.println(<span class="string">&quot;obj = &quot;</span> + obj);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3.2.set name 虎哥</span></span><br><span class="line">            sendRequest(<span class="string">&quot;set&quot;</span>, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;虎哥&quot;</span>);</span><br><span class="line">            <span class="comment">// 4.解析响应</span></span><br><span class="line">            obj = handleResponse();</span><br><span class="line">            System.out.println(<span class="string">&quot;obj = &quot;</span> + obj);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3.2.set name 虎哥</span></span><br><span class="line">            sendRequest(<span class="string">&quot;get&quot;</span>, <span class="string">&quot;name&quot;</span>);</span><br><span class="line">            <span class="comment">// 4.解析响应</span></span><br><span class="line">            obj = handleResponse();</span><br><span class="line">            System.out.println(<span class="string">&quot;obj = &quot;</span> + obj);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3.2.set name 虎哥</span></span><br><span class="line">            sendRequest(<span class="string">&quot;mget&quot;</span>, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;num&quot;</span>, <span class="string">&quot;msg&quot;</span>);</span><br><span class="line">            <span class="comment">// 4.解析响应</span></span><br><span class="line">            obj = handleResponse();</span><br><span class="line">            System.out.println(<span class="string">&quot;obj = &quot;</span> + obj);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 5.释放连接</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (reader != <span class="literal">null</span>) reader.close();</span><br><span class="line">                <span class="keyword">if</span> (writer != <span class="literal">null</span>) writer.close();</span><br><span class="line">                <span class="keyword">if</span> (s != <span class="literal">null</span>) s.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object <span class="title function_">handleResponse</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 读取首字节</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">prefix</span> <span class="operator">=</span> reader.read();</span><br><span class="line">        <span class="comment">// 判断数据类型标示</span></span><br><span class="line">        <span class="keyword">switch</span> (prefix) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>: <span class="comment">// 单行字符串，直接读一行</span></span><br><span class="line">                <span class="keyword">return</span> reader.readLine();</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>: <span class="comment">// 异常，也读一行</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(reader.readLine());</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;:&#x27;</span>: <span class="comment">// 数字</span></span><br><span class="line">                <span class="keyword">return</span> Long.parseLong(reader.readLine());</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;$&#x27;</span>: <span class="comment">// 多行字符串</span></span><br><span class="line">                <span class="comment">// 先读长度</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> Integer.parseInt(reader.readLine());</span><br><span class="line">                <span class="keyword">if</span> (len == -<span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 再读数据,读len个字节。我们假设没有特殊字符，所以读一行（简化）</span></span><br><span class="line">                <span class="keyword">return</span> reader.readLine();</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span> readBulkString();</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;错误的数据格式！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object <span class="title function_">readBulkString</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 获取数组大小</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> Integer.parseInt(reader.readLine());</span><br><span class="line">        <span class="keyword">if</span> (len &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 定义集合，接收多个元素</span></span><br><span class="line">        List&lt;Object&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(len);</span><br><span class="line">        <span class="comment">// 遍历，依次读取每个元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            list.add(handleResponse());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// set name 虎哥</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sendRequest</span><span class="params">(String ... args)</span> &#123;</span><br><span class="line">        writer.println(<span class="string">&quot;*&quot;</span> + args.length);</span><br><span class="line">        <span class="keyword">for</span> (String arg : args) &#123;</span><br><span class="line">            writer.println(<span class="string">&quot;$&quot;</span> + arg.getBytes(StandardCharsets.UTF_8).length);</span><br><span class="line">            writer.println(arg);</span><br><span class="line">        &#125;</span><br><span class="line">        writer.flush();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="3-2、Redis内存回收-过期key处理"><a href="#3-2、Redis内存回收-过期key处理" class="headerlink" title="3.2、Redis内存回收-过期key处理"></a>3.2、Redis内存回收-过期key处理</h3><p>Redis之所以性能强，最主要的原因就是基于内存存储。然而单节点的Redis其内存大小不宜过大，会影响持久化或主从同步性能。<br>我们可以通过修改配置文件来设置Redis的最大内存：</p>
<p><img src="/2022/09/24/redis%E5%8E%9F%E7%90%86%E7%AF%87/1653983341150.png" alt="1653983341150"></p>
<p>当内存使用达到上限时，就无法存储更多数据了。为了解决这个问题，Redis提供了一些策略实现内存回收：</p>
<p>内存过期策略</p>
<p>在学习Redis缓存的时候我们说过，可以通过expire命令给Redis的key设置TTL（存活时间）：</p>
<p><img src="/2022/09/24/redis%E5%8E%9F%E7%90%86%E7%AF%87/1653983366243.png" alt="1653983366243"></p>
<p>可以发现，当key的TTL到期以后，再次访问name返回的是nil，说明这个key已经不存在了，对应的内存也得到释放。从而起到内存回收的目的。</p>
<p>Redis本身是一个典型的key-value内存存储数据库，因此所有的key、value都保存在之前学习过的Dict结构中。不过在其database结构体中，有两个Dict：一个用来记录key-value；另一个用来记录key-TTL。</p>
<p><img src="/2022/09/24/redis%E5%8E%9F%E7%90%86%E7%AF%87/1653983423128.png" alt="1653983423128"></p>
<p><img src="/2022/09/24/redis%E5%8E%9F%E7%90%86%E7%AF%87/1653983606531.png" alt="1653983606531"></p>
<p>这里有两个问题需要我们思考：<br>Redis是如何知道一个key是否过期呢？</p>
<p>利用两个Dict分别记录key-value对及key-ttl对</p>
<p>是不是TTL到期就立即删除了呢？</p>
<p><strong>惰性删除</strong></p>
<p>惰性删除：顾明思议并不是在TTL到期后就立刻删除，而是在访问一个key的时候，检查该key的存活时间，如果已经过期才执行删除。</p>
<p><img src="/2022/09/24/redis%E5%8E%9F%E7%90%86%E7%AF%87/1653983652865.png" alt="1653983652865"></p>
<p><strong>周期删除</strong></p>
<p>周期删除：顾明思议是通过一个定时任务，周期性的抽样部分过期的key，然后执行删除。执行周期有两种：<br>Redis服务初始化函数initServer()中设置定时任务，按照server.hz的频率来执行过期key清理，模式为SLOW<br>Redis的每个事件循环前会调用beforeSleep()函数，执行过期key清理，模式为FAST</p>
<p>周期删除：顾明思议是通过一个定时任务，周期性的抽样部分过期的key，然后执行删除。执行周期有两种：<br>Redis服务初始化函数initServer()中设置定时任务，按照server.hz的频率来执行过期key清理，模式为SLOW<br>Redis的每个事件循环前会调用beforeSleep()函数，执行过期key清理，模式为FAST</p>
<p>SLOW模式规则：</p>
<ul>
<li>执行频率受server.hz影响，默认为10，即每秒执行10次，每个执行周期100ms。</li>
<li>执行清理耗时不超过一次执行周期的25%.默认slow模式耗时不超过25ms</li>
<li>逐个遍历db，逐个遍历db中的bucket，抽取20个key判断是否过期</li>
<li>如果没达到时间上限（25ms）并且过期key比例大于10%，再进行一次抽样，否则结束</li>
<li>FAST模式规则（过期key比例小于10%不执行 ）：</li>
<li>执行频率受beforeSleep()调用频率影响，但两次FAST模式间隔不低于2ms</li>
<li>执行清理耗时不超过1ms</li>
<li>逐个遍历db，逐个遍历db中的bucket，抽取20个key判断是否过期<br>如果没达到时间上限（1ms）并且过期key比例大于10%，再进行一次抽样，否则结束</li>
</ul>
<p>小总结：</p>
<p>RedisKey的TTL记录方式：</p>
<p>在RedisDB中通过一个Dict记录每个Key的TTL时间</p>
<p>过期key的删除策略：</p>
<p>惰性清理：每次查找key时判断是否过期，如果过期则删除</p>
<p>定期清理：定期抽样部分key，判断是否过期，如果过期则删除。<br>定期清理的两种模式：</p>
<p>SLOW模式执行频率默认为10，每次不超过25ms</p>
<p>FAST模式执行频率不固定，但两次间隔不低于2ms，每次耗时不超过1ms</p>
<h3 id="3-3-Redis内存回收-内存淘汰策略"><a href="#3-3-Redis内存回收-内存淘汰策略" class="headerlink" title="3.3 Redis内存回收-内存淘汰策略"></a>3.3 Redis内存回收-内存淘汰策略</h3><p>内存淘汰：就是当Redis内存使用达到设置的上限时，主动挑选部分key删除以释放更多内存的流程。Redis会在处理客户端命令的方法processCommand()中尝试做内存淘汰：</p>
<p><img src="/2022/09/24/redis%E5%8E%9F%E7%90%86%E7%AF%87/1653983978671.png" alt="1653983978671"></p>
<p> 淘汰策略</p>
<p>Redis支持8种不同策略来选择要删除的key：</p>
<ul>
<li>noeviction： 不淘汰任何key，但是内存满时不允许写入新数据，默认就是这种策略。</li>
<li>volatile-ttl： 对设置了TTL的key，比较key的剩余TTL值，TTL越小越先被淘汰</li>
<li>allkeys-random：对全体key ，随机进行淘汰。也就是直接从db-&gt;dict中随机挑选</li>
<li>volatile-random：对设置了TTL的key ，随机进行淘汰。也就是从db-&gt;expires中随机挑选。</li>
<li>allkeys-lru： 对全体key，基于LRU算法进行淘汰</li>
<li>volatile-lru： 对设置了TTL的key，基于LRU算法进行淘汰</li>
<li>allkeys-lfu： 对全体key，基于LFU算法进行淘汰</li>
<li>volatile-lfu： 对设置了TTL的key，基于LFI算法进行淘汰<br>比较容易混淆的有两个：<ul>
<li>LRU（Least Recently Used），最少最近使用。用当前时间减去最后一次访问时间，这个值越大则淘汰优先级越高。</li>
<li>LFU（Least Frequently Used），最少频率使用。会统计每个key的访问频率，值越小淘汰优先级越高。</li>
</ul>
</li>
</ul>
<p>Redis的数据都会被封装为RedisObject结构：</p>
<p><img src="/2022/09/24/redis%E5%8E%9F%E7%90%86%E7%AF%87/1653984029506.png" alt="1653984029506"></p>
<p>LFU的访问次数之所以叫做逻辑访问次数，是因为并不是每次key被访问都计数，而是通过运算：</p>
<ul>
<li>生成0~1之间的随机数R</li>
<li>计算 (旧次数 * lfu_log_factor + 1)，记录为P</li>
<li>如果 R &lt; P ，则计数器 + 1，且最大不超过255</li>
<li>访问次数会随时间衰减，距离上一次访问时间每隔 lfu_decay_time 分钟，计数器 -1</li>
</ul>
<p>最后用一副图来描述当前的这个流程吧</p>
<p><img src="/2022/09/24/redis%E5%8E%9F%E7%90%86%E7%AF%87/1653984085095.png" alt="1653984085095"></p>
<h2 id="4、结束语"><a href="#4、结束语" class="headerlink" title="4、结束语"></a>4、结束语</h2><p>亲爱的小伙伴们，我们的redis到这里就结束了，希望小伙伴们好好学习，找到一份满意的工作！传智为你加油。</p>
]]></content>
      <categories>
        <category>redis系列</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title>git&amp;&amp;github学习</title>
    <url>/2022/09/24/git/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><ul>
<li>免费、开源<a href="assets/202209251429589.png">分布式</a></li>
<li>快速高效处理从小型到大型的各种项目</li>
<li>易于学习，占地面积小，性能极快</li>
</ul>
<h4 id="优缺点："><a href="#优缺点：" class="headerlink" title="优缺点："></a>优缺点：</h4><p><strong>深究其分布式版本</strong></p>
<ul>
<li>其集中式版本控制工具有缺点也有优点，可看到项目中内容管理，管理员也可管理单一系统也比较容易</li>
<li>缺点就是中央服务器的单点故障</li>
</ul>
<p><strong>分布式的版本控制系统出现之后,解决了集中式版本控制系统的缺陷</strong></p>
<ul>
<li>服务器断网的情况下也可以进行开发（因为版本控制是在本地进行的）</li>
<li>每个客户端保存的也都是整个完整的项目（包含历史记录，更加安全）</li>
</ul>
<p><strong>工作机制</strong></p>
<ul>
<li>工作区：通过写好的代码，放在了磁盘区，不是特指编译器中的代码</li>
<li>临时存储：通过工作区git add放到此处</li>
<li>本地库：通过临时存储的git commit放到此处</li>
<li>远程库：通过本地库上传到远程库，代码托管中心是基于网络服务器的远程代码仓库</li>
</ul>
<h3 id="1-Git概述"><a href="#1-Git概述" class="headerlink" title="1.Git概述"></a>1.Git概述</h3><p> Git 是一个免费的、开源的<strong>分布式版本控制系统</strong>，可以快速高效地处理从小型到大型的各种 项目。</p>
<p> Git 易于学习，占地面积小，性能极快。 它具有廉价的本地库，方便的暂存区域和多个工作 流分支等特性。其性能优于 Subversion、CVS、Perforce 和 ClearCase 等版本控制工具。</p>
<h4 id="1-1何为版本控制"><a href="#1-1何为版本控制" class="headerlink" title="1.1何为版本控制"></a>1.1何为版本控制</h4><p> 版本控制是一种记录文件内容变化，以便将来查阅特定版本修订情况的系统。</p>
<p> 版本控制其实最重要的是可以记录文件修改历史记录，从而让用户能够查看历史版本， 方便版本切换。</p>
<h4 id="1-2为什么需要版本控制"><a href="#1-2为什么需要版本控制" class="headerlink" title="1.2为什么需要版本控制"></a>1.2为什么需要版本控制</h4><p>个人开发过渡到团队协作</p>
<p><img src="/2022/09/24/git/2022092514295948.png" alt="个人开发过渡到团队协作"></p>
<h4 id="1-3版本控制工具"><a href="#1-3版本控制工具" class="headerlink" title="1.3版本控制工具"></a>1.3版本控制工具</h4><p> 集中化的版本控制系统诸如 CVS、SVN 等，都有一个单一的集中管理的服务器，保存 所有文件的修订版本，而协同工作的人们都通过客户端连到这台服务器，取出最新的文件或 者提交更新。多年以来，这已成为版本控制系统的标准做法。</p>
<p> 这种做法带来了许多好处，每个人都可以在一定程度上看到项目中的其他人正在做些什 么。而管理员也可以轻松掌控每个开发者的权限，并且管理一个集中化的版本控制系统，要 远比在各个客户端上维护本地数据库来得轻松容易。</p>
<p> 事分两面，有好有坏。这么做显而易见的缺点是中央服务器的单点故障。如果服务器宕 机一小时，那么在这一小时内，谁都无法提交更新，也就无法协同工作<br><img src="/2022/09/24/git/2022092514295957.png" alt="版本控制"></p>
<ul>
<li><strong>分布式版本控制工具</strong></li>
</ul>
<p> Git、Mercurial、Bazaar、Darcs……</p>
<p> 像 Git 这种分布式版本控制工具，客户端提取的不是最新版本的文件快照，而是把代码 仓库完整地镜像下来（本地库）。这样任何一处协同工作用的文件发生故障，事后都可以用 其他客户端的本地仓库进行恢复。因为每个客户端的每一次文件提取操作，实际上都是一次 对整个文件仓库的完整备份。</p>
<p>分布式的版本控制系统出现之后,解决了集中式版本控制系统的缺陷:</p>
<ol>
<li>服务器断网的情况下也可以进行开发（因为版本控制是在本地进行的）</li>
<li>每个客户端保存的也都是整个完整的项目（包含历史记录，更加安全）</li>
</ol>
<p><img src="/2022/09/24/git/2022092514295970.png" alt="在这里插入图片描述"></p>
<h4 id="1-4Git工作机制"><a href="#1-4Git工作机制" class="headerlink" title="1.4Git工作机制"></a>1.4Git工作机制</h4><p><img src="/2022/09/24/git/2022092514300074.png" alt="在这里插入图片描述"></p>
<ul>
<li>工作区：代码存放的磁盘目录的位置</li>
<li>暂存区：在工作区完成后把代码<strong>添加</strong>到暂存区（临时存储，还没有生成历史版本）</li>
<li>本地库：将暂存区代码commit（提交）到本地库，此时会生成历史版本</li>
</ul>
<h4 id="1-5Git和代码托管中心"><a href="#1-5Git和代码托管中心" class="headerlink" title="1.5Git和代码托管中心"></a>1.5Git和代码托管中心</h4><p>代码托管中心是基于网络服务器的远程代码仓库，一般我们简单称为<strong>远程库</strong>。</p>
<ul>
<li>➢ 局域网</li>
<li>✓ GitLab</li>
<li>➢ 互联网<ul>
<li>✓ GitHub（外网）</li>
<li>✓ Gitee 码云（国内网站）</li>
</ul>
</li>
</ul>
<h3 id="2-Git安装"><a href="#2-Git安装" class="headerlink" title="2.Git安装"></a>2.Git安装</h3><p>无脑next下载即可</p>
<h3 id="3-Git常用命令"><a href="#3-Git常用命令" class="headerlink" title="3.Git常用命令"></a>3.Git常用命令</h3><table>
<thead>
<tr>
<th>命令名称</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>git config –global user.name 用户名</td>
<td>设置用户签名</td>
</tr>
<tr>
<td>git config –global user.email 邮箱</td>
<td>设置用户签名</td>
</tr>
<tr>
<td><strong>git init</strong></td>
<td><strong>初始化本地库</strong></td>
</tr>
<tr>
<td><strong>git status</strong></td>
<td><strong>查看本地库状态</strong></td>
</tr>
<tr>
<td><strong>git add 文件名</strong></td>
<td><strong>添加到暂存区</strong></td>
</tr>
<tr>
<td><strong>git commit -m “日志信息” 文件名</strong></td>
<td><strong>提交到本地库</strong></td>
</tr>
<tr>
<td><strong>git reflog</strong></td>
<td><strong>查看历史记录</strong></td>
</tr>
<tr>
<td><strong>git reset –hard 版本号</strong></td>
<td><strong>版本穿梭</strong></td>
</tr>
</tbody></table>
<h4 id="3-1设置用户签名"><a href="#3-1设置用户签名" class="headerlink" title="3.1设置用户签名"></a>3.1设置用户签名</h4><p>1）基本语法</p>
<p>git config –global user.name 用户名</p>
<p>git config –global user.email 邮箱</p>
<p> 签名的作用是区分不同操作者身份。用户的签名信息在每一个版本的提交信息中能够看 到，以此确认本次提交是谁做的。</p>
<p> Git 首次安装必须设置一下用户签名，否则无法提交代码。</p>
<p> ※注意：这里设置用户签名和将来登录 GitHub（或其他代码托管中心）的账号没有任 何关系。</p>
<h4 id="3-2初始化本地库"><a href="#3-2初始化本地库" class="headerlink" title="3.2初始化本地库"></a>3.2初始化本地库</h4><p>1）基本语法</p>
<p><strong>git init</strong></p>
<p>2）案例实操</p>
<p><img src="/2022/09/24/git/20220925143000129.png" alt="实例操作1"></p>
<p><img src="/2022/09/24/git/20220925143000131.png" alt="实例操作2"></p>
<p><img src="/2022/09/24/git/20220925143001133.png" alt="实例操作3"></p>
<p>初始化成功</p>
<h4 id="3-3查看本地库状态"><a href="#3-3查看本地库状态" class="headerlink" title="3.3查看本地库状态"></a>3.3查看本地库状态</h4><p>1）基本语法</p>
<p><strong>git status</strong></p>
<p>2）案例实操</p>
<h5 id="3-3-1-首次查看（工作区没有任何文件）"><a href="#3-3-1-首次查看（工作区没有任何文件）" class="headerlink" title="3.3.1 首次查看（工作区没有任何文件）"></a>3.3.1 首次查看（工作区没有任何文件）</h5><p><img src="/2022/09/24/git/20220925143001147.png" alt="首次查看"></p>
<ul>
<li>on branch master ：目前在master分支</li>
<li>No commits yet：目前没有任何提交</li>
<li>nothing to commit：没有任何文件</li>
</ul>
<h5 id="3-3-2新增文件（hello-txt）"><a href="#3-3-2新增文件（hello-txt）" class="headerlink" title="3.3.2新增文件（hello.txt）"></a>3.3.2新增文件（hello.txt）</h5><p><img src="/2022/09/24/git/20220925143001155.png" alt="新增文件"></p>
<ul>
<li>在vim hello.txt后，出现界面后点击insert可以开始编写内容，点击esc退出编辑模式，shift + ：并输入wq保存文件；</li>
<li>cat hello.txt：查看文件内容；</li>
<li>tail -n 1 hello.txt：查看文件最后一行的内容</li>
</ul>
<h5 id="3-3-3再次查看（检查为追踪的文件）"><a href="#3-3-3再次查看（检查为追踪的文件）" class="headerlink" title="3.3.3再次查看（检查为追踪的文件）"></a>3.3.3再次查看（检查为追踪的文件）</h5><p><img src="/2022/09/24/git/20220925143001163.png" alt="再次查看"></p>
<p>文件名是红色代表还被未追踪</p>
<h4 id="3-4添加暂存区"><a href="#3-4添加暂存区" class="headerlink" title="3.4添加暂存区"></a>3.4添加暂存区</h4><h5 id="3-4-1将工作区的文件添加到暂存区"><a href="#3-4-1将工作区的文件添加到暂存区" class="headerlink" title="3.4.1将工作区的文件添加到暂存区"></a>3.4.1将工作区的文件添加到暂存区</h5><p>1）基本语法</p>
<p><strong>git add 文件名</strong></p>
<p>2）案例实操</p>
<p><img src="/2022/09/24/git/20220925143001177.png" alt="案例实操"></p>
<h5 id="3-4-2查看状态（检测到暂存区有新文件）"><a href="#3-4-2查看状态（检测到暂存区有新文件）" class="headerlink" title="3.4.2查看状态（检测到暂存区有新文件）"></a>3.4.2查看状态（检测到暂存区有新文件）</h5><p><img src="/2022/09/24/git/20220925143002181.png" alt="查看状态"></p>
<p>文件名是绿色代表git已追踪到该文件，但只是在暂存区</p>
<p><img src="/2022/09/24/git/20220925143002185.png" alt="查看状态"></p>
<p>将文件从暂存区删除，工作区还是存在</p>
<h4 id="3-5提交本地库"><a href="#3-5提交本地库" class="headerlink" title="3.5提交本地库"></a>3.5提交本地库</h4><h5 id="3-5-1-将暂存区的文件提交到本地库"><a href="#3-5-1-将暂存区的文件提交到本地库" class="headerlink" title="3.5.1 将暂存区的文件提交到本地库"></a>3.5.1 将暂存区的文件提交到本地库</h5><p>1）基本语法</p>
<p><strong>git commit -m “日志信息” 文件名</strong></p>
<p>2）案例实操</p>
<p><img src="/2022/09/24/git/20220925143002199.png" alt="案例实操"></p>
<p>835d3ec：版本号</p>
<p>“fitst commit”：必须填，内容每次不同</p>
<h5 id="3-5-2查看状态（没有文件需要提交）"><a href="#3-5-2查看状态（没有文件需要提交）" class="headerlink" title="3.5.2查看状态（没有文件需要提交）"></a>3.5.2查看状态（没有文件需要提交）</h5><p><img src="/2022/09/24/git/20220925143002207.png" alt="查看状态"></p>
<p><strong>git reflog</strong>：查看版本信息<br><img src="/2022/09/24/git/20220925143002210.png" alt="查看版本信息"></p>
<p><strong>git log</strong>：查看日志详细信息</p>
<p><img src="/2022/09/24/git/20220925143003214.png" alt="查看日志详细信息"></p>
<h4 id="3-6修改文件（hello-txt）"><a href="#3-6修改文件（hello-txt）" class="headerlink" title="3.6修改文件（hello.txt）"></a>3.6修改文件（hello.txt）</h4><h5 id="3-6-1查看状态（检测到工作区有文件被修改）"><a href="#3-6-1查看状态（检测到工作区有文件被修改）" class="headerlink" title="3.6.1查看状态（检测到工作区有文件被修改）"></a>3.6.1查看状态（检测到工作区有文件被修改）</h5><p><img src="/2022/09/24/git/20220925143003220.png" alt="查看状态"></p>
<p>modified 红色：告诉我们该文件被修改了</p>
<h5 id="3-6-2-将修改的文件再次添加暂存区"><a href="#3-6-2-将修改的文件再次添加暂存区" class="headerlink" title="3.6.2 将修改的文件再次添加暂存区"></a>3.6.2 将修改的文件再次添加暂存区</h5><p><img src="/2022/09/24/git/20220925143003226.png" alt="将修改的文件再次添加暂存区"></p>
<h5 id="3-6-3-查看状态（工作区的修改添加到了暂存区）"><a href="#3-6-3-查看状态（工作区的修改添加到了暂存区）" class="headerlink" title="3.6.3 查看状态（工作区的修改添加到了暂存区）"></a>3.6.3 查看状态（工作区的修改添加到了暂存区）</h5><p><img src="/2022/09/24/git/20220925143003230.png" alt="查看状态"></p>
<h4 id="3-7历史版本"><a href="#3-7历史版本" class="headerlink" title="3.7历史版本"></a>3.7历史版本</h4><h5 id="3-7-1-查看历史版本"><a href="#3-7-1-查看历史版本" class="headerlink" title="3.7.1 查看历史版本"></a>3.7.1 查看历史版本</h5><p>1）基本语法</p>
<p><strong>git reflog</strong> 查看版本信息</p>
<p><strong>git log</strong> 查看版本详细信息</p>
<p>2）案例实操</p>
<p><img src="/2022/09/24/git/20220925143004244.png" alt="案例实操"></p>
<p>当指针HEAD指向该版本号时，cat hello.txt可以获取该版本号的文件内容</p>
<p><img src="/2022/09/24/git/20220925143004248.png" alt="案例实操"></p>
<h5 id="3-7-2版本穿梭"><a href="#3-7-2版本穿梭" class="headerlink" title="3.7.2版本穿梭"></a>3.7.2版本穿梭</h5><p>1）基本语法</p>
<p><strong>git reset –hard</strong> 版本号</p>
<p>2）案例实操</p>
<p>Step1：查看想要回退的版本号</p>
<p><img src="/2022/09/24/git/20220925143004260.png" alt="案例实操"></p>
<p>Step2：切换版本号</p>
<p><img src="/2022/09/24/git/20220925143005264.png" alt="案例实操"></p>
<p>Step3：切换成功后查看历史记录，可以看到成功切换到a9cbb5a版本</p>
<p><img src="/2022/09/24/git/20220925143005268.png" alt="案例实操"></p>
<p>此后在cat hello.txt可以看到a9cbb5a版本号的hello.txt</p>
<p>查看.git里的文件，HEAD是当前所在分支，refs-&gt;heads-&gt;master显示的是当前指向的版本号</p>
<p><img src="/2022/09/24/git/20220925143005274.png" alt="查看分支、版本号"></p>
<h3 id="4-Git分支操作"><a href="#4-Git分支操作" class="headerlink" title="4.Git分支操作"></a>4.Git分支操作</h3><p><img src="/2022/09/24/git/20220925143005278.png" alt="Git分支操作"></p>
<h4 id="4-1-什么是分支"><a href="#4-1-什么是分支" class="headerlink" title="4.1 什么是分支"></a>4.1 什么是分支</h4><p> 在版本控制过程中，同时推进多个任务，为每个任务，我们就可以创建每个任务的单独 分支。使用分支意味着程序员可以把自己的工作从开发主线上分离开来，开发自己分支的时 候，不会影响主线分支的运行。对于初学者而言，分支可以简单理解为副本，一个分支就是 一个单独的副本。（分支底层其实也是指针的引用）</p>
<p><img src="/2022/09/24/git/20220925143005284.png" alt="什么是分支"></p>
<h4 id="4-2-分支的好处"><a href="#4-2-分支的好处" class="headerlink" title="4.2 分支的好处"></a>4.2 分支的好处</h4><p> 同时并行推进多个功能开发，提高开发效率。 各个分支在开发过程中，如果某一个分支开发失败，不会对其他分支有任何影响。失败 的分支删除重新开始即可。</p>
<h4 id="4-3-分支的操作"><a href="#4-3-分支的操作" class="headerlink" title="4.3 分支的操作"></a>4.3 分支的操作</h4><table>
<thead>
<tr>
<th>命令名称</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>git branch 分支名</td>
<td>git branch 分支名</td>
</tr>
<tr>
<td>git branch -v</td>
<td>查看分支</td>
</tr>
<tr>
<td>git checkout 分支名</td>
<td>切换分支</td>
</tr>
<tr>
<td>git merge 分支名</td>
<td>把指定的分支合并到当前分支</td>
</tr>
</tbody></table>
<h5 id="4-3-1-查看分支"><a href="#4-3-1-查看分支" class="headerlink" title="4.3.1 查看分支"></a>4.3.1 查看分支</h5><p>1）基本语法</p>
<p><strong>git branch -v</strong></p>
<p>2）案例实操</p>
<p><img src="/2022/09/24/git/20220925143006307.png" alt="案例实操"></p>
<h5 id="4-3-2创建分支"><a href="#4-3-2创建分支" class="headerlink" title="4.3.2创建分支"></a>4.3.2创建分支</h5><p>1）基本语法</p>
<p><strong>git branch 分支名</strong></p>
<p>2）案例实操</p>
<p><img src="/2022/09/24/git/20220925143006317.png" alt="案例实操"></p>
<h5 id="4-3-3-修改分支"><a href="#4-3-3-修改分支" class="headerlink" title="4.3.3 修改分支"></a>4.3.3 修改分支</h5><p>1）基本语法</p>
<p><strong>git checkout 分支名</strong></p>
<p>2）案例实操</p>
<p><img src="/2022/09/24/git/20220925143006327.png" alt="案例实操"><br><img src="/2022/09/24/git/20220925143006328.png" alt="案例实操"><br><img src="/2022/09/24/git/20220925143007329.png" alt="案例实操"><br><img src="/2022/09/24/git/20220925143007330.png" alt="案例实操"></p>
<h5 id="4-3-5-合并分支"><a href="#4-3-5-合并分支" class="headerlink" title="4.3.5 合并分支"></a>4.3.5 合并分支</h5><p>1）基本语法</p>
<p><strong>git merge 分支名</strong></p>
<p>2）案例实操</p>
<p>在 master 分支上合并 hot-fix 分支</p>
<p><img src="/2022/09/24/git/20220925143007342.png" alt="案例实操"></p>
<h5 id="4-3-6-产生冲突"><a href="#4-3-6-产生冲突" class="headerlink" title="4.3.6 产生冲突"></a>4.3.6 产生冲突</h5><ul>
<li>冲突产生的表现：后面状态为 MERGING</li>
<li>冲突产生的原因：</li>
</ul>
<p> 合并分支时，两个分支在<strong>同一个文件的同一个位置</strong>有两套完全不同的修改。Git 无法替 我们决定使用哪一个。必须<strong>人为决定</strong>新代码内容。</p>
<p>1）示例</p>
<p>Step1：在master分支上修改hello.txt并commit<br><img src="/2022/09/24/git/20220925143007354.png" alt="示例"><br><img src="/2022/09/24/git/20220925143007355.png" alt="示例"></p>
<p>Step2：切换到hot-fix分支上修改hello.txt并commit<br><img src="/2022/09/24/git/20220925143008358.png" alt="示例"></p>
<p><img src="/2022/09/24/git/20220925143008360.png" alt="示例"></p>
<p>Step3：切换分支回到master，在master分支上合并hot-fix分支<br><img src="/2022/09/24/git/20220925143008363.png" alt="示例"><br><img src="/2022/09/24/git/20220925143008364.png" alt="示例"><br><img src="/2022/09/24/git/20220925143009365.png" alt="示例"></p>
<h5 id="4-3-7-解决冲突"><a href="#4-3-7-解决冲突" class="headerlink" title="4.3.7 解决冲突"></a>4.3.7 解决冲突</h5><p>1）编辑有冲突的文件，删除特殊符号，决定要使用的内容 <strong>特殊符号：&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD 当前分支的代码 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; 合并过来的代码 &gt;&gt;&gt;&gt;&gt;&gt;&gt; hot-fix</strong><br><img src="/2022/09/24/git/20220925143009370.png" alt="解决冲突"></p>
<p>2）添加到暂存区</p>
<p><strong>git hello.txt</strong></p>
<p>3）执行提交（注意：此时使用 git commit 命令时<strong>不能带文件名</strong>）</p>
<p><img src="/2022/09/24/git/20220925143009378.png" alt="执行提交"></p>
<h4 id="4-4相关说明"><a href="#4-4相关说明" class="headerlink" title="4.4相关说明"></a>4.4相关说明</h4><p> master、hot-fix 其实都是指向具体版本记录的指针。当前所在的分支，其实是由 HEAD 决定的。所以创建分支的本质就是多创建一个指针。</p>
<p> HEAD 如果指向 master，那么我们现在就在 master 分支上。</p>
<p> HEAD 如果执行 hotfix，那么我们现在就在 hotfix 分支上。</p>
<p> 所以切换分支的本质就是移动 HEAD 指针。</p>
<h3 id="5-Git团队协作机制"><a href="#5-Git团队协作机制" class="headerlink" title="5.Git团队协作机制"></a>5.Git团队协作机制</h3><h4 id="5-1-团队内协作"><a href="#5-1-团队内协作" class="headerlink" title="5.1 团队内协作"></a>5.1 团队内协作</h4><p><img src="/2022/09/24/git/20220925143010394.png" alt="团队内协作"></p>
<h4 id="5-2-跨团队协作"><a href="#5-2-跨团队协作" class="headerlink" title="5.2 跨团队协作"></a>5.2 跨团队协作</h4><p><img src="/2022/09/24/git/20220925143010398.png" alt="跨团队合作"></p>
<h3 id="6-GitHub-操作"><a href="#6-GitHub-操作" class="headerlink" title="6.GitHub 操作"></a>6.GitHub 操作</h3><h4 id="6-1-创建远程仓库"><a href="#6-1-创建远程仓库" class="headerlink" title="6.1 创建远程仓库"></a>6.1 创建远程仓库</h4><p><img src="/2022/09/24/git/20220925143010404.png" alt="创建远程仓库"><br><img src="/2022/09/24/git/20220925143010405.png" alt="创建远程仓库"></p>
<h4 id="6-2-远程仓库操作"><a href="#6-2-远程仓库操作" class="headerlink" title="6.2 远程仓库操作"></a>6.2 远程仓库操作</h4><table>
<thead>
<tr>
<th>命令名称</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>git remote -v</td>
<td>查看当前所有远程地址别名</td>
</tr>
<tr>
<td>git remote add 别名 远程地址</td>
<td>起别名</td>
</tr>
<tr>
<td><strong>git push 别名 分支</strong></td>
<td><strong>推送本地分支上的内容到远程仓库</strong></td>
</tr>
<tr>
<td><strong>git clone 远程地址</strong></td>
<td><strong>将远程仓库的内容克隆到本地</strong></td>
</tr>
<tr>
<td><strong>git pull 远程库地址别名 远程分支名</strong></td>
<td><strong>将远程仓库对于分支最新内容拉下来后与 当前本地分支直接合并</strong></td>
</tr>
</tbody></table>
<h5 id="6-2-1-创建远程仓库别名"><a href="#6-2-1-创建远程仓库别名" class="headerlink" title="6.2.1 创建远程仓库别名"></a>6.2.1 创建远程仓库别名</h5><p>1）基本语法</p>
<p><strong>git remote -v</strong> 查看当前所有远程地址别名</p>
<p><strong>git remote add</strong> <strong>别名 远程地址</strong></p>
<p>2）案例实操</p>
<p><img src="/2022/09/24/git/20220925143011427.png" alt="在这里插入图片描述"></p>
<h5 id="6-2-2-推送本地分支到远程仓库"><a href="#6-2-2-推送本地分支到远程仓库" class="headerlink" title="6.2.2 推送本地分支到远程仓库"></a>6.2.2 推送本地分支到远程仓库</h5><p>1）基本语法</p>
<p><strong>git push 别名 分支</strong></p>
<p>2）案例实操</p>
<p><img src="/2022/09/24/git/20220925143011437.png" alt="案例实操"></p>
<p>此时发现已将我们 master 分支上的内容推送到 GitHub 创建的远程仓库。</p>
<p><img src="/2022/09/24/git/20220925143011441.png" alt="案例实操"></p>
<h5 id="6-2-3-克隆拉取远程仓库到本地"><a href="#6-2-3-克隆拉取远程仓库到本地" class="headerlink" title="6.2.3 克隆拉取远程仓库到本地"></a>6.2.3 克隆拉取远程仓库到本地</h5><p>1）基本语法</p>
<p><strong>git pull 别名 分支名</strong></p>
<p>2）案例实操</p>
<p><img src="/2022/09/24/git/20220925143011451.png" alt="案例实操"></p>
<p><strong>拉取动作会自动提交到本地库</strong>，远程库代码会同步到本地库代码</p>
<h5 id="6-2-4-克隆远程仓库到本地"><a href="#6-2-4-克隆远程仓库到本地" class="headerlink" title="6.2.4 克隆远程仓库到本地"></a>6.2.4 克隆远程仓库到本地</h5><p>1）基本语法</p>
<p><strong>git clone 远程地址</strong></p>
<p>2）案例实操</p>
<p><img src="/2022/09/24/git/20220925143012463.png" alt="案例实操"></p>
<p>clone 会做如下操作：</p>
<ul>
<li>拉取代码。</li>
<li>初始化本地仓库。</li>
<li>创建别名</li>
</ul>
<h5 id="6-2-4-邀请加入团队"><a href="#6-2-4-邀请加入团队" class="headerlink" title="6.2.4 邀请加入团队"></a>6.2.4 邀请加入团队</h5><h4 id="6-4-SSH-免密登录"><a href="#6-4-SSH-免密登录" class="headerlink" title="6.4 SSH 免密登录"></a>6.4 SSH 免密登录</h4><p>具体操作<br><img src="/2022/09/24/git/20220925143012476.png" alt="具体操作"><br><img src="/2022/09/24/git/20220925143012477.png" alt="具体操作"></p>
<h3 id="7-IDEA-集成-Git"><a href="#7-IDEA-集成-Git" class="headerlink" title="7. IDEA 集成 Git"></a>7. IDEA 集成 Git</h3><p><strong>为什么要忽略他们？</strong>（.idea等）</p>
<p>答：与项目的实际功能无关，不参与服务器上部署运行。把它们忽略掉能够屏蔽 IDE 工具之 间的差异。</p>
<p><strong>怎么忽略？</strong></p>
<p>1）创建忽略规则文件 <strong>xxxx.ignore</strong>（前缀名随便起，建议是 git.ignore）</p>
<p>这个文件的存放位置原则上在哪里都可以，为了便于让~&#x2F;.gitconfig 文件引用，建议也放在用 户家目录下</p>
<p>git.ignore 文件模版内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Compiled class file</span><br><span class="line">*.class</span><br><span class="line"># Log file</span><br><span class="line">*.log</span><br><span class="line"># BlueJ files</span><br><span class="line">*.ctxt</span><br><span class="line"># Mobile Tools for Java (J2ME)</span><br><span class="line">.mtj.tmp/</span><br><span class="line"># Package Files #</span><br><span class="line">*.jar</span><br><span class="line">*.war</span><br><span class="line">*.nar</span><br><span class="line">*.ear</span><br><span class="line">*.zip</span><br><span class="line">*.tar.gz</span><br><span class="line">*.rar</span><br><span class="line"># virtual machine crash logs, see </span><br><span class="line">http://www.java.com/en/download/help/error_hotspot.xml</span><br><span class="line">hs_err_pid*</span><br><span class="line">.classpath</span><br><span class="line">.project</span><br><span class="line">.settings</span><br><span class="line">target</span><br><span class="line">.idea</span><br><span class="line">*.iml</span><br><span class="line">12345678910111213141516171819202122232425</span><br></pre></td></tr></table></figure>

<p>2）在git.ignore 文件模版内容如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[user]</span><br><span class="line">name = Layne</span><br><span class="line">email = xxxx@qq.com</span><br><span class="line">[core]</span><br><span class="line">excludesfile = C:/Users/asus/git.ignore</span><br><span class="line">注意：这里要使用“正斜线（/）”，不要使用“反斜线（\）”</span><br><span class="line">123456</span><br></pre></td></tr></table></figure>

<h4 id="7-2-定位-Git-程序"><a href="#7-2-定位-Git-程序" class="headerlink" title="7.2 定位 Git 程序"></a>7.2 定位 Git 程序</h4><p><img src="/2022/09/24/git/20220925143013536.png" alt="定位Git程序"></p>
<h4 id="7-3-初始化本地库"><a href="#7-3-初始化本地库" class="headerlink" title="7.3 初始化本地库"></a>7.3 初始化本地库</h4><p>VCS下的Created Git Repository，然后选择要创建 Git 本地仓库的工程即可</p>
<h4 id="7-4-添加到暂存区"><a href="#7-4-添加到暂存区" class="headerlink" title="7.4 添加到暂存区"></a>7.4 添加到暂存区</h4><p>右键点击项目选择 Git -&gt; Add 将项目添加到暂存区。</p>
<h4 id="7-5-提交到本地库"><a href="#7-5-提交到本地库" class="headerlink" title="7.5 提交到本地库"></a>7.5 提交到本地库</h4><p>Git -&gt; Commit</p>
<p><img src="/2022/09/24/git/20220925143013550.png" alt="提交到本地库"></p>
<h4 id="7-6-查看版本号"><a href="#7-6-查看版本号" class="headerlink" title="7.6 查看版本号"></a>7.6 查看版本号</h4><p><img src="/2022/09/24/git/20220925143013554.png" alt="查看版本号"><br><img src="/2022/09/24/git/20220925143014555.png" alt="查看版本号"></p>
<h4 id="7-7-创建分支"><a href="#7-7-创建分支" class="headerlink" title="7.7 创建分支"></a>7.7 创建分支</h4><p><img src="/2022/09/24/git/20220925143014559.png" alt="创建分支"></p>
<p>填写分支名称，创建 hot-fix 分支。</p>
<p><img src="/2022/09/24/git/20220925143014563.png" alt="填写分支名"><br><img src="/2022/09/24/git/20220925143023564.png" alt="查看分支名"></p>
<h4 id="7-8-切换分支"><a href="#7-8-切换分支" class="headerlink" title="7.8 切换分支"></a>7.8 切换分支</h4><p>在 IDEA 窗口的右下角，切换到 master 分支</p>
<p><img src="/2022/09/24/git/20220925143023570.png" alt="切换分支"></p>
<h4 id="7-9-合并分支"><a href="#7-9-合并分支" class="headerlink" title="7.9 合并分支"></a>7.9 合并分支</h4><p><img src="/2022/09/24/git/20220925143023574.png" alt="合并分支"></p>
<p>如果代码没有冲突，分支直接合并成功，分支合并成功以后，代码自动提交，无需手动 提交本地库。</p>
<h4 id="7-10-解决冲突"><a href="#7-10-解决冲突" class="headerlink" title="7.10 解决冲突"></a>7.10 解决冲突</h4><p><img src="/2022/09/24/git/20220925143023580.png" alt="解决冲突"><br><img src="/2022/09/24/git/20220925143025581.png" alt="解决冲突"></p>
<p>手动合并完代码以后，点击右下角的 Apply 按钮。</p>
<p>代码冲突解决，自动提交本地库。</p>
<h3 id="8-IDEA-集成-GitHub"><a href="#8-IDEA-集成-GitHub" class="headerlink" title="8.IDEA 集成 GitHub"></a>8.IDEA 集成 GitHub</h3><h4 id="8-1-设置-GitHub-账号"><a href="#8-1-设置-GitHub-账号" class="headerlink" title="8.1 设置 GitHub 账号"></a>8.1 设置 GitHub 账号</h4><p><img src="/2022/09/24/git/20220925143025591.png" alt="设置GitHub账号"></p>
<p>可以使用Token登录</p>
<h4 id="8-2-分享工程到-GitHub"><a href="#8-2-分享工程到-GitHub" class="headerlink" title="8.2 分享工程到 GitHub"></a>8.2 分享工程到 GitHub</h4><p><img src="/2022/09/24/git/20220925143025597.png" alt="分享工厂到GitHub"></p>
<p>注意：push 是将本地库代码推送到远程库，如果本地库代码跟远程库代码版本不一致， push 的操作是会被拒绝的。也就是说，要想 push 成功，一定要保证本地库的版本要比远程 库的版本高！<strong>因此一个成熟的程序员在动手改本地代码之前，一定会先检查下远程库跟本地 代码的区别！如果本地的代码版本已经落后，切记要先 pull 拉取一下远程库的代码，将本地 代码更新到最新以后，然后再修改，提交，推送！</strong></p>
<h4 id="8-4-pull-拉取远程库到本地库"><a href="#8-4-pull-拉取远程库到本地库" class="headerlink" title="8.4 pull 拉取远程库到本地库"></a>8.4 pull 拉取远程库到本地库</h4><p><img src="/2022/09/24/git/20220925143025603.png" alt="pull拉取到本地库"></p>
<p>注意：pull 是拉取远端仓库代码到本地，如果远程库代码和本地库代码不一致，会自动 合并，如果自动合并失败，还会涉及到手动解决冲突的问题。</p>
<h4 id="8-5-clone-克隆远程库到本地库"><a href="#8-5-clone-克隆远程库到本地库" class="headerlink" title="8.5 clone 克隆远程库到本地库"></a>8.5 clone 克隆远程库到本地库</h4><p><img src="/2022/09/24/git/20220925143025609.png" alt="clone克隆远程库到本地库"></p>
]]></content>
      <categories>
        <category>git&amp;&amp;github学习</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker基础篇</title>
    <url>/2022/09/24/Docker/</url>
    <content><![CDATA[<h1 id="Docker简介"><a href="#Docker简介" class="headerlink" title="Docker简介"></a><a href="https://www.docker.com/">Docker</a>简介</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><img src="/2022/09/24/Docker/202209251507474.png" alt="img"></p>
<p>Docker的出现是为了解决代码在本机可以正常运行，而部署到其他机器不能运行的问题。这是因为代码运行所需要的环境、系统、配置、数据等不同，Docker透过镜像将程序运行所需要的系统环境由下而上打包，达到应用程序跨平台间的无缝接轨运行。</p>
<p>Linux <a href="https://so.csdn.net/so/search?q=%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF&spm=1001.2101.3001.7020">容器技术</a>的出现就解决了这样一个问题，而 Docker 就是在它的基础上发展过来的。将应用运行在 Docker 容器上面，而 Docker 容器在任何操作系统上都是一致的，这就实现了跨平台、跨服务器。只需要一次配置好环境，换到别的机子上就可以一键部署好，大大简化了操作。</p>
<h2 id="Docker与传统虚拟化方式的不同"><a href="#Docker与传统虚拟化方式的不同" class="headerlink" title="Docker与传统虚拟化方式的不同"></a>Docker与传统虚拟化方式的不同</h2><p><img src="/2022/09/24/Docker/2022092515074912.png" alt="img"></p>
<ul>
<li><p>传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程</p>
</li>
<li><p>而容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核，而且也没有进行硬件虚拟。因此容器要比传统虚拟机更为轻便</p>
</li>
<li><p>每个容器之间互相隔离，每个容器有自己的文件系统 ，容器之间进程不会相互影响，能区分计算资源</p>
</li>
</ul>
<h2 id="Docker三要素"><a href="#Docker三要素" class="headerlink" title="Docker三要素"></a>Docker三要素</h2><p>docker三要素：镜像、仓库、容器</p>
<p>镜像就是模板，容器就是镜像的一个实例，docker利用容器独立运行一个或一组应用，可以把容器看作是一个简易版的Linux环境和运行在其中的应用程序，仓库是集中存放镜像的地方。</p>
<h2 id="Docker的安装"><a href="#Docker的安装" class="headerlink" title="Docker的安装"></a>Docker的安装</h2><h3 id="centOS安装docker"><a href="#centOS安装docker" class="headerlink" title="centOS安装docker"></a>centOS安装docker</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install -y epel-release</span><br><span class="line">yum install -y docker-io</span><br><span class="line"><span class="comment"># 安装后的配置文件：/etc/sysconfig/docker</span></span><br><span class="line">service docker start <span class="comment"># 启动docker后台服务</span></span><br><span class="line">docker version <span class="comment"># 查看版本，验证是否安装成功</span></span><br><span class="line">12345</span><br></pre></td></tr></table></figure>

<h3 id="ubuntu安装docker"><a href="#ubuntu安装docker" class="headerlink" title="ubuntu安装docker"></a>ubuntu安装docker</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -sSL https://get.daocloud.io/docker | sh</span><br></pre></td></tr></table></figure>

<p>安装教程可查看：<a href="https://docs.docker.com/engine/install/ubuntu/">https://docs.docker.com/engine/install/ubuntu/</a></p>
<h3 id="配置阿里云镜像加速器："><a href="#配置阿里云镜像加速器：" class="headerlink" title="配置阿里云镜像加速器："></a>配置阿里云镜像加速器：</h3><p>首先在阿里云平台注册账户，登录后找到“镜像加速器”选项，在相应的操作系统下的命令复制，命令大约长下面这样。注意，其中<code>https</code>那段我没有给出完整的链接。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo <span class="built_in">mkdir</span> -p /etc/docker</span><br><span class="line"></span><br><span class="line">sudo <span class="built_in">tee</span> /etc/docker/daemon.json &lt;&lt;-<span class="string">&#x27;EOF&#x27;</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;registry-mirrors&quot;</span>: [<span class="string">&quot;https://*.mirror.aliyuncs.com&quot;</span>]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line"></span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure>

<p><code>ps -ef|grep docker</code>：查看是否是阿里云加速器</p>
<p>解决docker权限问题：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo gpasswd -a username docker <span class="comment">#将普通用户username加入到docker组</span></span><br><span class="line">newgrp docker <span class="comment">#更新docker组</span></span><br><span class="line">12</span><br></pre></td></tr></table></figure>

<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><ul>
<li><code>docker run hello-world</code>：运行hello world</li>
</ul>
<p><img src="/2022/09/24/Docker/2022092515075180.png" alt="img"></p>
<p>运行镜像的流程</p>
<p><img src="/2022/09/24/Docker/2022092515075384.png" alt="img"></p>
<h1 id="Docker常用命令"><a href="#Docker常用命令" class="headerlink" title="Docker常用命令"></a>Docker常用命令</h1><h2 id="docker帮助命令"><a href="#docker帮助命令" class="headerlink" title="docker帮助命令"></a>docker帮助命令</h2><h3 id="查看docker版本"><a href="#查看docker版本" class="headerlink" title="查看docker版本"></a>查看docker版本</h3><ul>
<li><code>docker version</code>：查看版本信息</li>
</ul>
<h3 id="查看docker信息"><a href="#查看docker信息" class="headerlink" title="查看docker信息"></a>查看docker信息</h3><ul>
<li><code>docker info</code>：查看docker信息</li>
</ul>
<h3 id="docker帮助命令-1"><a href="#docker帮助命令-1" class="headerlink" title="docker帮助命令"></a>docker帮助命令</h3><ul>
<li><code>docker --help</code>：帮助命令</li>
</ul>
<h2 id="docker镜像命令"><a href="#docker镜像命令" class="headerlink" title="docker镜像命令"></a>docker镜像命令</h2><p><img src="/2022/09/24/Docker/20220925150755104.png" alt="img"></p>
<h3 id="列出所有镜像"><a href="#列出所有镜像" class="headerlink" title="列出所有镜像"></a>列出所有镜像</h3><ul>
<li><p>&#96;&#96;&#96;<br>docker images</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  ：列出本地主机上的镜像，镜像由镜像名:tag唯一标记，tag可认为是版本号</span><br><span class="line"></span><br><span class="line">  - `docker images -a`：列出本地所有的镜像（含中间映像层）</span><br><span class="line">  - `docker images -q`：只显示镜像的id</span><br><span class="line">  - `docker images --digests`：显示镜像的摘要信息</span><br><span class="line">  - `docker images --no-trunc`：显示完整的镜像信息</span><br><span class="line"></span><br><span class="line">![img](20220925150757119.png)</span><br><span class="line"></span><br><span class="line">选项说明：</span><br><span class="line"></span><br><span class="line">- `REPOSITORY`：表示镜像的仓库源</span><br><span class="line">- `TAG`：镜像的标签</span><br><span class="line">- `IMAGE ID`：镜像ID</span><br><span class="line">- `CREATED`：镜像创建时间</span><br><span class="line">- `SIZE`：镜像大小</span><br><span class="line"></span><br><span class="line">### 在github搜索镜像</span><br><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  docker search 镜像名</span><br></pre></td></tr></table></figure>

<p>：在github上搜索某个镜像</p>
<ul>
<li><code>docker search -s 30 tomcat</code>：列出starts数不小于30的镜像</li>
<li><code>docker search --no-trunc 镜像名</code>：显示完整的镜像描述</li>
<li><code>docker --automated 镜像名</code>：只列出automated build类型的镜像</li>
</ul>
</li>
</ul>
<h3 id="下载镜像"><a href="#下载镜像" class="headerlink" title="下载镜像"></a>下载镜像</h3><ul>
<li><p>&#96;&#96;&#96;<br>docker pull 镜像名</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  ：下载镜像</span><br><span class="line"></span><br><span class="line">  - `docker pull 镜像名:TAG`：下载指定TAG的镜像，不加TAG默认为latest</span><br><span class="line"></span><br><span class="line">### 删除未在使用的镜像</span><br><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  docker rmi 镜像名</span><br></pre></td></tr></table></figure>

<p>：删除未在使用镜像，若在使用则不能删除，默认删除latest的</p>
<ul>
<li><code>docker rmi -f 镜像名</code>：强制删除</li>
<li><code>docker rmi -f 镜像名1:TAG 镜像名2:TAG</code>：删除多个</li>
<li><code>docker rmi -f $(docker images -qa)</code>：删除全部</li>
</ul>
</li>
</ul>
<h2 id="docker容器命令"><a href="#docker容器命令" class="headerlink" title="docker容器命令"></a>docker容器命令</h2><p>以CentOS镜像为例演示，先用<code>docker pull centos</code>命令下载相应镜像</p>
<h3 id="新建并启动容器"><a href="#新建并启动容器" class="headerlink" title="新建并启动容器"></a>新建并启动容器</h3><ul>
<li><p><code>docker run [options] 镜像名 [command] [arg...]</code>：新建并启动容器</p>
</li>
<li><p><code>docker run --name=容器新名字</code>：为容器指定一个名称</p>
<ul>
<li><code>docker run -i 镜像名</code>：以交互模式运行容器，通常与-t同时使用</li>
</ul>
</li>
<li><p><code>docker run -t 镜像名</code>：为容器重新分配一个伪输入终端，通常与-i同时使用</p>
<ul>
<li><p><code>docker run -d 镜像名</code>：后台运行容器，并返回容器id，即启动守护式容器</p>
</li>
<li><p><code>docker run -P 镜像名</code>： 随机端口映射</p>
</li>
<li><p>&#96;&#96;&#96;<br>docker run -p 镜像名</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">    ： 指定端口映射，有以下四种格式</span><br><span class="line"></span><br><span class="line">    - `ip:hostPort:containerPort`</span><br><span class="line">    - `ip::containerPort`</span><br><span class="line">    - `hostPort:containerPort`</span><br><span class="line">    - `containerPort`</span><br><span class="line"></span><br><span class="line">![img](20220925150759192.png)</span><br><span class="line"></span><br><span class="line">### 列出正在运行的容器</span><br><span class="line"></span><br><span class="line">- `docker ps`：列出当前所有正在运行的容器</span><br><span class="line"></span><br><span class="line">### 列出历史上运行过的容器</span><br><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  docker ps -a</span><br></pre></td></tr></table></figure></li>
</ul>
<p>：列出当前所有正在运行的容器+历史上运行过的容器</p>
<ul>
<li><code>docker ps -l</code>：显示最近创建的容器</li>
<li><code>docker ps -n 数字</code>：显示最近创建的n个容器</li>
<li><code>docker ps -q</code>：静默模式，只显示容器编号</li>
<li><code>docker ps --no-trunc</code>：不截断输出</li>
</ul>
</li>
</ul>
<h3 id="退出容器"><a href="#退出容器" class="headerlink" title="退出容器"></a>退出容器</h3><ul>
<li><code>exit</code>：容器停止退出</li>
<li><code>Ctrl+P+Q</code>：容器不停止退出</li>
</ul>
<h3 id="启动-x2F-重启-x2F-停止容器"><a href="#启动-x2F-重启-x2F-停止容器" class="headerlink" title="启动&#x2F;重启&#x2F;停止容器"></a>启动&#x2F;重启&#x2F;停止容器</h3><ul>
<li><code>docker start 容器名</code>：启动容器</li>
<li><code>docker restart 容器名</code>：重启容器</li>
<li><code>docker stop 容器名</code>：停止容器，类似于电脑关机</li>
<li><code>docker kill 容器名</code>：强制停止，类似于电脑拔电源关机</li>
</ul>
<h3 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h3><ul>
<li><p><code>docker rm 容器名</code>：删除已停止的容器，若未停止则不删除</p>
</li>
<li><pre><code>docker rm -f 容器名
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  ：停止并删除容器</span><br><span class="line"></span><br><span class="line">  - `docker rm -f $(docker ps -aq)`：删除所有容器</span><br><span class="line"></span><br><span class="line">### 后台运行容器</span><br><span class="line"></span><br><span class="line">- `docker run -d 容器名`：启动守护式容器，运行在后台，用docker ps查看看不到，因为已经退出了。docker容器后台运行，必须有一个前台进程</span><br><span class="line"></span><br><span class="line">### 容器日志相关</span><br><span class="line"></span><br><span class="line">- `docker logs [options] 容器名`：查看容器日志</span><br><span class="line">- `docker logs -t 容器名`：加入时间戳</span><br><span class="line">  - `docker logs -f 容器名`：跟随最新的日志打印（动态打印）</span><br><span class="line">  - `docker logs --tail 数字 容器名`：显示最后多少条</span><br><span class="line"></span><br><span class="line">### 查看容器内的进程</span><br><span class="line"></span><br><span class="line">- `docker top 容器名`：查看容器内的进程</span><br><span class="line"></span><br><span class="line">### 查看容器内部细节</span><br><span class="line"></span><br><span class="line">- `docker inspect 容器名`：查看容器内部细节，返回是json串</span><br><span class="line"></span><br><span class="line">### 进入正在运行的容器并以命令行交互</span><br><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  docker exec -it 容器名 bash命令</span><br></pre></td></tr></table></figure>

：在容器中打开新的终端，并可以启动新的进程

- `docker exec -it 容器名 ls -l /tmp`：不进入容器，直接拿到`ls -l /tmp`命令的执行结果，等价于使用`docker exec -it 容器名 /bin/bash`先进入bash，再执行`ls -l /tmp`得到结果
</code></pre>
</li>
<li><p><code>docker attach 容器名</code>：直接进入容器启动命令的终端，不会启动新的进程</p>
</li>
</ul>
<h3 id="拷贝容器内容到本机"><a href="#拷贝容器内容到本机" class="headerlink" title="拷贝容器内容到本机"></a>拷贝容器内容到本机</h3><ul>
<li><code>docker cp 容器名:容器中文件的路径 本机路径</code>：从容器内拷贝文件到本机上</li>
</ul>
<p><img src="/2022/09/24/Docker/20220925150802270.png" alt="img"></p>
<h1 id="Docker镜像"><a href="#Docker镜像" class="headerlink" title="Docker镜像"></a>Docker镜像</h1><h2 id="联合文件系统（UnionFS）"><a href="#联合文件系统（UnionFS）" class="headerlink" title="联合文件系统（UnionFS）"></a>联合文件系统（UnionFS）</h2><p>UnionFS是一种分层、轻量级并且高性能的文件系统，它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下，UnionFS是docker镜像的基础，镜像可以通过分层来进行继承，基于基础镜像（没有父镜像），可以制作各种具体的应用镜像。</p>
<p>特性：一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统该，联合加载会把各层文件系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录。</p>
<h2 id="docker镜像加载原理"><a href="#docker镜像加载原理" class="headerlink" title="docker镜像加载原理"></a>docker镜像加载原理</h2><p>docker的镜像实际上是由一层层的文件系统组成，这种层级的文件系统就是UnionFS</p>
<p>bootfs（boot文件系统）主要包含bootloader和kernel，bootloader主要是引导加载kernel，Linux刚启动的时候会加载bootfs文件系统，在docker镜像的最底层是bootfs。这一层与Linux系统该是一样的，包含boot加载器和内核。当boot加载完成后整个内核就都在内存中了，此时内存的使用权已由bootfs转交给内核，此时系统也会卸载bootfs。</p>
<p>rootfs（root文件系统），在bootfs之上，包含的是典型Linux系统中的&#x2F;dev，&#x2F;proc，&#x2F;bin，&#x2F;etc等标准目录和文件。rootfs就是各种不同的操作系统该发行版，如Ubuntu、CentOS等。</p>
<p>对于一个精简的OS，rootfs可以很小，只需要包括最基本的命令、工具和程序库就可以了，因为底层直接用Host的kernel，自己只需要提供rootfs就行了。所以对于不同的Linux发行版，bootfs基本是一致的，rootfs会有差别，因此不同的发行版可以共用bootfs。</p>
<h2 id="镜像的特点和优点"><a href="#镜像的特点和优点" class="headerlink" title="镜像的特点和优点"></a>镜像的特点和优点</h2><h3 id="镜像的特点"><a href="#镜像的特点" class="headerlink" title="镜像的特点"></a>镜像的特点</h3><p>docker镜像都是只读的，当容器启动时，一个新的可写层被加载到镜像的顶部，这一层通常被称作“容器层”，“容器层”之下的为“镜像层”。</p>
<h3 id="分层镜像的优点"><a href="#分层镜像的优点" class="headerlink" title="分层镜像的优点"></a>分层镜像的优点</h3><p>使用分层镜像的优点是可以共享资源，比如有多个镜像都从相同的base镜像构建而来，那么宿主机上只需要保存一份base镜像，内存中也只需要加载一份base镜像，就可以为所有容器服务了。镜像的每一层都可以被共享。 以pull为例，在下载的过程中可以看到docker的镜像好像是在一层一层的在下载。</p>
<p><img src="/2022/09/24/Docker/20220925150803300.png" alt="img"></p>
<h2 id="镜像提交"><a href="#镜像提交" class="headerlink" title="镜像提交"></a>镜像提交</h2><h3 id="commit命令"><a href="#commit命令" class="headerlink" title="commit命令"></a>commit命令</h3><ul>
<li><code>docker commit -m=&quot;提交的描述信息&quot; -a=&quot;作者&quot; 容器名 要创建的目标镜像名:[TAG]</code>：提交容器副本使之成为一个新的镜像</li>
</ul>
<h3 id="镜像提交实例"><a href="#镜像提交实例" class="headerlink" title="镜像提交实例"></a>镜像提交实例</h3><ul>
<li><p><code>docker run -it -p 8080:8080 tomcat</code>：从hub上下载tomcat镜像到本地并运行</p>
</li>
<li><p>故意删除上一步镜像生产tomcat容器的文档</p>
</li>
<li><p><code>docker commit -a=&quot;zuzhiang&quot; -m=&quot;del tomcat docs&quot; 容器名 atguigu/tomcat/02:1.2</code>：以它为模板提交一个没有文档的tomcat新镜像<code>atguigu/tomcat02</code></p>
</li>
<li><p><code>docker run -it -p 7777:8080 atguigu/tomcat02:1.2</code>：启动新镜像并访问<code>localhost:7777/docs</code>界面，可以发现与原镜像相比无文档</p>
</li>
</ul>
<h1 id="容器数据卷"><a href="#容器数据卷" class="headerlink" title="容器数据卷"></a>容器数据卷</h1><h2 id="容器数据卷-1"><a href="#容器数据卷-1" class="headerlink" title="容器数据卷"></a>容器数据卷</h2><h3 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h3><p>容器删除后数据自然也就没有了，所以用卷来保存数据。容器数据卷功能是持久化和数据共享。 卷就是目录或文件，存在于一个或多个容器中，由docker挂载到容器，但不属于联合文件系统，因此能够绕过Union File Syste提供一些用于持续存储或共享数据的特性。</p>
<h3 id="容器数据卷的特点"><a href="#容器数据卷的特点" class="headerlink" title="容器数据卷的特点"></a>容器数据卷的特点</h3><ul>
<li>数据卷可以在容器之间共享或重用数据</li>
<li>卷中的更改可以直接生效</li>
<li>数据卷中的更改不会包含在镜像的更新中</li>
<li>数据卷的生命周期一直持续到没有容器使用它为止</li>
</ul>
<h2 id="容器内添加数据卷"><a href="#容器内添加数据卷" class="headerlink" title="容器内添加数据卷"></a>容器内添加数据卷</h2><h3 id="直接命令添加"><a href="#直接命令添加" class="headerlink" title="直接命令添加"></a>直接命令添加</h3><ul>
<li><p><code>docker run -it -v /宿主机绝对路径:/容器内目录[:ro] 镜像名 .</code>：将宿主机的目录和容器内目录绑定，之后对宿主机或容器内相应文件夹的内容添加和修改就是同步的了。容器每次启动后会将数据同步。添加<code>:ro</code>时表示是只读模式，宿主机可以添加和修改文件，但是容器内不可以。</p>
</li>
<li><p><code>docker inspect 容器名</code>：查看数据卷是否挂载成功，其中Volumes里面有绑定的目录</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/bcdd80556a0ed8609909af8525ed700e.png" alt="img"></p>
</li>
<li><p>容器和宿主机之间数据共享</p>
</li>
<li><p>容器停止后，宿主机修改数据是否同步</p>
</li>
</ul>
<p>如果无权限，则使用<code>docker run -it -v /宿主机绝对路径:/容器内目录 --privileged=true 镜像名 .</code>即可</p>
<h3 id="dockerFile添加"><a href="#dockerFile添加" class="headerlink" title="dockerFile添加"></a>dockerFile添加</h3><p>dockerFile是镜像的描述文件</p>
<ul>
<li><p>根目录下新建<code>mydocker</code>文件夹并进入</p>
</li>
<li><p><code>VOLUME[&quot;/dataVolumeContainer&quot;,&quot;/dataVolumeContainer2&quot;,&quot;/dataVolumeContainer3&quot;]</code>：可在<code>dockerFile</code>中能使用volume指令来给镜像添加一个或多个数据卷</p>
</li>
<li><p><code>vi dockerfile</code>：File构建</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> centos</span><br><span class="line"><span class="keyword">VOLUME</span><span class="language-bash"> [<span class="string">&quot;/dataVolumeContainer1&quot;</span>,<span class="string">&quot;/dataVolumeContainer2&quot;</span>]</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> <span class="built_in">echo</span> <span class="string">&quot;finished,--------success1&quot;</span></span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> /bin/bash</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>docker build -f /mydocker/dockerfile -t zza/centos</code>：build后生成镜像，获得一个新镜像<code>zza/centos</code></p>
</li>
<li><p><code>docker run -it zza/centos</code>：运行容器，容器内自带两个容器数据卷，对应的宿主机的目录默认，可以通过<code>docker inspect</code>查看</p>
</li>
</ul>
<h2 id="数据卷容器"><a href="#数据卷容器" class="headerlink" title="数据卷容器"></a>数据卷容器</h2><h3 id="是什么-1"><a href="#是什么-1" class="headerlink" title="是什么"></a>是什么</h3><p>命名的容器挂载数据卷，其它容器通过挂载这个(父容器)实现数据共享，挂载数据卷的容器，称之为数据卷容器。</p>
<h3 id="容器间传递共享"><a href="#容器间传递共享" class="headerlink" title="容器间传递共享"></a>容器间传递共享</h3><ul>
<li><p>先启动一个父容器：<code>docker run -it --name dc01 zza/centos</code></p>
</li>
<li><p>dc02继承自dc01：<code>docker run -it --name dc02 --volumes-from dc01 zza/centos</code></p>
</li>
<li><p>回到dc01可以看到02&#x2F;03各自添加的都能共享了</p>
</li>
<li><p>删除dc01，dc02修改后dc03可否访问</p>
</li>
<li><p>删除dc02后dc03可否访问</p>
</li>
<li><p>新建dc04继承dc03后再删除dc03</p>
</li>
<li><p>结论：</p>
<ul>
<li>父子容器之间数据共享，删除父容器后，修改某一子容器会响应其兄弟元素</li>
<li>容器之间配置信息的传递，数据卷生命周期一直持续到没有容器使用它为止</li>
</ul>
</li>
</ul>
<h1 id="DockerFile解析"><a href="#DockerFile解析" class="headerlink" title="DockerFile解析"></a>DockerFile解析</h1><h2 id="DockerFile"><a href="#DockerFile" class="headerlink" title="DockerFile"></a>DockerFile</h2><h3 id="是什么-2"><a href="#是什么-2" class="headerlink" title="是什么"></a>是什么</h3><p>dockerFile是用来构建docker镜像的构建文件，是由一系列命令和参数构成的脚本。 Dockerfile定义了进程需要的一切东西。Dockerfile涉及的内容包括执行代码或者是文件、环境变量、依赖包、运行时环境、动态链接库、操作系统的发行版、服务进程和内核进程(当应用进程需要和系统服务和内核进程打交道，这时需要考虑如何设计namespace的权限控制)等等</p>
<h3 id="构建三步骤"><a href="#构建三步骤" class="headerlink" title="构建三步骤"></a>构建三步骤</h3><p><img src="/2022/09/24/Docker/20220925150805436.png" alt="img"></p>
<ul>
<li>编写DockerFile文件</li>
<li>docker build</li>
<li>docker run</li>
</ul>
<h3 id="DockerFile内容基础知识"><a href="#DockerFile内容基础知识" class="headerlink" title="DockerFile内容基础知识"></a>DockerFile内容基础知识</h3><ul>
<li>每条保留字指令都必须为大写字母且后面要跟随至少一个参数</li>
<li>指令从上到下顺序执行</li>
<li><code>#</code>表示注释</li>
<li>每条指令都会创建一个新的镜像层，并对镜像进行提交</li>
</ul>
<h3 id="docker运行dockerFile的大致流程："><a href="#docker运行dockerFile的大致流程：" class="headerlink" title="docker运行dockerFile的大致流程："></a>docker运行dockerFile的大致流程：</h3><ul>
<li>docker从基础镜像运行一个容器</li>
<li>执行一条指令并对容器做出修改</li>
<li>执行类似<code>docker commit</code>的操作提交一个新的镜像层</li>
<li>docker再基于刚提交的镜像运行一个新容器</li>
<li>执行dockerFile中的下一条指令知道所有指令都执行完成</li>
</ul>
<h2 id="保留字指令"><a href="#保留字指令" class="headerlink" title="保留字指令"></a>保留字指令</h2><p><img src="/2022/09/24/Docker/20220925150808459.png" alt="img"></p>
<ul>
<li><p><code>FROM</code>：基础镜像，当前镜像是基于哪个镜像的</p>
</li>
<li><p><code>MAINTAINER</code>：镜像维护者的姓名和邮箱地址</p>
</li>
<li><p><code>RUN</code>：容器构建时需要运行的命令</p>
</li>
<li><p><code>EXPOSE</code>：当前容器对外暴露出的端口</p>
</li>
<li><p><code>WORKDIR</code>：指定在创建容器后，终端默认登录进来的工作目录</p>
</li>
<li><p><code>ENV</code>：用来在构建镜像过程中设置环境变量</p>
</li>
<li><p><code>ADD</code>：将宿主机目录下的文件拷贝进镜像且ADD命令会自动处理URL和解压tar压缩包</p>
</li>
<li><p><code>COPY</code>：类似ADD，拷贝文件和目录到镜像中。将从构建上下文目录中&lt;源文件&gt;的文件&#x2F;目录复制到镜像内的&lt;目标路径&gt;位置</p>
</li>
<li><p><code>VOLUME</code>：容器数据卷，用于数据保存和持久化工作</p>
</li>
<li><p><code>CMD</code>：指定一个容器启动时要运行的命令，DockerFile中可以有多个CMD命令，但只有最后一个生效，CMD会被docker run之后的参数替换</p>
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-lVvPW0WL-1622124381817)(assets&#x2F;20220925150810481.png)]</p>
</li>
<li><p><code>ENTRYPOINT</code>：指定一个容器启动时要运行的命令，ENTRYPOINT的目的和CMD一样，都是指定容器启动程序及参数</p>
</li>
<li><p><code>ONBUILD</code>：当构建一个被继承的DockerFile时运行命令，父镜像在被子镜像继承后父镜像的onbuild被触发</p>
</li>
</ul>
<h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><h3 id="自定义镜像mycentos"><a href="#自定义镜像mycentos" class="headerlink" title="自定义镜像mycentos"></a>自定义镜像mycentos</h3><h4 id="编写"><a href="#编写" class="headerlink" title="编写"></a>编写</h4><ul>
<li><p>默认CentOS镜像的情况</p>
<p><img src="/2022/09/24/Docker/20220925150811495.png" alt="29B0qs.png"></p>
</li>
<li><p>编写DokerFile文件</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> centos</span><br><span class="line"><span class="keyword">MAINTAINER</span> zuzhiang&lt;zuzhiang@<span class="number">126</span>.com&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">ENV</span> MYPATH /tmp</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> <span class="variable">$MYPATH</span></span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> yum -y install vim</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> yum -y install net-tools</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">80</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> <span class="built_in">echo</span> <span class="variable">$MYPATH</span></span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> <span class="built_in">echo</span> <span class="string">&quot;success    ok&quot;</span></span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> /bin/bash</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h4><ul>
<li><code>docker build -t mycentos:1.3</code></li>
</ul>
<p>[<img src="/2022/09/24/Docker/20220925150813520.png" alt="29BDZn.png"></p>
<p><img src="/2022/09/24/Docker/20220925150815522.png" alt="img"></p>
<h4 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h4><ul>
<li><code>docker run -it mycentos:1.3</code></li>
</ul>
<p><img src="/2022/09/24/Docker/20220925150818528.png" alt="img"></p>
<h4 id="镜像变更历史"><a href="#镜像变更历史" class="headerlink" title="镜像变更历史"></a>镜像变更历史</h4><ul>
<li><code>docker history 镜像名</code>：列出镜像变更历史</li>
</ul>
<h3 id="CMD-x2F-ENTRYPOINT镜像案例"><a href="#CMD-x2F-ENTRYPOINT镜像案例" class="headerlink" title="CMD&#x2F;ENTRYPOINT镜像案例"></a>CMD&#x2F;ENTRYPOINT镜像案例</h3><h4 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h4><p>都是指定一个容器启动时要运行的命令</p>
<h4 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h4><p>DockerFile中可以有多个CMD指令，但只有最后一个生效，CMD会被<code>docker run</code>之后的参数替换。在tomcat容器dockerFile的最后一行是<code>CMD [&quot;catalina.sh&quot;,&quot;run&quot;]</code>，但如果<code>docker run -it tomcat ls -l</code>时，则命令行参数会把最后一行CMD命令给替换，导致tomcat不能正常启动</p>
<h4 id="CMD版查询IP信息的容器"><a href="#CMD版查询IP信息的容器" class="headerlink" title="CMD版查询IP信息的容器"></a>CMD版查询IP信息的容器</h4><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> centos</span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> yum install -y curl</span></span><br><span class="line"><span class="comment"># curl命令可以用来执行下载、发送各种HTTP请求，指定HTTP头部等操作</span></span><br><span class="line"><span class="comment"># 执行后，www.baidu.com的html就会显示在屏幕上了</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;curl&quot;</span>,<span class="string">&quot;-s&quot;</span>,<span class="string">&quot;http://ip.cn&quot;</span>]</span></span><br></pre></td></tr></table></figure>

<p><code>docker build -f dockerfile4 -t myip</code>：构建</p>
<p><img src="/2022/09/24/Docker/20220925150820557.png" alt="img"></p>
<h4 id="ENTRYPOINT"><a href="#ENTRYPOINT" class="headerlink" title="ENTRYPOINT"></a>ENTRYPOINT</h4><p><code>docker run</code>之后的参数会被当作参数传递给ENTRYPOINT，之后形成新的命令组合</p>
<h4 id="ENTRYPOINT版查询IP信息的容器"><a href="#ENTRYPOINT版查询IP信息的容器" class="headerlink" title="ENTRYPOINT版查询IP信息的容器"></a>ENTRYPOINT版查询IP信息的容器</h4><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> centos</span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> yum install -y curl</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;curl&quot;</span>,<span class="string">&quot;-s&quot;</span>,<span class="string">&quot;http://ip.cn&quot;</span>]</span></span><br><span class="line"><span class="comment"># 被继承时，直接在子dockerFile中&quot;FROM 容器名&quot;进行继承</span></span><br><span class="line"><span class="keyword">ONBUILD</span> <span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">echo</span> <span class="string">&quot;father images onbuild.&quot;</span></span></span><br></pre></td></tr></table></figure>

<p>先build自己镜像myip，然后运行<code>docker run -it myip -i</code>，变成了执行<code>curl -s -i http://ip.cn</code>命令</p>
<p>[<img src="/2022/09/24/Docker/20220925150822576.png" alt="29BNRS.png"></p>
<h3 id="自定义镜像Tomcat9"><a href="#自定义镜像Tomcat9" class="headerlink" title="自定义镜像Tomcat9"></a>自定义镜像Tomcat9</h3><ul>
<li><p>创建工作目录：<code>mkdir -p /mydockerfile/tomcat9</code></p>
</li>
<li><p>新建txt文件：<code>touch c.txt</code></p>
</li>
<li><p>将jdk和tomcat安装的压缩包拷贝到新建的目录</p>
<ul>
<li><code>cp /jdk-8u171-linux-x64.tar.gz</code></li>
<li><code>cp /opt/apache-tomcat-9.0.8.tar.gz</code></li>
</ul>
</li>
<li><p>新建DockerFile文件：<code>vim Dockerfile</code></p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> centos</span><br><span class="line"><span class="keyword">MAINTAINER</span> zuzhiang&lt;zuzhiang@<span class="number">126</span>.com&gt;</span><br><span class="line"><span class="comment"># 把宿主机当前上下文的c.txt靠背巾容器/usr/local/路径下</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> c.txt /usr/local/cincontainer.txt</span></span><br><span class="line"><span class="comment"># 把javahetomcat添加到容器内</span></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> jdk-8u171-linux-x64.tar.gz /usr/local</span></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> apache-tomcat-9.0.8.tar.gz</span></span><br><span class="line"><span class="comment"># 安装vim编辑器</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> yum -y install vim</span></span><br><span class="line"><span class="keyword">ENV</span> MYPATH /usr/local</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> <span class="variable">$MYPATH</span></span></span><br><span class="line"><span class="comment"># 配置java和tomcat环境变量</span></span><br><span class="line"><span class="keyword">ENV</span> JAVA_HOME /usr/local/jdk1.<span class="number">8.0</span>_171</span><br><span class="line"><span class="keyword">ENV</span> CLASSPATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar</span><br><span class="line"><span class="keyword">ENV</span> CATALINA_HOME /usr/local/apache-tomcat-<span class="number">9.0</span>.<span class="number">8</span></span><br><span class="line"><span class="keyword">ENV</span> CATALINA_BASE /usr/local/apache-tomcat-<span class="number">9.0</span>.<span class="number">8</span></span><br><span class="line"><span class="keyword">ENV</span> PATH $PATH:$JAVA_HOME/bin:$CATALINA_HOME/lib:$CATALINA_HOME/bin</span><br><span class="line"><span class="comment"># 容器运行时的监听的端口</span></span><br><span class="line">ENVEXPOSE <span class="number">8080</span></span><br><span class="line"><span class="comment"># ENTRYPOINT [&quot;/usr/local/apache-tomcat-9.0.8/bin/startup.sh&quot;]</span></span><br><span class="line"><span class="comment"># CMD [&quot;/usr/local/apache-tomcat-9.0.8/bin/catalina.sh&quot;,&quot;run&quot;]</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> /usr/local/apache-tomcat-9.0.8/bin/startup.sh &amp;&amp; <span class="built_in">tail</span> -F /usr/local/apache-tomcat-9.0.8/bin/logs/catalina.out</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>构建：<code>docker build -t zzatomcat9 .</code></p>
</li>
<li><p>运行：<code>docker run -d -p 9080:8080 --name myt9 -v /mydockerfile/tomcat9/test:/usr/local/apache-tomcat-9.0.8/webapps/test -v /mydockerfile/tomcat9/tomcat9logs/:/usr/local/apache-tomcat-9.0.8/logs --privileged=true zzatomcat9</code></p>
</li>
<li><p>验证：在浏览器访问localhost:9080</p>
</li>
</ul>
<h3 id="综合前面的tomcat容器卷将测试的web服务test发布"><a href="#综合前面的tomcat容器卷将测试的web服务test发布" class="headerlink" title="综合前面的tomcat容器卷将测试的web服务test发布"></a>综合前面的tomcat容器卷将测试的web服务test发布</h3><ul>
<li><p>总体概述</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在mydockerfile/tomcat9/test下</span></span><br><span class="line"><span class="built_in">mkdir</span> WEB-INF</span><br><span class="line"><span class="built_in">cd</span> WEB-INF</span><br><span class="line">vim web.xml</span><br><span class="line"><span class="built_in">cd</span> ..</span><br><span class="line">vim a.jsp</span><br></pre></td></tr></table></figure>
</li>
<li><p>web.xml内容</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns</span>=<span class="string">&quot;http://java.sun.com/xml/ns/javaee&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&quot;</span></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag">         <span class="attr">id</span>=<span class="string">&quot;WebApp_ID&quot;</span> <span class="attr">version</span>=<span class="string">&quot;2.5&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">display-name</span>&gt;</span>test<span class="tag">&lt;/<span class="name">display-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>a.jsp内容</p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%@ page language=<span class="string">&quot;java&quot;</span> contentType=<span class="string">&quot;text/html; charset=UTF-8&quot;</span> pageEncoding=<span class="string">&quot;UTF-8&quot;</span> %&gt;</span><br><span class="line">&lt;!DOCTYPE html PUBLIC <span class="string">&quot;-//W3C//DTD HTML 4.0.1 Transitional//EN&quot;</span> <span class="string">&quot;http://www.23.org/TR/html/loose.dtd&quot;</span>&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">        &lt;meta http-equiv=<span class="string">&quot;Content-Type&quot;</span> content=<span class="string">&quot;text/html; charset=UTF-8&quot;</span>&gt;</span><br><span class="line">        &lt;title&gt;Insert title here&lt;/title&gt;</span><br><span class="line">    &lt;/head&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        -------------------welcome------------------</span><br><span class="line">        &lt;%=<span class="string">&quot;I am in docker tomcat self&quot;</span>%&gt;</span><br><span class="line">        &lt;br&gt;</span><br><span class="line">        &lt;br&gt;</span><br><span class="line">        &lt;% System.out.println(<span class="string">&quot;=============docker tomcat self&quot;</span>);%&gt;</span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>测试：在浏览器访问<code>localhost:9080/test/a.jsp</code></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/89131f6798d5abb70fcdafc2117b6760.png" alt="img"></p>
</li>
</ul>
<h2 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h2><p><img src="/2022/09/24/Docker/20220925150824697.png" alt="img"></p>
<h1 id="Docker常用安装"><a href="#Docker常用安装" class="headerlink" title="Docker常用安装"></a>Docker常用安装</h1><h2 id="安装tomcat"><a href="#安装tomcat" class="headerlink" title="安装tomcat"></a>安装tomcat</h2><ul>
<li><p><code>docker search tomcat</code> ：docker hub上面查找tomcat镜像</p>
</li>
<li><p><code>docker pull tomcat</code>：从docker hub上拉取tomcat镜像到本地</p>
</li>
<li><p><code>docker images</code>：查看你是否有拉取到tomcat</p>
</li>
<li><p><code>docker run -it -p 8080:8080 tomcat</code>：运行镜像</p>
</li>
</ul>
<h2 id="安装MySQL"><a href="#安装MySQL" class="headerlink" title="安装MySQL"></a>安装MySQL</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker search mysql <span class="comment"># docker hub上面查找mysql镜像</span></span><br><span class="line">docker pull mysql:5.6 <span class="comment"># 从docker hub上拉取mysql:5.6镜像到本地</span></span><br><span class="line">docker images <span class="comment"># 查看你是否有拉取到mysql</span></span><br><span class="line"><span class="comment"># 运行镜像</span></span><br><span class="line">docker run -p 12345:3306 --name mysql -v /zza/mysql/conf:/etc/mysql/conf.d -v /zza/mysql/logs:/logs -v /zza/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 -d mysql:5.6</span><br></pre></td></tr></table></figure>

<h2 id="安装redis"><a href="#安装redis" class="headerlink" title="安装redis"></a>安装redis</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker search redis <span class="comment"># docker hub上面查找redis镜像</span></span><br><span class="line">docker pull redis:3.2 <span class="comment"># 从docker hub上拉取redis:3.2镜像到本地</span></span><br><span class="line">docker images <span class="comment"># 查看你是否有拉取到redis</span></span><br><span class="line"><span class="comment"># 运行镜像</span></span><br><span class="line">docker run -p 6379:6379 -v /zza/myredis/data:/data -v /zza/myredis/conf/redis.conf:/usr/local/etc/redis/redis.conf -d redis:3.2 redis-server /usr/local/etc/redis/redis.conf --appendonly <span class="built_in">yes</span></span><br><span class="line"><span class="comment"># 在/zza/myredis/conf/redis.conf目录下新建redis.conf文件</span></span><br><span class="line">vim /zza/myredis/conf/redis.conf/redis.conf</span><br><span class="line"><span class="comment"># 添加redis配置文件</span></span><br><span class="line"><span class="comment"># 进入reids并添加键值对</span></span><br><span class="line">docker <span class="built_in">exec</span> -it redis容器<span class="built_in">id</span> redis-cli</span><br></pre></td></tr></table></figure>

<h1 id="本地镜像推送到阿里云"><a href="#本地镜像推送到阿里云" class="headerlink" title="本地镜像推送到阿里云"></a>本地镜像推送到阿里云</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -it 镜像</span><br><span class="line">docker -a zuzhiang -m <span class="string">&quot;new mycentos 1.4 from 1.3&quot;</span> 镜像<span class="built_in">id</span> 新镜像名</span><br><span class="line"><span class="comment"># 在阿里云开发者平台创建仓库镜像</span></span><br><span class="line"><span class="comment"># 将镜像推送到registry</span></span><br><span class="line">docker --username= registry.cn-hangzhou.aliyuncs.com</span><br><span class="line">docker tag 镜像<span class="built_in">id</span> registry.cn-hangzhou.aliyuncs.com/zuzhiang/centos.1.4</span><br><span class="line">docker push registry.cn-hangzhou.aliyuncs.com/zuzhiang/centos.1.4</span><br><span class="line"><span class="comment"># 在https://dev.aliyun.com查找</span></span><br><span class="line">docker pull registry.cn-hangzhou.aliyuncs.com/zuzhiang/centos.1.4</span><br></pre></td></tr></table></figure>

<p><img src="/assets/20220925150827762.png" alt="img"></p>
]]></content>
      <categories>
        <category>docker学习</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title>SSM学习</title>
    <url>/2022/09/26/ssm%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><p>**IOC **(Inverse Of Control：反转控制）</p>
<p>**AOP **(Aspect Oriented Programming：面向切面编程）</p>
<h2 id="Spring的体系结构："><a href="#Spring的体系结构：" class="headerlink" title="Spring的体系结构："></a><strong>Spring的体系结构：</strong></h2><p><img src="/2022/09/26/ssm%E5%AD%A6%E4%B9%A0/202209262040158.png" alt="在这里插入图片描述"></p>
<h2 id="Spring程序的开发步骤："><a href="#Spring程序的开发步骤：" class="headerlink" title="Spring程序的开发步骤："></a>Spring程序的开发步骤：</h2><h3 id="①导入-Spring-开发的基本包坐标"><a href="#①导入-Spring-开发的基本包坐标" class="headerlink" title="①导入 Spring 开发的基本包坐标"></a>①导入 Spring 开发的基本包坐标</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.0.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="②编写-Dao-接口和实现类"><a href="#②编写-Dao-接口和实现类" class="headerlink" title="②编写 Dao 接口和实现类"></a>②编写 Dao 接口和实现类</h3><h3 id="③创建-Spring-核心配置文件"><a href="#③创建-Spring-核心配置文件" class="headerlink" title="③创建 Spring 核心配置文件"></a>③创建 Spring 核心配置文件</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">&lt;@xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;@&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=</span></span><br><span class="line"><span class="tag">       <span class="string">&quot;http://www.springframework.org/schema/beans 				        	 http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="④在-Spring-配置文件中配置-UserDaoImpl"><a href="#④在-Spring-配置文件中配置-UserDaoImpl" class="headerlink" title="④在 Spring 配置文件中配置 UserDaoImpl"></a>④在 Spring 配置文件中配置 UserDaoImpl</h3><h3 id="⑤使用-Spring-的-API-获得-Bean-实例"><a href="#⑤使用-Spring-的-API-获得-Bean-实例" class="headerlink" title="⑤使用 Spring 的 API 获得 Bean 实例"></a>⑤使用 Spring 的 <a href="https://so.csdn.net/so/search@q=API&spm=1001.2101.3001.7020">API</a> 获得 Bean 实例</h3><h2 id="Spring的配置文件"><a href="#Spring的配置文件" class="headerlink" title="Spring的配置文件"></a>Spring的配置文件</h2><h3 id="Spring标签配置范围："><a href="#Spring标签配置范围：" class="headerlink" title="Spring标签配置范围："></a>Spring标签配置范围：</h3><p><strong>singleton</strong> 默认，单例</p>
<p><strong>prototype</strong> 多例</p>
<p><strong>request</strong> web项目中，Spring创建一个Bean的对象，将对象存入到 request 域中</p>
<p><strong>session</strong> WEB 项目中，Spring 创建一个 Bean 的对象，将对象存入到 session 域中</p>
<p><strong>global</strong> <strong>session</strong> WEB 项目中，应用在 Portlet 环境，如果没有 Portlet 环境那么global session相当于session</p>
<h3 id="Bean生命周期配置"><a href="#Bean生命周期配置" class="headerlink" title="Bean生命周期配置"></a>Bean<a href="https://so.csdn.net/so/search@q=%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F&spm=1001.2101.3001.7020">生命周期</a>配置</h3><p><strong>init-method</strong>：指定类中的初始化方法名称</p>
<p><strong>destroy-method</strong>：指定类中销毁方法名称</p>
<h3 id="Bean实例化三种方式"><a href="#Bean实例化三种方式" class="headerlink" title="Bean实例化三种方式"></a>Bean实例化三种方式</h3><p>1） 使用无参构造方法实例化</p>
<p>@ 它会根据默认无参构造方法来创建类对象，如果bean中没有默认无参构造函数，将会创建失败</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.UserDaoImpl&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>2） 工厂静态方法实例化</p>
<p>@ 工厂的静态方法返回Bean实例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticFactoryBean</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> UserDao <span class="title function_">createUserDao</span><span class="params">()</span>&#123;    </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UserDaoImpl</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;bean id=<span class="string">&quot;userDao&quot;</span> class=<span class="string">&quot;com.itheima.factory.StaticFactoryBean&quot;</span> </span><br><span class="line">    factory-method=<span class="string">&quot;createUserDao&quot;</span> /&gt;</span><br></pre></td></tr></table></figure>

<p>3） 工厂实例方法实例化</p>
<p>@ 工厂的非静态方法返回Bean实例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DynamicFactoryBean</span> &#123;  </span><br><span class="line">	<span class="keyword">public</span> UserDao <span class="title function_">createUserDao</span><span class="params">()</span>&#123;        </span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UserDaoImpl</span>(); </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;bean id=<span class="string">&quot;factoryBean&quot;</span> class=<span class="string">&quot;com.itheima.factory.DynamicFactoryBean&quot;</span>/&gt;</span><br><span class="line">&lt;bean id=<span class="string">&quot;userDao&quot;</span> factory-bean=<span class="string">&quot;factoryBean&quot;</span> factory-method=<span class="string">&quot;createUserDao&quot;</span>/&gt;</span><br></pre></td></tr></table></figure>

<h3 id="Bean的依赖注入"><a href="#Bean的依赖注入" class="headerlink" title="Bean的依赖注入"></a>Bean的<a href="https://so.csdn.net/so/search@q=%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5&spm=1001.2101.3001.7020">依赖注入</a></h3><p>从 Spring 容器中获得 Bean进行操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;Spring配置文件名&quot;</span>);</span><br><span class="line">applicationContext.getBean(<span class="string">&quot;userService&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>参数的数据类型是字符串时，表示根据Bean的id从容器中获得Bean实例，返回是Object，需要强转。</p>
<p>参数的数据类型是Class类型时，表示根据类型从容器中匹配Bean实例，<strong>当容器中相同类型的Bean有多个时，则此方法会报错</strong></p>
<h3 id="Bean的依赖注入方式"><a href="#Bean的依赖注入方式" class="headerlink" title="Bean的依赖注入方式"></a>Bean的依赖注入方式</h3><p>①构造方法</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.UserDaoImpl&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.service.impl.UserServiceImpl&quot;</span>&gt;</span>    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;userDao&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>②set方法</p>
<p>类中必须要有相应的set方法</p>
<p>配置Spring容器调用set方法进行注入</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.UserDaoImpl&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.service.impl.UserServiceImpl&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;userDao&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>set方法:P命名空间注入</p>
<p>@ P命名空间注入本质也是set方法注入，但比起上述的set方法注入更加方便，主要体现在配置文件中，如下：</p>
<p>@ 首先，需要引入P命名空间：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">xmlns:p=&quot;http://www.springframework.org/schema/p&quot;</span><br></pre></td></tr></table></figure>

<p>其次，需要修改注入方式</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.service.impl.UserServiceImpl&quot;</span> <span class="attr">p:userDao-ref</span>=<span class="string">&quot;userDao&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="Bean的依赖注入的数据类型"><a href="#Bean的依赖注入的数据类型" class="headerlink" title="Bean的依赖注入的数据类型"></a>Bean的依赖注入的数据类型</h3><p>注入数据的三种数据类型</p>
<ol>
<li><p>普通数据类型</p>
<p>value 属性</p>
</li>
<li><p>引用数据类型</p>
<p>ref 属性</p>
</li>
<li><p>集合数据类型</p>
<p>List类型:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>aaa<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>bbb<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>ccc<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>List类型:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line"> 	<span class="comment">&lt;!--要么是bean的全限定名--&gt;</span>   </span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.domain.User&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--要么是已经配置好的对象引用--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;u1&quot;</span>/&gt;</span>      </span><br><span class="line"><span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>   Map&lt;String,User&gt;类型：</p>
   <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">map</span>&gt;</span>            </span><br><span class="line">       <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;user1&quot;</span> <span class="attr">value-ref</span>=<span class="string">&quot;u1&quot;</span>/&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;user2&quot;</span> <span class="attr">value-ref</span>=<span class="string">&quot;u2&quot;</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>   集合数据类型 Properties</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;p1&quot;</span>&gt;</span>aaa<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="引入其他配置文件（分模块开发）"><a href="#引入其他配置文件（分模块开发）" class="headerlink" title="引入其他配置文件（分模块开发）"></a>引入其他配置文件（分模块开发）</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">&quot;applicationContext-xxx.xml&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="spring相关API"><a href="#spring相关API" class="headerlink" title="spring相关API"></a>spring相关API</h2><h3 id="ApplicationContext的继承体系"><a href="#ApplicationContext的继承体系" class="headerlink" title="ApplicationContext的继承体系"></a>ApplicationContext的继承体系</h3><p>applicationContext：接口类型，代表应用上下文，可以通过其实例获得 Spring 容器中的 Bean 对象</p>
<h3 id="ApplicationContext的实现类"><a href="#ApplicationContext的实现类" class="headerlink" title="ApplicationContext的实现类"></a>ApplicationContext的实现类</h3><p>1）ClassPathXmlApplicationContext</p>
<p>@ 它是从类的根路径下加载配置文件 推荐使用这种</p>
<p>2）FileSystemXmlApplicationContext</p>
<p>@ 它是从磁盘路径上加载配置文件，配置文件可以在磁盘的任意位置。</p>
<p>3）AnnotationConfigApplicationContext</p>
<p>@ 当使用注解配置容器对象时，需要使用此类来创建 spring 容器。它用来读取注解。</p>
<h2 id="Spring的注解开发"><a href="#Spring的注解开发" class="headerlink" title="Spring的注解开发"></a>Spring的注解开发</h2><p>Spring容器加载properties文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;xx.properties&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;key&#125;&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="Spring原始注解"><a href="#Spring原始注解" class="headerlink" title="Spring原始注解"></a>Spring原始注解</h3><table>
<thead>
<tr>
<th><strong>注解</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td>@Component</td>
<td>使用在类上用于实例化Bean</td>
</tr>
<tr>
<td>@Controller</td>
<td>使用在web层类上用于实例化Bean</td>
</tr>
<tr>
<td>@Service</td>
<td>使用在service层类上用于实例化Bean</td>
</tr>
<tr>
<td>@Repository</td>
<td>使用在dao层类上用于实例化Bean</td>
</tr>
<tr>
<td>@Autowired</td>
<td>使用在字段上用于根据类型依赖注入</td>
</tr>
<tr>
<td>@Qualifier</td>
<td>结合@Autowired一起使用用于根据名称进行依赖注入</td>
</tr>
<tr>
<td>@Resource</td>
<td>相当于@Autowired+@Qualifier，按照名称进行注入</td>
</tr>
<tr>
<td>@Value</td>
<td>注入普通属性</td>
</tr>
<tr>
<td>@Scope</td>
<td>标注Bean的作用范围</td>
</tr>
<tr>
<td>@PostConstruct</td>
<td>使用在方法上标注该方法是Bean的初始化方法</td>
</tr>
<tr>
<td>@PreDestroy</td>
<td>使用在方法上标注该方法是Bean的销毁方法</td>
</tr>
</tbody></table>
<p>1、@Autowired 是通过 byType 的方式去注入的， 使用该注解，要求接口只能有一个实现类。<br>2、@Resource 可以通过 byName 和 byType的方式注入， 默认先按 byName的方式进行匹配，如果匹配不到，再按 byType的方式进行匹配。<br>3、@Qualifier 注解可以按名称注入， 但是注意是 类名</p>
<p>还需要用注解替代的配置:</p>
<blockquote>
<p>非自定义的Bean的配置：<br>加载properties文件的配置：context:property-placeholder<br>组件扫描的配置：context:component-scan<br>引入其他文件：</p>
</blockquote>
<p>新注解：</p>
<p>前三个是配置在配置类上面的</p>
<table>
<thead>
<tr>
<th><strong>注解</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td>@Configuration</td>
<td>用于指定当前类是一个 Spring 配置类，当创建容器时会从该类上加载注解</td>
</tr>
<tr>
<td>@ComponentScan</td>
<td>用于指定 Spring 在初始化容器时要扫描的包。 作用和在 Spring 的 xml 配置文件中的 &lt;context:component-scan base-package&#x3D;“com.itheima”&#x2F;&gt;一样</td>
</tr>
<tr>
<td>@Import</td>
<td>用于导入其他配置类</td>
</tr>
<tr>
<td>@Bean</td>
<td>使用在方法上，标注将该方法的返回值存储到 Spring 容器中</td>
</tr>
<tr>
<td>@PropertySource</td>
<td>用于加载.properties 文件中的配置</td>
</tr>
</tbody></table>
<h2 id="Spring集成Junit"><a href="#Spring集成Junit" class="headerlink" title="Spring集成Junit"></a>Spring集成Junit</h2><p>每个测试方法都有加载配置文件和从配置文件获取bean的代码</p>
<p><strong>解决思路</strong></p>
<p>@让SpringJunit负责创建Spring容器，但是需要将配置文件的名称告诉它</p>
<p>@将需要进行测试Bean直接在测试类中进行注入</p>
<p>集成步骤：</p>
<p>①导入spring集成Junit的坐标</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--此处需要注意的是，spring5 及以上版本要求 junit 的版本必须是 4.12 及以上--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>   </span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.0.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>②使用@Runwith注解替换原来的运行期</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringJUnit4ClassRunner.**class**)</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringJunitTest</span> &#123;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>③使用@ContextConfiguration指定配置文件或配置类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringJUnit4ClassRunner.class)</span></span><br><span class="line"><span class="comment">//加载spring核心配置文件</span></span><br><span class="line"><span class="comment">//@ContextConfiguration(value = &#123;&quot;classpath:applicationContext.xml&quot;&#125;)</span></span><br><span class="line"><span class="comment">//加载spring核心配置类</span></span><br><span class="line"><span class="meta">@ContextConfiguration(classes = &#123;SpringConfiguration.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringJunitTest</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>④使用@Autowired注入需要测试的对象</p>
<p>⑤创建测试方法进行测试</p>
<h2 id="AOP配置"><a href="#AOP配置" class="headerlink" title="AOP配置"></a>AOP配置</h2><p>动态代理</p>
<p>常用的动态代理技术</p>
<p>JDK 代理 : 基于接口的动态代理技术</p>
<p>cglib 代理：基于父类的动态代理技术</p>
<p><a href="https://so.csdn.net/so/search@q=SSM&spm=1001.2101.3001.7020">外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-e8u6X1Ew-1628212818066)(G:\PMY\专业资料[SSM</a>\03-就业课(2.1)]-Spring\day03_ AOP简介\笔记\img\图片1.png)</p>
<h3 id="JDK-的动态代理"><a href="#JDK-的动态代理" class="headerlink" title="JDK 的动态代理"></a>JDK 的动态代理</h3><p>①目标类接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">TargetInterface</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>②目标类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Target</span> <span class="keyword">implements</span> <span class="title class_">TargetInterface</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Target running....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>③动态代理代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Target</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Target</span>(); <span class="comment">//创建目标对象</span></span><br><span class="line"><span class="comment">//创建代理对象</span></span><br><span class="line"><span class="type">TargetInterface</span> <span class="variable">proxy</span> <span class="operator">=</span> (TargetInterface) Proxy.newProxyInstance(target.getClass()</span><br><span class="line">.getClassLoader(),target.getClass().getInterfaces(),<span class="keyword">new</span> <span class="title class_">InvocationHandler</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> </span><br><span class="line">            <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;前置增强代码...&quot;</span>);</span><br><span class="line">                <span class="type">Object</span> <span class="variable">invoke</span> <span class="operator">=</span> method.invoke(target, args);</span><br><span class="line">                System.out.println(<span class="string">&quot;后置增强代码...&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> invoke;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>④ 调用代理对象的方法测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 测试,当调用接口的任何方法时，代理对象的代码都无序修改</span></span><br><span class="line">proxy.method();</span><br></pre></td></tr></table></figure>

<h3 id="cglib-的动态代理"><a href="#cglib-的动态代理" class="headerlink" title="cglib 的动态代理"></a>cglib 的动态代理</h3><p>①目标类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Target</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Target running....&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>②动态代理代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Target</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Target</span>(); <span class="comment">//创建目标对象</span></span><br><span class="line"><span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enhancer</span>();   <span class="comment">//创建增强器</span></span><br><span class="line">enhancer.setSuperclass(Target.class); <span class="comment">//设置父类</span></span><br><span class="line">enhancer.setCallback(<span class="keyword">new</span> <span class="title class_">MethodInterceptor</span>() &#123; <span class="comment">//设置回调</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object o, Method method, Object[] objects, </span></span><br><span class="line"><span class="params">    MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;前置代码增强....&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">invoke</span> <span class="operator">=</span> method.invoke(target, objects);</span><br><span class="line">        System.out.println(<span class="string">&quot;后置代码增强....&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> invoke;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="type">Target</span> <span class="variable">proxy</span> <span class="operator">=</span> (Target) enhancer.create(); <span class="comment">//创建代理对象</span></span><br></pre></td></tr></table></figure>

<p>③调用代理对象的方法测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//测试,当调用接口的任何方法时，代理对象的代码都无序修改</span></span><br><span class="line">proxy.method();</span><br></pre></td></tr></table></figure>

<h3 id="AOP相关概念"><a href="#AOP相关概念" class="headerlink" title="AOP相关概念"></a>AOP相关概念</h3><ul>
<li><p>Target（目标对象）：代理的目标对象</p>
</li>
<li><p>Proxy （代理）：一个类被 AOP 织入增强后，就产生一个结果代理类</p>
</li>
<li><p>Joinpoint（连接点）：所谓连接点是指那些被拦截到的点。在spring中,这些点指的是方法，因为spring只支持方法类型的连接点</p>
</li>
<li><p>Pointcut（切入点）：所谓切入点是指我们要对哪些 Joinpoint 进行拦截的定义</p>
</li>
<li><p>Advice（通知&#x2F; 增强）：所谓通知是指拦截到 Joinpoint 之后所要做的事情就是通知</p>
</li>
<li><p>Aspect（切面）：是切入点和通知（引介）的结合</p>
</li>
<li><p>Weaving（织入）：是指把增强应用到目标对象来创建新的代理对象的过程。spring采用动态代理织入，而AspectJ采用编译期织入和类装载期织入</p>
<p><strong>AOP 技术实现的内容</strong></p>
</li>
</ul>
<p>Spring 框架监控切入点方法的执行。一旦监控到切入点方法被运行，使用代理机制，动态创建目标对象的代理对象，根据通知类别，在代理对象的对应位置，将通知对应的功能织入，完成完整的代码逻辑运行。</p>
<p>@ <strong>AOP 底层使用哪种代理方式</strong></p>
<p>在 spring 中，框架会根据目标类是否实现了接口来决定采用哪种动态代理的方式。</p>
<h3 id="基于-XML-的-AOP-开发"><a href="#基于-XML-的-AOP-开发" class="headerlink" title="基于 XML 的 AOP 开发"></a>基于 XML 的 AOP 开发</h3><p><strong>步骤：</strong></p>
<p>①导入 AOP 相关坐标</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--导入spring的context坐标，context依赖aop--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.0.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- aspectj的织入 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjweaver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.8.13<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>②创建目标接口和目标类（内部有切点）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">TargetInterface</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Target</span> <span class="keyword">implements</span> <span class="title class_">TargetInterface</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Target running....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>③创建切面类（内部有增强方法）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAspect</span> &#123;</span><br><span class="line">    <span class="comment">//前置增强方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;前置代码增强.....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>④将目标类和切面类的对象创建权交给 spring</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置目标类--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;target&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.aop.Target&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--配置切面类--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;myAspect&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.aop.MyAspect&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>⑤在 applicationContext.xml 中配置织入关系</p>
<p>导入aop命名空间</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/aop/spring-aop.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>⑤在 applicationContext.xml 中配置织入关系</p>
<p>配置切点表达式和前置增强的织入关系</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--引用myAspect的Bean为切面对象--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">&quot;myAspect&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--配置Target的method方法执行时要进行myAspect的before方法前置增强--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">&quot;before&quot;</span> <span class="attr">pointcut</span>=<span class="string">&quot;execution(public void com.itheima.aop.Target.method())&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:before</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>⑥测试代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringJUnit4ClassRunner.class)</span></span><br><span class="line"><span class="meta">@ContextConfiguration(&quot;classpath:applicationContext.xml&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AopTest</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> TargetInterface target;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">        target.method();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="XML-配置-AOP-详解"><a href="#XML-配置-AOP-详解" class="headerlink" title="XML 配置 AOP 详解"></a>XML 配置 AOP 详解</h4><h5 id="1）表达式语法："><a href="#1）表达式语法：" class="headerlink" title="1）表达式语法："></a>1）表达式语法：</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">execution([修饰符] 返回值类型 包名.类名.方法名(参数))</span><br></pre></td></tr></table></figure>

<ul>
<li>访问修饰符可以省略</li>
<li>返回值类型、包名、类名、方法名可以使用星号* 代表任意</li>
<li>包名与类名之间一个点 . 代表当前包下的类，两个点 … 表示当前包及其子包下的类</li>
<li>参数列表可以使用两个点 … 表示任意个数，任意类型的参数列表</li>
</ul>
<h5 id="2-通知的类型"><a href="#2-通知的类型" class="headerlink" title="2) 通知的类型"></a>2) 通知的类型</h5><p>通知的配置语法：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:通知类型</span> <span class="attr">method</span>=<span class="string">“切面类中方法名”</span> <span class="attr">pointcut</span>=<span class="string">“切点表达式</span>&quot;&gt;</span><span class="tag">&lt;/<span class="name">aop:通知类型</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="3-切点表达式的抽取"><a href="#3-切点表达式的抽取" class="headerlink" title="3) 切点表达式的抽取"></a>3) 切点表达式的抽取</h5><p>当多个增强的切点表达式相同时，可以将切点表达式进行抽取，在增强中使用 pointcut-ref 属性代替 pointcut 属性来引用抽取后的切点表达式。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--引用myAspect的Bean为切面对象--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">&quot;myAspect&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;myPointcut&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* com.itheima.aop.*.*(..))&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">&quot;before&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;myPointcut&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:before</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="知识要点"><a href="#知识要点" class="headerlink" title="知识要点"></a>知识要点</h4><ul>
<li>aop织入的配置</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">“切面类”</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">“通知方法名称”</span> <span class="attr">pointcut</span>=<span class="string">＂切点表达式＂</span>&gt;</span>					<span class="tag">&lt;/<span class="name">aop:before</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>通知的类型：前置通知、后置通知、环绕通知、异常抛出通知、最终通知</li>
<li>切点表达式的写法：</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">execution([修饰符] 返回值类型 包名.类名.方法名(参数))</span><br></pre></td></tr></table></figure>

<h3 id="基于注解的-AOP-开发"><a href="#基于注解的-AOP-开发" class="headerlink" title="基于注解的 AOP 开发"></a>基于注解的 AOP 开发</h3><h4 id="注解配置步骤"><a href="#注解配置步骤" class="headerlink" title="注解配置步骤"></a>注解配置步骤</h4><p>①创建目标接口和目标类（内部有切点）</p>
<p>②创建切面类（内部有增强方法)</p>
<p>③将目标类和切面类的对象创建权交给 spring</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component(&quot;target&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Target</span> <span class="keyword">implements</span> <span class="title class_">TargetInterface</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Target running....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Component(&quot;myAspect&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAspect</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;前置代码增强.....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>④在切面类中使用注解配置织入关系</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component(&quot;myAspect&quot;)</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAspect</span> &#123;</span><br><span class="line">    <span class="meta">@Before(&quot;execution(* com.itheima.aop.*.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;前置代码增强.....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>⑤在配置文件中开启组件扫描和 AOP 的自动代理</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--组件扫描--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.itheima.aop&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--aop的自动代理--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:aspectj-autoproxy</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>⑥测试代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringJUnit4ClassRunner.class)</span></span><br><span class="line"><span class="meta">@ContextConfiguration(&quot;classpath:applicationContext.xml&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AopTest</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> TargetInterface target;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">        target.method();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="注解配置-AOP-详解"><a href="#注解配置-AOP-详解" class="headerlink" title="注解配置 AOP 详解"></a>注解配置 AOP 详解</h4><h5 id="1-注解通知的类型"><a href="#1-注解通知的类型" class="headerlink" title="1) 注解通知的类型"></a>1) 注解通知的类型</h5><p>通知的配置语法：@通知注解(“切点表达式”)</p>
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-xA0CPAja-1628212818070)(G:\PMY\专业资料\SSM\03-就业课(2.1)]-Spring\day03_ AOP简介\笔记\img\图片7.png)</p>
<h5 id="2-切点表达式的抽取"><a href="#2-切点表达式的抽取" class="headerlink" title="2) 切点表达式的抽取"></a>2) 切点表达式的抽取</h5><p>同 xml配置<br>aop 一样，我们可以将切点表达式抽取。抽取方式是在切面内定义方法，在该方法上使用@Pointcut注解定义切点表达式，然后在在增强注解中进行引用。具体如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component(&quot;myAspect&quot;)</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAspect</span> &#123;</span><br><span class="line">    <span class="meta">@Before(&quot;MyAspect.myPoint()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;前置代码增强.....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(* com.itheima.aop.*.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">myPoint</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="知识要点-1"><a href="#知识要点-1" class="headerlink" title="知识要点"></a>知识要点</h4><ul>
<li>注解aop开发步骤</li>
</ul>
<p>①使用@Aspect标注切面类</p>
<p>②使用@通知注解标注通知方法</p>
<p>③在配置文件中配置aop自动代理aop:aspectj-autoproxy&#x2F;</p>
<ul>
<li>通知注解类型</li>
</ul>
<h2 id="声明式事务"><a href="#声明式事务" class="headerlink" title="声明式事务"></a>声明式事务</h2><h3 id="编程式事务控制相关对象"><a href="#编程式事务控制相关对象" class="headerlink" title="编程式事务控制相关对象"></a>编程式事务控制相关对象</h3><p><strong>PlatformTransactionManager</strong></p>
<p>PlatformTransactionManager 接口是 spring 的事务管理器，它里面提供了我们常用的操作事务的方法。</p>
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-xBssHLjq-1628212818072)(G:\PMY\专业资料\SSM\03-就业课(2.1)]-Spring\day04_ JdbcTemplate基本使用\笔记\img\2.png)</p>
<p>注意：</p>
<p>PlatformTransactionManager 是接口类型，不同的 Dao 层技术则有不同的实现类，例如：Dao 层技术是jdbc 或 mybatis 时：org.springframework.jdbc.datasource.DataSourceTransactionManager</p>
<p>Dao 层技术是hibernate时：org.springframework.orm.hibernate5.HibernateTransactionManager</p>
<p><strong>TransactionDefinition</strong></p>
<p>TransactionDefinition 是事务的定义信息对象，里面有如下方法：</p>
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-QWm8Sf5J-1628212818072)(G:\PMY\专业资料\SSM\03-就业课(2.1)]-Spring\day04_ JdbcTemplate基本使用\笔记\img\3.png)</p>
<h3 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h3><p>设置隔离级别，可以解决事务并发产生的问题，如脏读、不可重复读和虚读。</p>
<ul>
<li>ISOLATION_DEFAULT</li>
<li>ISOLATION_READ_UNCOMMITTED</li>
<li>ISOLATION_READ_COMMITTED</li>
<li>ISOLATION_REPEATABLE_READ</li>
<li>ISOLATION_SERIALIZABLE</li>
</ul>
<h3 id="事务传播行为"><a href="#事务传播行为" class="headerlink" title="事务传播行为"></a>事务传播行为</h3><ul>
<li><strong>REQUIRED：如果当前没有事务，就新建一个事务，如果已经存在一个事务中，加入到这个事务中。一般的选择（默认值）</strong></li>
<li><strong>SUPPORTS：支持当前事务，如果当前没有事务，就以非事务方式执行（没有事务）</strong></li>
<li>MANDATORY：使用当前的事务，如果当前没有事务，就抛出异常</li>
<li>REQUERS_NEW：新建事务，如果当前在事务中，把当前事务挂起。</li>
<li>NOT_SUPPORTED：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起</li>
<li>NEVER：以非事务方式运行，如果当前存在事务，抛出异常</li>
<li>NESTED：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行 REQUIRED 类似的操作</li>
<li>超时时间：默认值是-1，没有超时限制。如果有，以秒为单位进行设置</li>
<li>是否只读：建议查询时设置为只读</li>
</ul>
<h3 id="TransactionStatus"><a href="#TransactionStatus" class="headerlink" title="TransactionStatus"></a>TransactionStatus</h3><p>TransactionStatus 接口提供的是事务具体的运行状态，方法介绍如下。</p>
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-hP19zQoC-1628212818073)(G:\PMY\专业资料\SSM\03-就业课(2.1)]-Spring\day04_ JdbcTemplate基本使用\笔记\img\4.png)</p>
<h3 id="知识要点-2"><a href="#知识要点-2" class="headerlink" title="知识要点"></a>知识要点</h3><p>编程式事务控制三大对象</p>
<ul>
<li>PlatformTransactionManager</li>
<li>TransactionDefinition</li>
<li>TransactionStatus</li>
</ul>
<h3 id="基于-XML-的声明式事务控制"><a href="#基于-XML-的声明式事务控制" class="headerlink" title="基于 XML 的声明式事务控制"></a>基于 XML 的声明式事务控制</h3><h4 id="声明式事务控制的实现"><a href="#声明式事务控制的实现" class="headerlink" title="声明式事务控制的实现"></a>声明式事务控制的实现</h4><p>声明式事务底层就是AOP</p>
<p>声明式事务控制明确事项：</p>
<ul>
<li>谁是切点？</li>
<li>谁是通知？</li>
<li>配置切面？</li>
</ul>
<p>①引入tx命名空间</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:tx</span>=<span class="string">&quot;http://www.springframework.org/schema/tx&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="string"><span class="tag">                           http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">                           http://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">                           http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="string"><span class="tag">                           http://www.springframework.org/schema/aop/spring-aop.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">                           http://www.springframework.org/schema/tx </span></span></span><br><span class="line"><span class="string"><span class="tag">                           http://www.springframework.org/schema/tx/spring-tx.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">                           http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">                           http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>②配置事务增强</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--平台事务管理器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transactionManager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--事务增强配置--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">&quot;txAdvice&quot;</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;transactionManager&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;*&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>③配置事务 AOP 织入</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--事务的aop增强--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;myPointcut&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* com.itheima.service.impl.*.*(..))&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">&quot;txAdvice&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;myPointcut&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:advisor</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>④测试事务控制转账业务代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(String outMan, String inMan, <span class="type">double</span> money)</span> &#123;</span><br><span class="line">    accountDao.out(outMan,money);</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>/<span class="number">0</span>;</span><br><span class="line">    accountDao.in(inMan,money);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="切点方法的事务参数的配置"><a href="#切点方法的事务参数的配置" class="headerlink" title="切点方法的事务参数的配置"></a>切点方法的事务参数的配置</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--事务增强配置--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">&quot;txAdvice&quot;</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;transactionManager&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;*&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>其中，tx:method 代表切点方法的事务参数的配置，例如：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;transfer&quot;</span> <span class="attr">isolation</span>=<span class="string">&quot;REPEATABLE_READ&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;REQUIRED&quot;</span> <span class="attr">timeout</span>=<span class="string">&quot;-1&quot;</span> <span class="attr">read-only</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>name：切点方法名称</li>
<li>isolation:事务的隔离级别</li>
<li>propogation：事务的传播行为</li>
<li>timeout：超时时间</li>
<li>read-only：是否只读</li>
</ul>
<h4 id="知识要点-3"><a href="#知识要点-3" class="headerlink" title="知识要点"></a>知识要点</h4><p><strong>声明式事务控制的配置要点</strong></p>
<ul>
<li>平台事务管理器配置</li>
<li>事务通知的配置</li>
<li>事务aop织入的配置</li>
</ul>
<h3 id="基于注解的声明式事务控制"><a href="#基于注解的声明式事务控制" class="headerlink" title="基于注解的声明式事务控制"></a>基于注解的声明式事务控制</h3><h4 id="使用注解配置声明式事务控制"><a href="#使用注解配置声明式事务控制" class="headerlink" title="使用注解配置声明式事务控制"></a>使用注解配置声明式事务控制</h4><ol>
<li>编写 AccoutDao</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Repository(&quot;accountDao&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">AccountDao</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JdbcTemplate jdbcTemplate;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">out</span><span class="params">(String outMan, <span class="type">double</span> money)</span> &#123;</span><br><span class="line">        jdbcTemplate.update(<span class="string">&quot;update account set money=money-@ where name=@&quot;</span>,money,outMan);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">in</span><span class="params">(String inMan, <span class="type">double</span> money)</span> &#123;</span><br><span class="line">        jdbcTemplate.update(<span class="string">&quot;update account set money=money+@ where name=@&quot;</span>,money,inMan);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>编写 AccoutService</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service(&quot;accountService&quot;)</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">AccountService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AccountDao accountDao;</span><br><span class="line">    <span class="meta">@Transactional(isolation = Isolation.READ_COMMITTED,propagation = Propagation.REQUIRED)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(String outMan, String inMan, <span class="type">double</span> money)</span> &#123;</span><br><span class="line">        accountDao.out(outMan,money);</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>/<span class="number">0</span>;</span><br><span class="line">        accountDao.in(inMan,money);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>编写 applicationContext.xml 配置文件</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">&lt;!—之前省略datsSource、jdbcTemplate、平台事务管理器的配置--&gt;</span><br><span class="line"><span class="comment">&lt;!--组件扫描--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.itheima&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--事务的注解驱动--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:annotation-driven</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="注解配置声明式事务控制解析"><a href="#注解配置声明式事务控制解析" class="headerlink" title="注解配置声明式事务控制解析"></a>注解配置声明式事务控制解析</h4><p>①使用 @Transactional 在需要进行事务控制的类或是方法上修饰，注解可用的属性同 xml 配置方式，例如隔离级别、传播行为等。</p>
<p>②注解使用在类上，那么该类下的所有方法都使用同一套注解参数配置。</p>
<p>③使用在方法上，不同的方法可以采用不同的事务参数配置。</p>
<p>④Xml配置文件中要开启事务的注解驱动&lt;tx:annotation-driven &#x2F;&gt;</p>
<h4 id="知识要点-4"><a href="#知识要点-4" class="headerlink" title="知识要点"></a>知识要点</h4><p><strong>注解声明式事务控制的配置要点</strong></p>
<ul>
<li>平台事务管理器配置（xml方式）</li>
<li>事务通知的配置（@Transactional注解配置）</li>
<li>事务注解驱动的配置 tx:annotation-driven&#x2F;</li>
</ul>
<h1 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h1><h2 id="Spring与Web环境集成"><a href="#Spring与Web环境集成" class="headerlink" title="Spring与Web环境集成"></a>Spring与Web环境集成</h2><h3 id="ApplicationContext应用上下文获取方式"><a href="#ApplicationContext应用上下文获取方式" class="headerlink" title="ApplicationContext应用上下文获取方式"></a>ApplicationContext应用上下文获取方式</h3><p>应用上下文对象是通过new ClasspathXmlApplicationContext(spring配置文件) 方式获取的，但是每次从容器中获得Bean时都要编写new ClasspathXmlApplicationContext(spring配置文件) ，这样的弊端是配置文件加载多次，应用上下文对象创建多次。</p>
<p>在Web项目中，可以使用ServletContextListener监听Web应用的启动，我们可以在Web应用启动时，就加载Spring的配置文件，创建应用上下文对象ApplicationContext，在将其存储到最大的域servletContext域中，这样就可以在任意位置从域中获得应用上下文ApplicationContext对象了。</p>
<h3 id="Spring提供获取应用上下文的工具"><a href="#Spring提供获取应用上下文的工具" class="headerlink" title="Spring提供获取应用上下文的工具"></a>Spring提供获取应用上下文的工具</h3><p>上面的分析不用手动实现，Spring提供了一个监听器ContextLoaderListener就是对上述功能的封装，该监听器内部加载Spring配置文件，创建应用上下文对象，并存储到ServletContext域中，提供了一个客户端工具WebApplicationContextUtils供使用者获得应用上下文对象。</p>
<p>所以我们需要做的只有两件事：</p>
<p>①在web.xml中配置ContextLoaderListener监听器（导入spring-web坐标）</p>
<p>②使用WebApplicationContextUtils获得应用上下文对象ApplicationContext</p>
<h3 id="导入Spring集成web的坐标"><a href="#导入Spring集成web的坐标" class="headerlink" title="导入Spring集成web的坐标"></a>导入Spring集成web的坐标</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.0.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="配置ContextLoaderListener监听器"><a href="#配置ContextLoaderListener监听器" class="headerlink" title="配置ContextLoaderListener监听器"></a>配置ContextLoaderListener监听器</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--全局参数--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:applicationContext.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--Spring的监听器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">listener-class</span>&gt;</span></span><br><span class="line">       org.springframework.web.context.ContextLoaderListener</span><br><span class="line">   <span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="通过工具获得应用上下文对象"><a href="#通过工具获得应用上下文对象" class="headerlink" title="通过工具获得应用上下文对象"></a>通过工具获得应用上下文对象</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span>    </span><br><span class="line">    WebApplicationContextUtils.getWebApplicationContext(servletContext);</span><br><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> applicationContext.getBean(<span class="string">&quot;id&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><strong>知识要点</strong></p>
<p>Spring集成web环境步骤</p>
<p>@ ①配置ContextLoaderListener监听器</p>
<p>@ ②使用WebApplicationContextUtils获得应用上下文</p>
<h2 id="SpringMVC的简介"><a href="#SpringMVC的简介" class="headerlink" title="SpringMVC的简介"></a>SpringMVC的简介</h2><h3 id="Spring开发步骤"><a href="#Spring开发步骤" class="headerlink" title="Spring开发步骤"></a>Spring开发步骤</h3><p>需求：客户端发起请求，服务器端接收请求，执行逻辑并进行视图跳转。</p>
<p><strong>开发步骤</strong></p>
<p>①导入Spring和SpringMVC的坐标、导入Servlet和Jsp的坐标</p>
<p>②在web.xml配置SpringMVC的核心控制器</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">        org.springframework.web.servlet.DispatcherServlet</span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--springmvc的配置文件--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:spring-mvc.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    	<span class="comment">&lt;!--服务器已启动就开始--&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span>   </span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>③创建Controller和业务方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QuickController</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">quickMethod</span><span class="params">()</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;quickMethod running.....&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;index&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>③创建视图页面index.jsp</p>
<p>④配置注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QuickController</span> &#123;</span><br><span class="line">	<span class="meta">@RequestMapping(&quot;/quick&quot;)</span></span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">quickMethod</span><span class="params">()</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;quickMethod running.....&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="string">&quot;index&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>⑤创建spring-mvc.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span>  </span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:mvc</span>=<span class="string">&quot;http://www.springframework.org/schema/mvc&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans </span></span></span><br><span class="line"><span class="string"><span class="tag">    http://www.springframework.org/schema/beans/spring-beans.xsd </span></span></span><br><span class="line"><span class="string"><span class="tag">    http://www.springframework.org/schema/mvc   </span></span></span><br><span class="line"><span class="string"><span class="tag">    http://www.springframework.org/schema/mvc/spring-mvc.xsd  </span></span></span><br><span class="line"><span class="string"><span class="tag">    http://www.springframework.org/schema/context   </span></span></span><br><span class="line"><span class="string"><span class="tag">    http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置注解扫描--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.itheima&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>⑥访问测试地址</p>
<h3 id="SpringMVC流程图示"><a href="#SpringMVC流程图示" class="headerlink" title="SpringMVC流程图示"></a>SpringMVC流程图示</h3><p>步骤</p>
<p><img src="/2022/09/26/ssm%E5%AD%A6%E4%B9%A0/202209262040151073.png" alt="在这里插入图片描述"></p>
<p>代码角度的访问流程<br>在这里插入图片描述</p>
<h3 id="知识要点-5"><a href="#知识要点-5" class="headerlink" title="知识要点"></a>知识要点</h3><p>SpringMVC的开发步骤</p>
<p>①导入SpringMVC相关坐标</p>
<p>②配置SpringMVC核心控制器DispathcerServlet</p>
<p>③创建Controller类和视图页面</p>
<p>④使用注解配置Controller类中业务方法的映射地址</p>
<p>⑤配置SpringMVC核心文件 spring-mvc.xml</p>
<p>⑥客户端发起请求测试</p>
<h2 id="SpringMVC的组件解析"><a href="#SpringMVC的组件解析" class="headerlink" title="SpringMVC的组件解析"></a>SpringMVC的组件解析</h2><h3 id="SpringMVC的执行流程"><a href="#SpringMVC的执行流程" class="headerlink" title="SpringMVC的执行流程"></a>SpringMVC的执行流程</h3><p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-gfgLzbyJ-1628212818075)(C:\Users\PMY\AppData\Roaming\Typora\typora-user-images\image-20210427105735495.png)]</p>
<p>①用户发送请求至前端控制器DispatcherServlet。</p>
<p>②DispatcherServlet收到请求调用HandlerMapping处理器映射器。</p>
<p>③处理器映射器找到具体的处理器(可以根据xml配置、注解进行查找)，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet。</p>
<p>④DispatcherServlet调用HandlerAdapter处理器适配器。</p>
<p>⑤HandlerAdapter经过适配调用具体的处理器(Controller，也叫后端控制器)。</p>
<p>⑥Controller执行完成返回ModelAndView。</p>
<p>⑦HandlerAdapter将controller执行结果ModelAndView返回给DispatcherServlet。</p>
<p>⑧DispatcherServlet将ModelAndView传给ViewReslover视图解析器。</p>
<p>⑨ViewReslover解析后返回具体View。</p>
<p>⑩DispatcherServlet根据View进行渲染视图（即将模型数据填充至视图中）。DispatcherServlet响应用户。</p>
<h3 id="SpringMVC组件解析"><a href="#SpringMVC组件解析" class="headerlink" title="SpringMVC组件解析"></a>SpringMVC组件解析</h3><ol>
<li><strong>前端控制器：DispatcherServlet</strong></li>
</ol>
<p>@ 用户请求到达前端控制器，它就相当于 MVC 模式中的 C，DispatcherServlet 是整个流程控制的中心，由它调用其它组件处理用户的请求，DispatcherServlet 的存在降低了组件之间的耦合性。</p>
<ol>
<li><strong>处理器映射器：HandlerMapping</strong></li>
</ol>
<p>@ HandlerMapping 负责根据用户请求找到 Handler 即处理器，SpringMVC 提供了不同的映射器实现不同的映射方式，例如：配置文件方式，实现接口方式，注解方式等。</p>
<ol>
<li><strong>处理器适配器：HandlerAdapter</strong></li>
</ol>
<p>@ 通过 HandlerAdapter 对处理器进行执行，这是适配器模式的应用，通过扩展适配器可以对更多类型的处理器进行执行。</p>
<ol>
<li><strong>处理器：Handler</strong></li>
</ol>
<p>@ 它就是我们开发中要编写的具体业务控制器。由 DispatcherServlet 把用户请求转发到 Handler。由Handler 对具体的用户请求进行处理。</p>
<ol>
<li><strong>视图解析器：View Resolver</strong></li>
</ol>
<p>@ View Resolver 负责将处理结果生成 View 视图，View Resolver 首先根据逻辑视图名解析成物理视图名，即具体的页面地址，再生成 View 视图对象，最后对 View 进行渲染将处理结果通过页面展示给用户。</p>
<ol>
<li><strong>视图：View</strong></li>
</ol>
<p>@ SpringMVC 框架提供了很多的 View 视图类型的支持，包括：jstlView、freemarkerView、pdfView等。最常用的视图就是 jsp。一般情况下需要通过页面标签或页面模版技术将模型数据通过页面展示给用户，需要由程序员根据业务需求开发具体的页面</p>
<h3 id="SpringMVC注解解析"><a href="#SpringMVC注解解析" class="headerlink" title="SpringMVC注解解析"></a>SpringMVC注解解析</h3><p>@RequestMapping</p>
<p>作用：用于建立请求 URL 和处理请求方法之间的对应关系</p>
<p>位置：</p>
<p>@类上，请求URL 的第一级访问目录。此处不写的话，就相当于应用的根目录</p>
<p>@ 方法上，请求 URL 的第二级访问目录，与类上的使用@RequestMapping标注的一级目录一起组成访问虚拟路径</p>
<p>属性：</p>
<p>@ value：用于指定请求的URL。它和path属性的作用是一样的</p>
<p>@ method：用于指定请求的方式</p>
<p>@ params：用于指定限制请求参数的条件。它支持简单的表达式。要求请求参数的key和value必须和配置的一模一样</p>
<p>例如：</p>
<p>@ params &#x3D; {“accountName”}，表示请求参数必须有accountName</p>
<p>@ params &#x3D; {“moeny!100”}，表示请求参数中money不能是100</p>
<p>1.mvc命名空间引入</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">命名空间：xmlns:context=&quot;http://www.springframework.org/schema/context&quot;</span><br><span class="line">        xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;</span><br><span class="line">约束地址：http://www.springframework.org/schema/context</span><br><span class="line">        http://www.springframework.org/schema/context/spring-context.xsd</span><br><span class="line">        http://www.springframework.org/schema/mvc </span><br><span class="line">        http://www.springframework.org/schema/mvc/spring-mvc.xsd</span><br></pre></td></tr></table></figure>

<p>组件扫描</p>
<p>SpringMVC基于Spring容器，所以在进行SpringMVC操作时，需要将Controller存储到Spring容器中，如果使用@Controller注解标注的话，就需要使用&lt;context:component-scan base-package&#x3D;“com.itheima.controller”&#x2F;&gt;进行组件扫描。</p>
<h3 id="SpringMVC的XML配置解析"><a href="#SpringMVC的XML配置解析" class="headerlink" title="SpringMVC的XML配置解析"></a>SpringMVC的XML配置解析</h3><p>SpringMVC有默认组件配置，默认组件都是DispatcherServlet.properties配置文件中配置的，该配置文件地址org&#x2F;springframework&#x2F;web&#x2F;servlet&#x2F;DispatcherServlet.properties，该文件中配置了默认的视图解析器，如下：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">org.springframework.web.servlet.ViewResolver</span>=<span class="string">org.springframework.web.servlet.view.InternalResourceViewResolver</span></span><br></pre></td></tr></table></figure>

<p>翻看该解析器源码，可以看到该解析器的默认设置，如下：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">REDIRECT_URL_PREFIX</span> = <span class="string">&quot;redirect:&quot;  --重定向前缀</span></span><br><span class="line"><span class="attr">FORWARD_URL_PREFIX</span> = <span class="string">&quot;forward:&quot;    --转发前缀（默认值）</span></span><br><span class="line"><span class="attr">prefix</span> = <span class="string">&quot;&quot;;     --视图名称前缀</span></span><br><span class="line"><span class="attr">suffix</span> = <span class="string">&quot;&quot;;     --视图名称后缀</span></span><br></pre></td></tr></table></figure>

<ol>
<li>视图解析器</li>
</ol>
<p>我们可以通过属性注入的方式修改视图的的前后缀</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置内部资源视图解析器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;prefix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/WEB-INF/views/&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suffix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;.jsp&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="知识要点-6"><a href="#知识要点-6" class="headerlink" title="知识要点"></a>知识要点</h3><p><strong>SpringMVC的相关组件</strong></p>
<p>前端控制器：DispatcherServlet</p>
<p>处理器映射器：HandlerMapping</p>
<p>处理器适配器：HandlerAdapter</p>
<p>处理器：Handler</p>
<p>视图解析器：View Resolver</p>
<p>视图：View</p>
<p><strong>SpringMVC的注解和配置</strong></p>
<p>请求映射注解：@RequestMapping</p>
<p>视图解析器配置：</p>
<p>REDIRECT_URL_PREFIX &#x3D; “redirect:”</p>
<p>FORWARD_URL_PREFIX &#x3D; “forward:”</p>
<p>prefix &#x3D; “”;</p>
<p>suffix &#x3D; “”;</p>
<h2 id="SpringMVC的数据响应"><a href="#SpringMVC的数据响应" class="headerlink" title="SpringMVC的数据响应"></a>SpringMVC的数据响应</h2><h3 id="SpringMVC的数据响应-数据响应方式-理解"><a href="#SpringMVC的数据响应-数据响应方式-理解" class="headerlink" title="SpringMVC的数据响应-数据响应方式(理解)"></a>SpringMVC的数据响应-数据响应方式(理解)</h3><ol>
<li>页面跳转</li>
</ol>
<p>直接返回字符串</p>
<p>通过ModelAndView对象返回</p>
<p>2） 回写数据</p>
<p>直接返回字符串</p>
<p>返回对象或集合</p>
<h3 id="SpringMVC的数据响应-页面跳转-返回字符串形式（应用）"><a href="#SpringMVC的数据响应-页面跳转-返回字符串形式（应用）" class="headerlink" title="SpringMVC的数据响应-页面跳转-返回字符串形式（应用）"></a>SpringMVC的数据响应-页面跳转-返回字符串形式（应用）</h3><p><img src="/2022/09/26/ssm%E5%AD%A6%E4%B9%A0/202209262040151266.png" alt="在这里插入图片描述"></p>
<h3 id="SpringMVC的数据响应-页面跳转-返回ModelAndView形式1-应用"><a href="#SpringMVC的数据响应-页面跳转-返回ModelAndView形式1-应用" class="headerlink" title="SpringMVC的数据响应-页面跳转-返回ModelAndView形式1(应用)"></a>SpringMVC的数据响应-页面跳转-返回ModelAndView形式1(应用)</h3><p>在Controller中方法返回ModelAndView对象，并且设置视图名称</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value=&quot;/quick2&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ModelAndView <span class="title function_">save2</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">            Model:模型 作用封装数据</span></span><br><span class="line"><span class="comment">            View：视图 作用展示数据</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    <span class="type">ModelAndView</span> <span class="variable">modelAndView</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ModelAndView</span>();</span><br><span class="line">    <span class="comment">//设置模型数据</span></span><br><span class="line">    modelAndView.addObject(<span class="string">&quot;username&quot;</span>,<span class="string">&quot;itcast&quot;</span>);</span><br><span class="line">    <span class="comment">//设置视图名称</span></span><br><span class="line">    modelAndView.setViewName(<span class="string">&quot;success&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> modelAndView;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="SpringMVC的数据响应-页面跳转-返回ModelAndView形式2-应用"><a href="#SpringMVC的数据响应-页面跳转-返回ModelAndView形式2-应用" class="headerlink" title="SpringMVC的数据响应-页面跳转-返回ModelAndView形式2(应用)"></a>SpringMVC的数据响应-页面跳转-返回ModelAndView形式2(应用)</h3><p>n在Controller中方法形参上直接声明ModelAndView，无需在方法中自己创建，在方法中直接使用该对象设置视图，同样可以跳转页面</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value=&quot;/quick3&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ModelAndView <span class="title function_">save3</span><span class="params">(ModelAndView modelAndView)</span>&#123;</span><br><span class="line">    modelAndView.addObject(<span class="string">&quot;username&quot;</span>,<span class="string">&quot;itheima&quot;</span>);</span><br><span class="line">    modelAndView.setViewName(<span class="string">&quot;success&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> modelAndView;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@RequestMapping(value=&quot;/quick4&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">save4</span><span class="params">(Model model)</span>&#123;</span><br><span class="line">    model.addAttribute(<span class="string">&quot;username&quot;</span>,<span class="string">&quot;博学谷&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="SpringMVC的数据响应-页面跳转-返回ModelAndView3-应用"><a href="#SpringMVC的数据响应-页面跳转-返回ModelAndView3-应用" class="headerlink" title="SpringMVC的数据响应-页面跳转-返回ModelAndView3(应用)"></a>SpringMVC的数据响应-页面跳转-返回ModelAndView3(应用)</h3><p>在Controller方法的形参上可以直接使用原生的HttpServeltRequest对象，只需声明即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value=&quot;/quick5&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">save5</span><span class="params">(HttpServletRequest request)</span>&#123;</span><br><span class="line">    request.setAttribute(<span class="string">&quot;username&quot;</span>,<span class="string">&quot;酷丁鱼&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="SpringMVC的数据响应-回写数据-直接回写字符串-应用"><a href="#SpringMVC的数据响应-回写数据-直接回写字符串-应用" class="headerlink" title="SpringMVC的数据响应-回写数据-直接回写字符串(应用)"></a>SpringMVC的数据响应-回写数据-直接回写字符串(应用)</h3><p>通过SpringMVC框架注入的response对象，使用response.getWriter().print(“hello world”) 回写数据，此时不需要视图跳转，业务方法返回值为void</p>
<p>将需要回写的字符串直接返回，但此时需要通过@ResponseBody注解告知SpringMVC框架，方法返回的字符串不是跳转是直接在http响应体中返回</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value=&quot;/quick7&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span>  <span class="comment">//告知SpringMVC框架 不进行视图跳转 直接进行数据响应</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">save7</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hello itheima&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping(value=&quot;/quick6&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save6</span><span class="params">(HttpServletResponse response)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    response.getWriter().print(<span class="string">&quot;hello itcast&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="SpringMVC的数据响应-回写数据-直接回写json格式字符串-应用"><a href="#SpringMVC的数据响应-回写数据-直接回写json格式字符串-应用" class="headerlink" title="SpringMVC的数据响应-回写数据-直接回写json格式字符串(应用)"></a>SpringMVC的数据响应-回写数据-直接回写json格式字符串(应用)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value=&quot;/quick8&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">save8</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&#123;\&quot;username\&quot;:\&quot;zhangsan\&quot;,\&quot;age\&quot;:18&#125;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>手动拼接json格式字符串的方式很麻烦，开发中往往要将复杂的java对象转换成json格式的字符串，我们可以使用web阶段学习过的json转换工具jackson进行转换,通过jackson转换json格式字符串，回写字符串</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value=&quot;/quick9&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">save9</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    user.setUsername(<span class="string">&quot;lisi&quot;</span>);</span><br><span class="line">    user.setAge(<span class="number">30</span>);</span><br><span class="line">    <span class="comment">//使用json的转换工具将对象转换成json格式字符串在返回</span></span><br><span class="line">    <span class="type">ObjectMapper</span> <span class="variable">objectMapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line">    <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> objectMapper.writeValueAsString(user);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> json;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="SpringMVC的数据响应-回写数据-返回对象或集合-应用"><a href="#SpringMVC的数据响应-回写数据-返回对象或集合-应用" class="headerlink" title="SpringMVC的数据响应-回写数据-返回对象或集合(应用)"></a>SpringMVC的数据响应-回写数据-返回对象或集合(应用)</h3><p>通过SpringMVC帮助我们对对象或集合进行json字符串的转换并回写，为处理器适配器配置消息转换参数，指定使用jackson进行对象或集合的转换，因此需要在spring-mvc.xml中进行如下配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;messageConverters&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.http.converter.json.MappingJackson2HttpMessageConverter&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">@RequestMapping(value=&quot;/quick10&quot;)</span><br><span class="line">    @ResponseBody</span><br><span class="line">    //期望SpringMVC自动将User转换成json格式的字符串</span><br><span class="line">    public User save10() throws IOException &#123;</span><br><span class="line">        User user = new User();</span><br><span class="line">        user.setUsername(&quot;lisi2&quot;);</span><br><span class="line">        user.setAge(32);</span><br><span class="line">        return user;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="SpringMVC的数据响应-回写数据-返回对象或集合2-应用"><a href="#SpringMVC的数据响应-回写数据-返回对象或集合2-应用" class="headerlink" title="SpringMVC的数据响应-回写数据-返回对象或集合2(应用)"></a>SpringMVC的数据响应-回写数据-返回对象或集合2(应用)</h3><p>在方法上添加@ResponseBody就可以返回json格式的字符串，但是这样配置比较麻烦，配置的代码比较多，因此，我们可以使用mvc的注解驱动代替上述配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>在 SpringMVC 的各个组件中，处理器映射器、处理器适配器、视图解析器称为 SpringMVC 的三大组件。</p>
<p>使用<code>&lt;mvc:annotation-driven /&gt;</code>自动加载 RequestMapping、HandlerMapping（处理映射器）和RequestMappingHandlerAdapter（ 处 理 适 配 器 ），可用在Spring-xml.xml配置文件中使用<code>&lt;mvc:annotation-driven /&gt;</code>替代注解处理器和适配器的配置。</p>
<p>同时使用<code>&lt;mvc:annotation-driven /&gt;</code></p>
<p>默认底层就会集成jackson进行对象或集合的json格式字符串的转换</p>
<h3 id="SpringMVC的数据响应-知识要点小结-理解，记忆"><a href="#SpringMVC的数据响应-知识要点小结-理解，记忆" class="headerlink" title="SpringMVC的数据响应-知识要点小结(理解，记忆)"></a>SpringMVC的数据响应-知识要点小结(理解，记忆)</h3><p>1） 页面跳转</p>
<p>直接返回字符串</p>
<p>通过ModelAndView对象返回</p>
<p>2） 回写数据</p>
<p>直接返回字符串</p>
<p>HttpServletResponse 对象直接写回数据，HttpServletRequest对象带回数据，Model对象带回数据或者@ResponseBody将字符串数据写回</p>
<p>返回对象或集合</p>
<p>@ResponseBody+<code>&lt;mvc:annotation-driven/&gt;</code></p>
<h2 id="SpringMVC的请求"><a href="#SpringMVC的请求" class="headerlink" title="SpringMVC的请求"></a>SpringMVC的请求</h2><h3 id="SpringMVC的请求-获得请求参数-请求参数类型-理解"><a href="#SpringMVC的请求-获得请求参数-请求参数类型-理解" class="headerlink" title="SpringMVC的请求-获得请求参数-请求参数类型(理解)"></a>SpringMVC的请求-获得请求参数-请求参数类型(理解)</h3><p>客户端请求参数的格式是：name&#x3D;value&amp;name&#x3D;value……</p>
<p>服务器端要获得请求的参数，有时还需要进行数据的封装，SpringMVC可以接收如下类型的参数</p>
<p>基本类型参数</p>
<p>POJO类型参数</p>
<p>数组类型参数</p>
<p>集合类型参数</p>
<h3 id="SpringMVC的请求-获得请求参数-获得基本类型参数-应用"><a href="#SpringMVC的请求-获得请求参数-获得基本类型参数-应用" class="headerlink" title="SpringMVC的请求-获得请求参数-获得基本类型参数(应用)"></a>SpringMVC的请求-获得请求参数-获得基本类型参数(应用)</h3><p>Controller中的业务方法的参数名称要与请求参数的name一致，参数值会自动映射匹配。并且能自动做类型转换；</p>
<p>自动的类型转换是指从String向其他类型的转换</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">http:<span class="comment">//localhost:8080/itheima_springmvc1/quick9@username=zhangsan&amp;age=12</span></span><br><span class="line"><span class="meta">@RequestMapping(value=&quot;/quick11&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save11</span><span class="params">(String username,<span class="type">int</span> age)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    System.out.println(username);</span><br><span class="line">    System.out.println(age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="SpringMVC的请求-获得请求参数-获得POJO类型参数-应用"><a href="#SpringMVC的请求-获得请求参数-获得POJO类型参数-应用" class="headerlink" title="SpringMVC的请求-获得请求参数-获得POJO类型参数(应用)"></a>SpringMVC的请求-获得请求参数-获得POJO类型参数(应用)</h3><p>Controller中的业务方法的POJO参数的属性名与请求参数的name一致，参数值会自动映射匹配。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.domain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getUsername</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUsername</span><span class="params">(String username)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.username = username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;User&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;username=&#x27;&quot;</span> + username + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@RequestMapping(value=&quot;/quick12&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save12</span><span class="params">(User user)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="SpringMVC的请求-获得请求参数-获得数组类型参数-应用"><a href="#SpringMVC的请求-获得请求参数-获得数组类型参数-应用" class="headerlink" title="SpringMVC的请求-获得请求参数-获得数组类型参数(应用)"></a>SpringMVC的请求-获得请求参数-获得数组类型参数(应用)</h3><p>Controller中的业务方法数组名称与请求参数的name一致，参数值会自动映射匹配。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value=&quot;/quick13&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save13</span><span class="params">(String[] strs)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        System.out.println(Arrays.asList(strs));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="SpringMVC的请求-获得请求参数-获得集合类型参数1-应用"><a href="#SpringMVC的请求-获得请求参数-获得集合类型参数1-应用" class="headerlink" title="SpringMVC的请求-获得请求参数-获得集合类型参数1(应用)"></a>SpringMVC的请求-获得请求参数-获得集合类型参数1(应用)</h3><p>获得集合参数时，要将集合参数包装到一个POJO中才可以。</p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;form action=<span class="string">&quot;$&#123;pageContext.request.contextPath&#125;/user/quick14&quot;</span> method=<span class="string">&quot;post&quot;</span>&gt;</span><br><span class="line">        &lt;%--表明是第一个User对象的username age--%&gt;</span><br><span class="line">        &lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;userList[0].username&quot;</span>&gt;&lt;br/&gt;</span><br><span class="line">        &lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;userList[0].age&quot;</span>&gt;&lt;br/&gt;</span><br><span class="line">        &lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;userList[1].username&quot;</span>&gt;&lt;br/&gt;</span><br><span class="line">        &lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;userList[1].age&quot;</span>&gt;&lt;br/&gt;</span><br><span class="line">        &lt;input type=<span class="string">&quot;submit&quot;</span> value=<span class="string">&quot;提交&quot;</span>&gt;</span><br><span class="line">    &lt;/form&gt;</span><br><span class="line"><span class="keyword">package</span> com.itheima.domain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VO</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;User&gt; userList;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;User&gt; <span class="title function_">getUserList</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> userList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUserList</span><span class="params">(List&lt;User&gt; userList)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userList = userList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;VO&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;userList=&quot;</span> + userList +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping(value=&quot;/quick14&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save14</span><span class="params">(VO vo)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        System.out.println(vo);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="SpringMVC的请求-获得请求参数-获得集合类型参数2-应用"><a href="#SpringMVC的请求-获得请求参数-获得集合类型参数2-应用" class="headerlink" title="SpringMVC的请求-获得请求参数-获得集合类型参数2(应用)"></a>SpringMVC的请求-获得请求参数-获得集合类型参数2(应用)</h3><p>当使用ajax提交时，可以指定contentType为json形式，那么在方法参数位置使用**@RequestBody**可以直接接收集合数据而无需使用POJO进行包装</p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;script src=<span class="string">&quot;$&#123;pageContext.request.contextPath&#125;/js/jquery-3.3.1.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="type">var</span> <span class="variable">userList</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Array</span>();</span><br><span class="line">    userList.push(&#123;username:<span class="string">&quot;zhangsan&quot;</span>,age:<span class="number">18</span>&#125;);</span><br><span class="line">    userList.push(&#123;username:<span class="string">&quot;lisi&quot;</span>,age:<span class="number">28</span>&#125;);</span><br><span class="line"></span><br><span class="line">    $.ajax(&#123;</span><br><span class="line">        type:<span class="string">&quot;POST&quot;</span>,</span><br><span class="line">        url:<span class="string">&quot;$&#123;pageContext.request.contextPath&#125;/user/quick15&quot;</span>,</span><br><span class="line">        data:JSON.stringify(userList),</span><br><span class="line">        contentType:<span class="string">&quot;application/json;charset=utf-8&quot;</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br><span class="line"><span class="meta">@RequestMapping(value=&quot;/quick15&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save15</span><span class="params">(<span class="meta">@RequestBody</span> List&lt;User&gt; userList)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    System.out.println(userList);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="SpringMVC的请求-获得请求参数-静态资源访问的开启-应用"><a href="#SpringMVC的请求-获得请求参数-静态资源访问的开启-应用" class="headerlink" title="SpringMVC的请求-获得请求参数-静态资源访问的开启(应用)"></a>SpringMVC的请求-获得请求参数-静态资源访问的开启(应用)</h3><p>当有静态资源需要加载时，比如jquery文件，通过谷歌开发者工具抓包发现，没有加载到jquery文件，原因是SpringMVC的前端控制器DispatcherServlet的url-pattern配置的是&#x2F;,代表对所有的资源都进行过滤操作，我们可以通过以下两种方式指定放行静态资源：</p>
<p>@在spring-mvc.xml配置文件中指定放行的资源</p>
<p>@ <code>&lt;mvc:resources mapping=&quot;/js/**&quot;location=&quot;/js/&quot;/&gt;</code></p>
<p>@使用<code>&lt;mvc:default-servlet-handler/&gt;</code>标签</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--开发资源的访问--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--&lt;mvc:resources mapping=&quot;/js/**&quot; location=&quot;/js/&quot;/&gt;</span></span><br><span class="line"><span class="comment">    &lt;mvc:resources mapping=&quot;/img/**&quot; location=&quot;/img/&quot;/&gt;--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:default-servlet-handler</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="SpringMVC的请求-获得请求参数-配置全局乱码过滤器-应用"><a href="#SpringMVC的请求-获得请求参数-配置全局乱码过滤器-应用" class="headerlink" title="SpringMVC的请求-获得请求参数-配置全局乱码过滤器(应用)"></a>SpringMVC的请求-获得请求参数-配置全局乱码过滤器(应用)</h3><p>当post请求时，数据会出现乱码，我们可以设置一个过滤器来进行编码的过滤。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置全局过滤的filter--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span></span><br><span class="line">        org.springframework.web.filter.CharacterEncodingFilter</span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="SpringMVC的请求-获得请求参数-参数绑定注解-RequestParam-应用"><a href="#SpringMVC的请求-获得请求参数-参数绑定注解-RequestParam-应用" class="headerlink" title="SpringMVC的请求-获得请求参数-参数绑定注解@RequestParam(应用)"></a>SpringMVC的请求-获得请求参数-参数绑定注解@RequestParam(应用)</h3><p>当请求的参数名称与Controller的业务方法参数名称不一致时，就需要通过@RequestParam注解显示的绑定</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;$&#123;pageContext.request.contextPath&#125;/quick16&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;提交&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line">12345</span><br><span class="line">@RequestMapping(value=&quot;/quick16&quot;)</span><br><span class="line">    @ResponseBody</span><br><span class="line">    public void save16(@RequestParam(value=&quot;name&quot;,required = false,defaultValue = &quot;itcast&quot;) String username) throws IOException &#123;</span><br><span class="line">        System.out.println(username);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="SpringMVC的请求-获得请求参数-Restful风格的参数的获取-应用"><a href="#SpringMVC的请求-获得请求参数-Restful风格的参数的获取-应用" class="headerlink" title="SpringMVC的请求-获得请求参数-Restful风格的参数的获取(应用)"></a>SpringMVC的请求-获得请求参数-Restful风格的参数的获取(应用)</h3><p>Restful是一种软件架构风格、设计风格，而不是标准，只是提供了一组设计原则和约束条件。主要用于客户端和服务器交互类的软件，基于这个风格设计的软件可以更简洁，更有层次，更易于实现缓存机制等。</p>
<p>Restful风格的请求是使用“url+请求方式”表示一次请求目的的，HTTP 协议里面四个表示操作方式的动词如下：</p>
<p>GET：用于获取资源</p>
<p>POST：用于新建资源</p>
<p>PUT：用于更新资源</p>
<p>DELETE：用于删除资源</p>
<p>例如：</p>
<p>&#x2F;user&#x2F;1 GET ： 得到 id &#x3D; 1 的 user</p>
<p>&#x2F;user&#x2F;1 DELETE： 删除 id &#x3D; 1 的 user</p>
<p>&#x2F;user&#x2F;1 PUT： 更新 id &#x3D; 1 的 user</p>
<p>&#x2F;user POST： 新增 user</p>
<p>上述url地址&#x2F;user&#x2F;1中的1就是要获得的请求参数，在SpringMVC中可以使用占位符进行参数绑定。地址&#x2F;user&#x2F;1可以写成&#x2F;user&#x2F;{id}，占位符{id}对应的就是1的值。在业务方法中我们可以使用@PathVariable注解进行占位符的匹配获取工作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">http:<span class="comment">//localhost:8080/itheima_springmvc1/quick17/zhangsan</span></span><br><span class="line"><span class="meta">@RequestMapping(value=&quot;/quick17/&#123;name&#125;&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save17</span><span class="params">(<span class="meta">@PathVariable(value=&quot;name&quot;)</span> String username)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        System.out.println(username);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h3 id="SpringMVC的请求-获得请求参数-自定义类型转换器-应用"><a href="#SpringMVC的请求-获得请求参数-自定义类型转换器-应用" class="headerlink" title="SpringMVC的请求-获得请求参数-自定义类型转换器(应用)"></a>SpringMVC的请求-获得请求参数-自定义类型转换器(应用)</h3><p>SpringMVC 默认已经提供了一些常用的类型转换器，例如客户端提交的字符串转换成int型进行参数设置。</p>
<p>但是不是所有的数据类型都提供了转换器，没有提供的就需要自定义转换器，例如：日期类型的数据就需要自定义转换器。</p>
<p>还需要在spring-mvc.xml里面配置它</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DateConverter</span> <span class="keyword">implements</span> <span class="title class_">Converter</span>&lt;String, Date&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> Date <span class="title function_">convert</span><span class="params">(String dateStr)</span> &#123;</span><br><span class="line">        <span class="comment">//将日期字符串转换成日期对象 返回</span></span><br><span class="line">        <span class="type">SimpleDateFormat</span> <span class="variable">format</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br><span class="line">        <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            date = format.parse(dateStr);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> date;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping(value=&quot;/quick18&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save18</span><span class="params">(Date date)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    System.out.println(date);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;mvc:annotation-driven conversion-service=<span class="string">&quot;conversionService&quot;</span>/&gt;</span><br></pre></td></tr></table></figure>

<h3 id="SpringMVC的请求-获得请求参数-获得Servlet相关API-应用"><a href="#SpringMVC的请求-获得请求参数-获得Servlet相关API-应用" class="headerlink" title="SpringMVC的请求-获得请求参数-获得Servlet相关API(应用)"></a>SpringMVC的请求-获得请求参数-获得Servlet相关API(应用)</h3><p>SpringMVC支持使用原始ServletAPI对象作为控制器方法的参数进行注入，常用的对象如下：</p>
<p>HttpServletRequest</p>
<p>HttpServletResponse</p>
<p>HttpSession</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value=&quot;/quick19&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save19</span><span class="params">(HttpServletRequest request, HttpServletResponse response, HttpSession session)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        System.out.println(request);</span><br><span class="line">        System.out.println(response);</span><br><span class="line">        System.out.println(session);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="SpringMVC的请求-获得请求参数-获得请求头信息-应用"><a href="#SpringMVC的请求-获得请求参数-获得请求头信息-应用" class="headerlink" title="SpringMVC的请求-获得请求参数-获得请求头信息(应用)"></a>SpringMVC的请求-获得请求参数-获得请求头信息(应用)</h3><p>使用@RequestHeader可以获得请求头信息，相当于web阶段学习的request.getHeader(name)</p>
<p>@RequestHeader注解的属性如下：</p>
<p>value：请求头的名称</p>
<p>required：是否必须携带此请求头</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value=&quot;/quick20&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save20</span><span class="params">(<span class="meta">@RequestHeader(value = &quot;User-Agent&quot;,required = false)</span> String user_agent)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        System.out.println(user_agent);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>使用@CookieValue可以获得指定Cookie的值</p>
<p>@CookieValue注解的属性如下：</p>
<p>value：指定cookie的名称</p>
<p>required：是否必须携带此cookie</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value=&quot;/quick21&quot;)</span></span><br><span class="line">   <span class="meta">@ResponseBody</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save21</span><span class="params">(<span class="meta">@CookieValue(value = &quot;JSESSIONID&quot;)</span> String jsessionId)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">       System.out.println(jsessionId);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h2 id="SpringMVC的文件上传"><a href="#SpringMVC的文件上传" class="headerlink" title="SpringMVC的文件上传"></a>SpringMVC的文件上传</h2><h3 id="SpringMVC文件上传"><a href="#SpringMVC文件上传" class="headerlink" title="SpringMVC文件上传"></a>SpringMVC文件上传</h3><figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;form action=<span class="string">&quot;$&#123;pageContext.request.contextPath&#125;/user/quick22&quot;</span> method=<span class="string">&quot;post&quot;</span> enctype=<span class="string">&quot;multipart/form-data&quot;</span>&gt;</span><br><span class="line">    名称&lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;username&quot;</span>&gt;&lt;br/&gt;</span><br><span class="line">    文件<span class="number">1</span>&lt;input type=<span class="string">&quot;file&quot;</span> name=<span class="string">&quot;uploadFile&quot;</span>&gt;&lt;br/&gt;</span><br><span class="line">    &lt;input type=<span class="string">&quot;submit&quot;</span> value=<span class="string">&quot;提交&quot;</span>&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure>

<h3 id="文件上传的原理"><a href="#文件上传的原理" class="headerlink" title="文件上传的原理"></a>文件上传的原理</h3><p><img src="/ssm/202209262040161772.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(202209262040161772.png)(G:\PMY\专业资料\SSM\04-就业课(2.1)]-SpringMVC\day03_SpringMVC的文件上传\笔记\img\5.jpg)"></p>
<h3 id="单文件上传的代码实现1"><a href="#单文件上传的代码实现1" class="headerlink" title="单文件上传的代码实现1"></a>单文件上传的代码实现1</h3><p>添加依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-fileupload<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-fileupload<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>配置多媒体解析器</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置文件上传解析器--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;multipartResolver&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;defaultEncoding&quot;</span> <span class="attr">value</span>=<span class="string">&quot;UTF-8&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxUploadSize&quot;</span> <span class="attr">value</span>=<span class="string">&quot;500000&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>后台程序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value=&quot;/quick22&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save22</span><span class="params">(String username, MultipartFile uploadFile)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        System.out.println(username);</span><br><span class="line">       	System.out.println(uploadFile);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="单文件上传的代码实现2"><a href="#单文件上传的代码实现2" class="headerlink" title="单文件上传的代码实现2"></a>单文件上传的代码实现2</h3><p>完成文件上传</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value=&quot;/quick22&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save22</span><span class="params">(String username, MultipartFile uploadFile)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        System.out.println(username);</span><br><span class="line">        <span class="comment">//获得上传文件的名称</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">originalFilename</span> <span class="operator">=</span> uploadFile.getOriginalFilename();</span><br><span class="line">        uploadFile.transferTo(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;C:\\upload\\&quot;</span>+originalFilename));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="多文件上传的代码实现"><a href="#多文件上传的代码实现" class="headerlink" title="多文件上传的代码实现"></a>多文件上传的代码实现</h3><p>多文件上传，只需要将页面修改为多个文件上传项，将方法参数MultipartFile类型修改为MultipartFile[]即可</p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;form action=<span class="string">&quot;$&#123;pageContext.request.contextPath&#125;/user/quick23&quot;</span> method=<span class="string">&quot;post&quot;</span> enctype=<span class="string">&quot;multipart/form-data&quot;</span>&gt;</span><br><span class="line">        名称&lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;username&quot;</span>&gt;&lt;br/&gt;</span><br><span class="line">        文件<span class="number">1</span>&lt;input type=<span class="string">&quot;file&quot;</span> name=<span class="string">&quot;uploadFile&quot;</span>&gt;&lt;br/&gt;</span><br><span class="line">        文件<span class="number">2</span>&lt;input type=<span class="string">&quot;file&quot;</span> name=<span class="string">&quot;uploadFile&quot;</span>&gt;&lt;br/&gt;</span><br><span class="line">        &lt;input type=<span class="string">&quot;submit&quot;</span> value=<span class="string">&quot;提交&quot;</span>&gt;</span><br><span class="line">    &lt;/form&gt;</span><br><span class="line"><span class="meta">@RequestMapping(value=&quot;/quick23&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save23</span><span class="params">(String username, MultipartFile[] uploadFile)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        System.out.println(username);</span><br><span class="line">        <span class="keyword">for</span> (MultipartFile multipartFile : uploadFile) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">originalFilename</span> <span class="operator">=</span> multipartFile.getOriginalFilename();</span><br><span class="line">            multipartFile.transferTo(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;C:\\upload\\&quot;</span>+originalFilename));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="SpringMVC的请求-知识要点-理解，记忆"><a href="#SpringMVC的请求-知识要点-理解，记忆" class="headerlink" title="SpringMVC的请求-知识要点(理解，记忆)"></a>SpringMVC的请求-知识要点(理解，记忆)</h3><p><img src="/2022/09/26/ssm%E5%AD%A6%E4%B9%A0/202209262040161851.png" alt="在这里插入图片描述"></p>
<h2 id="SpringMVC的拦截器"><a href="#SpringMVC的拦截器" class="headerlink" title="SpringMVC的拦截器"></a>SpringMVC的拦截器</h2><h3 id="拦截器的作用"><a href="#拦截器的作用" class="headerlink" title="拦截器的作用"></a>拦截器的作用</h3><p>Spring MVC 的拦截器类似于 Servlet 开发中的过滤器 Filter，用于对处理器进行预处理和后处理。</p>
<p>将拦截器按一定的顺序联结成一条链，这条链称为拦截器链（InterceptorChain）。在访问被拦截的方法或字段时，拦截器链中的拦截器就会按其之前定义的顺序被调用。拦截器也是AOP思想的具体实现。</p>
<h3 id="interceptor和filter区别"><a href="#interceptor和filter区别" class="headerlink" title="interceptor和filter区别"></a>interceptor和filter区别</h3><p>关于interceptor和filter的区别，如图所示：</p>
<p><img src="/2022/09/26/ssm%E5%AD%A6%E4%B9%A0/202209262040171865.png" alt="在这里插入图片描述"></p>
<h3 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h3><p>自定义拦截器很简单，只有如下三步：</p>
<p>①创建拦截器类实现HandlerInterceptor接口</p>
<p>②配置拦截器</p>
<p>③测试拦截器的拦截效果</p>
<p>编写拦截器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyInterceptor1</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line">    <span class="comment">//在目标方法执行之前 执行</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;preHandle.....&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//在目标方法执行之后 视图对象返回之前执行</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;postHandle...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//在流程都执行完毕后 执行</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;afterCompletion....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>配置：在SpringMVC的配置文件中配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置拦截器--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:interceptors</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--对哪些资源执行拦截操作--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">&quot;/**&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.interceptor.MyInterceptor1&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mvc:interceptors</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>编写测试程序测试：</p>
<p>编写Controller,发请求到controller,跳转页面</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TargetController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/target&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ModelAndView <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;目标资源执行......&quot;</span>);</span><br><span class="line">        <span class="type">ModelAndView</span> <span class="variable">modelAndView</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ModelAndView</span>();</span><br><span class="line">        modelAndView.addObject(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;itcast&quot;</span>);</span><br><span class="line">        modelAndView.setViewName(<span class="string">&quot;index&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> modelAndView;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="入门详解"><a href="#入门详解" class="headerlink" title="入门详解"></a>入门详解</h3><p>拦截器在预处理后什么情况下会执行目标资源，什么情况下不执行目标资源，以及在有多个拦截器的情况下拦截器的执行顺序是什么@</p>
<p><strong>结论：</strong></p>
<p>当拦截器的preHandle方法返回true则会执行目标资源，如果返回false则不执行目标资源</p>
<p>多个拦截器情况下，配置在前的先执行，配置在后的后执行</p>
<p>拦截器中的方法执行顺序是：preHandler——-目标资源—-postHandle—- afterCompletion</p>
<h3 id="知识小结"><a href="#知识小结" class="headerlink" title="知识小结"></a>知识小结</h3><p>拦截器中的方法说明如下</p>
<p><img src="/2022/09/26/ssm%E5%AD%A6%E4%B9%A0/202209262040171946.png" alt="在这里插入图片描述"></p>
<h2 id="SpringMVC异常处理机制"><a href="#SpringMVC异常处理机制" class="headerlink" title="SpringMVC异常处理机制"></a>SpringMVC异常处理机制</h2><h3 id="异常处理的思路"><a href="#异常处理的思路" class="headerlink" title="异常处理的思路"></a>异常处理的思路</h3><p>系统中异常包括两类：预期异常和运行时异常RuntimeException，前者通过捕获异常从而获取异常信息，后者主要通过规范代码开发、测试等手段减少运行时异常的发生。</p>
<p>系统的Dao、Service、Controller出现都通过throws Exception向上抛出，最后由SpringMVC前端控制器交由异常处理器进行异常处理，如下图：</p>
<h3 id="异常处理两种方式"><a href="#异常处理两种方式" class="headerlink" title="异常处理两种方式"></a>异常处理两种方式</h3><p>① 使用Spring MVC提供的简单异常处理器SimpleMappingExceptionResolver</p>
<p>② 实现Spring的异常处理接口HandlerExceptionResolver 自定义自己的异常处理器</p>
<h3 id="简单异常处理器SimpleMappingExceptionResolver"><a href="#简单异常处理器SimpleMappingExceptionResolver" class="headerlink" title="简单异常处理器SimpleMappingExceptionResolver"></a>简单异常处理器SimpleMappingExceptionResolver</h3><p>SpringMVC已经定义好了该类型转换器，在使用时可以根据项目情况进行相应异常与视图的映射配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置简单映射异常处理器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">“org.springframework.web.servlet.handler.SimpleMappingExceptionResolver”</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">“defaultErrorView”</span> <span class="attr">value</span>=<span class="string">“error”/</span>&gt;</span>   默认错误视图</span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">“exceptionMappings”</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">map</span>&gt;</span>		异常类型		                             错误视图</span><br><span class="line">            <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;com.itheima.exception.MyException&quot;</span> 									<span class="attr">value</span>=<span class="string">&quot;error&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;java.lang.ClassCastException&quot;</span> <span class="attr">value</span>=<span class="string">&quot;error&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="自定义异常处理步骤"><a href="#自定义异常处理步骤" class="headerlink" title="自定义异常处理步骤"></a>自定义异常处理步骤</h3><p>①创建异常处理器类实现HandlerExceptionResolver</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyExceptionResolver</span> <span class="keyword">implements</span> <span class="title class_">HandlerExceptionResolver</span> &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> ModelAndView <span class="title function_">resolveException</span><span class="params">(HttpServletRequest request, </span></span><br><span class="line"><span class="params">    HttpServletResponse response, Object handler, Exception ex)</span> &#123;</span><br><span class="line">    <span class="comment">//处理异常的代码实现</span></span><br><span class="line">    <span class="comment">//创建ModelAndView对象</span></span><br><span class="line">    <span class="type">ModelAndView</span> <span class="variable">modelAndView</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ModelAndView</span>(); </span><br><span class="line">    modelAndView.setViewName(<span class="string">&quot;exceptionPage&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> modelAndView;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>②配置异常处理器</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;exceptionResolver&quot;</span>        </span></span><br><span class="line"><span class="tag">      <span class="attr">class</span>=<span class="string">&quot;com.itheima.exception.MyExceptionResolver&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>③编写异常页面</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">	这是一个最终异常的显示页面</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>④测试异常跳转</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/quick22&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">quickMethod22</span><span class="params">()</span> <span class="keyword">throws</span> IOException, ParseException &#123;</span><br><span class="line">    <span class="type">SimpleDateFormat</span> <span class="variable">simpleDateFormat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd&quot;</span>); </span><br><span class="line">    simpleDateFormat.parse(<span class="string">&quot;abcde&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="知识要点-7"><a href="#知识要点-7" class="headerlink" title="知识要点"></a>知识要点</h3><p>异常处理方式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">配置简单异常处理器SimpleMappingExceptionResolver</span><br><span class="line"></span><br><span class="line">自定义异常处理器</span><br></pre></td></tr></table></figure>

<p>自定义异常处理步骤</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">①创建异常处理器类实现HandlerExceptionResolver</span><br><span class="line"></span><br><span class="line">②配置异常处理器</span><br><span class="line"></span><br><span class="line">③编写异常页面</span><br><span class="line"></span><br><span class="line">④测试异常跳转</span><br></pre></td></tr></table></figure>

<p>问题：</p>
<ol>
<li>urlpattern里面的&#x2F;和&#x2F;*、&#x2F;**的区别</li>
</ol>
<h1 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a>Mybatis</h1><p><strong>MyBatis开发步骤：</strong></p>
<p>1)导入MyBatis的坐标和其他相关坐标</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--mybatis坐标--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--mysql驱动坐标--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>   </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--单元测试坐标--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--日志坐标--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol>
<li>创建user数据表</li>
<li>编写User实体</li>
</ol>
<p>4)编写UserMapper映射文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">&lt;@xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; @&gt;</span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span>        </span></span><br><span class="line"><span class="meta">	<span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span>        </span></span><br><span class="line"><span class="meta">	<span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;userMapper&quot;</span>&gt;</span>    </span><br><span class="line">	<span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findAll&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.itheima.domain.User&quot;</span>&gt;</span>        </span><br><span class="line">		select * from User    </span><br><span class="line">	<span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol>
<li>编写MyBatis核心文件</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">configuration</span> <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Config 3.0//EN“ &quot;</span>http://mybatis.org/dtd/mybatis-3-config.dtd<span class="string">&quot;&gt;</span></span></span><br><span class="line"><span class="string"><span class="meta">&lt;configuration&gt;    </span></span></span><br><span class="line"><span class="string"><span class="meta">    &lt;environments default=&quot;</span>development<span class="string">&quot;&gt;        </span></span></span><br><span class="line"><span class="string"><span class="meta">        &lt;environment id=&quot;</span>development<span class="string">&quot;&gt;            </span></span></span><br><span class="line"><span class="string"><span class="meta">            &lt;transactionManager type=&quot;</span>JDBC<span class="string">&quot;/&gt;            </span></span></span><br><span class="line"><span class="string"><span class="meta">            &lt;dataSource type=&quot;</span>POOLED<span class="string">&quot;&gt;                </span></span></span><br><span class="line"><span class="string"><span class="meta">                &lt;property name=&quot;</span>driver<span class="string">&quot; value=&quot;</span>com.mysql.jdbc.Driver<span class="string">&quot;/&gt;</span></span></span><br><span class="line"><span class="string"><span class="meta">                &lt;property name=&quot;</span>url<span class="string">&quot; value=&quot;</span>jdbc:mysql:///test<span class="string">&quot;/&gt;      </span></span></span><br><span class="line"><span class="string"><span class="meta">                &lt;property name=&quot;</span>username<span class="string">&quot; value=&quot;</span>root<span class="string">&quot;/&gt;</span></span></span><br><span class="line"><span class="string"><span class="meta">                &lt;property name=&quot;</span>password<span class="string">&quot; value=&quot;</span>root<span class="string">&quot;/&gt;            </span></span></span><br><span class="line"><span class="string"><span class="meta">            &lt;/dataSource&gt;        </span></span></span><br><span class="line"><span class="string"><span class="meta">        &lt;/environment&gt;    </span></span></span><br><span class="line"><span class="string"><span class="meta">    &lt;/environments&gt;    </span></span></span><br><span class="line"><span class="string"><span class="meta"></span></span></span><br><span class="line"><span class="string"><span class="meta">    &lt;mappers&gt; </span></span></span><br><span class="line"><span class="string"><span class="meta">        &lt;mapper resource=&quot;</span>com/itheima/mapper/UserMapper.xml<span class="string">&quot;/&gt; </span></span></span><br><span class="line"><span class="string"><span class="meta">    &lt;/mappers&gt;</span></span></span><br><span class="line"><span class="string"><span class="meta">&lt;/configuration&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>6)测试代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//加载核心配置文件</span></span><br><span class="line"><span class="type">InputStream</span> <span class="variable">resourceAsStream</span> <span class="operator">=</span> Resources.getResourceAsStream(<span class="string">&quot;SqlMapConfig.xml&quot;</span>);</span><br><span class="line"><span class="comment">//获得sqlSession工厂对象</span></span><br><span class="line"><span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> <span class="keyword">new</span>            </span><br><span class="line">                           <span class="title class_">SqlSessionFactoryBuilder</span>().build(resourceAsStream);</span><br><span class="line"><span class="comment">//获得sqlSession对象</span></span><br><span class="line"><span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> sqlSessionFactory.openSession();</span><br><span class="line"><span class="comment">//执行sql语句</span></span><br><span class="line">List&lt;User&gt; userList = sqlSession.selectList(<span class="string">&quot;userMapper.findAll&quot;</span>);</span><br><span class="line"><span class="comment">//打印结果</span></span><br><span class="line">System.out.println(userList);</span><br><span class="line"><span class="comment">//释放资源</span></span><br><span class="line">sqlSession.close();</span><br></pre></td></tr></table></figure>

<h2 id="MyBatis的映射文件概述"><a href="#MyBatis的映射文件概述" class="headerlink" title="MyBatis的映射文件概述"></a>MyBatis的映射文件概述</h2><p><img src="/2022/09/26/ssm%E5%AD%A6%E4%B9%A0/202209262040172151.png" alt="在这里插入图片描述"></p>
<h2 id="MyBatis的增删改查操作"><a href="#MyBatis的增删改查操作" class="headerlink" title="MyBatis的增删改查操作"></a>MyBatis的增删改查操作</h2><p><strong>编写UserMapper映射文件</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;userMapper&quot;</span>&gt;</span>    </span><br><span class="line">	<span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;add&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;com.itheima.domain.User&quot;</span>&gt;</span>        </span><br><span class="line">		insert into user values(#&#123;id&#125;,#&#123;username&#125;,#&#123;password&#125;)    </span><br><span class="line">	<span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>编写插入实体User的代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//加载Mybatis的配置文件</span></span><br><span class="line"><span class="type">InputStream</span> <span class="variable">resourceAsStream</span> <span class="operator">=</span> Resources.getResourceAsStream(<span class="string">&quot;SqlMapConfig.xml&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> <span class="keyword">new</span>                       <span class="title class_">SqlSessionFactoryBuilder</span>().build(resourceAsStream);</span><br><span class="line"></span><br><span class="line"><span class="comment">//传入true的话,自动提交事务</span></span><br><span class="line"><span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> sqlSessionFactory.openSession();</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">insert</span> <span class="operator">=</span> sqlSession.insert(<span class="string">&quot;userMapper.add&quot;</span>, user);</span><br><span class="line">System.out.println(insert);</span><br><span class="line"><span class="comment">//提交事务</span></span><br><span class="line">sqlSession.commit();</span><br><span class="line">sqlSession.close();</span><br></pre></td></tr></table></figure>

<p><strong>操作注意问题</strong></p>
<p>@ 插入语句使用insert标签</p>
<p>@ 在映射文件中使用parameterType属性指定要插入的数据类型</p>
<p>@Sql语句中使用#{实体属性名}方式引用实体中的属性值</p>
<p>@插入操作使用的API是sqlSession.insert(“命名空间.id”,实体对象);</p>
<p>@插入操作涉及数据库数据变化，所以要使用sqlSession对象显示的提交事务，即sqlSession.commit()</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">增删改查映射配置与API：</span><br><span class="line">查询数据： List<span class="tag">&lt;<span class="name">User</span>&gt;</span> userList = sqlSession.selectList(&quot;userMapper.findAll&quot;);</span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findAll&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.itheima.domain.User&quot;</span>&gt;</span></span><br><span class="line">        select * from User</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">    添加数据： sqlSession.insert(&quot;userMapper.add&quot;, user);</span><br><span class="line">    <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;add&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;com.itheima.domain.User&quot;</span>&gt;</span></span><br><span class="line">        insert into user values(#&#123;id&#125;,#&#123;username&#125;,#&#123;password&#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line">    修改数据： sqlSession.update(&quot;userMapper.update&quot;, user);</span><br><span class="line">    <span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;update&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;com.itheima.domain.User&quot;</span>&gt;</span></span><br><span class="line">        update user set username=#&#123;username&#125;,password=#&#123;password&#125; where id=#&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br><span class="line">    删除数据：sqlSession.delete(&quot;userMapper.delete&quot;,3);</span><br><span class="line">    <span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;delete&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;java.lang.Integer&quot;</span>&gt;</span></span><br><span class="line">        delete from user where id=#&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="MyBatis核心配置文件概述"><a href="#MyBatis核心配置文件概述" class="headerlink" title="MyBatis核心配置文件概述"></a>MyBatis核心配置文件概述</h2><h3 id="MyBatis核心配置文件层级关系"><a href="#MyBatis核心配置文件层级关系" class="headerlink" title="MyBatis核心配置文件层级关系"></a>MyBatis核心配置文件层级关系</h3><p><img src="/2022/09/26/ssm%E5%AD%A6%E4%B9%A0/202209262040172220.png" alt="在这里插入图片描述"></p>
<h3 id="MyBatis常用配置解析"><a href="#MyBatis常用配置解析" class="headerlink" title="MyBatis常用配置解析"></a>MyBatis常用配置解析</h3><p><strong>environments标签</strong></p>
<p>数据库环境的配置，支持多环境配置</p>
<p><img src="/2022/09/26/ssm%E5%AD%A6%E4%B9%A0/202209262040182228.png" alt="在这里插入图片描述"></p>
<p>其中，事务管理器（transactionManager）类型有两种：</p>
<p>@JDBC：这个配置就是直接使用了JDBC 的提交和回滚设置，它依赖于从数据源得到的连接来管理事务作用域。</p>
<p>@MANAGED：这个配置几乎没做什么。它从来不提交或回滚一个连接，而是让容器来管理事务的整个生命周期（比如 JEE 应用服务器的上下文）。 默认情况下它会关闭连接，然而一些容器并不希望这样，因此需要将 closeConnection 属性设置为 false 来阻止它默认的关闭行为。</p>
<p>其中，数据源（dataSource）类型有三种：</p>
<p>UNPOOLED：这个数据源的实现只是每次被请求时打开和关闭连接。</p>
<p>POOLED：这种数据源的实现利用“池”的概念将 JDBC 连接对象组织起来。</p>
<p>JNDI：这个数据源的实现是为了能在如 EJB 或应用服务器这类容器中使用，容器可以集中或在外部配置数据源，然后放置一个 JNDI 上下文的引用。</p>
<p><strong>mapper标签</strong></p>
<p>该标签的作用是加载映射的，加载方式有如下几种：</p>
<p>使用相对于类路径的资源引用，例如：</p>
<p>使用完全限定资源定位符（URL），例如：</p>
<p>使用映射器接口实现类的完全限定类名，例如：</p>
<p>将包内的映射器接口实现全部注册为映射器，例如：</p>
<p><strong>Properties标签</strong></p>
<p>实际开发中，习惯将数据源的配置信息单独抽取成一个properties文件，该标签可以加载额外配置的properties文件</p>
<p><img src="/ssm/202209262040182260.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(202209262040182260.png)(G:/PMY/专业资料/SSM/06-就业课(2.1)]-Mybatis/day01_Mybatis快速入门/笔记/img/图片9.png)"></p>
<p><strong>typeAliases标签</strong></p>
<p>类型别名是为Java 类型设置一个短的名字。原来的类型名称配置如下</p>
<p><img src="/ssm/202209262040182266.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(202209262040182266.png)(G:/PMY/专业资料/SSM/06-就业课(2.1)]-Mybatis/day01_Mybatis快速入门/笔记/img/图片10.png)"></p>
<p>配置typeAliases，为com.itheima.domain.User定义别名为user<br><img src="/2022/09/26/ssm%E5%AD%A6%E4%B9%A0/202209262040192269.png" alt="在这里插入图片描述"></p>
<p>上面我们是自定义的别名，mybatis框架已经为我们设置好的一些常用的类型的别名<br><img src="/2022/09/26/ssm%E5%AD%A6%E4%B9%A0/202209262040192272.png" alt="在这里插入图片描述"></p>
<h3 id="知识小结-1"><a href="#知识小结-1" class="headerlink" title="知识小结"></a>知识小结</h3><p><strong>核心配置文件常用配置：</strong></p>
<p>properties标签：该标签可以加载外部的properties文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">&quot;jdbc.properties&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>typeAliases标签：设置类型别名</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">type</span>=<span class="string">&quot;com.itheima.domain.User&quot;</span> <span class="attr">alias</span>=<span class="string">&quot;user&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">typeAlias</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>mappers标签：加载映射配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;com/itheima/mapper/UserMapping.xml&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>environments标签：数据源环境配置标签</p>
<p><img src="/2022/09/26/ssm%E5%AD%A6%E4%B9%A0/202209262040192298.png" alt="在这里插入图片描述"></p>
<h2 id="MyBatis相应API"><a href="#MyBatis相应API" class="headerlink" title="MyBatis相应API"></a>MyBatis相应API</h2><h3 id="SqlSession工厂构建器SqlSessionFactoryBuilder"><a href="#SqlSession工厂构建器SqlSessionFactoryBuilder" class="headerlink" title="SqlSession工厂构建器SqlSessionFactoryBuilder"></a>SqlSession工厂构建器SqlSessionFactoryBuilder</h3><p>常用API：SqlSessionFactory build(InputStream inputStream)</p>
<p>通过加载mybatis的核心文件的输入流的形式构建一个SqlSessionFactory对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="string">&quot;org/mybatis/builder/mybatis-config.xml&quot;</span>; </span><br><span class="line"><span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> Resources.getResourceAsStream(resource); </span><br><span class="line"><span class="type">SqlSessionFactoryBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>(); </span><br><span class="line"><span class="type">SqlSessionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> builder.build(inputStream);</span><br></pre></td></tr></table></figure>

<p>其中， Resources 工具类，这个类在 org.apache.ibatis.io 包中。Resources 类帮助你从类路径下、文件系统或一个 web URL 中加载资源文件。</p>
<h3 id="SqlSession工厂对象SqlSessionFactory"><a href="#SqlSession工厂对象SqlSessionFactory" class="headerlink" title="SqlSession工厂对象SqlSessionFactory"></a>SqlSession工厂对象SqlSessionFactory</h3><p>SqlSessionFactory 有多个个方法创建SqlSession 实例。常用的有如下两个：</p>
<p><img src="/2022/09/26/ssm%E5%AD%A6%E4%B9%A0/202209262040192321.png" alt="在这里插入图片描述"></p>
<h3 id="SqlSession会话对象"><a href="#SqlSession会话对象" class="headerlink" title="SqlSession会话对象"></a>SqlSession会话对象</h3><p>SqlSession 实例在 MyBatis 中是非常强大的一个类。在这里你会看到所有执行语句、提交或回滚事务和获取映射器实例的方法。</p>
<p>执行语句的方法主要有：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;T&gt; T <span class="title function_">selectOne</span><span class="params">(String statement, Object parameter)</span> </span><br><span class="line">&lt;E&gt; List&lt;E&gt; <span class="title function_">selectList</span><span class="params">(String statement, Object parameter)</span> </span><br><span class="line"><span class="type">int</span> <span class="title function_">insert</span><span class="params">(String statement, Object parameter)</span> </span><br><span class="line"><span class="type">int</span> <span class="title function_">update</span><span class="params">(String statement, Object parameter)</span> </span><br><span class="line"><span class="type">int</span> <span class="title function_">delete</span><span class="params">(String statement, Object parameter)</span></span><br></pre></td></tr></table></figure>

<p>操作事务的方法主要有：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">commit</span><span class="params">()</span>  </span><br><span class="line"><span class="keyword">void</span> <span class="title function_">rollback</span><span class="params">()</span> </span><br></pre></td></tr></table></figure>

<h2 id="Mybatis的Dao层实现"><a href="#Mybatis的Dao层实现" class="headerlink" title="Mybatis的Dao层实现"></a>Mybatis的Dao层实现</h2><h3 id="传统开发方式"><a href="#传统开发方式" class="headerlink" title="传统开发方式"></a>传统开发方式</h3><h4 id="编写UserDao接口"><a href="#编写UserDao接口" class="headerlink" title="编写UserDao接口"></a>编写UserDao接口</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">    List&lt;User&gt; <span class="title function_">findAll</span><span class="params">()</span> <span class="keyword">throws</span> IOException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="编写UserDaoImpl实现"><a href="#编写UserDaoImpl实现" class="headerlink" title="编写UserDaoImpl实现"></a>编写UserDaoImpl实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;User&gt; <span class="title function_">findAll</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">resourceAsStream</span> <span class="operator">=</span> </span><br><span class="line">                    Resources.getResourceAsStream(<span class="string">&quot;SqlMapConfig.xml&quot;</span>);</span><br><span class="line">        <span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> </span><br><span class="line">                    <span class="title class_">SqlSessionFactoryBuilder</span>().build(resourceAsStream);</span><br><span class="line">        <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> sqlSessionFactory.openSession();</span><br><span class="line">        List&lt;User&gt; userList = sqlSession.selectList(<span class="string">&quot;userMapper.findAll&quot;</span>);</span><br><span class="line">        sqlSession.close();</span><br><span class="line">        <span class="keyword">return</span> userList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="测试传统方式"><a href="#测试传统方式" class="headerlink" title="测试传统方式"></a>测试传统方式</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testTraditionDao</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">UserDao</span> <span class="variable">userDao</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserDaoImpl</span>();</span><br><span class="line">    List&lt;User&gt; all = userDao.findAll();</span><br><span class="line">    System.out.println(all);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="代理开发方式"><a href="#代理开发方式" class="headerlink" title="代理开发方式"></a>代理开发方式</h3><h4 id="代理开发方式介绍"><a href="#代理开发方式介绍" class="headerlink" title="代理开发方式介绍"></a>代理开发方式介绍</h4><p>采用 Mybatis 的代理开发方式实现 DAO 层的开发，这种方式是我们后面进入企业的主流。</p>
<p>Mapper 接口开发方法只需要程序员编写Mapper 接口（相当于Dao 接口），由Mybatis 框架根据接口定义创建接口的动态代理对象，代理对象的方法体同上边Dao接口实现类方法。</p>
<p>Mapper 接口开发需要遵循以下规范：</p>
<p><strong>Mapper.xml文件中的namespace与mapper接口的全限定名相同</strong></p>
<p><strong>Mapper接口方法名和Mapper.xml中定义的每个statement的id相同</strong></p>
<p><strong>Mapper接口方法的输入参数类型和mapper.xml中定义的每个sql的parameterType的类型相同</strong></p>
<p><strong>Mapper接口方法的输出参数类型和mapper.xml中定义的每个sql的resultType的类型相同</strong></p>
<h4 id="编写UserMapper接口"><a href="#编写UserMapper接口" class="headerlink" title="编写UserMapper接口"></a>编写UserMapper接口</h4><p><img src="/2022/09/26/ssm%E5%AD%A6%E4%B9%A0/202209262040192404.png" alt="在这里插入图片描述"></p>
<h4 id="测试代理方式"><a href="#测试代理方式" class="headerlink" title="测试代理方式"></a>测试代理方式</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testProxyDao</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">resourceAsStream</span> <span class="operator">=</span> Resources.getResourceAsStream(<span class="string">&quot;SqlMapConfig.xml&quot;</span>);</span><br><span class="line">    <span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(resourceAsStream);</span><br><span class="line">    <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> sqlSessionFactory.openSession();</span><br><span class="line">    <span class="comment">//获得MyBatis框架生成的UserMapper接口的实现类</span></span><br><span class="line">  <span class="type">UserMapper</span> <span class="variable">userMapper</span> <span class="operator">=</span> sqlSession.getMapper(UserMapper.class);</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userMapper.findById(<span class="number">1</span>);</span><br><span class="line">    System.out.println(user);</span><br><span class="line">    sqlSession.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="知识小结-2"><a href="#知识小结-2" class="headerlink" title="知识小结"></a>知识小结</h4><p>MyBatis的Dao层实现的两种方式：</p>
<p>手动对Dao进行实现：传统开发方式</p>
<p><strong>代理方式对Dao进行实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">UserMapper</span> <span class="variable">userMapper</span> <span class="operator">=</span> sqlSession.getMapper(UserMapper.class);</span><br></pre></td></tr></table></figure>

<h2 id="MyBatis映射文件深入"><a href="#MyBatis映射文件深入" class="headerlink" title="MyBatis映射文件深入"></a>MyBatis映射文件深入</h2><h3 id="动态sql语句"><a href="#动态sql语句" class="headerlink" title="动态sql语句"></a>动态sql语句</h3><h4 id="动态sql语句概述"><a href="#动态sql语句概述" class="headerlink" title="动态sql语句概述"></a>动态sql语句概述</h4><p>Mybatis 的映射文件中，前面我们的 SQL 都是比较简单的，有些时候业务逻辑复杂时，我们的 SQL是动态变化的，此时在前面的学习中我们的 SQL 就不能满足要求了。</p>
<p>参考的官方文档，描述如下：<br><img src="/2022/09/26/ssm%E5%AD%A6%E4%B9%A0/202209262040192443.png" alt="在这里插入图片描述"></p>
<h4 id="动态-SQL-之-lt-if-gt"><a href="#动态-SQL-之-lt-if-gt" class="headerlink" title="动态 SQL 之&lt;if&gt;"></a>动态 SQL 之&lt;<strong>if&gt;</strong></h4><p>我们根据实体类的不同取值，使用不同的 SQL语句来进行查询。比如在 id如果不为空时可以根据id查询，如果username 不同空时还要加入用户名作为条件。这种情况在我们的多条件组合查询中经常会碰到。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findByCondition&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;user&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;user&quot;</span>&gt;</span></span><br><span class="line">    select * from User</span><br><span class="line">    <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;id!=0&quot;</span>&gt;</span></span><br><span class="line">            and id=#&#123;id&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;username!=null&quot;</span>&gt;</span></span><br><span class="line">            and username=#&#123;username&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>当查询条件id和username都存在时，控制台打印的sql语句如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获得MyBatis框架生成的UserMapper接口的实现类</span></span><br><span class="line"><span class="type">UserMapper</span> <span class="variable">userMapper</span> <span class="operator">=</span> sqlSession.getMapper(UserMapper.class);</span><br><span class="line"><span class="type">User</span> <span class="variable">condition</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">condition.setId(<span class="number">1</span>);</span><br><span class="line">condition.setUsername(<span class="string">&quot;lucy&quot;</span>);</span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userMapper.findByCondition(condition);</span><br></pre></td></tr></table></figure>

<p><img src="/ssm/202209262040202475.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(202209262040202475.png)(G:\PMY\专业资料\SSM\06-就业课(2.1)]-Mybatis\day02_Mybatis的dao层实现原理\笔记\img\图片3.png)"></p>
<p>当查询条件只有id存在时，控制台打印的sql语句如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获得MyBatis框架生成的UserMapper接口的实现类</span></span><br><span class="line"><span class="type">UserMapper</span> <span class="variable">userMapper</span> <span class="operator">=</span> sqlSession.getMapper(UserMapper.class);</span><br><span class="line"><span class="type">User</span> <span class="variable">condition</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">condition.setId(<span class="number">1</span>);</span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userMapper.findByCondition(condition);</span><br></pre></td></tr></table></figure>

<p><img src="/2022/09/26/ssm%E5%AD%A6%E4%B9%A0/202209262040202487.png" alt="在这里插入图片描述"></p>
<h4 id="动态-SQL-之-lt-foreach-gt"><a href="#动态-SQL-之-lt-foreach-gt" class="headerlink" title="动态 SQL 之&lt;foreach&gt;"></a>动态 SQL 之&lt;<strong>foreach&gt;</strong></h4><p>循环执行sql的拼接操作，例如：SELECT * FROM USER WHERE id IN (1,2,5)。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findByIds&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;list&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;user&quot;</span>&gt;</span></span><br><span class="line">   select * from User</span><br><span class="line">   <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;array&quot;</span> <span class="attr">open</span>=<span class="string">&quot;id in(&quot;</span> <span class="attr">close</span>=<span class="string">&quot;)&quot;</span> <span class="attr">item</span>=<span class="string">&quot;id&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span>&gt;</span></span><br><span class="line">           #&#123;id&#125;</span><br><span class="line">       <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>测试代码片段如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> … … …</span><br><span class="line"> <span class="comment">//获得MyBatis框架生成的UserMapper接口的实现类</span></span><br><span class="line"><span class="type">UserMapper</span> <span class="variable">userMapper</span> <span class="operator">=</span> sqlSession.getMapper(UserMapper.class);</span><br><span class="line"><span class="type">int</span>[] ids = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">2</span>,<span class="number">5</span>&#125;;</span><br><span class="line">List&lt;User&gt; userList = userMapper.findByIds(ids);</span><br><span class="line">System.out.println(userList);</span><br></pre></td></tr></table></figure>

<p><img src="/2022/09/26/ssm%E5%AD%A6%E4%B9%A0/202209262040202515.png" alt="在这里插入图片描述"></p>
<p>foreach标签的属性含义如下：</p>
<p>标签用于遍历集合，它的属性：</p>
<p>@collection：代表要遍历的集合元素，注意编写时不要写#{}</p>
<p>@open：代表语句的开始部分</p>
<p>@close：代表结束部分</p>
<p>@item：代表遍历集合的每个元素，生成的变量名</p>
<p>@sperator：代表分隔符</p>
<h3 id="SQL片段抽取"><a href="#SQL片段抽取" class="headerlink" title="SQL片段抽取"></a>SQL片段抽取</h3><p>Sql 中可将重复的 sql 提取出来，使用时用 include 引用即可，最终达到 sql 重用的目的</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--抽取sql片段简化编写--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">&quot;selectUser&quot;</span> <span class="attr">select</span> * <span class="attr">from</span> <span class="attr">User</span>&lt;/<span class="attr">sql</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findById&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;int&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;user&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;selectUser&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">include</span>&gt;</span> where id=#&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findByIds&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;list&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;user&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;selectUser&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;array&quot;</span> <span class="attr">open</span>=<span class="string">&quot;id in(&quot;</span> <span class="attr">close</span>=<span class="string">&quot;)&quot;</span> <span class="attr">item</span>=<span class="string">&quot;id&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span>&gt;</span></span><br><span class="line">            #&#123;id&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="知识小结-3"><a href="#知识小结-3" class="headerlink" title="知识小结"></a>知识小结</h3><p>MyBatis映射文件配置：</p>
<p>：查询</p>
<p>：插入</p>
<p>：修改</p>
<p>：删除</p>
<p>：where条件</p>
<p>：if判断</p>
<p>：循环</p>
<p>：sql片段抽取</p>
<h2 id="MyBatis核心配置文件深入"><a href="#MyBatis核心配置文件深入" class="headerlink" title="MyBatis核心配置文件深入"></a>MyBatis核心配置文件深入</h2><h3 id="typeHandlers标签"><a href="#typeHandlers标签" class="headerlink" title="typeHandlers标签"></a>typeHandlers标签</h3><p>无论是 MyBatis 在预处理语句（PreparedStatement）中设置一个参数时，还是从结果集中取出一个值时， 都会用类型处理器将获取的值以合适的方式转换成 Java 类型。下表描述了一些默认的类型处理器（截取部分）。</p>
<p><img src="/2022/09/26/ssm%E5%AD%A6%E4%B9%A0/202209262040202577.png" alt="在这里插入图片描述"></p>
<p>你可以重写类型处理器或创建你自己的类型处理器来处理不支持的或非标准的类型。具体做法为：实现 org.apache.ibatis.type.TypeHandler 接口， 或继承一个很便利的类 org.apache.ibatis.type.BaseTypeHandler， 然后可以选择性地将它映射到一个JDBC类型。例如需求：一个Java中的Date数据类型，我想将之存到数据库的时候存成一个1970年至今的毫秒数，取出来时转换成java的Date，即java的Date与数据库的varchar毫秒值之间转换。</p>
<p>开发步骤：</p>
<p>①定义转换类继承类BaseTypeHandler</p>
<p>②覆盖4个未实现的方法，其中setNonNullParameter为java程序设置数据到数据库的回调方法，getNullableResult为查询时 mysql的字符串类型转换成 java的Type类型的方法</p>
<p>③在MyBatis核心配置文件中进行注册</p>
<p>测试转换是否正确</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyDateTypeHandler</span> <span class="keyword">extends</span> <span class="title class_">BaseTypeHandler</span>&lt;Date&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNonNullParameter</span><span class="params">(PreparedStatement preparedStatement, <span class="type">int</span> i, Date date, JdbcType type)</span> &#123;</span><br><span class="line">        preparedStatement.setString(i,date.getTime()+<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Date <span class="title function_">getNullableResult</span><span class="params">(ResultSet resultSet, String s)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Date</span>(resultSet.getLong(s));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Date <span class="title function_">getNullableResult</span><span class="params">(ResultSet resultSet, <span class="type">int</span> i)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Date</span>(resultSet.getLong(i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Date <span class="title function_">getNullableResult</span><span class="params">(CallableStatement callableStatement, <span class="type">int</span> i)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="keyword">return</span> callableStatement.getDate(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;!--注册类型自定义转换器--&gt;</span><br><span class="line">    &lt;typeHandlers&gt;</span><br><span class="line">    &lt;typeHandler handler=<span class="string">&quot;com.itheima.typeHandlers.MyDateTypeHandler&quot;</span>&gt;                 &lt;/typeHandler&gt;</span><br><span class="line">    &lt;/typeHandlers&gt;</span><br></pre></td></tr></table></figure>

<p>测试添加操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">user.setBirthday(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">userMapper.add2(user);</span><br></pre></td></tr></table></figure>

<p>数据库数据：</p>
<p>测试查询操作：</p>
<p>@ <img src="/2022/09/26/ssm%E5%AD%A6%E4%B9%A0/202209262040202623.png" alt="在这里插入图片描述"></p>
<h3 id="plugins标签"><a href="#plugins标签" class="headerlink" title="plugins标签"></a>plugins标签</h3><p>MyBatis可以使用第三方的插件来对功能进行扩展，分页助手PageHelper是将分页的复杂操作进行封装，使用简单的方式即可获得分页的相关数据</p>
<p>开发步骤：</p>
<p>①导入通用PageHelper的坐标</p>
<p>②在mybatis核心配置文件中配置PageHelper插件</p>
<p>③测试分页数据获取</p>
<h4 id="导入通用PageHelper坐标"><a href="#导入通用PageHelper坐标" class="headerlink" title="导入通用PageHelper坐标"></a>导入通用PageHelper坐标</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 分页助手 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.pagehelper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pagehelper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.7.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.jsqlparser<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jsqlparser<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.9.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="在mybatis核心配置文件中配置PageHelper插件"><a href="#在mybatis核心配置文件中配置PageHelper插件" class="headerlink" title="在mybatis核心配置文件中配置PageHelper插件"></a>在mybatis核心配置文件中配置PageHelper插件</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 注意：分页助手的插件  配置在通用馆mapper之前 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugin</span> <span class="attr">interceptor</span>=<span class="string">&quot;com.github.pagehelper.PageHelper&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 指定方言 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dialect&quot;</span> <span class="attr">value</span>=<span class="string">&quot;mysql&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="测试分页代码实现"><a href="#测试分页代码实现" class="headerlink" title="测试分页代码实现"></a>测试分页代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testPageHelper</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//设置分页参数</span></span><br><span class="line">    PageHelper.startPage(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    List&lt;User&gt; select = userMapper2.select(<span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">for</span>(User user : select)&#123;</span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>获得分页相关的其他参数</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//其他分页的数据</span></span><br><span class="line">PageInfo&lt;User&gt; pageInfo = <span class="keyword">new</span> <span class="title class_">PageInfo</span>&lt;User&gt;(select);</span><br><span class="line">System.out.println(<span class="string">&quot;总条数：&quot;</span>+pageInfo.getTotal());</span><br><span class="line">System.out.println(<span class="string">&quot;总页数：&quot;</span>+pageInfo.getPages());</span><br><span class="line">System.out.println(<span class="string">&quot;当前页：&quot;</span>+pageInfo.getPageNum());</span><br><span class="line">System.out.println(<span class="string">&quot;每页显示长度：&quot;</span>+pageInfo.getPageSize());</span><br><span class="line">System.out.println(<span class="string">&quot;是否第一页：&quot;</span>+pageInfo.isIsFirstPage());</span><br><span class="line">System.out.println(<span class="string">&quot;是否最后一页：&quot;</span>+pageInfo.isIsLastPage());</span><br></pre></td></tr></table></figure>

<h3 id="知识小结-4"><a href="#知识小结-4" class="headerlink" title="知识小结"></a>知识小结</h3><p>MyBatis核心配置文件常用标签：</p>
<p>1、properties标签：该标签可以加载外部的properties文件</p>
<p>2、typeAliases标签：设置类型别名</p>
<p>3、environments标签：数据源环境配置标签</p>
<p>4、typeHandlers标签：配置自定义类型处理器</p>
<p>5、plugins标签：配置MyBatis的插件</p>
<h2 id="Mybatis的多表操作"><a href="#Mybatis的多表操作" class="headerlink" title="Mybatis的多表操作"></a>Mybatis的多表操作</h2><h3 id="一对一"><a href="#一对一" class="headerlink" title="一对一"></a>一对一</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;orderMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;com.itheima.domain.Order&quot;</span>&gt;</span> </span><br><span class="line">     <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;ordertime&quot;</span> <span class="attr">column</span>=<span class="string">&quot;ordertime&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;total&quot;</span> <span class="attr">column</span>=<span class="string">&quot;total&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">     </span><br><span class="line">     <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;user&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;com.itheima.domain.User&quot;</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;uid&quot;</span> <span class="attr">property</span>=<span class="string">&quot;user.id&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;username&quot;</span> <span class="attr">property</span>=<span class="string">&quot;user.username&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;password&quot;</span> <span class="attr">property</span>=<span class="string">&quot;user.password&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span> </span><br><span class="line">         <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;birthday&quot;</span> <span class="attr">property</span>=<span class="string">&quot;user.birthday&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span>  </span><br><span class="line">     <span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findAll&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;orderMap&quot;</span>&gt;</span></span><br><span class="line">    select * from orders o,user u where o.uid=u.id    </span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="一对多"><a href="#一对多" class="headerlink" title="一对多"></a>一对多</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;userMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;com.itheima.domain.User&quot;</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;username&quot;</span> <span class="attr">property</span>=<span class="string">&quot;username&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;password&quot;</span> <span class="attr">property</span>=<span class="string">&quot;password&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;birthday&quot;</span> <span class="attr">property</span>=<span class="string">&quot;birthday&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;orderList&quot;</span> <span class="attr">ofType</span>=<span class="string">&quot;com.itheima.domain.Order&quot;</span>&gt;</span>             	  <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;oid&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span>   </span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;ordertime&quot;</span> <span class="attr">property</span>=<span class="string">&quot;ordertime&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;total&quot;</span> <span class="attr">property</span>=<span class="string">&quot;total&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span>     </span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findAll&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;userMap&quot;</span>&gt;</span>       </span><br><span class="line">    select *,o.id oid from user u left join orders o on u.id=o.uid  </span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span> </span><br></pre></td></tr></table></figure>

<h3 id="多对多"><a href="#多对多" class="headerlink" title="多对多"></a>多对多</h3><p>和一对多一样，只是sql语句的差别</p>
<h3 id="知识小结："><a href="#知识小结：" class="headerlink" title="知识小结："></a>知识小结：</h3><p>一对一配置：使用+做配置</p>
<p>一对多配置：使用+做配置</p>
<p>多对多配置：使用+做配置</p>
<h2 id="Mybatis注解开发"><a href="#Mybatis注解开发" class="headerlink" title="Mybatis注解开发"></a>Mybatis注解开发</h2><h3 id="常用注解："><a href="#常用注解：" class="headerlink" title="常用注解："></a>常用注解：</h3><p>@Insert：实现新增</p>
<p>@Update：实现更新</p>
<p>@Delete：实现删除</p>
<p>@Select：实现查询</p>
<p>@Result：实现结果集封装</p>
<p>@Results：可以与@Result 一起使用，封装多个结果集</p>
<p>@One：实现一对一结果集封装</p>
<p>@Many：实现一对多结果集封装</p>
<p><strong>修改MyBatis的核心配置文件，我们使用了注解替代的映射文件，所以我们只需要加载使用了注解的Mapper接口即可</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">&lt; mappers &gt;</span><br><span class="line">   <span class="comment">&lt;!-- 扫描使用注解的类 --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.mapper.UserMapper&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line">1234</span><br><span class="line">&lt; mappers &gt;</span><br><span class="line">   <span class="comment">&lt;!-- 扫描使用注解的类所在的包 --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">name</span>=<span class="string">&quot;com.itheima.mapper&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>注解：</p>
<table>
<thead>
<tr>
<th><strong>注解</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td>@Results</td>
<td>代替的是标签该注解中可以使用单个@Result注解，也可以使用@Result集合。使用格式：@Results（{@Result（），@Result（）}）或@Results（@Result（））</td>
</tr>
<tr>
<td>@Resut</td>
<td>代替了标签和标签 @Result中属性介绍： column：数据库的列名 property：需要装配的属性名 one：需要使用的@One 注解（@Result（one&#x3D;@One）（））） many：需要使用的@Many 注解（@Result（many&#x3D;@many）（）））</td>
</tr>
<tr>
<td>@One （一对一）</td>
<td>代替了 标签，是多表查询的关键，在注解中用来指定子查询返回单一对象。 @One注解属性介绍： select: 指定用来多表查询的 sqlmapper 使用格式：@Result(column&#x3D;””,property&#x3D;””,one&#x3D;@One(select&#x3D;””))</td>
</tr>
<tr>
<td>@Many （多对一）</td>
<td>代替了标签, 是是多表查询的关键，在注解中用来指定子查询返回对象集合。 使用格式：@Result(property&#x3D;””,column&#x3D;””,many&#x3D;@Many(select&#x3D;””))</td>
</tr>
</tbody></table>
<p>一对一：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//查询订单顺便查询订单所属用户</span></span><br><span class="line"><span class="meta">@Select(&quot;select * from orders&quot;)</span></span><br><span class="line"><span class="meta">@Results(&#123;</span></span><br><span class="line"><span class="meta">        @Result(column = &quot;id&quot;,property = &quot;id&quot;),</span></span><br><span class="line"><span class="meta">        @Result(column = &quot;ordertime&quot;,property = &quot;ordertime&quot;),</span></span><br><span class="line"><span class="meta">        @Result(column = &quot;total&quot;,property = &quot;total&quot;),</span></span><br><span class="line"><span class="meta">        @Result(column = &quot;oid&quot;,property = &quot;id&quot;),</span></span><br><span class="line"><span class="meta">        @Result(</span></span><br><span class="line"><span class="meta">             property = &quot;user&quot;,             //属性名</span></span><br><span class="line"><span class="meta">                javaType = User.class,      //属性类型</span></span><br><span class="line"><span class="meta">                column = &quot;id&quot;,              //根据查询出来的结果集再去查询</span></span><br><span class="line"><span class="meta">                one =@One(select = &quot;com.pmy.mapper.UserMapper.findById&quot;)</span></span><br><span class="line"><span class="meta">        ),</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line">List&lt;Order&gt; <span class="title function_">findAll</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>

<p>一对多：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//查询用户并查询他所属的订单</span></span><br><span class="line"><span class="meta">@Select(&quot;select *from user&quot;)</span></span><br><span class="line"><span class="meta">@Results(&#123;</span></span><br><span class="line"><span class="meta">        @Result(id = true,column = &quot;id&quot;,property = &quot;id&quot;),</span></span><br><span class="line"><span class="meta">        @Result(column = &quot;username&quot;,property = &quot;username&quot;),</span></span><br><span class="line"><span class="meta">        @Result(column = &quot;password&quot;,property = &quot;password&quot;),</span></span><br><span class="line"><span class="meta">        @Result(column = &quot;birthday&quot;,property = &quot;birthday&quot;),</span></span><br><span class="line"><span class="meta">        @Result(</span></span><br><span class="line"><span class="meta">                column = &quot;id&quot;,</span></span><br><span class="line"><span class="meta">                javaType = List.class,</span></span><br><span class="line"><span class="meta">                many = @Many(select = &quot;com.pmy.mapper.OrderMapper.findById&quot;)</span></span><br><span class="line"><span class="meta">        )</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line">List&lt;User&gt; <span class="title function_">findUserAndOrderAll</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>

<p>多对多：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//查询用户并查询用户的角色</span></span><br><span class="line"><span class="meta">@Select(&quot;select * from user&quot;)</span></span><br><span class="line"><span class="meta">@Results(&#123;</span></span><br><span class="line"><span class="meta">        @Result(id = true,column = &quot;id&quot;,property = &quot;id&quot;),</span></span><br><span class="line"><span class="meta">        @Result(column = &quot;username&quot;,property = &quot;username&quot;),</span></span><br><span class="line"><span class="meta">        @Result(column = &quot;password&quot;,property = &quot;password&quot;),</span></span><br><span class="line"><span class="meta">        @Result(column = &quot;birthday&quot;,property = &quot;birthday&quot;),</span></span><br><span class="line"><span class="meta">        @Result(</span></span><br><span class="line"><span class="meta">                property = &quot;roleList&quot;,</span></span><br><span class="line"><span class="meta">                javaType = List.class,</span></span><br><span class="line"><span class="meta">                column = &quot;id&quot;,</span></span><br><span class="line"><span class="meta">                many = @Many(select = &quot;com.pmy.mapper.RoleMapper.findByUid&quot;)</span></span><br><span class="line"><span class="meta">        )</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line">List&lt;User&gt; <span class="title function_">findUserAndRoleAll</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>

<h2 id="MyBatis缓存"><a href="#MyBatis缓存" class="headerlink" title="MyBatis缓存"></a>MyBatis缓存</h2><p>1、什么是缓存 [ Cache ]？</p>
<ul>
<li>存在内存中的临时数据。</li>
<li>将用户经常查询的数据放在缓存（内存）中，用户去查询数据就不用从磁盘上(关系型数据库数据文件)查询，从缓存中查询，从而提高查询效率，解决了高并发系统的性能问题。</li>
</ul>
<p>2、为什么使用缓存？</p>
<ul>
<li>减少和数据库的交互次数，减少系统开销，提高系统效率。</li>
</ul>
<p>3、什么样的数据能使用缓存？</p>
<ul>
<li>经常查询并且不经常改变的数据。</li>
</ul>
<blockquote>
<p>Mybatis缓存</p>
</blockquote>
<ul>
<li><p>MyBatis包含一个非常强大的查询缓存特性，它可以非常方便地定制和配置缓存。缓存可以极大的提升查询效率。</p>
</li>
<li><p>MyBatis系统中默认定义了两级缓存：<strong>一级缓存</strong>和<strong>二级缓存</strong></p>
</li>
<li><ul>
<li>默认情况下，只有一级缓存开启。（SqlSession级别的缓存，也称为本地缓存）</li>
<li>二级缓存需要手动开启和配置，他是基于namespace级别的缓存。</li>
<li>为了提高扩展性，MyBatis定义了缓存接口Cache。我们可以通过实现Cache接口来自定义二级缓存</li>
</ul>
</li>
</ul>
<h3 id="一级缓存"><a href="#一级缓存" class="headerlink" title="一级缓存"></a>一级缓存</h3><p>一级缓存也叫本地缓存：</p>
<ul>
<li>与数据库同一次会话期间查询到的数据会放在本地缓存中。</li>
<li>以后如果需要获取相同的数据，直接从缓存中拿，没必须再去查询数据库；</li>
</ul>
<blockquote>
<p>测试</p>
</blockquote>
<p>1、在mybatis中加入日志，方便测试结果</p>
<p>2、编写接口方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//根据id查询用户</span></span><br><span class="line">User <span class="title function_">queryUserById</span><span class="params">(<span class="meta">@Param(&quot;id&quot;)</span> <span class="type">int</span> id)</span>;</span><br></pre></td></tr></table></figure>

<p>3、接口对应的Mapper文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryUserById&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;user&quot;</span>&gt;</span></span><br><span class="line">  select * from user where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>4、测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testQueryUserById</span><span class="params">()</span>&#123;</span><br><span class="line">   <span class="type">SqlSession</span> <span class="variable">session</span> <span class="operator">=</span> MybatisUtils.getSession();</span><br><span class="line">   <span class="type">UserMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> session.getMapper(UserMapper.class);</span><br><span class="line"></span><br><span class="line">   <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> mapper.queryUserById(<span class="number">1</span>);</span><br><span class="line">   System.out.println(user);</span><br><span class="line">   <span class="type">User</span> <span class="variable">user2</span> <span class="operator">=</span> mapper.queryUserById(<span class="number">1</span>);</span><br><span class="line">   System.out.println(user2);</span><br><span class="line">   System.out.println(user==user2);</span><br><span class="line"></span><br><span class="line">   session.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5、结果分析</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7KickRVspms8t4ZU0jXovPT2qe5QluO0MoibU09bTKiaGG923AzFwOSxICrM7BZFWNJqiaCUOGxDA54Tg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<blockquote>
<p>一级缓存失效的四种情况</p>
</blockquote>
<p>一级缓存是SqlSession级别的缓存，是一直开启的，我们关闭不了它；</p>
<p>一级缓存失效情况：没有使用到当前的一级缓存，效果就是，还需要再向数据库中发起一次查询请求！</p>
<p>1、sqlSession不同</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testQueryUserById</span><span class="params">()</span>&#123;</span><br><span class="line">   <span class="type">SqlSession</span> <span class="variable">session</span> <span class="operator">=</span> MybatisUtils.getSession();</span><br><span class="line">   <span class="type">SqlSession</span> <span class="variable">session2</span> <span class="operator">=</span> MybatisUtils.getSession();</span><br><span class="line">   <span class="type">UserMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> session.getMapper(UserMapper.class);</span><br><span class="line">   <span class="type">UserMapper</span> <span class="variable">mapper2</span> <span class="operator">=</span> session2.getMapper(UserMapper.class);</span><br><span class="line"></span><br><span class="line">   <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> mapper.queryUserById(<span class="number">1</span>);</span><br><span class="line">   System.out.println(user);</span><br><span class="line">   <span class="type">User</span> <span class="variable">user2</span> <span class="operator">=</span> mapper2.queryUserById(<span class="number">1</span>);</span><br><span class="line">   System.out.println(user2);</span><br><span class="line">   System.out.println(user==user2);</span><br><span class="line"></span><br><span class="line">   session.close();</span><br><span class="line">   session2.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>观察结果：发现发送了两条SQL语句！</p>
<p>结论：<strong>每个sqlSession中的缓存相互独立</strong></p>
<p>2、sqlSession相同，查询条件不同</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testQueryUserById</span><span class="params">()</span>&#123;</span><br><span class="line">   <span class="type">SqlSession</span> <span class="variable">session</span> <span class="operator">=</span> MybatisUtils.getSession();</span><br><span class="line">   <span class="type">UserMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> session.getMapper(UserMapper.class);</span><br><span class="line">   <span class="type">UserMapper</span> <span class="variable">mapper2</span> <span class="operator">=</span> session.getMapper(UserMapper.class);</span><br><span class="line"></span><br><span class="line">   <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> mapper.queryUserById(<span class="number">1</span>);</span><br><span class="line">   System.out.println(user);</span><br><span class="line">   <span class="type">User</span> <span class="variable">user2</span> <span class="operator">=</span> mapper2.queryUserById(<span class="number">2</span>);</span><br><span class="line">   System.out.println(user2);</span><br><span class="line">   System.out.println(user==user2);</span><br><span class="line"></span><br><span class="line">   session.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>观察结果：发现发送了两条SQL语句！很正常的理解</p>
<p>结论：<strong>当前缓存中，不存在这个数据</strong></p>
<p>3、sqlSession相同，两次查询之间执行了增删改操作！</p>
<p>增加方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//修改用户</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">updateUser</span><span class="params">(Map map)</span>;</span><br></pre></td></tr></table></figure>

<p>编写SQL</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateUser&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;map&quot;</span>&gt;</span></span><br><span class="line">  update user set name = #&#123;name&#125; where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testQueryUserById</span><span class="params">()</span>&#123;</span><br><span class="line">   <span class="type">SqlSession</span> <span class="variable">session</span> <span class="operator">=</span> MybatisUtils.getSession();</span><br><span class="line">   <span class="type">UserMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> session.getMapper(UserMapper.class);</span><br><span class="line"></span><br><span class="line">   <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> mapper.queryUserById(<span class="number">1</span>);</span><br><span class="line">   System.out.println(user);</span><br><span class="line"></span><br><span class="line">   <span class="type">HashMap</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">   map.put(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;kuangshen&quot;</span>);</span><br><span class="line">   map.put(<span class="string">&quot;id&quot;</span>,<span class="number">4</span>);</span><br><span class="line">   mapper.updateUser(map);</span><br><span class="line"></span><br><span class="line">   <span class="type">User</span> <span class="variable">user2</span> <span class="operator">=</span> mapper.queryUserById(<span class="number">1</span>);</span><br><span class="line">   System.out.println(user2);</span><br><span class="line"></span><br><span class="line">   System.out.println(user==user2);</span><br><span class="line"></span><br><span class="line">   session.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>观察结果：查询在中间执行了增删改操作后，重新执行了</p>
<p>结论：<strong>因为增删改操作可能会对当前数据产生影响</strong></p>
<p>4、sqlSession相同，手动清除一级缓存</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testQueryUserById</span><span class="params">()</span>&#123;</span><br><span class="line">   <span class="type">SqlSession</span> <span class="variable">session</span> <span class="operator">=</span> MybatisUtils.getSession();</span><br><span class="line">   <span class="type">UserMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> session.getMapper(UserMapper.class);</span><br><span class="line"></span><br><span class="line">   <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> mapper.queryUserById(<span class="number">1</span>);</span><br><span class="line">   System.out.println(user);</span><br><span class="line"></span><br><span class="line">   session.clearCache();<span class="comment">//手动清除缓存</span></span><br><span class="line"></span><br><span class="line">   <span class="type">User</span> <span class="variable">user2</span> <span class="operator">=</span> mapper.queryUserById(<span class="number">1</span>);</span><br><span class="line">   System.out.println(user2);</span><br><span class="line"></span><br><span class="line">   System.out.println(user==user2);</span><br><span class="line"></span><br><span class="line">   session.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一级缓存就是一个map</p>
<h3 id="二级缓存"><a href="#二级缓存" class="headerlink" title="二级缓存"></a>二级缓存</h3><ul>
<li><p>二级缓存也叫全局缓存，一级缓存作用域太低了，所以诞生了二级缓存</p>
</li>
<li><p>基于namespace级别的缓存，一个名称空间，对应一个二级缓存；</p>
</li>
<li><p>工作机制</p>
</li>
<li><ul>
<li>一个会话查询一条数据，这个数据就会被放在当前会话的一级缓存中；</li>
<li>如果当前会话关闭了，这个会话对应的一级缓存就没了；但是我们想要的是，会话关闭了，一级缓存中的数据被保存到二级缓存中；</li>
<li>新的会话查询信息，就可以从二级缓存中获取内容；</li>
<li>不同的mapper查出的数据会放在自己对应的缓存（map）中；</li>
</ul>
</li>
</ul>
<blockquote>
<p>使用步骤</p>
</blockquote>
<p>1、开启全局缓存 【mybatis-config.xml】</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;cacheEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>2、去每个mapper.xml中配置使用二级缓存，这个配置非常简单；【xxxMapper.xml】</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">cache</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">官方示例=====&gt;查看官方文档</span><br><span class="line"><span class="tag">&lt;<span class="name">cache</span></span></span><br><span class="line"><span class="tag">       <span class="attr">eviction</span>=<span class="string">&quot;FIFO&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">flushInterval</span>=<span class="string">&quot;60000&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">size</span>=<span class="string">&quot;512&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">readOnly</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">这个更高级的配置创建了一个 FIFO 缓存，每隔 60 秒刷新，最多可以存储结果对象或列表的 512 个引用，而且返回的对象被认为是只读的，因此对它们进行修改可能会在不同线程中的调用者产生冲突。</span><br></pre></td></tr></table></figure>

<p>3、代码测试</p>
<ul>
<li>所有的实体类先实现序列化接口</li>
<li>测试代码</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testQueryUserById</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">SqlSession</span> <span class="variable">session</span> <span class="operator">=</span> MybatisUtils.getSession();</span><br><span class="line">    <span class="type">SqlSession</span> <span class="variable">session2</span> <span class="operator">=</span> MybatisUtils.getSession();</span><br><span class="line"></span><br><span class="line">    <span class="type">UserMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> session.getMapper(UserMapper.class);</span><br><span class="line">    <span class="type">UserMapper</span> <span class="variable">mapper2</span> <span class="operator">=</span> session2.getMapper(UserMapper.class);</span><br><span class="line"></span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> mapper.queryUserById(<span class="number">1</span>);</span><br><span class="line">    System.out.println(user);</span><br><span class="line">    session.close();</span><br><span class="line"></span><br><span class="line">    <span class="type">User</span> <span class="variable">user2</span> <span class="operator">=</span> mapper2.queryUserById(<span class="number">1</span>);</span><br><span class="line">    System.out.println(user2);</span><br><span class="line">    System.out.println(user==user2);</span><br><span class="line"></span><br><span class="line">    session2.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>结论</p>
</blockquote>
<ul>
<li>只要开启了二级缓存，我们在同一个Mapper中的查询，可以在二级缓存中拿到数据</li>
<li>查出的数据都会被默认先放在一级缓存中</li>
<li>只有会话提交或者关闭以后，一级缓存中的数据才会转到二级缓存中</li>
</ul>
<blockquote>
<p>缓存原理图</p>
</blockquote>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7KickRVspms8t4ZU0jXovPT2egdNicaJuVnzMYxibyYFvB0COWW4sgDhHPqvFbG9F9KS1vX7ibIMNqefg/640@wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<blockquote>
<p>EhCache</p>
</blockquote>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7KickRVspms8t4ZU0jXovPT29RfsqgE50IOicMbHPzceX3r2BWn2U9MZ29rpQAy3gtQBnWpveiaRr2lw/640@wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>第三方缓存实现–EhCache: 查看百度百科</p>
<p>Ehcache是一种广泛使用的java分布式缓存，用于通用缓存；</p>
<p>要在应用程序中使用Ehcache，需要引入依赖的jar包</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.mybatis.caches/mybatis-ehcache --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.caches<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-ehcache<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在mapper.xml中使用对应的缓存即可</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span> = <span class="string">“org.acme.FooMapper”</span> &gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">cache</span> <span class="attr">type</span> = <span class="string">“org.mybatis.caches.ehcache.EhcacheCache”</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>编写ehcache.xml文件，如果在加载时未找到&#x2F;ehcache.xml资源或出现问题，则将使用默认配置。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">&lt;@xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;@&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">ehcache</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:noNamespaceSchemaLocation</span>=<span class="string">&quot;http://ehcache.org/ehcache.xsd&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">updateCheck</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">      diskStore：为缓存路径，ehcache分为内存和磁盘两级，此属性定义磁盘的缓存位置。参数解释如下：</span></span><br><span class="line"><span class="comment">      user.home – 用户主目录</span></span><br><span class="line"><span class="comment">      user.dir – 用户当前工作目录</span></span><br><span class="line"><span class="comment">      java.io.tmpdir – 默认临时文件路径</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">diskStore</span> <span class="attr">path</span>=<span class="string">&quot;./tmpdir/Tmp_EhCache&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">defaultCache</span></span></span><br><span class="line"><span class="tag">                  <span class="attr">eternal</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">                  <span class="attr">maxElementsInMemory</span>=<span class="string">&quot;10000&quot;</span></span></span><br><span class="line"><span class="tag">                  <span class="attr">overflowToDisk</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">                  <span class="attr">diskPersistent</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">                  <span class="attr">timeToIdleSeconds</span>=<span class="string">&quot;1800&quot;</span></span></span><br><span class="line"><span class="tag">                  <span class="attr">timeToLiveSeconds</span>=<span class="string">&quot;259200&quot;</span></span></span><br><span class="line"><span class="tag">                  <span class="attr">memoryStoreEvictionPolicy</span>=<span class="string">&quot;LRU&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">cache</span></span></span><br><span class="line"><span class="tag">           <span class="attr">name</span>=<span class="string">&quot;cloud_user&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">eternal</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">maxElementsInMemory</span>=<span class="string">&quot;5000&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">overflowToDisk</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">diskPersistent</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">timeToIdleSeconds</span>=<span class="string">&quot;1800&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">timeToLiveSeconds</span>=<span class="string">&quot;1800&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">memoryStoreEvictionPolicy</span>=<span class="string">&quot;LRU&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">      defaultCache：默认缓存策略，当ehcache找不到定义的缓存时，则使用这个缓存策略。只能定义一个。</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">     name:缓存名称。</span></span><br><span class="line"><span class="comment">     maxElementsInMemory:缓存最大数目</span></span><br><span class="line"><span class="comment">     maxElementsOnDisk：硬盘最大缓存个数。</span></span><br><span class="line"><span class="comment">     eternal:对象是否永久有效，一但设置了，timeout将不起作用。</span></span><br><span class="line"><span class="comment">     overflowToDisk:是否保存到磁盘，当系统当机时</span></span><br><span class="line"><span class="comment">     timeToIdleSeconds:设置对象在失效前的允许闲置时间（单位：秒）。仅当eternal=false对象不是永久有效时使用，可选属性，默认值是0，也就是可闲置时间无穷大。</span></span><br><span class="line"><span class="comment">     timeToLiveSeconds:设置对象在失效前允许存活时间（单位：秒）。最大时间介于创建时间和失效时间之间。仅当eternal=false对象不是永久有效时使用，默认是0.，也就是对象存活时间无穷大。</span></span><br><span class="line"><span class="comment">     diskPersistent：是否缓存虚拟机重启期数据 Whether the disk store persists between restarts of the Virtual Machine. The default value is false.</span></span><br><span class="line"><span class="comment">     diskSpoolBufferSizeMB：这个参数设置DiskStore（磁盘缓存）的缓存区大小。默认是30MB。每个Cache都应该有自己的一个缓冲区。</span></span><br><span class="line"><span class="comment">     diskExpiryThreadIntervalSeconds：磁盘失效线程运行时间间隔，默认是120秒。</span></span><br><span class="line"><span class="comment">     memoryStoreEvictionPolicy：当达到maxElementsInMemory限制时，Ehcache将会根据指定的策略去清理内存。默认策略是LRU（最近最少使用）。你可以设置为FIFO（先进先出）或是LFU（较少使用）。</span></span><br><span class="line"><span class="comment">     clearOnFlush：内存数量最大时是否清除。</span></span><br><span class="line"><span class="comment">     memoryStoreEvictionPolicy:可选策略有：LRU（最近最少使用，默认策略）、FIFO（先进先出）、LFU（最少访问次数）。</span></span><br><span class="line"><span class="comment">     FIFO，first in first out，这个是大家最熟的，先进先出。</span></span><br><span class="line"><span class="comment">     LFU， Less Frequently Used，就是上面例子中使用的策略，直白一点就是讲一直以来最少被使用的。如上面所讲，缓存的元素有一个hit属性，hit值最小的将会被清出缓存。</span></span><br><span class="line"><span class="comment">     LRU，Least Recently Used，最近最少使用的，缓存的元素有一个时间戳，当缓存容量满了，而又需要腾出地方来缓存新的元素的时候，那么现有缓存元素中时间戳离当前时间最远的元素将被清出缓存。</span></span><br><span class="line"><span class="comment">  --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">ehcache</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ssm学习</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL基础篇(上)</title>
    <url>/2022/09/28/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8A)/</url>
    <content><![CDATA[<h1 id="数据库概述"><a href="#数据库概述" class="headerlink" title="数据库概述"></a>数据库概述</h1><h2 id="为什么要使用数据库"><a href="#为什么要使用数据库" class="headerlink" title="为什么要使用数据库"></a><strong>为什么要使用数据库</strong></h2><p>​    持久化(persistence) ： <strong>把数据保存到可掉电式存储设备中以供之后使用</strong> 。大多数情况下，特别是企业级应用， <strong>数据持久化意味着将内存中的数据保存到硬盘上加以</strong> <strong>”</strong> <strong>固化</strong> <strong>”</strong> ，而持久化的实现过程大多通过各种关系数据库来完成。</p>
<p>​    持久化的主要作用是 <strong>将内存中的数据存储在关系型数据库中</strong> ，当然也可以存储在磁盘文件、 XML 数据文件中。</p>
<p><img src="/2022/09/28/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8A)/202209282152498.png" alt="img"></p>
<h2 id="数据库与数据库管理系统"><a href="#数据库与数据库管理系统" class="headerlink" title="数据库与数据库管理系统"></a><strong>数据库与数据库管理系统</strong></h2><h3 id="数据库的相关概念"><a href="#数据库的相关概念" class="headerlink" title="数据库的相关概念"></a><strong>数据库的相关概念</strong></h3><p><strong>DB</strong> <strong>：数据库（</strong> <strong>Database</strong> <strong>）</strong></p>
<p>​    即存储数据的“ 仓库 ” ，其本质是一个文件系统。它保存了一系列有组织的数据。</p>
<p><strong>DBMS</strong> <strong>：数据库管理系统（</strong> <strong>Database Management System</strong> <strong>）</strong></p>
<p>​    是一种操纵和管理数据库的大型 软件 ，用于建立、使用和维护数据库，对数据库进行统一管理和控制。用户通过数据库管理系统访问数据库中表内的数据。（如mysql）</p>
<p><strong>SQL</strong> <strong>：结构化查询语言（</strong> <strong>Structured Query Language</strong> <strong>）</strong></p>
<p>​    专门用来与数据库通信的语言。</p>
<h3 id="数据库与数据库管理系统的关系"><a href="#数据库与数据库管理系统的关系" class="headerlink" title="数据库与数据库管理系统的关系"></a><strong>数据库与数据库管理系统的关系</strong></h3><p>​    数据库管理系统(DBMS) 可以管理多个数据库，一般开发人员会针对每一个应用创建一个数据库。为保存应用中实体的数据，一般会在数据库创建多个表，以保存程序中实体用户的数据。</p>
<p>​    数据库管理系统、数据库和表的关系如图所示：</p>
<p><img src="/2022/09/28/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8A)/2022092821524934.png" alt="img"></p>
<h3 id="常见的数据库管理系统排名-DBMS"><a href="#常见的数据库管理系统排名-DBMS" class="headerlink" title="常见的数据库管理系统排名(DBMS)"></a><strong>常见的数据库管理系统排名(DBMS)</strong></h3><p>​    目前互联网上常见的数据库管理软件有Oracle 、 MySQL 、 MS SQL Server 、 DB2 、 PostgreSQL 、 Access 、Sybase、 Informix 这几种。以下是 2021 年 <strong>DB-Engines Ranking</strong> 对各数据库受欢迎程度进行调查后的统计结 果：（查看数据库最新排名: <strong><a href="https://db-engines.com/en/ranking">https://db-engines.com/en/ranking</a></strong> ）</p>
<p><img src="/2022/09/28/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8A)/2022092821524940.png" alt="img"></p>
<p>对应的走势图：（ <strong><a href="https://db-engines.com/en/ranking_trend">https://db-engines.com/en/ranking_trend</a></strong> ）</p>
<p><img src="/2022/09/28/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8A)/2022092821524944.png" alt="img"></p>
<h3 id="常见的数据库介绍"><a href="#常见的数据库介绍" class="headerlink" title="常见的数据库介绍"></a><strong>常见的数据库介绍</strong></h3><p><strong>Oracle</strong></p>
<p>​    1979 年， Oracle 2 诞生，它是第一个商用的 RDBMS （关系型数据库管理系统）。随着 Oracle 软件的名气 越来越大，公司也改名叫 Oracle 公司。</p>
<p>​    2007年，总计 85 亿美金收购 BEA Systems 。</p>
<p>​    2009年，总计 74 亿美金收购 SUN 。此前的 2008 年， SUN 以 10 亿美金收购 MySQL 。意味着 Oracle 同时拥有了 MySQL 的管理权，至此 Oracle 在数据库领域中成为绝对的领导者。</p>
<p>​    2013年，甲骨文超越 IBM ，成为继 Microsoft 后全球第二大软件公司。</p>
<p>​    如今 Oracle 的年收入达到了 400 亿美金，足以证明商用（收费）数据库软件的价值。</p>
<p><strong>SQL Server</strong></p>
<p>​    SQL Server 是微软开发的大型商业数据库，诞生于 1989 年。 C# 、 .net 等语言常使用，与 WinNT 完全集 成，也可以很好地与Microsoft BackOffice 产品集成。</p>
<p><strong>DB2</strong></p>
<p>​    IBM公司的数据库产品 , 收费的。常应用在银行系统中。</p>
<p><strong>PostgreSQL</strong></p>
<p>​    PostgreSQL 的稳定性极强，最符合 SQL 标准，开放源码，具备商业级 DBMS 质量。 PG 对数据量大的文本以及SQL 处理较快。</p>
<p><strong>Sy</strong> <strong>Base</strong></p>
<p>​    已经淡出历史舞台。提供了一个非常专业数据建模的工具PowerDesigner 。</p>
<p><strong>SQLite</strong></p>
<p>​    嵌入式的小型数据库，应用在手机端。 零配置，SQlite3 不用安装，不用配置，不用启动，关闭或者配置数据库实例。当系统崩溃后不用做任何恢复操作，再下次使用数据库的时候自动恢复。</p>
<p><strong>informix</strong></p>
<p>​    IBM公司出品，取自 Information 和 Unix 的结合，它是第一个被移植到 Linux 上的商业数据库产品。仅运行 于unix&#x2F;linux 平台，命令行操作。 性能较高，支持集群，适应于安全性要求极高的系统，尤其是银行，证券系统的应用。</p>
<h2 id="MySQL介绍"><a href="#MySQL介绍" class="headerlink" title="MySQL介绍"></a><strong>MySQL介绍</strong></h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a><strong>概述</strong></h3><p>​    MySQL是一个 开放源代码的关系型数据库管理系统 ，由瑞典 MySQL AB （创始人 Michael Widenius ）公 司1995 年开发，迅速成为开源数据库的 No.1 。</p>
<p>​    2008被 Sun 收购（10亿美金）， 2009 年 Sun 被 Oracle 收购。 MariaDB 应运而生。（ MySQL 的创 造者担心 MySQL 有闭源的风险，因此创建了 MySQL 的分支项目 MariaDB ）</p>
<p>​    MySQL6.x 版本之后分为 社区版 和 商业版 。</p>
<p>​    MySQL是一种关联数据库管理系统，将数据保存在不同的表中，而不是将所有数据放在一个大仓库 内，这样就增加了速度并提高了灵活性。</p>
<p>​    MySQL是开源的，所以你不需要支付额外的费用。</p>
<p>​    MySQL是可以定制的，采用了 GPL （ GNU General Public License ） 协议，你可以修改源码来 开发自己的MySQL 系统。</p>
<p>​    MySQL支持大型的数据库。可以处理拥有上千万条记录的大型数据库。</p>
<p>​    MySQL支持大型数据库，支持 5000 万条记录的数据仓库， 32 位系统表文件最大可支持 4GB ， 64 位系 统支持最大的表文件为 8TB 。</p>
<p>​    MySQL使用 标准的 SQL 数据语言 形式。</p>
<p>​    MySQL可以允许运行于多个系统上，并且支持多种语言。这些编程语言包括 C 、 C++ 、 Python 、Java、 Perl 、 PHP 和 Ruby 等。</p>
<h3 id="关于MySQL-8-0"><a href="#关于MySQL-8-0" class="headerlink" title="关于MySQL 8.0"></a><strong>关于MySQL 8.0</strong></h3><p>​    MySQL从 5.7 版本直接跳跃发布了 8.0 版本 ，可见这是一个令人兴奋的里程碑版本。 MySQL 8 版本在功能上 做了显著的改进与增强，开发者对MySQL 的源代码进行了重构，最突出的一点是多 MySQL Optimizer 优化 器进行了改进。不仅在速度上得到了改善，还为用户带来了更好的性能和更棒的体验。</p>
<p><strong>为什么如此多的厂商要选用MySQL？大概总结的原因主要有以下几点：</strong></p>
<p>​    \1. 开放源代码，使用成本低。</p>
<p>​    \2. 性能卓越，服务稳定。</p>
<p>​    \3. 软件体积小，使用简单，并且易于维护。</p>
<p>​    \4. 历史悠久，社区用户非常活跃，遇到问题可以寻求帮助。</p>
<p>​    \5. 许多互联网公司在用，经过了时间的验证。</p>
<h3 id="Oracle-vs-MySQL"><a href="#Oracle-vs-MySQL" class="headerlink" title="Oracle vs MySQL"></a><strong>Oracle vs MySQL</strong></h3><p>​    Oracle 更适合大型跨国企业的使用，因为他们对费用不敏感，但是对性能要求以及安全性有更高的要 求。</p>
<p>​    MySQL 由于其 <strong>体积小、速度快、总体拥有成本低，可处理上千万条记录的大型数据库，尤其是开放源码</strong> <strong>这一特点，使得很多互联网公司、中小型网站选择了</strong> <strong>MySQL</strong> <strong>作为网站数据库</strong> （Facebook， Twitter ，YouTube，阿里巴巴 &#x2F; 蚂蚁金服，去哪儿，美团外卖，腾讯）。</p>
<h2 id="RDBMS-与-非RDBMS"><a href="#RDBMS-与-非RDBMS" class="headerlink" title="RDBMS 与 非RDBMS"></a><strong>RDBMS 与 非RDBMS</strong></h2><p>​    从排名中我们能看出来，关系型数据库绝对是 DBMS 的主流，其中使用最多的 DBMS 分别是 Oracle 、MySQL 和 SQL Server 。这些都是关系型数据库（RDBMS）。</p>
<h3 id="关系型数据库-RDBMS"><a href="#关系型数据库-RDBMS" class="headerlink" title="关系型数据库(RDBMS)"></a><strong>关系型数据库(RDBMS)</strong></h3><h4 id="实质"><a href="#实质" class="headerlink" title="实质"></a><strong>实质</strong></h4><p>​    这种类型的数据库是 最古老 的数据库类型，关系型数据库模型是把复杂的数据结构归结为简单的 二元关系 （即二维表格形式）：</p>
<p><img src="/2022/09/28/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8A)/20220928215249142.png" alt="img"></p>
<p>​    <strong>关系型数据库以</strong> <em>*<em>*行*</em>**(row)*</em> *<em>和*</em> *<em>列*</em>*<em>(column)*</em> *<em>的形式存储数据，以便于用户理解。这一系列的行和列被 称为*</em> *<em>表*</em>*<em>(table)*</em> *<em>，一组表组成了一个库(database)。*</em>**</p>
<p>​     <em><strong>*SQL** **就是关系型数据库的查询语言。*</strong></em></p>
<h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a><strong>优势</strong></h4><p><strong>复杂查询</strong> 可以用 SQL 语句方便的在一个表以及多个表之间做非常复杂的数据查询。</p>
<p><strong>事务支持</strong> 使得对于安全性能很高的数据访问要求得以实现。</p>
<h3 id="非关系型数据库-非RDBMS"><a href="#非关系型数据库-非RDBMS" class="headerlink" title="非关系型数据库(非RDBMS)"></a><strong>非关系型数据库(非RDBMS)</strong></h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a><strong>介绍</strong></h4><p>​    <strong>非关系型数据库</strong> ，可看成传统关系型数据库的功能 阉割版本 ，基于键值对存储数据，不需要经过 SQL 层的解析， 性能非常高 。同时，通过减少不常用的功能，进一步提高性能。</p>
<p>目前基本上大部分主流的非关系型数据库都是免费的。</p>
<h4 id="有哪些非关系型数据库"><a href="#有哪些非关系型数据库" class="headerlink" title="有哪些非关系型数据库"></a><strong>有哪些非关系型数据库</strong></h4><p>​    相比于 SQL ， NoSQL 泛指非关系型数据库，包括了榜单上的键值型数据库、文档型数据库、搜索引擎和 列存储等，除此以外还包括图形数据库。也只有用 NoSQL 一词才能将这些技术囊括进来。</p>
<p><strong>键值型数据库</strong></p>
<p>​    键值型数据库通过 Key-Value 键值的方式来存储数据，其中 Key 和 Value 可以是简单的对象，也可以是复 杂的对象。Key 作为唯一的标识符，优点是查找速度快，在这方面明显优于关系型数据库，缺点是无法 像关系型数据库一样使用条件过滤（比如 WHERE ），如果你不知道去哪里找数据，就要遍历所有的键， 这就会消耗大量的计算。</p>
<p>​    键值型数据库典型的使用场景是作为 内存缓存 。 Redis 是最流行的键值型数据库。</p>
<p><img src="/2022/09/28/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8A)/20220928215250176.png" alt="img"></p>
<p><strong>文档型数据库</strong></p>
<p>​    此类数据库可存放并获取文档，可以是XML 、 JSON 等格式。在数据库中文档作为处理信息的基本单位一个文档就相当于一条记录。文档数据库所存放的文档，就相当于键值数据库所存放的“ 值 ” 。 MongoDB是最流行的文档型数据库。此外，还有CouchDB 等。</p>
<p><strong>搜索引擎数据库</strong></p>
<p>​    虽然关系型数据库采用了索引提升检索效率，但是针对全文索引效率却较低。搜索引擎数据库是应用在搜索引擎领域的数据存储形式，由于搜索引擎会爬取大量的数据，并以特定的格式进行存储，这样在检索的时候才能保证性能最优。核心原理是“ 倒排索引 ” 。</p>
<p>典型产品： Solr 、 Elasticsearch 、 Splunk 等。</p>
<p><strong>列式数据库</strong></p>
<p>​    列式数据库是相对于行式存储的数据库，Oracle 、 MySQL 、 SQLServer等数据库都是采用的行式存储 （ Row-based ），而列式数据库是将数据按照列存储到数据库中，这样做的好处是可以大量降低系统的 I&#x2F;O ，适合于分布式文件系统，不足在于功能相对有限。典型产品： HBase 等。</p>
<p><strong>图形数据库</strong></p>
<p>​    </p>
<p>​    图形数据库，利用了图这种数据结构存储了实体（对象）之间的关系。图形数据库最典型的例子就是社交网络中人与人的关系，数据模型主要是以<strong>节点和边（关系）</strong>来实现，特点在于能高效地解决复杂的关系问题。</p>
<p>​    图形数据库顾名思义，就是一种存储图形关系的数据库。它利用了图这种数据结构存储了实体（对象）之间的关系。关系型数据用于存储明确关系的数据，但对于复杂关系的数据存储却有些力不从心。如社交网络中人物之间的关系，如果用关系型数据库则非常复杂，用图形数据库将非常简单。典型产品： Neo4J、 InfoGrid 等。</p>
<h4 id="NoSQL的演变"><a href="#NoSQL的演变" class="headerlink" title="NoSQL的演变"></a><strong>NoSQL的演变</strong></h4><p>​    由于 SQL 一直称霸 DBMS ，因此许多人在思考是否有一种数据库技术能远离 SQL ，于是 NoSQL 诞生了， 但是随着发展却发现越来越离不开 SQL 。到目前为止 NoSQL 阵营中的 DBMS 都会有实现类似 SQL 的功 能。下面是“NoSQL” 这个名词在不同时期的诠释，从这些释义的变化中可以看出 NoSQL 功能的演变 ：</p>
<p>​    1970： NoSQL &#x3D; We have no SQL</p>
<p>​    1980： NoSQL &#x3D; Know SQL</p>
<p>​    2000： NoSQL &#x3D; No SQL!</p>
<p>​    2005： NoSQL &#x3D; Not only SQL</p>
<p>​    2013： NoSQL &#x3D; No, SQL!</p>
<p>​    NoSQL 对 SQL 做出了很好的补充，比如实际开发中，有很多业务需求，其实并不需要完整的关系型数据 库功能，非关系型数据库的功能就足够使用了。这种情况下，使用 性能更高 、 成本更低 的非关系型数据 库当然是更明智的选择。比如：日志收集、排行榜、定时器等。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a><strong>小结</strong></h3><p>​    NoSQL 的分类很多，即便如此，在 DBMS 排名中，还是 SQL 阵营的比重更大，影响力前 5 的 DBMS 中有 4 个是关系型数据库，而排名前 20 的 DBMS 中也有 12 个是关系型数据库。所以说，掌握 SQL 是非常有 必要的。整套课程将围绕 SQL 展开。</p>
<h2 id="关系型数据库设计规则"><a href="#关系型数据库设计规则" class="headerlink" title="关系型数据库设计规则"></a><strong>关系型数据库设计规则</strong></h2><p>​    关系型数据库的典型数据结构就是 数据表 ，这些数据表的组成都是结构化的（</p>
<p>Structured ）。</p>
<p>​    将数据放到表中，表再放到库中。</p>
<p>​    一个数据库中可以有多个表，每个表都有一个名字，用来标识自己。表名具有唯一性。</p>
<p>​    表具有一些特性，这些特性定义了数据在表中如何存储，类似Java 和 Python 中 “ 类 ” 的设计。</p>
<h3 id="表、记录、字段"><a href="#表、记录、字段" class="headerlink" title="表、记录、字段"></a><strong>表、记录、字段</strong></h3><p>​    E-R（entity-relationship，实体 - 联系）模型中有三个主要概念是： 实体集 、 属性 、 联系集 。</p>
<p>​    一个实体集（class）对应于数据库中的一个表（table），一个实体（instance）则对应于数据库表 中的一行（row），也称为一条记录（record）。一个属性（attribute）对应于数据库表中的一列 （column），也称为一个字段（field）。</p>
<p><img src="/2022/09/28/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8A)/20220928215250240.png" alt="img"></p>
<p> <strong>ORM思想</strong> <em>*<em>*(Object Relational Mapping)*</em>*<em>体现：*</em>*</em></p>
<p>​    <em>*<em>*数据库中的一个表 &lt;—&gt; Java*</em>*<em>或*</em>*<em>Python*</em>*<em>中的一个类*</em>*</em></p>
<p>​    <em><strong>*表中的一条数据 &lt;—&gt;** **类中的一个对象（或实体）*</strong></em></p>
<p>​    <em>*<em>*表中的一个列 &lt;—-&gt;*</em> *<em>类中的一个字段、属性*</em>**(field)*</em>**</p>
<h3 id="表的关联关系"><a href="#表的关联关系" class="headerlink" title="表的关联关系"></a><strong>表的关联关系</strong></h3><p>​    表与表之间的数据记录有关系(relationship) 。现实世界中的各种实体以及实体之间的各种联系均用 关系模型来表示。</p>
<p>​    四种：一对一关联、一对多关联、多对多关联、自我引用</p>
<h4 id="一对一关联（one-to-one）"><a href="#一对一关联（one-to-one）" class="headerlink" title="一对一关联（one-to-one）"></a><strong>一对一关联（one-to-one）</strong></h4><p>​    在实际的开发中应用不多，因为一对一可以创建成一张表。</p>
<p>​    举例：设计 学生表 ：学号、姓名、手机号码、班级、系别、身份证号码、家庭住址、籍贯、紧急 联系人、…</p>
<p>​    拆为两个表：两个表的记录是一一对应关系。</p>
<p>​        基础信息表 （常用信息）：学号、姓名、手机号码、班级、系别</p>
<p>​        档案信息表 （不常用信息）：学号、身份证号码、家庭住址、籍贯、紧急联系人、 …</p>
<p>​    <strong>两种建表原则：</strong></p>
<p>​        <em><strong>*外键唯一：主表的主键和从表的外键（唯一），形成主外键关系，外键唯一。*</strong></em></p>
<p>​        <strong>外键是主键：主表的主键和从表的主键，形成主外键关系。</strong></p>
<p><img src="/2022/09/28/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8A)/20220928215250274.png" alt="img"></p>
<h4 id="一对多关系（one-to-many）"><a href="#一对多关系（one-to-many）" class="headerlink" title="一对多关系（one-to-many）"></a><strong>一对多关系（one-to-many）</strong></h4><p>​    常见实例场景： 客户表和订单表 ， 分类表和商品表 ， 部门表和员工表 。</p>
<p>​    举例：</p>
<p>​        员工表：编号、姓名、…、所属部门</p>
<p>​        部门表：编号、名称、简介</p>
<p>​    <strong>一对多建表原则</strong>：在从表( 多方 ) 创建一个字段，字段作为外键指向主表 ( 一方 ) 的主键</p>
<p><img src="/2022/09/28/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8A)/20220928215250290.png" alt="img"></p>
<h4 id="多对多（many-to-many）"><a href="#多对多（many-to-many）" class="headerlink" title="多对多（many-to-many）"></a><strong>多对多（many-to-many）</strong></h4><p>​    要表示多对多关系，必须创建第三个表，该表通常称为 联接表 ，它将多对多关系划分为两个一对多关系。将这两个表的主键都插入到第三个表中。</p>
<p><img src="/2022/09/28/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8A)/20220928215251296.png" alt="img"></p>
<p><strong>举例</strong> <strong>1</strong> <strong>：学生</strong> <strong>-</strong> <strong>课程</strong></p>
<p>​    学生信息表 ：一行代表一个学生的信息（学号、姓名、手机号码、班级、系别 … ）    </p>
<p>​    课程信息表 ：一行代表一个课程的信息（课程编号、授课老师、简介 … ）</p>
<p>​    选课信息表 ：一个学生可以选多门课，一门课可以被多个学生选择</p>
<p><strong>举例</strong> <strong>2</strong> <strong>：产品</strong> <strong>-</strong> <strong>订单</strong></p>
<p>​    “订单 ” 表和 “ 产品 ” 表有一种多对多的关系，这种关系是通过与 “ 订单明细 ” 表建立两个一对多关系来 定义的。一个订单可以有多个产品，每个产品可以出现在多个订单中。</p>
<p>​    产品表 ： “ 产品 ” 表中的每条记录表示一个产品。</p>
<p>​    订单表 ： “ 订单 ” 表中的每条记录表示一个订单。</p>
<p>​    订单明细表 ：每个产品可以与 “ 订单 ” 表中的多条记录对应，即出现在多个订单中。一个订单 可以与“ 产品 ” 表中的多条记录对应，即包含多个产品。</p>
<p><img src="/2022/09/28/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8A)/20220928215251318.png" alt="img"></p>
<p><strong>举例</strong> <strong>3</strong> <strong>：用户</strong> <strong>-</strong> <strong>角色</strong></p>
<p>​    多对多关系建表原则：需要创建第三张表，中间表中至少两个字段，这两个字段分别作为外键指向</p>
<p>​    各自一方的主键。</p>
<p><img src="/2022/09/28/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8A)/20220928215251328.png" alt="img"></p>
<h4 id="自我引用-Self-reference"><a href="#自我引用-Self-reference" class="headerlink" title="自我引用(Self reference)"></a><strong>自我引用(Self reference)</strong></h4><p><img src="/2022/09/28/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8A)/20220928215251332.png" alt="img"></p>
<h1 id="MySQL-基本的SELECT语句"><a href="#MySQL-基本的SELECT语句" class="headerlink" title="MySQL 基本的SELECT语句"></a>MySQL 基本的SELECT语句</h1><h2 id="所查询的数据内容"><a href="#所查询的数据内容" class="headerlink" title="所查询的数据内容"></a>所查询的数据内容</h2><p><a href="https://download.csdn.net/download/weixin_65637841/85502597">mysql查询sql文件-数据集文档类资源-CSDN文库</a></p>
<h2 id="SELECT语句"><a href="#SELECT语句" class="headerlink" title="SELECT语句"></a><strong>SELECT语句</strong></h2><h3 id="SELECT…"><a href="#SELECT…" class="headerlink" title="SELECT…"></a><strong>SELECT…</strong></h3><p>​    SELECT 1 ;  # 没有任何子句</p>
<p>​    SELECT 9 &#x2F;2;  # 没有任何子句</p>
<p><img src="https://img-blog.csdnimg.cn/f0ba361cb169463f8ee0c7291a9e1739.png" alt="img"><img src="https://img-blog.csdnimg.cn/39840a68654d4f07a6d568ff7f0af590.png" alt="img"></p>
<h3 id="SELECT-…-FROM"><a href="#SELECT-…-FROM" class="headerlink" title="SELECT … FROM"></a><strong>SELECT … FROM</strong></h3><p><strong>语法：</strong></p>
<p>​    <strong>SELECT</strong> <em><strong>*标识选择哪些列*</strong></em></p>
<p>​    <em><strong>*FROM** **标识从哪个表中选择*</strong></em></p>
<p><em><strong>*查询所有列：*</strong></em></p>
<p>​    <strong>SELECT</strong> <strong><em>*</em>*</strong>*</p>
<p>​    <em><strong>*FROM** **表名;*</strong></em></p>
<p>（通配符*表示所有列）</p>
<p><img src="/2022/09/28/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8A)/20220928215252370.png" alt="img"></p>
<p>​    一般情况下，除非需要使用表中所有的字段数据，最好不要使用通配符‘*’ 。使用通配符虽然可以节 省输入查询语句的时间，但是获取不需要的列数据通常会降低查询和所使用的应用程序的效率。通 配符的优势是，当不知道所需要的列的名称时，可以通过它获取它们。</p>
<p>在生产环境下，不推荐你直接使用 SELECT * 进行查询。</p>
<p><strong>查询特定的列：</strong></p>
<p>​    <strong>SELECT</strong> <em><strong>*字段名1, 字段名2，字段名3…*</strong></em></p>
<p>​    <em><strong>*FROM** **departments;*</strong></em></p>
<p><img src="/2022/09/28/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8A)/20220928215252382.png" alt="img"></p>
<p>​    MySQL中的 SQL 语句是不区分大小写的，因此 SELECT 和 select 的作用是相同的，但是，许多开发人员习惯将关键字大写、数据列和表名小写，读者也应该养成一个良好的编程习惯，这样写出来的代码更容易阅读和维护。</p>
<h3 id="列的别名"><a href="#列的别名" class="headerlink" title="列的别名"></a><strong>列的别名</strong></h3><p><em><strong>*重命名一个列*</strong></em></p>
<p><em><strong>*便于计算*</strong></em></p>
<p><em>*<em>*紧跟列名，也可以*</em>*<em>在列名和别名之间加入关键字*</em>*<em>AS*</em>*<em>，别名使用双引号*</em>*<em>，以便在别名中包含空格或特殊的字符并区分大小写。*</em>*</em></p>
<p><em><strong>*AS** **可以省略*</strong></em></p>
<p><em><strong>*建议别名简短，见名知意*</strong></em></p>
<p><img src="/2022/09/28/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8A)/20220928215252400.png" alt="img"></p>
<h3 id="去除重复行"><a href="#去除重复行" class="headerlink" title="去除重复行"></a>去除重复行</h3><p><em>*<em>*语法*</em>*<em>：*</em>*</em> <strong>在</strong> <strong>SELECT</strong> <strong>语句中使用关键字</strong> <strong>DISTINCT</strong> <strong>去除重复行</strong></p>
<p>​    <strong>SELECT DISTINCT</strong> <em><strong>*字段名1, 字段名2，字段名3…*</strong></em></p>
<p>​    <em><strong>*FROM** **表名;*</strong></em></p>
<p><img src="/2022/09/28/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8A)/20220928215252412.png" alt="img"></p>
<p><img src="/2022/09/28/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8A)/20220928215252414.png" alt="img"></p>
<p>注：</p>
<p>​    \1. DISTINCT 需要放到所有列名的前面，如果写成 SELECT salary, DISTINCTdepartment_id FROM employees 会报错。</p>
<p>​    \2. DISTINCT 其实是对后面所有列名的组合进行去重，你能看到最后的结果是 74 条，因为这 74 个部门id 不同，都有 salary 这个属性值。如果你想要看都有哪些不同的部门（</p>
<p>department_id ），只需要写 DISTINCT department_id 即可，后面不需要再加其他的列名了。</p>
<h3 id="空值参与运算"><a href="#空值参与运算" class="headerlink" title="空值参与运算"></a><strong>空值参与运算</strong></h3><p>​    <em>*<em>*所有运算符或列值遇到null*</em>*<em>值，运算的结果都为*</em>*<em>null*</em>*</em></p>
<p>​    这里你一定要注意，在 MySQL 里面， 空值不等于空字符串。一个空字符串的长度是 0 ，而一个空值的长度是空。而且，在 MySQL 里面，空值是占用空间的。</p>
<p><img src="/2022/09/28/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8A)/20220928215252432.png" alt="img"></p>
<p>解决年工资为null的方法，引入IFNULL函数： <img src="/2022/09/28/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8A)/20220928215253434.png" alt="img"></p>
<h3 id="着重号"><a href="#着重号" class="headerlink" title="着重号"></a><strong>着重号</strong></h3><p>​    <strong>我们需要保证表中的字段、表名等没有和保留字、数据库系统或常用方法冲突。如果真的相同，请在 SQL语句中使用一对&#96;&#96;</strong> <em><strong>*（着重号）引起来*</strong></em></p>
<p><img src="/2022/09/28/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8A)/20220928215253442.png" alt="img"></p>
<p> <img src="/2022/09/28/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8A)/20220928215253444.png" alt="img"></p>
<h3 id="查询常数"><a href="#查询常数" class="headerlink" title="查询常数"></a><strong>查询常数</strong></h3><p>​    SELECT 查询还可以对常数进行查询。对的，就是在 SELECT 查询结果中增加一列固定的常数列。这列的 取值是我们指定的，而不是从数据表中动态取出的。</p>
<p>为什么我们还要对常数进行查询呢？</p>
<p>​    SQL 中的 SELECT 语法的确提供了这个功能，一般来说我们只从一个表中查询数据，通常不需要增加一个固定的常数列，但如果我们想整合不同的数据源，用常数列作为这个表的标记，就需要查询常数。</p>
<p><img src="/2022/09/28/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8A)/20220928215253454.png" alt="img"></p>
<h2 id="显示表结构"><a href="#显示表结构" class="headerlink" title="显示表结构"></a><strong>显示表结构</strong></h2><p>​    使用DESCRIBE 或 DESC 命令，表示表结构。</p>
<p><em><strong>*语法：*</strong></em></p>
<p>​    DESCRIBE employees;</p>
<p>​    或</p>
<p>​    DESC employees;</p>
<p><img src="/2022/09/28/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8A)/20220928215253470.png" alt="img"></p>
<p><em><strong>*其中，各个字段的含义分别解释如下：*</strong></em></p>
<p>​    <em><strong>*Field：表示字段名称。*</strong></em></p>
<p>​    <em>*<em>*Type：表示字段类型，这里*</em> *<em>barcode*</em>*<em>、*</em>*<em>goodsname*</em> *<em>是文本型的，*</em>*<em>price*</em> *<em>是整数类型的。*</em>*</em></p>
<p>​    <em>*<em>*Null：表示该列是否可以存储*</em>*<em>NULL*</em>*<em>值。*</em>*</em></p>
<p>​    <em>*<em>*Key：表示该列是否已编制索引。*</em>*<em>PRI*</em>*<em>表示该列是表主键的一部分；*</em>*<em>UNI*</em>*<em>表示该列是*</em>*<em>UNIQUE*</em>*<em>索引的一 部分；MUL*</em>*<em>表示在列中某个给定值允许出现多次。*</em>*</em></p>
<p>​    <em><strong>*Default：表示该列是否有默认值，如果有，那么值是多少。*</strong></em></p>
<p>​    <em>*<em>*Extra：表示可以获取的与给定列有关的附加信息，例如*</em>*<em>AUTO_INCREMENT*</em>*<em>等。*</em>*</em></p>
<h2 id="过滤数据"><a href="#过滤数据" class="headerlink" title="过滤数据"></a><strong>过滤数据</strong></h2><p><img src="/2022/09/28/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8A)/20220928215253490.png" alt="img"></p>
<p> <strong>语法：</strong></p>
<p>​    <strong>SELECT</strong> <em>*<em>*字段*</em>*<em>1,*</em>*<em>字段*</em>*<em>2*</em>*</em></p>
<p>​    <em><strong>*FROM** **表名*</strong></em></p>
<p>​    <em><strong>*WHERE** **过滤条件*</strong></em></p>
<p><em>*<em>*使用*</em>*<em>WHERE*</em> *<em>子句，将不满足条件的行过滤掉*</em>*</em></p>
<p><em>*<em>*WHERE*</em>*<em>子句紧随*</em> *<em>FROM*</em>*<em>子句*</em>*</em></p>
<p><img src="/2022/09/28/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8A)/20220928215254504.png" alt="img"></p>
<p> <img src="/2022/09/28/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8A)/20220928215254506.png" alt="img"></p>
<h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p>\1. 查询employees表中员工 12 个月的工资总和，并起别名为 ANNUAL SALARY</p>
<p><img src="/2022/09/28/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8A)/20220928215254512.png" alt="img"></p>
<p>\2. 查询 employees 表中去除重复的 job_id 以后的数据</p>
<p><img src="/2022/09/28/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8A)/20220928215254518.png" alt="img"></p>
<p>\3. 查询工资大于 12000 的员工姓名和工资</p>
<p><img src="/2022/09/28/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8A)/20220928215254524.png" alt="img"></p>
<p>\4. 查询员工号为 176 的员工的姓名和部门号</p>
<p><img src="/2022/09/28/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8A)/20220928215254530.png" alt="img"></p>
<p>\5. 显示表 departments 的结构，并查询其中的全部数据</p>
<p><img src="/2022/09/28/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8A)/20220928215255536.png" alt="img"></p>
<p><img src="/2022/09/28/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8A)/20220928215255538.png" alt="img"> </p>
<h1 id="MySQL运算符"><a href="#MySQL运算符" class="headerlink" title="MySQL运算符"></a>MySQL运算符</h1><h2 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a><strong>算术运算符</strong></h2><p><img src="/2022/09/28/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8A)/20220928215255544.png" alt="img"></p>
<h3 id="加法与减法运算符"><a href="#加法与减法运算符" class="headerlink" title="加法与减法运算符"></a><strong>加法与减法运算符</strong></h3><p>​    <strong>1.一个整数类型的值对整数进行加法和减法操作，结果还是一个整数；</strong></p>
<p>​    <strong>2.一个整数类型的值对浮点数进行加法和减法操作，结果是一个浮点数；</strong></p>
<p>​    <strong>3.加法和减法的优先级相同，进行先加后减操作与进行先减后加操作的结果是一样的；</strong></p>
<p><img src="/2022/09/28/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8A)/20220928215255554.png" alt="img"></p>
<p>​    <em><strong>*4.在Java中，+的左右两边如果有字符串，那么表示字符串的拼接。但是在MySQL中+只表示数 值相加。如果遇到非数值类型，先尝试转成数值(隐式转换)，如果转失败，就按0计算。（补充：MySQL 中字符串拼接要使用字符串函数CONCAT()实现）*</strong></em></p>
<p><img src="/2022/09/28/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8A)/20220928215255560.png" alt="img"></p>
<h3 id="乘法与除法运算符"><a href="#乘法与除法运算符" class="headerlink" title="乘法与除法运算符"></a><strong>乘法与除法运算符</strong></h3><p>​     <strong>1.一个数乘以整数1和除以整数1后仍得原数；</strong></p>
<p>​    <strong>2.一个数乘以浮点数1和除以浮点数1后变成浮点数，数值与原数相等；</strong></p>
<p>​    <strong>3.一个数除以整数后，不管是否能除尽，结果都为一个浮点数；</strong></p>
<p>​    <strong>4.一个数除以另一个数，除不尽时，结果为一个浮点数，并保留到小数点后4位；</strong></p>
<p>​    <strong>5.乘法和除法的优先级相同，进行先乘后除操作与先除后乘操作，得出的结果相同。</strong></p>
<p>​    <strong>6.在数学运算中，0不能用作除数，在MySQL中，一个数除以0为NULL。</strong></p>
<p><img src="/2022/09/28/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8A)/20220928215255576.png" alt="img"></p>
<h3 id="求模（求余）运算符"><a href="#求模（求余）运算符" class="headerlink" title="求模（求余）运算符"></a><strong>求模（求余）运算符</strong></h3><p><img src="/2022/09/28/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8A)/20220928215255580.png" alt="img"></p>
<p> <img src="/2022/09/28/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8A)/20220928215255582.png" alt="img"></p>
<p><strong>筛选出employee_id是偶数的员工</strong></p>
<p><img src="/2022/09/28/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8A)/20220928215255586.png" alt="img"></p>
<h2 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a><strong>比较运算符</strong></h2><p>​    <strong>比较运算符用来对表达式左边的操作数和右边的操作数进行比较，比较的结果为真则返回1</strong> <em>*<em>*，比较的结果 为假则返回0*</em>*<em>，其他情况则返回*</em>*<em>NULL*</em>*<em>。*</em>*</em></p>
<p>​    <em>*<em>*比较运算符经常被用来作为SELECT*</em>*<em>查询语句的条件来使用，返回符合条件的结果记录。*</em>*</em></p>
<h3 id="符号型比较运算符"><a href="#符号型比较运算符" class="headerlink" title="符号型比较运算符"></a>符号型比较运算符</h3><p><img src="/2022/09/28/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8A)/20220928215256598.png" alt="img"></p>
<p>这里着重说明 “&#x3D; “与” &lt;&#x3D;&gt;”<a href="https://so.csdn.net/so/search?q=%E8%BF%90%E7%AE%97%E7%AC%A6&spm=1001.2101.3001.7020">运算符</a> </p>
<h4 id="等号运算符"><a href="#等号运算符" class="headerlink" title="等号运算符"></a><strong>等号运算符</strong></h4><p>​    等号运算符（&#x3D;）判断等号两边的值、字符串或表达式是否相等，如果相等则返回1 ，不相等则返回 0。</p>
<p><strong>在使用等号运算符时，遵循如下规则：</strong></p>
<p>​    <strong>1.如果等号两边的值、字符串或表达式都为字符串，则MySQL会按照字符串进行比较，其比较的 是每个字符串中字符的ANSI（实际为ascii码比较）编码是否相等。</strong></p>
<p><img src="/2022/09/28/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8A)/20220928215256610.png" alt="img"></p>
<p>​     <strong>2.如果等号两边的值都是整数，则MySQL会按照整数来比较两个值的大小。</strong></p>
<p>​     <strong>3.如果等号两边的值一个是整数，另一个是字符串，则MySQL会将字符串转化为数字进行比较。</strong></p>
<p><img src="/2022/09/28/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8A)/20220928215256616.png" alt="img"></p>
<p>​    <strong>4.如果等号两边的值、字符串或表达式中有一个为NULL，则比较结果为NULL。</strong></p>
<p><img src="/2022/09/28/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8A)/20220928215256620.png" alt="img"></p>
<p> <img src="/2022/09/28/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8A)/20220928215256622.png" alt="img"></p>
<h4 id="安全等于运算符"><a href="#安全等于运算符" class="headerlink" title="安全等于运算符"></a><strong>安全等于运算符</strong></h4><p>​    <strong>安全等于运算符（&lt;&#x3D;&gt;）与等于运算符（&#x3D;）的作用是相似的，</strong> <em>*<em>*唯一的区别*</em> *<em>是*</em>*<em>‘&lt;&#x3D;&gt;’*</em>*<em>可*</em>*</em></p>
<p><em>*<em>*以用来对*</em>*<em>NULL*</em>*<em>进行判断。在两个操作数均为*</em>*<em>NULL*</em>*<em>时，其返回值为*</em>*<em>1*</em>*<em>，而不为*</em>*<em>NULL*</em>*<em>；当一个操作数为*</em>*<em>NULL 时，其返回值为0*</em>*<em>，而不为*</em>*<em>NULL*</em>*<em>。*</em>*</em></p>
<p>​       <img src="/2022/09/28/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8A)/20220928215256632.png" alt="img"></p>
<p>​       <img src="/2022/09/28/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8A)/20220928215256634.png" alt="img"></p>
<p> <img src="/2022/09/28/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8A)/20220928215256636.png" alt="img"></p>
<h3 id="非符号型比较运算符"><a href="#非符号型比较运算符" class="headerlink" title="非符号型比较运算符"></a>非符号型比较运算符</h3><p>  <img src="/2022/09/28/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8A)/20220928215256640.png" alt="img"></p>
<p> <img src="/2022/09/28/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8A)/20220928215256642.png" alt="img"></p>
<h4 id="空运算符"><a href="#空运算符" class="headerlink" title="空运算符"></a><strong>空运算符</strong></h4><p>​    <strong>空运算符（IS NULL或者ISNULL</strong> <em>*<em>*）判断一个值是否为*</em>*<em>NULL*</em>*<em>，如果为*</em>*<em>NULL*</em>*<em>则返回*</em>*<em>1*</em>*<em>，否则返回 0。*</em>*</em> </p>
<p><img src="/2022/09/28/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8A)/20220928215257648.png" alt="img"></p>
<h4 id="非空运算符"><a href="#非空运算符" class="headerlink" title="非空运算符"></a><strong>非空运算符</strong></h4><p>​    <strong>非空运算符（IS NOT NULL）判断一个值是否不为NULL</strong> <em>*<em>*，如果不为*</em>*<em>NULL*</em>*<em>则返回*</em>*<em>1*</em>*<em>，否则返回0*</em>*<em>。*</em>*</em></p>
<p> <img src="/2022/09/28/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8A)/20220928215257656.png" alt="img"></p>
<h4 id="最小值运算符与最大值运算符"><a href="#最小值运算符与最大值运算符" class="headerlink" title="最小值运算符与最大值运算符"></a><strong>最小值运算符与最大值运算符</strong></h4><p><em><strong>*LEAST 与 GREATEST*</strong></em></p>
<ul>
<li><strong>如果任何参数为<a href="http://www.yiibai.com/mysql/null.html">NULL</a>，则两个函数都将立即返回<code>NULL</code>，而不进行任何比较。</strong></li>
<li><strong>如果在<a href="http://www.yiibai.com/mysql/int.html">INT</a>或<code>REAL</code>上下文中使用函数，或者所有参数都是整数值或<code>REAL</code>值，那么它们将分别作为<code>INT</code>和<code>REAL</code>来比较。</strong></li>
<li><strong>如果参数由数字和字符串组成，则函数将它们作为数字进行比较。</strong></li>
<li><strong>如果至少一个参数是非二进制(字符)字符串，则函数将将参数作为非二进制字符串进行比较。</strong></li>
<li><strong>在所有其他情况下，函数将参数作为二进制字符串进行比较</strong></li>
</ul>
<p><strong>最小值运算符（</strong> LEAST <strong>）</strong></p>
<p>​    语法格式为：LEAST( 值 1 ，值 2 ， … ，值 n) 。其中， “ 值 n” 表示参数列表中有 n 个值。在有</p>
<p>两个或多个参数的情况下，返回最小值。</p>
<p><img src="/2022/09/28/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8A)/20220928215257678.png" alt="img"></p>
<p><strong>最大值运算符</strong></p>
<p>​     语法格式为： GREATEST( 值 1 ，值 2 ， … ，值 n) 。其中， n 表示参数列表中有 n 个值。当有 两个或多个参数时，返回值为最大值。</p>
<p><img src="/2022/09/28/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8A)/20220928215257684.png" alt="img"></p>
<h4 id="BETWEEN-AND运算符"><a href="#BETWEEN-AND运算符" class="headerlink" title="BETWEEN AND运算符"></a><strong>BETWEEN AND运算符</strong></h4><p>BETWEEN运算符使用的<strong>格式</strong>通常为:</p>
<p>​     <strong>SELECT 字段列表</strong></p>
<p>​    <strong>FROM 表名</strong></p>
<p>​    <strong>WHERE C BETWEEN A AND B</strong></p>
<p><em>*<em>*此时，当C*</em>*<em>大于或等*</em>*<em>于*</em>*<em>A*</em>*<em>，并且*</em>*<em>C*</em>*<em>小于或等于*</em>*<em>B*</em>*<em>时，结果为*</em>*<em>1*</em>*<em>，否则结果为*</em>*<em>0*</em>*<em>。*</em>*</em></p>
<p><em><strong>*(A为条件下界，B为条件上界 A&lt;B)*</strong></em></p>
<p><img src="/2022/09/28/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8A)/20220928215257702.png" alt="img"></p>
<p> <img src="/2022/09/28/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8A)/20220928215257704.png" alt="img"></p>
<h4 id="IN运算符-与-NOT-IN运算符"><a href="#IN运算符-与-NOT-IN运算符" class="headerlink" title="IN运算符 与 NOT IN运算符"></a><strong>IN运算符 与 NOT IN运算符</strong></h4><p><strong>语法格式：</strong>    </p>
<p><strong>SELECT 字段列表</strong></p>
<p>​    <strong>FROM 表名</strong></p>
<p>​    <strong>WHERE 所求区间的字段名（NOT） IN(</strong> 值1,值2… <strong>)</strong></p>
<p><strong>IN</strong> <strong>运算符</strong></p>
<p>​     IN 运算符用于判断给定的值是否是 IN 列表中的一个值，如果是则返回 1 ，否则返回 0 。如果给 定的值为NULL ，或者 IN 列表中存在 NULL ，则结果为 NULL 。</p>
<p><img src="/2022/09/28/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8A)/20220928215257722.png" alt="img"></p>
<p><strong>NOT IN</strong> <strong>运算符</strong></p>
<p>​     NOT IN 运算符用于判断给定的值是否不是 IN 列表中的一个值，如果不是 IN 列表中的一</p>
<p>个值，则返回 1 ，否则返回 0 。</p>
<p><img src="/2022/09/28/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8A)/20220928215258730.png" alt="img"></p>
<h4 id="LIKE运算符"><a href="#LIKE运算符" class="headerlink" title="LIKE运算符"></a><strong>LIKE运算符</strong></h4><p>​    LIKE运算符主要用来匹配字符串，通常用于模糊匹配，如果满足条件则返回 1 ，否则返回 0。如果给定的值或者匹配条件为 NULL ，则返回结果为 NULL 。</p>
<p><strong>通配符：</strong></p>
<p>​    <strong>“%”：匹配0个或多个字符。</strong></p>
<p>​    <strong>“_”：只能匹配一个字符。</strong></p>
<p><strong>转义字符：“\”</strong></p>
<p><img src="/2022/09/28/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8A)/20220928215258746.png" alt="img"></p>
<p> <img src="/2022/09/28/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8A)/20220928215258748.png" alt="img"></p>
<p> <img src="/2022/09/28/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8A)/20220928215258750.png" alt="img"></p>
<p><img src="/2022/09/28/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8A)/20220928215258752.png" alt="img"></p>
<h4 id="正则表达式运算符（REGEXP-x2F-RLIKE）"><a href="#正则表达式运算符（REGEXP-x2F-RLIKE）" class="headerlink" title="正则表达式运算符（REGEXP &#x2F; RLIKE）"></a><strong>正则表达式运算符（</strong>REGEXP &#x2F; RLIKE<strong>）</strong></h4><p>​    <strong>REGEXP运算符用来匹配字符串，语法格式为：</strong> <em>*<em>*expr REGEXP*</em> *<em>匹配条件*</em> *<em>。如果*</em>*<em>expr*</em>*<em>满足匹配条件，返回 1；如果不满足，则返回*</em>*<em>0*</em>*<em>。若*</em>*<em>expr*</em>*<em>或匹配条件任意一个为*</em>*<em>NULL*</em>*<em>，则结果为*</em>*<em>NULL*</em>*<em>。*</em>*</em></p>
<p>​    MySQL中使用 REGEXP 关键字指定正则表达式的字符匹配模式。下表列出了 REGEXP 操作符中常用字符匹配 列表。</p>
<p><img src="/2022/09/28/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8A)/20220928215258762.png" alt="img"></p>
<p><img src="/2022/09/28/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8A)/20220928215258764.png" alt="img"></p>
<p> <img src="/2022/09/28/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8A)/20220928215259766.png" alt="img"></p>
<h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a><strong>逻辑运算符</strong></h2><p>​    逻辑运算符主要用来判断表达式的真假，在MySQL 中，逻辑运算符的返回结果为 1 、 0 或者 NULL 。</p>
<p>​    MySQL中支持 4 种逻辑运算符如下：</p>
<p><img src="/2022/09/28/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8A)/20220928215259774.png" alt="img"></p>
<h3 id="逻辑非运算符"><a href="#逻辑非运算符" class="headerlink" title="逻辑非运算符"></a><strong>逻辑非运算符</strong></h3><p>​    <strong>逻辑非（NOT</strong> <em>*<em>*或*</em>**!*</em>*<em>）运算符表示当给定的值为*</em>*<em>0*</em>*<em>时返回*</em>*<em>1*</em>*<em>；当给定的值为非*</em>*<em>0*</em>*<em>值时返回*</em>*<em>0*</em>*<em>；*</em>**</p>
<p><em>*<em>*当给定的值为*</em>*<em>NULL*</em>*<em>时，返回*</em>*<em>NULL*</em>*<em>。*</em>*</em></p>
<p><img src="/2022/09/28/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8A)/20220928215259784.png" alt="img"></p>
<p> <img src="/2022/09/28/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8A)/20220928215259786.png" alt="img"></p>
<h3 id="逻辑与运算符"><a href="#逻辑与运算符" class="headerlink" title="逻辑与运算符"></a><strong>逻辑与运算符</strong></h3><p>​    <strong>逻辑与（AND或&amp;&amp;</strong> <em>*<em>*）运算符是当给定的所有值均为非*</em>*<em>0*</em>*<em>值，并且都不为*</em>*<em>NULL*</em>*<em>时，返回*</em>*</em></p>
<p><em>*<em>*1*</em>*<em>；*</em>*<em>当给定的一个值或者多个值为0时则返回0(0 &amp;&amp; NULL 返回0)*</em>*<em>；否则返回*</em>*<em>NULL*</em>*<em>。*</em>*</em></p>
<p><img src="/2022/09/28/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8A)/20220928215259796.png" alt="img"></p>
<p> <img src="/2022/09/28/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8A)/20220928215259798.png" alt="img"></p>
<h3 id="逻辑或运算符"><a href="#逻辑或运算符" class="headerlink" title="逻辑或运算符"></a><strong>逻辑或运算符</strong></h3><p>​    <strong>逻辑或（OR或||</strong> <em>*<em>*）运算符是当给定的值都不为*</em>*<em>NULL*</em>*<em>，并且任何一个值为非*</em>*<em>0*</em>*<em>值时，则返*</em>*</em></p>
<p><em>*<em>*回*</em>*<em>1*</em>*<em>，否则返回*</em>*<em>0*</em>*<em>；*</em>*<em>当一个值为NULL，并且另一个值为非0值时，返回1*</em>*<em>，否则返回*</em>*<em>NULL*</em>*<em>；当两个值都为 NULL时，返回*</em>*<em>NULL*</em>*<em>。*</em>*</em></p>
<p><img src="/2022/09/28/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8A)/20220928215259808.png" alt="img"></p>
<p><img src="/2022/09/28/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8A)/20220928215259810.png" alt="img"></p>
<p><strong>注意：</strong></p>
<p>​    <strong>OR可以和AND一起使用，但是在使用时要注意两者的优先级，由于AND的优先级高于OR，因此先 对AND两边的操作数进行操作，再与OR中的操作数结合。</strong></p>
<h3 id="逻辑异或运算符"><a href="#逻辑异或运算符" class="headerlink" title="逻辑异或运算符"></a><strong>逻辑异或运算符</strong></h3><p>​    <strong>逻辑异或（XOR）运算符是当给定的值中任意一个值为NULL</strong> <em>*<em>*时，则返回*</em>*<em>NULL*</em>*<em>；如果*</em>*</em></p>
<p><em>*<em>*两个非*</em>*<em>NULL*</em>*<em>的值都是*</em>*<em>0*</em>*<em>或者都不等于*</em>*<em>0*</em>*<em>时，则返回*</em>*<em>0*</em>*<em>；如果一个值为*</em>*<em>0*</em>*<em>，另一个值不为*</em>*<em>0*</em>*<em>时，则返回*</em>*<em>1*</em>*<em>。*</em>*</em></p>
<p><img src="/2022/09/28/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8A)/20220928215259824.png" alt="img"></p>
<p> <img src="/2022/09/28/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8A)/20220928215300826.png" alt="img"></p>
<h2 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a><strong>位运算符</strong></h2><p>​    位运算符是在二进制数上进行计算的运算符。位运算符会先将操作数变成二进制数，然后进行位运算， 最后将计算结果从二进制变回十进制数。</p>
<p>​    MySQL支持的位运算符如下：</p>
<p><img src="/2022/09/28/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8A)/20220928215300836.png" alt="img"></p>
<h3 id="amp-运算符"><a href="#amp-运算符" class="headerlink" title="&amp; , | , ^ 运算符"></a>&amp; , | , ^ 运算符</h3><p><em>*<em>*1*</em>*<em>．按位与运算符*</em>*</em></p>
<p>​    <em><strong>*按位与（&amp;）运算符将给定值对应的二进制数逐位进行逻辑与运算。当给定值对应的二*</strong></em></p>
<p><em>*<em>*进制位的数值都为*</em>*<em>1*</em>*<em>时，则该位返回*</em>*<em>1*</em>*<em>，否则返回*</em>*<em>0*</em>*<em>。*</em>*</em></p>
<p><em><strong>*2.** **按位或运算符*</strong></em></p>
<p>​    <em><strong>*按位或（|）运算符将给定的值对应的二进制数逐位进行逻辑或运算。当给定值对应的*</strong></em></p>
<p><em>*<em>*二进制位的数值有一个或两个为*</em>*<em>1*</em>*<em>时，则该位返回*</em>*<em>1*</em>*<em>，否则返回*</em>*<em>0*</em>*<em>。*</em>*</em></p>
<p><em><strong>*3.** **按位异或运算符*</strong></em></p>
<p>​    <em><strong>*按位异或（^）运算符将给定的值对应的二进制数逐位进行逻辑异或运算。当给定值*</strong></em></p>
<p><em>*<em>*对应的二进制位的数值不同时，则该位返回*</em>*<em>1*</em>*<em>，否则返回*</em>*<em>0*</em>*<em>。*</em>*</em></p>
<p><img src="/2022/09/28/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8A)/20220928215300858.png" alt="img"></p>
<p> 解释说明：</p>
<p><img src="/2022/09/28/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8A)/20220928215300862.png" alt="img"></p>
<h3 id="按位取反运算符"><a href="#按位取反运算符" class="headerlink" title="按位取反运算符"></a><strong>按位取反运算符</strong></h3><p>​    按位取反（~）运算符将给定的值的二进制数逐位进行取反操作，即将1变为0，将0变</p>
<p>为 1</p>
<p><img src="/2022/09/28/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8A)/20220928215300870.png" alt="img"></p>
<p> 解释：</p>
<p><img src="/2022/09/28/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8A)/20220928215300874.png" alt="img"></p>
<h3 id="gt-gt-与-lt-lt-运算符"><a href="#gt-gt-与-lt-lt-运算符" class="headerlink" title="&gt;&gt; 与 &lt;&lt; 运算符"></a><strong>&gt;&gt; 与 &lt;&lt; 运算符</strong></h3><p><em><strong>*1.** **按位右移运算符*</strong></em></p>
<p>​    <em><strong>*按位右移（&gt;&gt;）运算符将给定的值的二进制数的所有位右移指定的位数。右移指定的*</strong></em></p>
<p><em>*<em>*位数后，右边低位的数值被移出并丢弃，左边高位空出的位置用*</em>*<em>0*</em>*<em>补齐。*</em>*</em></p>
<p><em><strong>*2.** **按位左移运算符*</strong></em></p>
<p>​    <em><strong>*按位左移（&lt;&lt;）运算符将给定的值的二进制数的所有位左移指定的位数。左移指定的*</strong></em></p>
<p><em>*<em>*位数后，左边高位的数值被移出并丢弃，右边低位空出的位置用*</em>*<em>0*</em>*<em>补齐。*</em>*</em></p>
<p><img src="/2022/09/28/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8A)/20220928215300890.png" alt="img"></p>
<h2 id="运算符的优先级"><a href="#运算符的优先级" class="headerlink" title="运算符的优先级"></a><strong>运算符的优先级</strong></h2><p><img src="/2022/09/28/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8A)/20220928215300894.png" alt="img"></p>
<p>​    <strong>数字编号越大，优先级越高，优先级高的运算符先进行计算。可以看到，赋值运算符的优先级最低，使 用“()”括起来的表达式的优先级最高</strong>。</p>
<h2 id="练习-1"><a href="#练习-1" class="headerlink" title="练习"></a>练习</h2><p>【题目】</p>
<p># 1. 选择工资不在 5000 到 12000 的员工的姓名和工资</p>
<p># 2. 选择在 20 或 50 号部门工作的员工姓名和部门号</p>
<p># 3. 选择公司中没有管理者的员工姓名及 job_id</p>
<p># 4. 选择公司中有奖金的员工姓名，工资和奖金级别</p>
<p># 5. 选择员工姓名的第三个字母是 a 的员工姓名</p>
<p># 6. 选择姓名中有字母 a 和 k 的员工姓名</p>
<p># 7. 显示出表 employees 表中 first_name 以 ‘e’ 结尾的员工信息</p>
<p># 8. 显示出表 employees 部门编号在 80-100 之间的姓名、工种</p>
<p># 9. 显示出表 employees 的 manager_id 是 100,101,110 的员工姓名、工资、管理者 id</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 答案</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># <span class="number">1.</span>选择工资不在<span class="number">5000</span>到<span class="number">12000</span>的员工的姓名和工资</span><br><span class="line">    <span class="keyword">SELECT</span> last_name,salary</span><br><span class="line">    <span class="keyword">FROM</span> employees</span><br><span class="line">    <span class="keyword">WHERE</span> salary <span class="keyword">NOT</span> <span class="keyword">BETWEEN</span> <span class="number">5000</span> <span class="keyword">AND</span> <span class="number">12000</span>;</span><br><span class="line"></span><br><span class="line"># <span class="number">2.</span>选择在<span class="number">20</span>或<span class="number">50</span>号部门工作的员工姓名和部门号 </span><br><span class="line">    <span class="keyword">SELECT</span> last_name,department_id</span><br><span class="line">    <span class="keyword">FROM</span> employees</span><br><span class="line">    <span class="keyword">WHERE</span> department_id <span class="keyword">IN</span>(<span class="number">20</span>,<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line"># <span class="number">3.</span>选择公司中没有管理者的员工姓名及job_id </span><br><span class="line">    <span class="keyword">SELECT</span> last_name,job_id</span><br><span class="line">    <span class="keyword">FROM</span> employees</span><br><span class="line">    <span class="keyword">WHERE</span> manager_id <span class="keyword">IS</span> <span class="keyword">NULL</span>;</span><br><span class="line"></span><br><span class="line"># <span class="number">4.</span>选择公司中有奖金的员工姓名，工资和奖金级别 </span><br><span class="line">    <span class="keyword">SELECT</span> last_name,salary,commission_pct</span><br><span class="line">    <span class="keyword">FROM</span> employees</span><br><span class="line">    <span class="keyword">WHERE</span> commission_pct <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>;</span><br><span class="line"># <span class="number">5.</span>选择员工姓名的第三个字母是a的员工姓名 </span><br><span class="line">    <span class="keyword">SELECT</span> last_name</span><br><span class="line">    <span class="keyword">FROM</span> employees</span><br><span class="line">    <span class="keyword">WHERE</span> last_name <span class="keyword">LIKE</span> <span class="string">&#x27;__a%&#x27;</span>;</span><br><span class="line"># <span class="number">6.</span>选择姓名中有字母a和k的员工姓名 </span><br><span class="line">    <span class="keyword">SELECT</span> last_name</span><br><span class="line">    <span class="keyword">FROM</span> employees</span><br><span class="line">    <span class="keyword">WHERE</span> last_name REGEXP <span class="string">&#x27;[a]&#x27;</span> <span class="keyword">AND</span> last_name REGEXP <span class="string">&#x27;[K]&#x27;</span>; </span><br><span class="line"></span><br><span class="line"> # 或</span><br><span class="line">    <span class="keyword">SELECT</span> last_name</span><br><span class="line">    <span class="keyword">FROM</span> employees</span><br><span class="line">    <span class="keyword">WHERE</span> last_name <span class="keyword">LIKE</span> <span class="string">&#x27;%a%k%&#x27;</span> <span class="keyword">OR</span> last_name <span class="keyword">LIKE</span> <span class="string">&#x27;%k%a%&#x27;</span>;</span><br><span class="line"></span><br><span class="line"># <span class="number">7.</span>显示出表 employees 表中 first_name 以 <span class="string">&#x27;e&#x27;</span>结尾的员工信息 </span><br><span class="line">    <span class="keyword">SELECT</span> last_name</span><br><span class="line">    <span class="keyword">FROM</span> employees</span><br><span class="line">    <span class="keyword">WHERE</span> last_name REGEXP <span class="string">&#x27;e$&#x27;</span>;</span><br><span class="line"></span><br><span class="line"> # 或</span><br><span class="line">    <span class="keyword">SELECT</span> last_name</span><br><span class="line">    <span class="keyword">FROM</span> employees</span><br><span class="line">    <span class="keyword">WHERE</span> last_name <span class="keyword">LIKE</span> <span class="string">&#x27;%e&#x27;</span>;</span><br><span class="line"></span><br><span class="line"># <span class="number">8.</span>显示出表 employees 部门编号在 <span class="number">80</span><span class="number">-100</span> 之间的姓名、工种 </span><br><span class="line">    <span class="keyword">SELECT</span> last_name,job_id</span><br><span class="line">    <span class="keyword">FROM</span> employees</span><br><span class="line">    <span class="keyword">WHERE</span> department_id <span class="keyword">BETWEEN</span> <span class="number">80</span> <span class="keyword">AND</span> <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"># <span class="number">9.</span>显示出表 employees 的 manager_id 是 <span class="number">100</span>,<span class="number">101</span>,<span class="number">110</span> 的员工姓名、工资、管理者id</span><br><span class="line">    <span class="keyword">SELECT</span> last_name,salary,manager_id</span><br><span class="line">    <span class="keyword">FROM</span> employees</span><br><span class="line">    <span class="keyword">WHERE</span> manager_id <span class="keyword">IN</span>(<span class="number">100</span>,<span class="number">101</span>,<span class="number">110</span>);</span><br></pre></td></tr></table></figure>



<h1 id="MySQL-排序与分页"><a href="#MySQL-排序与分页" class="headerlink" title="MySQL 排序与分页"></a>MySQL 排序与分页</h1><h2 id="排序数据"><a href="#排序数据" class="headerlink" title="排序数据"></a><strong>排序数据</strong></h2><h3 id="排序规则"><a href="#排序规则" class="headerlink" title="排序规则"></a><strong>排序规则</strong></h3><p>​    使用 ORDER BY 子句排序</p>
<p>​        <strong>ASC（</strong> <strong>ascend</strong> <strong>）</strong> <strong>:</strong> <strong>升序</strong></p>
<p>​        <strong>DESC（</strong> <strong>descend</strong> <strong>）</strong> <strong>:</strong> <strong>降序</strong></p>
<p>​    <strong>ORDER BY 子句在</strong> <strong>SELECT</strong> <strong>语句的结尾。</strong></p>
<h3 id="单列排序"><a href="#单列排序" class="headerlink" title="单列排序"></a><strong>单列排序</strong></h3><p><img src="/2022/09/28/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8A)/20220928215301999.png" alt="img"></p>
<p> <img src="/2022/09/28/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8A)/202209282153011001.png" alt="img"></p>
<p> <img src="/2022/09/28/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8A)/202209282153011003.png" alt="img"></p>
<p><img src="/2022/09/28/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8A)/202209282153011007.png" alt="img"></p>
<p>注：别名只能在ORDER BY中使用，不能在WHERE中使用 </p>
<p><img src="/2022/09/28/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8A)/202209282153011013.png" alt="img"></p>
<h3 id="多列排序"><a href="#多列排序" class="headerlink" title="多列排序"></a><strong>多列排序</strong></h3><p>​    <em><strong>*在对多列进行排序的时候，首先排序的第一列必须有相同的列值，才会对第二列进行排序。如果第 一列数据中所有值都是唯一的，将不再对第二列进行排序。以此类推。*</strong></em></p>
<p><img src="/2022/09/28/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8A)/202209282153011019.png" alt="img"></p>
<h2 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>​    背景1：查询返回的记录太多了，查看起来很不方便，怎么样能够实现分页查询呢？</p>
<p>​    背景2：表里有 4 条数据，我们只想要显示第 2、3 条数据怎么办呢？</p>
<h3 id="实现规则"><a href="#实现规则" class="headerlink" title="实现规则"></a>实现规则</h3><p>​    <strong>分页原理 所谓分页显示，就是将数据库中的结果集，一段一段显示出来需要的条件。 MySQL中使用 *<em>LIMIT*</em> 实现分页</strong></p>
<p><strong>格式：LIMIT [位置偏移量,] 行数</strong></p>
<p>​    第一个“位置偏移量”参数指示MySQL从哪一行开始显示，是一个可选参数，如果不指定“位置偏移 量”，将会从表中的第一条记录开始（第一条记录的位置偏移量是0，第二条记录的位置偏移量是 1，以此类推）；第二个参数“行数”指示返回的记录条数。</p>
<p><strong>分页显式公式：（当前页数-1）*每页条数，每页条数</strong></p>
<p><img src="/2022/09/28/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8A)/202209282153011047.png" alt="img"></p>
<p> <img src="/2022/09/28/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8A)/202209282153011049.png" alt="img"></p>
<p> <img src="/2022/09/28/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8A)/202209282153021051.png" alt="img"></p>
<p><strong>使用 LIMIT 的好处:</strong></p>
<p>​    约束返回结果的数量可以 减少数据表的网络传输量 ，也可以 提升查询效率 。如果我们知道返回结果只有 1 条，就可以使用 LIMIT 1 ，告诉 SELECT 语句只需要返回一条记录即可。这样的好处就是 SELECT 不需 要扫描完整的表，只需要检索到一条符合条件的记录即可返回。</p>
<p><strong>MySQL 8.0新特性</strong></p>
<p>​    <strong>LIMIT  行数 OFFSET 偏移量</strong></p>
<p><img src="/2022/09/28/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8A)/202209282153021065.png" alt="img"></p>
<p> <em><strong>*注意：LIMIT 子句必须放在整个SELECT语句的最后！*</strong></em></p>
<p><img src="/2022/09/28/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8A)/202209282153021069.png" alt="img"></p>
<h2 id="练习-2"><a href="#练习-2" class="headerlink" title="练习"></a>练习</h2><h3 id="查询员工的姓名和部门号和年薪，按年薪降序-按姓名升序显示"><a href="#查询员工的姓名和部门号和年薪，按年薪降序-按姓名升序显示" class="headerlink" title="查询员工的姓名和部门号和年薪，按年薪降序,按姓名升序显示"></a>查询员工的姓名和部门号和年薪，按年薪降序,按姓名升序显示</h3><p><img src="/2022/09/28/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8A)/202209282153021075.png" alt="img"></p>
<h3 id="选择工资不在-8000-到-17000-的员工的姓名和工资，按工资降序，显示第21到40位置的数据"><a href="#选择工资不在-8000-到-17000-的员工的姓名和工资，按工资降序，显示第21到40位置的数据" class="headerlink" title="选择工资不在 8000 到 17000 的员工的姓名和工资，按工资降序，显示第21到40位置的数据"></a>选择工资不在 8000 到 17000 的员工的姓名和工资，按工资降序，显示第21到40位置的数据</h3><p><img src="/2022/09/28/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8A)/202209282153021081.png" alt="img"></p>
<h3 id="查询邮箱中包含-e-的员工信息，并先按邮箱的字节数降序，再按部门号升序"><a href="#查询邮箱中包含-e-的员工信息，并先按邮箱的字节数降序，再按部门号升序" class="headerlink" title="查询邮箱中包含 e 的员工信息，并先按邮箱的字节数降序，再按部门号升序"></a>查询邮箱中包含 e 的员工信息，并先按邮箱的字节数降序，再按部门号升序</h3><p><img src="/2022/09/28/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8A)/202209282153021087.png" alt="img"></p>
<h1 id="MySQL-多表查询"><a href="#MySQL-多表查询" class="headerlink" title="MySQL 多表查询"></a>MySQL 多表查询</h1><h2 id="一个案例引发的多表连接"><a href="#一个案例引发的多表连接" class="headerlink" title="一个案例引发的多表连接"></a>一个案例引发的多表连接</h2><h3 id="案例说明"><a href="#案例说明" class="headerlink" title="案例说明"></a>案例说明</h3><p>​    <strong>多表查询，也称为关联查询，指两个或更多个表一起完成查询操作。 前提条件：这些一起查询的表之间是有关系的（一对一、一对多），它们之间一定是有关联字段，这个 关联字段可能建立了外键，也可能没有建立外键。比如：员工表和部门表，这两个表依靠“部门编号”进 行关联。</strong></p>
<p><img src="/2022/09/28/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8A)/202209282153021099.png" alt="img"></p>
<p> <strong>查询员工名为‘Abel’所在的城市：</strong></p>
<p><img src="/2022/09/28/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8A)/202209282153031103.png" alt="img"></p>
<p> <img src="/2022/09/28/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8A)/202209282153031105.png" alt="img"></p>
<p> <img src="/2022/09/28/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8A)/202209282153031107.png" alt="img"></p>
<p> <strong>所以Abel所在的城市为Oxford。</strong></p>
<h3 id="笛卡尔积的错误"><a href="#笛卡尔积的错误" class="headerlink" title="笛卡尔积的错误"></a>笛卡尔积的错误</h3><p><img src="/2022/09/28/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8A)/202209282153031113.png" alt="img"></p>
<p><em><strong>*此错误为笛卡儿积的错误*</strong></em></p>
<h3 id="笛卡尔积（或交叉连接）的理解"><a href="#笛卡尔积（或交叉连接）的理解" class="headerlink" title="笛卡尔积（或交叉连接）的理解"></a>笛卡尔积（或交叉连接）的理解</h3><p>​    <strong>笛卡尔乘积是一个数学运算。假设我有两个集合 X 和 Y，那么 X 和 Y 的笛卡尔积就是 X 和 Y 的所有可能 组合，也就是第一个对象来自于 X，第二个对象来自于 Y 的所有可能。组合的个数即为两个集合中元素 个数的乘积数。</strong></p>
<p><img src="/2022/09/28/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8A)/202209282153031121.png" alt="img"></p>
<p>​     SQL92中，笛卡尔积也称为 交叉连接 ，英文是 CROSS JOIN 。在 SQL99 中也是使用 CROSS JOIN表示交 叉连接。它的作用就是可以把任意表进行连接，即使这两张表不相关。在MySQL中如下情况会出现笛卡 尔积：</p>
<p><strong>#查询员工姓名和所在部门名称</strong></p>
<p>*<em>SELECT last_name,department_name FROM employees*</em>,*<em>departments;</em>*</p>
<p><strong>SELECT last_name,department_name FROM employees *<em>CROSS JOIN*</em> departments;</strong></p>
<p><strong>SELECT last_name,department_name FROM employees *<em>INNER JOIN*</em> departments;</strong></p>
<p><strong>SELECT last_name,department_name FROM employees *<em>JOIN*</em> departments;</strong></p>
<h3 id="问题分析与问题解决"><a href="#问题分析与问题解决" class="headerlink" title="问题分析与问题解决"></a>问题分析与问题解决</h3><p>笛卡尔积的错误会在下面条件下产生：</p>
<p>​    <strong>1.略多个表的连接条件（或关联条件）</strong></p>
<p>​    <strong>2.连接条件（或关联条件）</strong></p>
<p>​    <strong>3.无效 所有表中的所有行互相连接</strong></p>
<p>**为了避免笛卡尔积， 可以在 *<em>WHERE 加入有效的连接条件*<em>。</em></em></p>
<p>**加入连接条件后，查询*<em>语法*<em>：</em></em></p>
<p>​    <em><strong>*SELECT table1.column, table2.column*</strong></em></p>
<p>​    <em><strong>*FROM table1, table2*</strong></em></p>
<p>​    <em><strong>*WHERE table1.column1 &#x3D; table2.column2; #连接条件*</strong></em></p>
<p><img src="/2022/09/28/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8A)/202209282153031163.png" alt="img"></p>
<p> <strong>在表中有相同列时，在列名之前加上表名前缀</strong></p>
<p><img src="/2022/09/28/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8A)/202209282153041167.png" alt="img"></p>
<h3 id="表的别名"><a href="#表的别名" class="headerlink" title="表的别名"></a>表的别名</h3><p> <img src="/2022/09/28/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8A)/202209282153041171.png" alt="img"></p>
<p> <strong>注：如果给表起了别名后，就必须使用别名，不可再使用表的原名</strong></p>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p><strong>结论：如果有n个表实现多表查询，则至少需要n-1个链接条件</strong></p>
<p><img src="/2022/09/28/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8A)/202209282153041181.png" alt="img"></p>
<h2 id="多表查询分类"><a href="#多表查询分类" class="headerlink" title="多表查询分类"></a>多表查询分类</h2><h3 id="分类1：等值连接-vs-非等值连接"><a href="#分类1：等值连接-vs-非等值连接" class="headerlink" title="分类1：等值连接 vs 非等值连接"></a>分类1：等值连接 vs 非等值连接</h3><p><strong>等值连接：</strong></p>
<p>​    <strong>当条件为“&#x3D;”的连接为等值连接，是连接属性值相等的那些元组。其结果是连接的表的所有列，包括重复列。</strong></p>
<p>​    <strong>上述案例均为等值连接</strong></p>
<p><strong>等值连接：</strong> </p>
<p>​    <strong>当条件不为“&#x3D;”的连接，是连接 属性值间含有某种关系 的那些元组。其结果是连接的表的所有列，包括重复列。</strong></p>
<p>​    <strong>案例演示：</strong></p>
<p><img src="/2022/09/28/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8A)/202209282153041203.png" alt="img"></p>
<h3 id="分类2：自连接-vs-非自连接"><a href="#分类2：自连接-vs-非自连接" class="headerlink" title="分类2：自连接 vs 非自连接"></a>分类2：自连接 vs 非自连接</h3><p><strong>非自连接：</strong>当table1和table2…不相同的表之间进行的连接为非自连接</p>
<p><strong>自连接：</strong>当table1和table2本质上是同一张表，只是用取别名的方式虚拟成两张表以代表不同的意义。</p>
<p>​    <strong>案例演示</strong></p>
<p><img src="/2022/09/28/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8A)/202209282153041213.png" alt="img"></p>
<p> <img src="/2022/09/28/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8A)/202209282153051215.png" alt="img"></p>
<h3 id="分类3：内连接-vs-外连接"><a href="#分类3：内连接-vs-外连接" class="headerlink" title="分类3：内连接 vs 外连接"></a>分类3：内连接 vs 外连接</h3><p>​    在正式开始讲连接表的种类时，我们首先需要知道 SQL 存在不同版本的标准规范，因为不同规范下的表 连接操作是有区别的。</p>
<p>​     SQL 有两个主要的标准，分别是 <strong>SQL92 和 SQL99</strong> 。92 和 99 代表了标准提出的时间，SQL92 就是 92 年 提出的标准规范。当然除了 SQL92 和 SQL99 以外，还存在 SQL-86、SQL-89、SQL:2003、SQL:2008、 SQL:2011 和 SQL:2016 等其他的标准。</p>
<p>​     这么多标准，到底该学习哪个呢？</p>
<p>​    实际上最重要的 SQL 标准就是 SQL92 和 SQL99。一般来说 SQL92 的 形式更简单，但是写的 SQL 语句会比较长，可读性较差。而 SQL99 相比于 SQL92 来说，语法更加复杂， 但可读性更强。我们从这两个标准发布的页数也能看出，SQL92 的标准有 500 页，而 SQL99 标准超过了 1000 页。实际上从 SQL99 之后，很少有人能掌握所有内容，因为确实太多了。就好比我们使用 Windows、Linux 和 Office 的时候，很少有人能掌握全部内容一样。我们只需要掌握一些核心的功能，满 足日常工作的需求即可。</p>
<p>​    SQL92 和 SQL99 是经典的 SQL 标准，也分别叫做 SQL-2 和 SQL-3 标准。也正是在这两个标准发布之 后，SQL 影响力越来越大，甚至超越了数据库领域。现如今 SQL 已经不仅仅是数据库领域的主流语言， 还是信息领域中信息处理的主流语言。在图形检索、图像检索以及语音检索中都能看到 SQL 语言的使用</p>
<h3 id="SQL92语法：（上述代码均为SQL92语法）"><a href="#SQL92语法：（上述代码均为SQL92语法）" class="headerlink" title="SQL92语法：（上述代码均为SQL92语法）"></a><strong>SQL92语法：（上述代码均为SQL92语法）</strong></h3><p><strong>内连接</strong><strong>: 合并具有同一列的两个以上的表的行, 结果集中不包含一个表与另一个表不匹配的行</strong></p>
<p>（上述案例均为内连接）</p>
<p><img src="/2022/09/28/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8A)/202209282153051239.png" alt="img"></p>
<p><strong>外连接</strong><strong>: 两个表在连接过程中除了返回满足连接条件的行以外还返回左（或右）表中不满足条件的 行 ，这种连接称为左（或右） 外连接。没有匹配的行时, 结果表中相应的列为空(NULL)。</strong></p>
<p>​    ****左外连接：****<strong>两个表在连接过程中除了返回满足连接条件的行以外还返回左表中不满足条件的 行 ，</strong>连接条件中左边的表也称为 主表 ，右边的表称为 从表 。</p>
<p>​    <strong>右外连接：****两个表在连接过程中除了返回满足连接条件的行以外还返回右表中不满足条件的 行 ，</strong>连接条件中右边的表也称为 主表 ，左边的表称为 从表 。</p>
<p>​    <strong>满外连接：****两个表在连接过程中除了返回满足连接条件的行以外还返回左表和右表中不满足条件的 行 。</strong></p>
<p><strong>SQL92：使用(+)创建连接</strong></p>
<p>​    **在 SQL92 中采用（+）代表从表所在的位置。即左或右外连接中，(+) 表示哪个是从表。（*<em>注：MySQL不支持SQL92的外连接操作*<em>）</em></em></p>
<p>​    <strong>左外连接：****连接条件中左边的表也称为 主表 ，右边的表称为 从表 。</strong></p>
<p><img src="/2022/09/28/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8A)/202209282153051259.png" alt="img"></p>
<p>​    <strong>右外连接：****连接条件中右边的表也称为 主表 ，左边的表称为 从表 。</strong></p>
<p><img src="/2022/09/28/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8A)/202209282153051263.png" alt="img"></p>
<h2 id="SQL99语法实现多表查询"><a href="#SQL99语法实现多表查询" class="headerlink" title="SQL99语法实现多表查询"></a>SQL99语法实现多表查询</h2><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法:"></a><strong>基本语法:</strong></h3><p><strong>使用JOIN…ON子句创建连接的语法结构：</strong></p>
<p><em><strong>*SELECT table1.column, table2.column,table3.column*</strong></em></p>
<p><em><strong>*FROM table1*</strong></em></p>
<p>​    <em><strong>*JOIN table2 ON table1 和 table2 的连接条件*</strong></em></p>
<p>​        <em><strong>*JOIN table3 ON table2 和 table3 的连接条件*</strong></em></p>
<p><strong>它的嵌套逻辑类似我们使用的 FOR 循环：</strong></p>
<p><em><strong>*for t1 in table1:*</strong></em></p>
<p>​     <em><strong>*for t2 in table2:*</strong></em></p>
<p>​        <em><strong>*if condition1:*</strong></em></p>
<p>​            <em><strong>*for t3 in table3:*</strong></em></p>
<p>​                <em><strong>*if condition2:*</strong></em></p>
<p>​                    <em><strong>*output t1 + t2 + t3*</strong></em></p>
<p>​    SQL99 采用的这种嵌套结构非常清爽、层次性更强、可读性更强，即使再多的表进行连接也都清晰 可见。如果你采用 SQL92，可读性就会大打折扣。</p>
<p><strong>语法说明：</strong></p>
<p>​    <strong>1.可以使用 ON 子句指定额外的连接条件。</strong></p>
<p>​    <strong>2.这个连接条件是与其它条件分开的。</strong></p>
<p>​    <strong>3.ON 子句使语句具有更高的易读性。</strong></p>
<p>​    <strong>4.关键字 JOIN、INNER JOIN、CROSS JOIN 的含义是一样的，都表示内连接</strong></p>
<h3 id="内连接-INNER-JOIN-的实现"><a href="#内连接-INNER-JOIN-的实现" class="headerlink" title="内连接(INNER JOIN)的实现"></a><strong>内连接(INNER JOIN)的实现</strong></h3><p><strong>语法：</strong></p>
<p>​    <strong>SELECT 字段列表</strong></p>
<p>​    <strong>FROM A表</strong></p>
<p>​    <strong>(INNER) JOIN B表 ON 关联条件</strong></p>
<p>​    <strong>WHERE 等其他子句;</strong></p>
<p><img src="/2022/09/28/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8A)/202209282153051319.png" alt="img"></p>
<p><img src="/2022/09/28/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8A)/202209282153061323.png" alt="img"></p>
<h3 id="外连接-OUTER-JOIN-的实现"><a href="#外连接-OUTER-JOIN-的实现" class="headerlink" title="外连接(OUTER JOIN)的实现"></a><strong>外连接(OUTER JOIN)的实现</strong></h3><h4 id="左外连接-LEFT-OUTER-JOIN"><a href="#左外连接-LEFT-OUTER-JOIN" class="headerlink" title="左外连接(LEFT OUTER JOIN)"></a>左外连接(LEFT OUTER JOIN)</h4><p>语法：</p>
<p>#实现查询结果是A</p>
<p>​    <strong>SELECT 字段列表</strong></p>
<p>​    <strong>FROM A表</strong></p>
<p>​    <strong>LEFT （OUTER）JOIN B表 ON 关联条件</strong></p>
<p>​    <strong>WHERE 等其他子句;</strong></p>
<p><img src="/2022/09/28/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8A)/202209282153061341.png" alt="img"></p>
<h4 id="右外连接-RIGHT-OUTER-JOIN"><a href="#右外连接-RIGHT-OUTER-JOIN" class="headerlink" title="右外连接(RIGHT OUTER JOIN)"></a>右外连接(RIGHT OUTER JOIN)</h4><p>语法：</p>
<p>#实现查询结果是B</p>
<p>​    <strong>SELECT 字段列表</strong></p>
<p>​    <strong>FROM A表</strong></p>
<p>​    <strong>RIGHT JOIN B表 ON 关联条件</strong></p>
<p>​    <strong>WHERE 等其他子句;</strong></p>
<p><img src="/2022/09/28/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8A)/202209282153071357.png" alt="img"></p>
<h4 id="满外连接-FULL-OUTER-JOIN"><a href="#满外连接-FULL-OUTER-JOIN" class="headerlink" title="满外连接(FULL OUTER JOIN)"></a>满外连接(FULL OUTER JOIN)</h4><p>​    <strong>满外连接的结果 &#x3D; 左右表匹配的数据 + 左表没有匹配到的数据 + 右表没有匹配到的数据。</strong></p>
<p>​    <strong>SQL99是支持满外连接的。使用FULL JOIN 或 FULL OUTER JOIN来实现。</strong></p>
<p>​    <strong>需要注意的是，MySQL不支持FULL JOIN，但是可以用 LEFT JOIN UNION RIGHT JOIN代替。</strong></p>
<h2 id="UNION的使用"><a href="#UNION的使用" class="headerlink" title="UNION的使用"></a><strong>UNION的使用</strong></h2><p><strong>合并查询结果</strong> 利用 UNION 关键字，可以给出多条 SELECT 语句，并将它们的结果组合成单个结果集。合并时，两个表对应的列数和数据类型必须相同，并且相互对应。各个SELECT 语句之间使用 <em><strong>*UNION*</strong></em> 或 <strong>UNION ALL</strong>关键字分隔。</p>
<p><em><strong>*语法格式：*</strong></em></p>
<p>​    <strong>SELECT column</strong> <em><strong>*,…** *<em>FROM*</em> **table1*</strong></em></p>
<p>​    <em>*<em>*UNION*</em> **[*</em>*<em>ALL*</em>*<em>]*</em>**</p>
<p>​    <em>*<em>*SELECT column*</em>**,…*</em> *<em>FROM*</em> *<em>table2*</em>**</p>
<h3 id="UNION操作符"><a href="#UNION操作符" class="headerlink" title="UNION操作符"></a><strong>UNION操作符</strong></h3><p><img src="/2022/09/28/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8A)/202209282153071383.png" alt="img"></p>
<p> <em><strong>*UNION** **操作符返回两个查询的结果集的并集，去除重复记录。*</strong></em></p>
<h3 id="UNION-ALL操作符"><a href="#UNION-ALL操作符" class="headerlink" title="UNION ALL操作符"></a><strong>UNION ALL操作符</strong></h3><p><img src="/2022/09/28/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8A)/202209282153071391.png" alt="img"></p>
<p> <em>*<em>*UNION ALL*</em>*<em>操作符返回两个查询的结果集的并集。对于两个结果集的重复部分，不去重。*</em>*</em></p>
<h3 id="UNION-与-UNION-ALL-执行效率"><a href="#UNION-与-UNION-ALL-执行效率" class="headerlink" title="UNION 与 UNION ALL 执行效率"></a><strong>UNION 与 UNION ALL 执行效率</strong></h3><p>​    执行UNION ALL 语句时所需要的资源比 UNION 语句少。如果明确知道合并数据后的结果<strong>数据 不存在重复数据，或者不需要去除重复的数据，则尽量使用UNION ALL</strong> <em><strong>*语句，以提高数据查询的效率。*</strong></em></p>
<p><img src="/2022/09/28/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8A)/202209282153081399.png" alt="img"></p>
<h3 id="种SQL-JOINS的实现"><a href="#种SQL-JOINS的实现" class="headerlink" title="种SQL JOINS的实现"></a><strong>种SQL JOINS的实现</strong></h3><h4 id="图解"><a href="#图解" class="headerlink" title="图解"></a><strong>图解</strong></h4><h2 id=""><a href="#" class="headerlink" title=""></a><img src="/2022/09/28/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8A)/202209282153081405.png" alt="img"></h2><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><h4 id="中图：内连接-A∩B"><a href="#中图：内连接-A∩B" class="headerlink" title="中图：内连接 A∩B"></a>中图：内连接 A∩B</h4><p> <strong>代码格式：</strong></p>
<p>​    <strong>SELECT 字段列表</strong></p>
<p>​    <strong>FROM table1</strong></p>
<p>​    <strong>(INNER) JOIN table2 ON 关联条件</strong></p>
<p>​    <strong>WHERE 等其他子句;</strong></p>
<p><strong>代码实现：</strong></p>
<p><img src="/2022/09/28/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8A)/202209282153081425.png" alt="img"></p>
<h4 id="左上图：左外连接"><a href="#左上图：左外连接" class="headerlink" title="左上图：左外连接"></a>左上图：左外连接</h4><p><strong>语法格式：</strong>    </p>
<p>​    <em><strong>*SELECT 字段列表*</strong></em></p>
<p>​    <strong>FROM table1</strong></p>
<p>​    <strong>LEFT （OUTER）JOIN Btable2ON 关联条件</strong></p>
<p>​    <strong>WHERE 等其他子句;</strong></p>
<p><strong>代码实现：</strong></p>
<p><img src="/2022/09/28/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8A)/202209282153081441.png" alt="img"></p>
<h4 id="右上图：右外连接"><a href="#右上图：右外连接" class="headerlink" title="右上图：右外连接"></a>右上图：右外连接</h4><p><strong>语法格式：</strong>    </p>
<p>​    <em><strong>*SELECT 字段列表*</strong></em></p>
<p>​    <strong>FROM table1</strong></p>
<p>​    <strong>RIGHT（OUTER）JOIN Btable2ON 关联条件</strong></p>
<p>​    <strong>WHERE 等其他子句;</strong></p>
<p><strong>代码实现：</strong></p>
<p><img src="/2022/09/28/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8A)/202209282153081457.png" alt="img"></p>
<h4 id="左中图：A-A∩B"><a href="#左中图：A-A∩B" class="headerlink" title="左中图：A - A∩B"></a>左中图：A - A∩B</h4><p><strong>语法格式：</strong>        </p>
<p>​     <strong>#实现A - A∩B</strong></p>
<p>​    <strong>select 字段列表</strong></p>
<p>​    <strong>from A表</strong></p>
<p>​    <strong>left join B表 on 关联条件</strong></p>
<p>​    <strong>where 从表关联字段 is null and 等其他子句;</strong></p>
<p><strong>代码实现：</strong></p>
<p><img src="/2022/09/28/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8A)/202209282153091475.png" alt="img"></p>
<h4 id="右中图：B-A∩B"><a href="#右中图：B-A∩B" class="headerlink" title="右中图：B-A∩B"></a>右中图：B-A∩B</h4><p><strong>语法格式：</strong>            </p>
<p>​     <strong>#实现B - A∩B</strong></p>
<p>​    <strong>select 字段列表</strong></p>
<p>​    <strong>from A表 right join B表</strong></p>
<p>​    <strong>on 关联条件</strong></p>
<p>​    <strong>where 从表关联字段 is null and 等其他子句;</strong></p>
<p><strong>代码实现：</strong></p>
<p><img src="/2022/09/28/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8A)/202209282153091493.png" alt="img"></p>
<h4 id="左下图：满外连接"><a href="#左下图：满外连接" class="headerlink" title="左下图：满外连接"></a>左下图：满外连接</h4><p><strong>满外连接(A∪B) &#x3D; 左中图 + 右上图 &#x3D; 右中图 + 左上图</strong></p>
<p><strong>语法格式：</strong>            </p>
<p>​     <strong>#实现查询结果是A∪B</strong></p>
<p>​    <strong>#用左外的A，union 右外的B</strong></p>
<p>​    <strong>select 字段列表</strong></p>
<p>​    <strong>from A表 left join B表</strong></p>
<p>​    <strong>on 关联条件</strong></p>
<p>​    <strong>where 等其他子句</strong></p>
<p>​    <strong>union [ all ]</strong></p>
<p>​    <strong>select 字段列表</strong></p>
<p>​    <strong>from A表 right join B表</strong></p>
<p>​    <strong>on 关联条件</strong></p>
<p>​    <strong>where 等其他子句;</strong></p>
<p><strong>代码实现：</strong></p>
<p><img src="/2022/09/28/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8A)/202209282153091525.png" alt="img"></p>
<p> <img src="/2022/09/28/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8A)/202209282153091527.png" alt="img"></p>
<h4 id="右下图"><a href="#右下图" class="headerlink" title="右下图"></a>右下图</h4><p><strong>右下图 &#x3D; 左中图 + 右中图  &#x3D; (A - A∩B) ∪ （B - A∩B）</strong></p>
<p><strong>语法格式：</strong>            </p>
<p>​    <strong>#实现A∪B - A∩B 或 (A - A∩B) ∪ （B - A∩B）</strong></p>
<p>​    <strong>#使用左外的 (A - A∩B) union 右外的（B - A∩B）</strong></p>
<p>​    <strong>select 字段列表</strong></p>
<p>​    <strong>from A表 left join B表</strong></p>
<p>​    <strong>on 关联条件</strong></p>
<p>​    <strong>where 从表关联字段 is null and 等其他子句</strong></p>
<p>​    <strong>union [ all ]</strong></p>
<p>​    <strong>select 字段列表</strong></p>
<p>​    <strong>from A表 right join B表</strong></p>
<p>​    <strong>on 关联条件</strong></p>
<p>​    <strong>where 从表关联字段 is null and 等其他子句</strong></p>
<p><strong>代码实现：</strong></p>
<p><img src="/2022/09/28/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8A)/202209282153091563.png" alt="img"></p>
<h3 id="SQL-JOINS练习"><a href="#SQL-JOINS练习" class="headerlink" title="SQL JOINS练习"></a><strong>SQL JOINS练习</strong></h3><h4 id="资料插入"><a href="#资料插入" class="headerlink" title="资料插入"></a>资料插入</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t_dept` (</span><br><span class="line">`id` <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line"></span><br><span class="line">`deptName` <span class="type">VARCHAR</span>(<span class="number">30</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line"></span><br><span class="line">`address` <span class="type">VARCHAR</span>(<span class="number">40</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line"></span><br><span class="line"><span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line"></span><br><span class="line">) ENGINE<span class="operator">=</span>INNODB AUTO_INCREMENT<span class="operator">=</span><span class="number">1</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t_emp` (</span><br><span class="line"></span><br><span class="line">`id` <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">`name` <span class="type">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`age` <span class="type">INT</span>(<span class="number">3</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`deptId` <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">empno <span class="type">int</span> <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">KEY `idx_dept_id` (`deptId`)</span><br><span class="line">#<span class="keyword">CONSTRAINT</span> `fk_dept_id` <span class="keyword">FOREIGN</span> KEY (`deptId`) <span class="keyword">REFERENCES</span> `t_dept` (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>INNODB AUTO_INCREMENT<span class="operator">=</span><span class="number">1</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t_dept(deptName,address) <span class="keyword">VALUES</span>(<span class="string">&#x27;华山&#x27;</span>,<span class="string">&#x27;华山&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t_dept(deptName,address) <span class="keyword">VALUES</span>(<span class="string">&#x27;丐帮&#x27;</span>,<span class="string">&#x27;洛阳&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t_dept(deptName,address) <span class="keyword">VALUES</span>(<span class="string">&#x27;峨眉&#x27;</span>,<span class="string">&#x27;峨眉山&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t_dept(deptName,address) <span class="keyword">VALUES</span>(<span class="string">&#x27;武当&#x27;</span>,<span class="string">&#x27;武当山&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t_dept(deptName,address) <span class="keyword">VALUES</span>(<span class="string">&#x27;明教&#x27;</span>,<span class="string">&#x27;光明顶&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t_dept(deptName,address) <span class="keyword">VALUES</span>(<span class="string">&#x27;少林&#x27;</span>,<span class="string">&#x27;少林寺&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t_emp(NAME,age,deptId,empno) <span class="keyword">VALUES</span>(<span class="string">&#x27;风清扬&#x27;</span>,<span class="number">90</span>,<span class="number">1</span>,<span class="number">100001</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t_emp(NAME,age,deptId,empno) <span class="keyword">VALUES</span>(<span class="string">&#x27;岳不群&#x27;</span>,<span class="number">50</span>,<span class="number">1</span>,<span class="number">100002</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t_emp(NAME,age,deptId,empno) <span class="keyword">VALUES</span>(<span class="string">&#x27;令狐冲&#x27;</span>,<span class="number">24</span>,<span class="number">1</span>,<span class="number">100003</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t_emp(NAME,age,deptId,empno) <span class="keyword">VALUES</span>(<span class="string">&#x27;洪七公&#x27;</span>,<span class="number">70</span>,<span class="number">2</span>,<span class="number">100004</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t_emp(NAME,age,deptId,empno) <span class="keyword">VALUES</span>(<span class="string">&#x27;乔峰&#x27;</span>,<span class="number">35</span>,<span class="number">2</span>,<span class="number">100005</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t_emp(NAME,age,deptId,empno) <span class="keyword">VALUES</span>(<span class="string">&#x27;灭绝师太&#x27;</span>,<span class="number">70</span>,<span class="number">3</span>,<span class="number">100006</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t_emp(NAME,age,deptId,empno) <span class="keyword">VALUES</span>(<span class="string">&#x27;周芷若&#x27;</span>,<span class="number">20</span>,<span class="number">3</span>,<span class="number">100007</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t_emp(NAME,age,deptId,empno) <span class="keyword">VALUES</span>(<span class="string">&#x27;张三丰&#x27;</span>,<span class="number">100</span>,<span class="number">4</span>,<span class="number">100008</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t_emp(NAME,age,deptId,empno) <span class="keyword">VALUES</span>(<span class="string">&#x27;张无忌&#x27;</span>,<span class="number">25</span>,<span class="number">5</span>,<span class="number">100009</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t_emp(NAME,age,deptId,empno) <span class="keyword">VALUES</span>(<span class="string">&#x27;韦小宝&#x27;</span>,<span class="number">18</span>,<span class="keyword">null</span>,<span class="number">100010</span>);</span><br></pre></td></tr></table></figure>

<h4 id="所有有门派的人员信息"><a href="#所有有门派的人员信息" class="headerlink" title="所有有门派的人员信息"></a><strong>所有有门派的人员信息</strong></h4><p><strong>a、b表共有</strong></p>
<p><img src="/2022/09/28/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8A)/202209282153101614.png" alt="img"></p>
<h4 id="列出所有用户，并显示其机构信息"><a href="#列出所有用户，并显示其机构信息" class="headerlink" title="列出所有用户，并显示其机构信息"></a><strong>列出所有用户，并显示其机构信息</strong></h4><p><img src="/2022/09/28/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8A)/202209282153101618.png" alt="img"></p>
<h4 id="列出所有门派包含各门派人员信息（B的全集）"><a href="#列出所有门派包含各门派人员信息（B的全集）" class="headerlink" title="列出所有门派包含各门派人员信息（B的全集）"></a><strong>列出所有门派包含各门派人员信息</strong>（B的全集）</h4><p><img src="/2022/09/28/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8A)/202209282153101624.png" alt="img"></p>
<h4 id="所有不入门派的人员-（A的独有）"><a href="#所有不入门派的人员-（A的独有）" class="headerlink" title="所有不入门派的人员 （A的独有）"></a><strong>所有不入门派的人员 （A的独有）</strong></h4><p><img src="/2022/09/28/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8A)/202209282153111628.png" alt="img"></p>
<h4 id="所有没人入的门派-（B的独有）"><a href="#所有没人入的门派-（B的独有）" class="headerlink" title="所有没人入的门派 （B的独有）"></a>所有没人入的门派 （B的独有）</h4><p><img src="/2022/09/28/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8A)/202209282153111632.png" alt="img"></p>
<h4 id="列出所有人员和机构的对照关系-AB全有"><a href="#列出所有人员和机构的对照关系-AB全有" class="headerlink" title="列出所有人员和机构的对照关系 (AB全有)"></a>列出所有人员和机构的对照关系 (AB全有)</h4><p><img src="/2022/09/28/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8A)/202209282153111636.png" alt="img"></p>
<h4 id="列出所有没入派的人员和没人入的门派-（A的独有-B的独有）"><a href="#列出所有没入派的人员和没人入的门派-（A的独有-B的独有）" class="headerlink" title="列出所有没入派的人员和没人入的门派 （A的独有+B的独有）"></a>列出所有没入派的人员和没人入的门派 （A的独有+B的独有）<img src="/2022/09/28/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8A)/202209282153111638.png" alt="img"></h4><h2 id="SQL99语法新特性"><a href="#SQL99语法新特性" class="headerlink" title="SQL99语法新特性"></a><strong>SQL99语法新特性</strong></h2><h3 id="自然连接"><a href="#自然连接" class="headerlink" title="自然连接"></a><strong>自然连接</strong></h3><p>​    SQL99 在 SQL92 的基础上提供了一些特殊语法，比如 NATURAL JOIN 用来表示自然连接。我们可以把 自然连接理解为 SQL92 中的等值连接。它会帮你自动查询两张连接表中 所有相同的字段 ，然后进行 等值连接 。</p>
<p>案例演示：</p>
<p><img src="https://img-blog.csdnimg.cn/11543101dcce4557899d57095dfc8c07.png" alt="img"> <img src="https://img-blog.csdnimg.cn/26bd120d2d4840baa91bf30f95b4b67e.png" alt="img"></p>
<p><img src="/2022/09/28/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8A)/202209282153121650.png" alt="img"></p>
<p> <img src="/2022/09/28/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8A)/202209282153121652.png" alt="img"></p>
<h3 id="USING连接"><a href="#USING连接" class="headerlink" title="USING连接"></a><strong>USING连接</strong></h3><p>​    当我们进行连接的时候，SQL99 还支持使用 USING 指定数据表里的 同名字段 进行等值连接。但是<strong>只能配 合JOIN</strong> <em><strong>*一起使用。*</strong></em></p>
<p>​    </p>
<p>​    与自然连接 NATURAL JOIN 不同的是， USING 指定了具体的相同的字段名称，需要在 <em><strong>*USING 的括号 ()*</strong></em> <strong>中填入要指定的同名字段</strong>。同时使用 JOIN…USING 可以简化 JOIN ON 的等值连接。</p>
<p><img src="/2022/09/28/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8A)/202209282153121662.png" alt="img"></p>
<h2 id="总结与拓展"><a href="#总结与拓展" class="headerlink" title="总结与拓展"></a>总结与拓展</h2><p><em><strong>*表连接的约束条件可以有三种方式：WHERE, ON, USING*</strong></em></p>
<p>​    <strong>WHERE：适用于所有关联查询</strong></p>
<p>​    <em>*<em>*ON*</em> *<em>：只能和*</em>*<em>JOIN*</em>*<em>一起使用，只能写关联条件。虽然关联条件可以并到*</em>*<em>WHERE*</em>*<em>中和其他条件一起 写，但分开写可读性更好。*</em>*</em></p>
<p>​    <em>*<em>*USING：只能和*</em>*<em>JOIN*</em>*<em>一起使用，而且要求*</em>*<em>两个*</em>*<em>关联字段在关联表中名称一致，而且只能表示关联字段值相等*</em>*</em></p>
<p><img src="/2022/09/28/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8A)/202209282153121676.png" alt="img"></p>
<p> <strong>多表连接的其他写法（了解）</strong></p>
<p><img src="/2022/09/28/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8A)/202209282153121680.png" alt="img"></p>
<p><strong>注意：</strong></p>
<p>​    要 控制连接表的数量 。多表连接就相当于嵌套 for 循环一样，非常消耗资源，会让 SQL 查询性能下 降得很严重，因此不要连接不必要的表。在许多 DBMS 中，也都会有最大连接表的限制。</p>
<p>​    【<strong>强制】超过三个表禁止 join。需要 join 的字段，数据类型保持绝对一致；多表关联查询时， 保 证被关联的字段需要有索引。</strong></p>
<h2 id="练习-3"><a href="#练习-3" class="headerlink" title="练习"></a>练习</h2><h3 id="显示所有员工的姓名，及其对应的部门号和部门名称。"><a href="#显示所有员工的姓名，及其对应的部门号和部门名称。" class="headerlink" title="显示所有员工的姓名，及其对应的部门号和部门名称。"></a>显示所有员工的姓名，及其对应的部门号和部门名称。</h3><p><img src="/2022/09/28/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8A)/202209282153121694.png" alt="img"></p>
<p>查询90号部门员工的job_id和90号部门的location_id</p>
<p><img src="/2022/09/28/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8A)/202209282153121700.png" alt="img"></p>
<h3 id="选择所有有奖金的员工的-last-name-department-name-location-id-city"><a href="#选择所有有奖金的员工的-last-name-department-name-location-id-city" class="headerlink" title="选择所有有奖金的员工的 last_name , department_name , location_id , city"></a>选择所有有奖金的员工的 last_name , department_name , location_id , city</h3><p><img src="/2022/09/28/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8A)/202209282153131706.png" alt="img"></p>
<h3 id="选择city在Toronto工作的员工的-last-name-job-id-department-id-department-name"><a href="#选择city在Toronto工作的员工的-last-name-job-id-department-id-department-name" class="headerlink" title="选择city在Toronto工作的员工的 last_name , job_id , department_id , department_name"></a>选择city在Toronto工作的员工的 last_name , job_id , department_id , department_name</h3><p><img src="/2022/09/28/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8A)/202209282153131712.png" alt="img"></p>
<h3 id="查询员工所在的部门名称、部门地址、姓名、工作、工资，其中员工所在部门的部门名称为’Executive’"><a href="#查询员工所在的部门名称、部门地址、姓名、工作、工资，其中员工所在部门的部门名称为’Executive’" class="headerlink" title="查询员工所在的部门名称、部门地址、姓名、工作、工资，其中员工所在部门的部门名称为’Executive’"></a>查询员工所在的部门名称、部门地址、姓名、工作、工资，其中员工所在部门的部门名称为’Executive’</h3><p><img src="/2022/09/28/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8A)/202209282153131718.png" alt="img"></p>
<h3 id="选择指定员工的姓名，员工号，以及他的管理者的姓名和员工号"><a href="#选择指定员工的姓名，员工号，以及他的管理者的姓名和员工号" class="headerlink" title="选择指定员工的姓名，员工号，以及他的管理者的姓名和员工号"></a>选择指定员工的姓名，员工号，以及他的管理者的姓名和员工号</h3><p>选择指定员工的姓名，员工号，以及他的管理者的姓名和员工号，结果类似于下面的格式</p>
<p><img src="/2022/09/28/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8A)/202209282153131728.png" alt="img"></p>
<p><img src="/2022/09/28/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8A)/202209282153131730.png" alt="img"></p>
<h3 id="查询哪些部门没有员工"><a href="#查询哪些部门没有员工" class="headerlink" title="查询哪些部门没有员工"></a>查询哪些部门没有员工</h3><p><img src="/2022/09/28/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8A)/202209282153131736.png" alt="img"></p>
<h3 id="查询哪个城市没有部门"><a href="#查询哪个城市没有部门" class="headerlink" title="查询哪个城市没有部门"></a>查询哪个城市没有部门</h3><p><img src="/2022/09/28/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8A)/202209282153131740.png" alt="img"></p>
<h3 id="查询部门名为-Sales-或-IT-的员工信息"><a href="#查询部门名为-Sales-或-IT-的员工信息" class="headerlink" title="查询部门名为 Sales 或 IT 的员工信息"></a>查询部门名为 Sales 或 IT 的员工信息</h3><p><img src="/mysql(%E4%B8%8A)/202209282153131744.png" alt="img"></p>
]]></content>
      <categories>
        <category>MySQL学习</category>
        <category>MySQL基础篇</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL基础篇(中)</title>
    <url>/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/</url>
    <content><![CDATA[<h1 id="MySQL-单行函数"><a href="#MySQL-单行函数" class="headerlink" title="MySQL 单行函数"></a>MySQL 单行函数</h1><h2 id="函数的理解"><a href="#函数的理解" class="headerlink" title="函数的理解"></a><strong>函数的理解</strong></h2><h3 id="什么是函数"><a href="#什么是函数" class="headerlink" title="什么是函数"></a><strong>什么是函数</strong></h3><p>​    函数在计算机语言的使用中贯穿始终，函数的作用是什么呢？它可以把我们经常使用的代码封装起来， 需要的时候直接调用即可。这样既 提高了代码效率 ，又 提高了可维护性 。在 SQL 中我们也可以使用函数 对检索出来的数据进行函数操作。使用这些函数，可以极大地 提高用户对数据库的管理效率 。</p>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061246208.png" alt="img"></p>
<p>​    从函数定义的角度出发，我们可以将函数分成 内置函数 和 自定义函数 。在 SQL 语言中，同样也包括了 内置函数和自定义函数。内置函数是系统内置的通用函数，而自定义函数是我们根据自己的需要编写 的。</p>
<h3 id="不同DBMS函数的差异"><a href="#不同DBMS函数的差异" class="headerlink" title="不同DBMS函数的差异"></a><strong>不同DBMS函数的差异</strong></h3><p>​    我们在使用 SQL 语言的时候，不是直接和这门语言打交道，而是通过它使用不同的数据库软件，即DBMS。 <strong>DBMS</strong> <strong>之间的差异性很大，远大于同一个语言不同版本之间的差异。</strong> 实际上，只有很少的函数是 被 DBMS 同时支持的。比如，大多数 DBMS 使用（||）或者（</p>
<p>+ ）来做拼接符，而在 MySQL 中的字符串拼 接函数为concat() 。大部分 DBMS 会有自己特定的函数，这就意味着 <strong>采用</strong> <strong>SQL</strong> <strong>函数的代码可移植性是很</strong> <strong>差的</strong> ，因此在使用函数的时候需要特别注意。</p>
<h3 id="MySQL的内置函数及分类"><a href="#MySQL的内置函数及分类" class="headerlink" title="MySQL的内置函数及分类"></a><strong>MySQL的内置函数及分类</strong></h3><p>​    MySQL提供了丰富的内置函数，这些函数使得数据的维护与管理更加方便，能够更好地提供数据的分析与统计功能，在一定程度上提高了开发人员进行数据分析与统计的效率。</p>
<p>MySQL 提供的内置函数从 实现的功能角度 可以分为数值函数、字符串函数、日期和时间函数、流程控制 函数、加密与解密函数、获取MySQL 信息函数、聚合函数等。这里，我将这些丰富的内置函数再分为两类： 单行函数 、 聚合函数（或分组函数） 。</p>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/2022100612462126.png" alt="img"></p>
<p><em><strong>*单行函数*</strong></em></p>
<p>​    <em><strong>*操作数据对象*</strong></em></p>
<p>​    <em><strong>*接受参数返回一个结果*</strong></em></p>
<p>​    <em><strong>*只对一行进行变换*</strong></em></p>
<p>​    <em><strong>*每行返回一个结果*</strong></em></p>
<p>​    <em><strong>*可以嵌套*</strong></em></p>
<p>​    <em><strong>*参数可以是一列或一个值*</strong></em></p>
<h2 id="数值函数"><a href="#数值函数" class="headerlink" title="数值函数"></a><strong>数值函数</strong></h2><h3 id="基本函数"><a href="#基本函数" class="headerlink" title="基本函数"></a><strong>基本函数</strong></h3><table>
<thead>
<tr>
<th><strong>函数</strong></th>
<th><strong>用法</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>ABS(x)</strong></td>
<td><strong>返回x的绝对值</strong></td>
</tr>
<tr>
<td><strong>SIGN(X)</strong></td>
<td><strong>返回X的符号。正数返回1，负数返回-1，0返回0</strong></td>
</tr>
<tr>
<td><strong>PI()</strong></td>
<td><strong>返回圆周率的值</strong></td>
</tr>
<tr>
<td><strong>CEIL(x)，CEILING(x)</strong></td>
<td><strong>返回大于或等于某个值的最小整数</strong></td>
</tr>
<tr>
<td><strong>FLOOR(x)</strong></td>
<td><strong>返回小于或等于某个值的最大整数</strong></td>
</tr>
<tr>
<td><strong>LEAST(e1,e2,e3…)</strong></td>
<td><strong>返回列表中的最小值</strong></td>
</tr>
<tr>
<td><strong>GREATEST(e1,e2,e3…)</strong></td>
<td><strong>返回列表中的最大值</strong></td>
</tr>
<tr>
<td><strong>MOD(x,y)</strong></td>
<td><strong>返回X除以Y后的余数</strong></td>
</tr>
<tr>
<td><strong>RAND()</strong></td>
<td><strong>返回0~1的随机值</strong></td>
</tr>
<tr>
<td><strong>RAND(x)</strong></td>
<td><strong>返回0~1的随机值，其中x的值用作种子值，相同的X值会产生相同的随机数</strong></td>
</tr>
<tr>
<td><strong>ROUND(x)</strong></td>
<td><strong>返回一个对x的值进行四舍五入后，最接近于X的整数</strong></td>
</tr>
<tr>
<td><strong>ROUND(x,y)</strong></td>
<td><strong>返回一个对x的值进行四舍五入后最接近X的值，并保留到小数点后面Y位</strong></td>
</tr>
<tr>
<td><strong>TRUNCATE(x,y)</strong></td>
<td><strong>返回数字x截断为y位小数的结果</strong></td>
</tr>
<tr>
<td><strong>SQRT(x)</strong></td>
<td><strong>返回x的平方根。当X的值为负数时，返回NULL</strong></td>
</tr>
</tbody></table>
<p>举例：</p>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/2022100612462165.png" alt="img"></p>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/2022100612462167.png" alt="img"></p>
<p> <strong>取随机数</strong></p>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/2022100612462271.png" alt="img"></p>
<p> <strong>四舍五入</strong></p>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/2022100612462275.png" alt="img"></p>
<p> <strong>截断</strong><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/2022100612462277.png" alt="img"></p>
<p> <strong>平方根</strong></p>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/2022100612462281.png" alt="img"></p>
<p> <strong>嵌套</strong></p>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/2022100612462385.png" alt="img"></p>
<h3 id="角度与弧度互换函数"><a href="#角度与弧度互换函数" class="headerlink" title="角度与弧度互换函数"></a><strong>角度与弧度互换函数</strong></h3><table>
<thead>
<tr>
<th><strong>函数</strong></th>
<th><strong>用法</strong></th>
</tr>
</thead>
<tbody><tr>
<td><em><strong>*RADIANS(x)*</strong></em></td>
<td><em><strong>*将角度转化为弧度，其中，参数x为角度值*</strong></em></td>
</tr>
<tr>
<td><em><strong>*DEGREES(x)*</strong></em></td>
<td><em><strong>*将弧度转化为角度，其中，参数x为弧度值*</strong></em></td>
</tr>
</tbody></table>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/2022100612462394.png" alt="img"></p>
<h3 id="三角函数"><a href="#三角函数" class="headerlink" title="三角函数"></a><strong>三角函数</strong></h3><table>
<thead>
<tr>
<th><strong>函数</strong></th>
<th><strong>用法</strong></th>
</tr>
</thead>
<tbody><tr>
<td><em><strong>*SIN(x)*</strong></em></td>
<td><em>*<em>*返回*</em>*<em>x*</em>*<em>的正弦值，其中，参数*</em>*<em>x*</em>*<em>为弧度值*</em>*</em></td>
</tr>
<tr>
<td><em><strong>*ASIN(x)*</strong></em></td>
<td><em>*<em>*返回*</em>*<em>x*</em>*<em>的反正弦值，即获取正弦为*</em>*<em>x*</em>*<em>的值。如果*</em>*<em>x*</em>*<em>的值不在*</em>**-1*</em>*<em>到*</em>*<em>1*</em>*<em>之间，则返回*</em>*<em>NULL*</em>**</td>
</tr>
<tr>
<td><em><strong>*COS(x)*</strong></em></td>
<td><em>*<em>*返回*</em>*<em>x*</em>*<em>的余弦值，其中，参数*</em>*<em>x*</em>*<em>为弧度值*</em>*</em></td>
</tr>
<tr>
<td><em><strong>*ACOS(x)*</strong></em></td>
<td><em>*<em>*返回*</em>*<em>x*</em>*<em>的反余弦值，即获取余弦为*</em>*<em>x*</em>*<em>的值。如果*</em>*<em>x*</em>*<em>的值不在*</em>**-1*</em>*<em>到*</em>*<em>1*</em>*<em>之间，则返回*</em>*<em>NULL*</em>**</td>
</tr>
<tr>
<td><em><strong>*TAN(x)*</strong></em></td>
<td><em>*<em>*返回*</em>*<em>x*</em>*<em>的正切值，其中，参数*</em>*<em>x*</em>*<em>为弧度值*</em>*</em></td>
</tr>
<tr>
<td><em><strong>*ATAN(x)*</strong></em></td>
<td><em>*<em>*返回*</em>*<em>x*</em>*<em>的反正切值，即返回正切值为*</em>*<em>x*</em>*<em>的值*</em>*</em></td>
</tr>
<tr>
<td><em><strong>*ATAN2(m,n)*</strong></em></td>
<td><em><strong>*返回两个参数的反正切值 ，相当于tan（m&#x2F;n）*</strong></em></td>
</tr>
<tr>
<td><em><strong>*COT(x)*</strong></em></td>
<td><em>*<em>*返回*</em>*<em>x*</em>*<em>的余切值，其中，*</em>*<em>X*</em>*<em>为弧度值*</em>*</em></td>
</tr>
</tbody></table>
<p>​    ATAN2(M,N)函数返回两个参数的反正切值。 与 ATAN(X) 函数相比， ATAN2(M,N) 需要两个参数，例如有两个点point(x1,y1) 和 point(x2,y2) ，使用 ATAN(X) 函数计算反正切值为 ATAN((y2-y1)&#x2F;(x2-x1)) ，使用 ATAN2(M,N) 计算反正切值则为ATAN2(y2-y1,x2-x1) 。由使用方式可以看出，当 x2-x1 等于 0 时， ATAN(X) 函数会报错，而ATAN2(M,N)函数则仍然可以计算。</p>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/20221006124623111.png" alt="img"></p>
<h3 id="指数与对数"><a href="#指数与对数" class="headerlink" title="指数与对数"></a><strong>指数与对数</strong></h3><table>
<thead>
<tr>
<th><strong>函数</strong></th>
<th><strong>用法</strong></th>
</tr>
</thead>
<tbody><tr>
<td><em>*<em>*POW(x,y)*</em>*<em>，*</em>*<em>POWER(X,Y)*</em>*</em></td>
<td><em>*<em>*返回*</em>*<em>x*</em>*<em>的*</em>*<em>y*</em>*<em>次方*</em>*</em></td>
</tr>
<tr>
<td><em><strong>*EXP(X)*</strong></em></td>
<td><em>*<em>*返回*</em>*<em>e*</em>*<em>的*</em>*<em>X*</em>*<em>次方，其中*</em>*<em>e*</em>*<em>是一个常数，*</em>*<em>2.718281828459045*</em>*</em></td>
</tr>
<tr>
<td><em>*<em>*LN(X)*</em>*<em>，*</em>*<em>LOG(X)*</em>*</em></td>
<td><em>*<em>*返回以*</em>*<em>e*</em>*<em>为底的*</em>*<em>X*</em>*<em>的对数，当*</em>*<em>X&lt;&#x3D;0*</em>*<em>时，返回的结果为*</em>*<em>NULL*</em>*</em></td>
</tr>
<tr>
<td><em><strong>*LOG(X,Y)*</strong></em></td>
<td><em>*<em>*返回以X*</em>*<em>为底的Y*</em>*<em>的对数，当X &lt;&#x3D; 0或Y*</em>**&lt;&#x3D;0*</em>*<em>时，返回的结果为*</em>*<em>NULL*</em>**</td>
</tr>
<tr>
<td><em><strong>*LOG10(X)*</strong></em></td>
<td><em>*<em>*返回以*</em>*<em>10*</em>*<em>为底的*</em>*<em>X*</em>*<em>的对数，当*</em>*<em>X&lt;&#x3D;0*</em>*<em>时，返回的结果为*</em>*<em>NULL*</em>*</em></td>
</tr>
<tr>
<td><em><strong>*LOG2(X)*</strong></em></td>
<td><em>*<em>*返回以*</em>*<em>2*</em>*<em>为底的*</em>*<em>X*</em>*<em>的对数，当*</em>*<em>X&lt;&#x3D;0*</em>*<em>时，返回*</em>*<em>NULL*</em>*</em></td>
</tr>
</tbody></table>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/20221006124623124.png" alt="img"></p>
<p> <img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/20221006124624126.png" alt="img"></p>
<h3 id="进制间的转换"><a href="#进制间的转换" class="headerlink" title="进制间的转换"></a><strong>进制间的转换</strong></h3><table>
<thead>
<tr>
<th><strong>函数</strong></th>
<th><strong>用法</strong></th>
</tr>
</thead>
<tbody><tr>
<td><em><strong>*BIN(x)*</strong></em></td>
<td><em>*<em>*返回*</em>*<em>x*</em>*<em>的二进制编码*</em>*</em></td>
</tr>
<tr>
<td><em><strong>*HEX(x)*</strong></em></td>
<td><em>*<em>*返回*</em>*<em>x*</em>*<em>的十六进制编码*</em>*</em></td>
</tr>
<tr>
<td><em><strong>*OCT(x)*</strong></em></td>
<td><em>*<em>*返回*</em>*<em>x*</em>*<em>的八进制编码*</em>*</em></td>
</tr>
<tr>
<td><em><strong>*CONV(x,f1,f2)*</strong></em></td>
<td><em>*<em>*返回*</em>*<em>f1*</em>*<em>进制数变成*</em>*<em>f2*</em>*<em>进制数*</em>*</em></td>
</tr>
</tbody></table>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/20221006124624137.png" alt="img"></p>
<h2 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a><strong>字符串函数</strong></h2><h3 id="字符串函数大全"><a href="#字符串函数大全" class="headerlink" title="字符串函数大全"></a><strong>字符串函数大全</strong></h3><table>
<thead>
<tr>
<th><em><strong>*函数*</strong></em></th>
<th><em><strong>*用法*</strong></em></th>
</tr>
</thead>
<tbody><tr>
<td><em><strong>*ASCII(S)*</strong></em></td>
<td><em><strong>*返回字符串S中的第一个字符的ASCII码值*</strong></em></td>
</tr>
<tr>
<td><em><strong>*CHAR_LENGTH(s)*</strong></em></td>
<td><em><strong>*返回字符串s的字符数。作用与CHARACTER_LENGTH(s)相同*</strong></em></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th><em><strong>*CONCAT(s1,s2,……,sn)*</strong></em></th>
<th><em><strong>*连接s1,s2,……,sn为一个字符串*</strong></em></th>
</tr>
</thead>
<tbody><tr>
<td><em><strong>*CONCAT_WS(x,s1,s2,……,sn)*</strong></em></td>
<td><em><strong>*同CONCAT(s1,s2,…)函数，但是每个字符串之间要加上x*</strong></em></td>
</tr>
<tr>
<td><em><strong>*INSERT(str,idx,len,replacestr)*</strong></em></td>
<td>****将字符串str从第idx位置开始，len个字符长的子串替换为符串replacestr，****若idx超出str长度，则返回原str，不再进行替换</td>
</tr>
<tr>
<td><em><strong>*REPLACE(str,a,b)*</strong></em></td>
<td>****用字符串b替换字符串str中所有出现的字符串a，****若a不在str中，则返回原str，不再进行替换</td>
</tr>
<tr>
<td><em><strong>*UPPER(s)或UCASE(s)*</strong></em></td>
<td><em><strong>*将字符串s的所有字母转成大写字母*</strong></em></td>
</tr>
<tr>
<td><em><strong>*LOWER(s)或LCASE(s)*</strong></em></td>
<td><em><strong>*将字符串s的所有字母转成小写字母*</strong></em></td>
</tr>
<tr>
<td><em><strong>*LEFT(str,n)*</strong></em></td>
<td><em><strong>*返回字符串str最左边的n个字符*</strong></em></td>
</tr>
<tr>
<td><em><strong>*RIGHT(str,n)*</strong></em></td>
<td><em><strong>*返回字符串str最右边的n个字符*</strong></em></td>
</tr>
<tr>
<td><em><strong>*LPAD(str,len,pad)*</strong></em></td>
<td><em><strong>*用字符串pad对str最左边进行填充，直到str的长度为len个字符*</strong></em></td>
</tr>
<tr>
<td><em><strong>*RPAD(str,len,pad)*</strong></em></td>
<td><em><strong>*用字符串pad对str最右边进行填充，直到str的长度为len个字符*</strong></em></td>
</tr>
<tr>
<td><em><strong>*LTRIM(s)*</strong></em></td>
<td><em><strong>*去掉字符串s左侧的空格*</strong></em></td>
</tr>
<tr>
<td><em><strong>*RTRIM(s)*</strong></em></td>
<td><em><strong>*去掉字符串s右侧的空格*</strong></em></td>
</tr>
<tr>
<td><em><strong>*TRIM(s)*</strong></em></td>
<td><em><strong>*去掉字符串s开始与结尾的空格*</strong></em></td>
</tr>
<tr>
<td><em><strong>*TRIM(s1 FROM s)*</strong></em></td>
<td><em><strong>*去掉字符串s开始与结尾的s1*</strong></em></td>
</tr>
<tr>
<td><em><strong>*TRIM(LEADING s1 FROM s)*</strong></em></td>
<td><em><strong>*去掉字符串s开始处的s1*</strong></em></td>
</tr>
<tr>
<td><em><strong>*TRIM(TRAILING s1*</strong></em> <em><strong>*FROM s)*</strong></em></td>
<td><em><strong>*去掉字符串s结尾处的s1*</strong></em></td>
</tr>
<tr>
<td><em><strong>*REPEAT(str,n)*</strong></em></td>
<td><em><strong>*返回str重复n次的结果*</strong></em></td>
</tr>
<tr>
<td><em><strong>*SPACE(n)*</strong></em></td>
<td><em><strong>*返回n个空格*</strong></em></td>
</tr>
<tr>
<td><em><strong>*STRCMP(s1,s2)*</strong></em></td>
<td><em><strong>*比较字符串s1,s2的ASCII码值的大小,返回正数为s1大，返回负数为s2大，返回0则一样大*</strong></em></td>
</tr>
<tr>
<td><em><strong>*SUBSTR(s,index,len)*</strong></em></td>
<td><em><strong>*返回从字符串s的index位置其len个字符，作用与SUBSTRING(s,n,len)、MID(s,n,len)相同*</strong></em></td>
</tr>
<tr>
<td><em><strong>*LOCATE(substr,str)*</strong></em></td>
<td><em><strong>*返回字符串substr在字符串str中首次出现的位置，作用于POSITION(substr IN str)、INSTR(str,substr)相同。未找到,FI’’返回0*</strong></em></td>
</tr>
<tr>
<td><em><strong>*ELT(m,s1,s2,…,sn)*</strong></em></td>
<td><em><strong>*返回指定位置的字符串，如果m&#x3D;1，则返回s1，如果m&#x3D;2，则返回s2，如果m&#x3D;n，则返回sn*</strong></em></td>
</tr>
<tr>
<td><em><strong>*FIELD(s,s1,s2,…,sn)*</strong></em></td>
<td><em><strong>*返回字符串s在字符串列表中第一次出现的位置*</strong></em></td>
</tr>
<tr>
<td><em><strong>*FIND_IN_SET(s1,s2)*</strong></em></td>
<td><em><strong>*返回字符串s1在字符串s2中出现的位置。其中,字符串s2是一个以逗号分隔的字符串*</strong></em></td>
</tr>
<tr>
<td><em><strong>*REVERSE(s)*</strong></em></td>
<td><em><strong>*返回s反转后的字符串*</strong></em></td>
</tr>
<tr>
<td><em><strong>*NULLIF(value1,value2)*</strong></em></td>
<td>****比较两个字符串，如果value1与value2相等，则返回NULL，否****则返回 value1</td>
</tr>
</tbody></table>
<p><strong>注意：MySQL中，字符串的位置是从1开始的。</strong></p>
<h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a><strong>代码示例</strong></h3><table>
<thead>
<tr>
<th><em><strong>*函数*</strong></em></th>
<th><em><strong>*用法*</strong></em></th>
</tr>
</thead>
<tbody><tr>
<td><em><strong>*ASCII(S)*</strong></em></td>
<td><em>*<em>*返回字符串*</em>*<em>S*</em>*<em>中的第一个字符的*</em>*<em>ASCII*</em>*<em>码值*</em>*</em></td>
</tr>
<tr>
<td><em><strong>*CHAR_LENGTH(s)*</strong></em></td>
<td><em>*<em>*返回字符串*</em>*<em>s*</em>*<em>的字符数。作用与*</em>*<em>CHARACTER_LENGTH(s)*</em>*<em>相同*</em>*</em></td>
</tr>
<tr>
<td><em><strong>*LENGTH(s)*</strong></em></td>
<td><em>*<em>*返回字符串*</em>*<em>s*</em>*<em>的字节数，和字符集有关*</em>*</em></td>
</tr>
</tbody></table>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/20221006124624188.png" alt="img"></p>
<table>
<thead>
<tr>
<th><strong>函数</strong></th>
<th><strong>用法</strong></th>
</tr>
</thead>
<tbody><tr>
<td><em><strong>*CONCAT(s1,s2,……,sn)*</strong></em></td>
<td><em>*<em>*连接*</em>*<em>s1,s2,……,sn*</em>*<em>为一个字符串*</em>*</em></td>
</tr>
<tr>
<td><em><strong>*CONCAT_WS(x,s1,s2,……,sn)*</strong></em></td>
<td><em>*<em>*同*</em>*<em>CONCAT(s1,s2,…)*</em>*<em>函数，但是每个字符串之间要加上*</em>*<em>x*</em>*</em></td>
</tr>
</tbody></table>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/20221006124625197.png" alt="img"></p>
<p> <img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/20221006124625199.png" alt="img"></p>
<table>
<thead>
<tr>
<th><strong>函数</strong></th>
<th><strong>用法</strong></th>
</tr>
</thead>
<tbody><tr>
<td><em><strong>*INSERT(str,idx,len,replacestr)*</strong></em></td>
<td>**<em>*将字符串*</em>*<em>str*</em>*<em>从第*</em>*<em>idx*</em>*<em>位置开始，*</em>*<em>len*</em>*<em>个字符长的子串替换为符串*</em>**replacestr，****若idx超出str长度，则返回原str，不再进行替换</td>
</tr>
<tr>
<td><em><strong>*REPLACE(str,a,b)*</strong></em></td>
<td>**<em>*用字符串*</em>*<em>b*</em>*<em>替换字符串*</em>*<em>str*</em>*<em>中所有出现的字符串*</em>**a，****若a不在str中，则返回原str，不再进行替换</td>
</tr>
</tbody></table>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/20221006124626208.png" alt="img"></p>
<table>
<thead>
<tr>
<th><strong>函数</strong></th>
<th><strong>用法</strong></th>
</tr>
</thead>
<tbody><tr>
<td><em>*<em>*UPPER(s)*</em>*<em>或*</em>*<em>UCASE(s)*</em>*</em></td>
<td><em>*<em>*将字符串*</em>*<em>s*</em>*<em>的所有字母转成大写字母*</em>*</em></td>
</tr>
<tr>
<td><em>*<em>*LOWER(s)*</em>*<em>或*</em>*<em>LCASE(s)*</em>*</em></td>
<td><em>*<em>*将字符串*</em>*<em>s*</em>*<em>的所有字母转成小写字母*</em>*</em></td>
</tr>
<tr>
<td><em><strong>*LEFT(str,n)*</strong></em></td>
<td><em>*<em>*返回字符串*</em>*<em>str*</em>*<em>最左边的*</em>*<em>n*</em>*<em>个字符*</em>*</em></td>
</tr>
<tr>
<td><em><strong>*RIGHT(str,n)*</strong></em></td>
<td><em>*<em>*返回字符串*</em>*<em>str*</em>*<em>最右边的*</em>*<em>n*</em>*<em>个字符*</em>*</em></td>
</tr>
</tbody></table>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/20221006124626219.png" alt="img"></p>
<table>
<thead>
<tr>
<th><strong>函数</strong></th>
<th><strong>用法</strong></th>
</tr>
</thead>
<tbody><tr>
<td><em><strong>*LPAD(str,len,pad)*</strong></em></td>
<td><em>*<em>*用字符串*</em>*<em>pad*</em>*<em>对*</em>*<em>str*</em>*<em>最左边进行填充，直到*</em>*<em>str*</em>*<em>的长度为*</em>*<em>len*</em>*<em>个字符*</em>*</em></td>
</tr>
<tr>
<td><em>*<em>*RPAD(str*</em>**,*</em>*<em>len,pad)*</em>**</td>
<td><em>*<em>*用字符串*</em>*<em>pad*</em>*<em>对*</em>*<em>str*</em>*<em>最右边进行填充，直到*</em>*<em>str*</em>*<em>的长度为*</em>*<em>len*</em>*<em>个字符*</em>*</em></td>
</tr>
</tbody></table>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/20221006124626228.png" alt="img"></p>
<table>
<thead>
<tr>
<th><strong>函数</strong></th>
<th><strong>用法</strong></th>
</tr>
</thead>
<tbody><tr>
<td><em><strong>*LTRIM(s)*</strong></em></td>
<td><em>*<em>*去掉字符串*</em>*<em>s*</em>*<em>左侧的空格*</em>*</em></td>
</tr>
<tr>
<td><em><strong>*RTRIM(s)*</strong></em></td>
<td><em>*<em>*去掉字符串*</em>*<em>s*</em>*<em>右侧的空格*</em>*</em></td>
</tr>
<tr>
<td><em><strong>*TRIM(s)*</strong></em></td>
<td><em>*<em>*去掉字符串*</em>*<em>s*</em>*<em>开始与结尾的空格*</em>*</em></td>
</tr>
<tr>
<td><em><strong>*TRIM(s1 FROM s)*</strong></em></td>
<td><em>*<em>*去掉字符串*</em>*<em>s*</em>*<em>开始与结尾的*</em>*<em>s1*</em>*</em></td>
</tr>
<tr>
<td><em><strong>*TRIM(LEADING s1 FROM s)*</strong></em></td>
<td><em>*<em>*去掉字符串*</em>*<em>s*</em>*<em>开始处的*</em>*<em>s1*</em>*</em></td>
</tr>
<tr>
<td><em><strong>*TRIM(TRAILING s1** **FROM s)*</strong></em></td>
<td><em>*<em>*去掉字符串*</em>*<em>s*</em>*<em>结尾处的*</em>*<em>s1*</em>*</em></td>
</tr>
</tbody></table>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/20221006124627241.png" alt="img"></p>
<table>
<thead>
<tr>
<th><strong>函数</strong></th>
<th><strong>用法</strong></th>
</tr>
</thead>
<tbody><tr>
<td><em><strong>*REPEAT(str,n)*</strong></em></td>
<td><em>*<em>*返回*</em>*<em>str*</em>*<em>重复*</em>*<em>n*</em>*<em>次的结果*</em>*</em></td>
</tr>
<tr>
<td><em><strong>*SPACE(n)*</strong></em></td>
<td><em>*<em>*返回*</em>*<em>n*</em>*<em>个空格*</em>*</em></td>
</tr>
<tr>
<td><em><strong>*STRCMP(s1,s2)*</strong></em></td>
<td><em>*<em>*比较字符串*</em>*<em>s1,s2*</em>*<em>的*</em>*<em>ASCII*</em>*<em>码值的大小,返回正数为s1大，返回负数为s2大，返回0则一样大*</em>*</em></td>
</tr>
<tr>
<td><em><strong>*SUBSTR(s,index,len)*</strong></em></td>
<td><em>*<em>*返回从字符串*</em>*<em>s*</em>*<em>的*</em>*<em>index*</em>*<em>位置其*</em>*<em>len*</em>*<em>个字符，作用与*</em>*<em>SUBSTRING(s,n,len)*</em>*<em>、*</em>*<em>MID(s,n,len)*</em>*<em>相同*</em>*</em></td>
</tr>
</tbody></table>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/20221006124628252.png" alt="img"></p>
<table>
<thead>
<tr>
<th><strong>函数</strong></th>
<th><strong>用法</strong></th>
</tr>
</thead>
<tbody><tr>
<td><em><strong>*LOCATE(substr,str)*</strong></em></td>
<td><em>*<em>*返回字符串*</em>*<em>substr*</em>*<em>在字符串*</em>*<em>str*</em>*<em>中首次出现的位置，作用于*</em>*<em>POSITION(substr IN str)*</em>*<em>、*</em>*<em>INSTR(str,substr)*</em>*<em>相同。未找到,FI’’返回*</em>*<em>0*</em>*</em></td>
</tr>
<tr>
<td><em><strong>*ELT(m,s1,s2,…,sn)*</strong></em></td>
<td><em>*<em>*返回指定位置的字符串，如果*</em>*<em>m&#x3D;1*</em>*<em>，则返回*</em>*<em>s1*</em>*<em>，如果*</em>*<em>m&#x3D;2*</em>*<em>，则返回*</em>*<em>s2*</em>*<em>，如果*</em>*<em>m&#x3D;n*</em>*<em>，则返回*</em>*<em>sn*</em>*</em></td>
</tr>
<tr>
<td><em><strong>*FIELD(s,s1,s2,…,sn)*</strong></em></td>
<td><em>*<em>*返回字符串*</em>*<em>s*</em>*<em>在字符串列表中第一次出现的位置*</em>*</em></td>
</tr>
<tr>
<td><em><strong>*FIND_IN_SET(s1,s2)*</strong></em></td>
<td><em>*<em>*返回字符串*</em>*<em>s1*</em>*<em>在字符串*</em>*<em>s2*</em>*<em>中出现的位置。其中,字符串*</em>*<em>s2*</em>*<em>是一个以逗号分隔的字符串*</em>*</em></td>
</tr>
<tr>
<td><em><strong>*REVERSE(s)*</strong></em></td>
<td><em>*<em>*返回*</em>*<em>s*</em>*<em>反转后的字符串*</em>*</em></td>
</tr>
<tr>
<td><em><strong>*NULLIF(value1,value2)*</strong></em></td>
<td>**<em>*比较两个字符串，如果*</em>*<em>value1*</em>*<em>与*</em>*<em>value2*</em>*<em>相等，则返回*</em>**NULL****<strong>，否</strong>则返回 value1</td>
</tr>
</tbody></table>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/20221006124628265.png" alt="img"></p>
<p> <img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/20221006124628267.png" alt="img"></p>
<h2 id="日期和时间函数"><a href="#日期和时间函数" class="headerlink" title="日期和时间函数"></a><strong>日期和时间函数</strong></h2><h3 id="获取日期、时间"><a href="#获取日期、时间" class="headerlink" title="获取日期、时间"></a><strong>获取日期、时间</strong></h3><table>
<thead>
<tr>
<th><strong>函数</strong></th>
<th><strong>用法</strong></th>
</tr>
</thead>
<tbody><tr>
<td><em>*<em>*CURDATE(),*</em>*<em>CURRENT_DATE()*</em>*</em></td>
<td><em><strong>*返回当前日期，只包含年、月、日*</strong></em></td>
</tr>
<tr>
<td><em>*<em>*CURTIME(),*</em>*<em>CURRENT_TIME()*</em>*</em></td>
<td><em><strong>*返回当前时间，只包含时、分、秒*</strong></em></td>
</tr>
<tr>
<td><em>*<em>*NOW()*</em>**&#x2F;SYSDATE()&#x2F;CURRENT_TIMESTAMP()&#x2F;*</em>**<em><strong>*LOCALTIME()&#x2F;LOCALTIMESTAMP()*</strong></em></td>
<td><em><strong>*返回当前系统日期和时间*</strong></em></td>
</tr>
<tr>
<td><em><strong>*UTC_DATE()*</strong></em></td>
<td><em>*<em>*返回*</em>*<em>UTC*</em>**(*</em>*<em>世界标准时间)日期*</em>**</td>
</tr>
<tr>
<td><em><strong>*UTC_TIME()*</strong></em></td>
<td><em>*<em>*返回*</em>*<em>UTC*</em>**(*</em>*<em>世界标准时间)时间*</em>**</td>
</tr>
</tbody></table>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/20221006124629281.png" alt="img"></p>
<h2 id=""><a href="#" class="headerlink" title=""></a><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/20221006124629283.png" alt="img"></h2><h3 id="日期与时间戳的转换"><a href="#日期与时间戳的转换" class="headerlink" title="日期与时间戳的转换"></a><strong>日期与时间戳的转换</strong></h3><table>
<thead>
<tr>
<th><em><strong>*函数*</strong></em></th>
<th><em><strong>*用法*</strong></em></th>
</tr>
</thead>
<tbody><tr>
<td><em><strong>*UNIX_TIMESTAMP()*</strong></em></td>
<td><em>*<em>*以*</em>*<em>UNIX*</em>*<em>时间戳的形式返回当前时间。*</em>*</em></td>
</tr>
<tr>
<td><em><strong>*UNIX_TIMESTAMP(date)*</strong></em></td>
<td><em>*<em>*将时间*</em>*<em>date*</em>*<em>以*</em>*<em>UNIX*</em>*<em>时间戳的形式返回。*</em>*</em></td>
</tr>
<tr>
<td><em><strong>*FROM_UNIXTIME(timestamp)*</strong></em></td>
<td><em>*<em>*将*</em>*<em>UNIX*</em>*<em>时间戳的时间转换为普通格式的时间*</em>*</em></td>
</tr>
</tbody></table>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/20221006124629295.png" alt="img"></p>
<h3 id="获取月份、星期、星期数、天数等函数"><a href="#获取月份、星期、星期数、天数等函数" class="headerlink" title="获取月份、星期、星期数、天数等函数"></a><strong>获取月份、星期、星期数、天数等函数</strong></h3><table>
<thead>
<tr>
<th><em><strong>*函数*</strong></em></th>
<th><em><strong>*用法*</strong></em></th>
</tr>
</thead>
<tbody><tr>
<td><em><strong>*YEAR(date)&#x2F;MONTH(date)&#x2F;DAY(date)*</strong></em></td>
<td><em><strong>*返回具体的日期值*</strong></em></td>
</tr>
<tr>
<td><em><strong>*HOUR(time)&#x2F;MINUTE(time)&#x2F;SECOND(time)*</strong></em></td>
<td><em><strong>*返回具体的时间值*</strong></em></td>
</tr>
<tr>
<td><em><strong>*MONTHNAME(date)*</strong></em></td>
<td><em>*<em>*返回月份：*</em>*<em>January*</em>*<em>，*</em>**…*</em>**</td>
</tr>
<tr>
<td><em><strong>*DAYNAME(date)*</strong></em></td>
<td><em>*<em>*返回星期几：*</em>*<em>MONDAY*</em>*<em>，*</em>*<em>TUESDAY…..SUNDAY*</em>*</em></td>
</tr>
<tr>
<td><em><strong>*WEEKDAY(date)*</strong></em></td>
<td><em>*<em>*返回周几，注意，周*</em>*<em>1*</em>*<em>是*</em>*<em>0*</em>*<em>，周*</em>*<em>2*</em>*<em>是*</em>*<em>1*</em>*<em>，。。。周日是*</em>*<em>6*</em>*</em></td>
</tr>
<tr>
<td><em><strong>*QUARTER(date)*</strong></em></td>
<td><em>*<em>*返回日期对应的季度，范围为*</em>*<em>1*</em>*<em>～*</em>*<em>4*</em>*</em></td>
</tr>
<tr>
<td><em>*<em>*WEEK(date)*</em>*<em>，*</em>*<em>WEEKOFYEAR(date)*</em>*</em></td>
<td><em><strong>*返回一年中的第几周*</strong></em></td>
</tr>
<tr>
<td><em><strong>*DAYOFYEAR(date)*</strong></em></td>
<td><em><strong>*返回日期是一年中的第几天*</strong></em></td>
</tr>
<tr>
<td><em><strong>*DAYOFMONTH(date)*</strong></em></td>
<td><em><strong>*返回日期位于所在月份的第几天*</strong></em></td>
</tr>
<tr>
<td><em><strong>*DAYOFWEEK(date)*</strong></em></td>
<td><em>*<em>*返回周几，注意：周日是*</em>*<em>1*</em>*<em>，周一是*</em>*<em>2*</em>*<em>，。。。周六是*</em>*<em>7*</em>*</em></td>
</tr>
</tbody></table>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/20221006124630312.png" alt="img"></p>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/20221006124630314.png" alt="img"></p>
<h3 id="日期的操作函数"><a href="#日期的操作函数" class="headerlink" title="日期的操作函数"></a><strong>日期的操作函数</strong></h3><table>
<thead>
<tr>
<th><em><strong>*函数*</strong></em></th>
<th><em><strong>*用法*</strong></em></th>
</tr>
</thead>
<tbody><tr>
<td><em><strong>*EXTRACT(type FROM date)*</strong></em></td>
<td><em>*<em>*返回指定日期中特定的部分，*</em>*<em>type*</em>*<em>指定返回的值*</em>*</em></td>
</tr>
</tbody></table>
<p><strong>EXTRACT(type FROM date)函数中type的取值与含义：</strong></p>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/20221006124630326.png" alt="img"></p>
<p> <img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/20221006124631328.png" alt="img"></p>
<h3 id="时间和秒钟转换的函数"><a href="#时间和秒钟转换的函数" class="headerlink" title="时间和秒钟转换的函数"></a><strong>时间和秒钟转换的函数</strong></h3><table>
<thead>
<tr>
<th><em><strong>*函数*</strong></em></th>
<th><em><strong>*用法*</strong></em></th>
</tr>
</thead>
<tbody><tr>
<td><em><strong>*TIME_TO_SEC(time)*</strong></em></td>
<td><em>*<em>*将*</em> *<em>time*</em> *<em>转化为秒并返回结果值。转化的公式为：*</em> *<em>小时*</em>***3600+*</em>*<em>分钟*</em> *<em>*60*</em>*<em>+*</em>*<em>秒*</em>**</td>
</tr>
<tr>
<td><em><strong>*SEC_TO_TIME(seconds)*</strong></em></td>
<td><em><strong>*将** *<em>seconds*</em> **描述转化为包含小时、分钟和秒的时间*</strong></em></td>
</tr>
</tbody></table>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/20221006124631339.png" alt="img"></p>
<h3 id="计算日期和时间的函数"><a href="#计算日期和时间的函数" class="headerlink" title="计算日期和时间的函数"></a><strong>计算日期和时间的函数</strong></h3><h4 id="第一组"><a href="#第一组" class="headerlink" title="第一组"></a>第一组</h4><table>
<thead>
<tr>
<th><em><strong>*函数*</strong></em></th>
<th><em><strong>*用法*</strong></em></th>
</tr>
</thead>
<tbody><tr>
<td><em>*<em>*DATE_ADD(datetime, INTERVAL expr type)*</em>*<em>，*</em> *<em>ADDDATE(date,INTERVAL expr type)*</em>*</em></td>
<td><em>*<em>*返回与给定日期时间相差*</em>*<em>INTERVAL*</em>*<em>时间段的日期时间*</em>*</em></td>
</tr>
<tr>
<td><em>*<em>*DATE_SUB(date,INTERVAL expr type)*</em>*<em>，*</em>*<em>SUBDATE(date,INTERVAL expr type)*</em>*</em></td>
<td><em>*<em>*返回与*</em>*<em>date*</em>*<em>相差*</em>*<em>INTERVAL*</em>*<em>时间间隔的日期*</em>*</em></td>
</tr>
</tbody></table>
<p><strong>上述函数中type的取值：</strong></p>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/20221006124632352.png" alt="img"></p>
<p>举例 </p>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/20221006124632356.png" alt="img"></p>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/20221006124633358.png" alt="img"></p>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/20221006124633360.png" alt="img"></p>
<h4 id="第二组"><a href="#第二组" class="headerlink" title="第二组"></a>第二组</h4><table>
<thead>
<tr>
<th><em><strong>*函数*</strong></em></th>
<th><em><strong>*用法*</strong></em></th>
</tr>
</thead>
<tbody><tr>
<td><em><strong>*ADDTIME(time1,time2)*</strong></em></td>
<td><em>*<em>*返回*</em>*<em>time1*</em>*<em>加上*</em>*<em>time2*</em>*<em>的时间。当*</em>*<em>time2*</em>*<em>为一个数字时，代表的是*</em>*<em>秒*</em> *<em>，可以为负数*</em>*</em></td>
</tr>
<tr>
<td><em><strong>*SUBTIME(time1,time2)*</strong></em></td>
<td><em>*<em>*返回*</em>*<em>time1*</em>*<em>减去*</em>*<em>time2*</em>*<em>后的时间。当*</em>*<em>time2*</em>*<em>为一个数字时，代表的*</em>*<em>是*</em> *<em>秒*</em> *<em>，可以为负数*</em>*</em></td>
</tr>
<tr>
<td><em><strong>*DATEDIFF(date1,date2)*</strong></em></td>
<td><em>*<em>*返回*</em>*<em>date1 - date2*</em>*<em>的日期间隔天数*</em>*</em></td>
</tr>
<tr>
<td><em><strong>*TIMEDIFF(time1, time2)*</strong></em></td>
<td><em>*<em>*返回*</em>*<em>time1 - time2*</em>*<em>的时间间隔*</em>*</em></td>
</tr>
<tr>
<td><em><strong>*FROM_DAYS(N)*</strong></em></td>
<td><em>*<em>*返回从*</em>*<em>0000*</em>*<em>年*</em>*<em>1*</em>*<em>月*</em>*<em>1*</em>*<em>日起，*</em>*<em>N*</em>*<em>天以后的日期*</em>*</em></td>
</tr>
<tr>
<td><em><strong>*TO_DAYS(date)*</strong></em></td>
<td><em>*<em>*返回日期*</em>*<em>date*</em>*<em>距离*</em>*<em>0000*</em>*<em>年*</em>*<em>1*</em>*<em>月*</em>*<em>1*</em>*<em>日的天数*</em>*</em></td>
</tr>
<tr>
<td><em><strong>*LAST_DAY(date)*</strong></em></td>
<td><em>*<em>*返回*</em>*<em>date*</em>*<em>所在月份的最后一天的日期*</em>*</em></td>
</tr>
<tr>
<td><em><strong>*MAKEDATE(year,n)*</strong></em></td>
<td><em><strong>*针对给定年份与所在年份中的天数返回一个日期*</strong></em></td>
</tr>
<tr>
<td><em><strong>*MAKETIME(hour,minute,second)*</strong></em></td>
<td><em><strong>*将给定的小时、分钟和秒组合成时间并返回*</strong></em></td>
</tr>
<tr>
<td><em><strong>*PERIOD_ADD(time,n)*</strong></em></td>
<td><em>*<em>*返回*</em>*<em>time*</em>*<em>加上*</em>*<em>n*</em>*<em>后的时间*</em>*</em></td>
</tr>
</tbody></table>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/20221006124633377.png" alt="img"></p>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/20221006124634379.png" alt="img"></p>
<p> <img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/20221006124634381.png" alt="img"></p>
<p> <img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/20221006124634383.png" alt="img"></p>
<h3 id="日期的格式化与解析"><a href="#日期的格式化与解析" class="headerlink" title="日期的格式化与解析"></a><strong>日期的格式化与解析</strong></h3><table>
<thead>
<tr>
<th><em><strong>*函数*</strong></em></th>
<th><em><strong>*用法*</strong></em></th>
</tr>
</thead>
<tbody><tr>
<td><em><strong>*DATE_FORMAT(date,fmt)*</strong></em></td>
<td><em>*<em>*按照字符串*</em>*<em>fmt*</em>*<em>格式化日期*</em>*<em>date*</em>*<em>值*</em>*</em></td>
</tr>
<tr>
<td><em><strong>*TIME_FORMAT(time,fmt)*</strong></em></td>
<td><em>*<em>*按照字符串*</em>*<em>fmt*</em>*<em>格式化时间*</em>*<em>time*</em>*<em>值*</em>*</em></td>
</tr>
<tr>
<td><em><strong>*GET_FORMAT(date_type,format_type)*</strong></em></td>
<td><em><strong>*返回日期字符串的显示格式*</strong></em></td>
</tr>
<tr>
<td><em><strong>*STR_TO_DATE(str, fmt)*</strong></em></td>
<td><em>*<em>*按照字符串*</em>*<em>fmt*</em>*<em>对*</em>*<em>str*</em>*<em>进行解析，解析为一个日期*</em>*</em></td>
</tr>
</tbody></table>
<p><em>*<em>*上述*</em> *<em>非*</em>*<em>GET_FORMAT*</em> *<em>函数中*</em>*<em>fmt*</em>*<em>参数常用的格式符：*</em>*</em></p>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/20221006124635396.png" alt="img"></p>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/20221006124635398.png" alt="img"></p>
<p> <img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/20221006124636400.png" alt="img"></p>
<p><em>*<em>*GET_FORMAT*</em>*<em>函数中*</em>*<em>date_type*</em>*<em>和*</em>*<em>format_type*</em>*<em>参数取值如下：*</em>*</em></p>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/20221006124636406.png" alt="img"></p>
<p> <img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/20221006124636408.png" alt="img"></p>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/20221006124637410.png" alt="img"></p>
<h2 id="流程控制函数"><a href="#流程控制函数" class="headerlink" title="流程控制函数"></a><strong>流程控制函数</strong></h2><p>​    流程处理函数可以根据不同的条件，执行不同的处理流程，可以在SQL 语句中实现不同的条件选择。</p>
<p>​    <strong>MySQL中的流程处理函数主要包括</strong> <em>*<em>*IF()*</em>*<em>、*</em>*<em>IFNULL()*</em>*<em>和*</em>*<em>CASE()*</em>*<em>函数。*</em>*</em></p>
<table>
<thead>
<tr>
<th><em><strong>*函数*</strong></em></th>
<th><em><strong>*用法*</strong></em></th>
</tr>
</thead>
<tbody><tr>
<td><em><strong>*IF(value,value1,value2)*</strong></em></td>
<td><em>*<em>*如果*</em>*<em>value*</em>*<em>的值为*</em>*<em>TRUE*</em>*<em>，返回*</em>*<em>value1*</em>*<em>，否则返回*</em>*<em>value2*</em>*</em></td>
</tr>
<tr>
<td><em><strong>*IFNULL(value1, value2)*</strong></em></td>
<td><em>*<em>*如果*</em>*<em>value1*</em>*<em>不为*</em>*<em>NULL*</em>*<em>，返回*</em>*<em>value1*</em>*<em>，否则返回*</em>*<em>value2*</em>*</em></td>
</tr>
<tr>
<td><em>*<em>*CASE WHEN*</em> *<em>条件*</em>*<em>1 THEN*</em> *<em>结果*</em>*<em>1*</em>*</em><em>*<em>*WHEN*</em> *<em>条件*</em>*<em>2 THEN*</em> *<em>结果*</em>*<em>2*</em>*</em><em><strong>*….*</strong></em><em><strong>*[ELSE resultn] END*</strong></em></td>
<td><em>*<em>*相当于*</em>*<em>Java*</em>*<em>的*</em>*<em>if…else if…else…*</em>*</em></td>
</tr>
<tr>
<td><em>*<em>*CASE expr WHEN*</em> *<em>常量值*</em>*<em>1 THEN*</em> *<em>值*</em>*<em>1*</em>*</em><em>*<em>*WHEN*</em> *<em>常量值*</em>*<em>1 THEN*</em>*<em>值*</em>*<em>1*</em>*</em><em><strong>*….*</strong></em><em>*<em>*[ELSE*</em> *<em>值*</em>*<em>n] END*</em>*</em></td>
<td><em>*<em>*相当于*</em>*<em>Java*</em>*<em>的*</em>*<em>switch…case…*</em>*</em></td>
</tr>
</tbody></table>
<h3 id="IF-expr1-expr2-expr3"><a href="#IF-expr1-expr2-expr3" class="headerlink" title="IF(expr1,expr2,expr3):"></a><strong>IF(expr1,expr2,expr3):</strong></h3><p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/20221006124637427.png" alt="img"></p>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/20221006124637429.png" alt="img"></p>
<h3 id="IFNULL-expr1-expr2"><a href="#IFNULL-expr1-expr2" class="headerlink" title="IFNULL(expr1,expr2):"></a>IFNULL(expr1,expr2):</h3><p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/20221006124638435.png" alt="img"></p>
<h3 id="CASE-WHEN-…-THEN-…-WHEN-…-THEN-……ELSE-…-END"><a href="#CASE-WHEN-…-THEN-…-WHEN-…-THEN-……ELSE-…-END" class="headerlink" title="CASE WHEN … THEN … WHEN … THEN ……ELSE … END"></a>CASE WHEN … THEN … WHEN … THEN ……ELSE … END</h3><p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/20221006124638439.png" alt="img"></p>
<p> <strong>也可以省略ELSE…</strong></p>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/20221006124639443.png" alt="img"></p>
<h3 id="CASE-…-WHEN-…-THEN-…-WHEN-…-THEN-……ELSE-…-END"><a href="#CASE-…-WHEN-…-THEN-…-WHEN-…-THEN-……ELSE-…-END" class="headerlink" title="CASE … WHEN … THEN … WHEN … THEN ……ELSE … END"></a>CASE … WHEN … THEN … WHEN … THEN ……ELSE … END</h3><p>要求1：</p>
<p>​    查询部门号，<br>​    若部门号为 10, 则打印其工资的 1.1 倍,<br>​    20 号部门, 则打印其工资的 1.2 倍,<br>​    30 号部门打印其工资的 1.3 倍数,<br>​    其他部门打印其工资的 1.4 倍数</p>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/20221006124640455.png" alt="img"></p>
<p>要求2：</p>
<p>​    查询部门号为 10,20, 30 的员工信息,<br>​    若部门号为 10, 则打印其工资的 1.1 倍,<br>​    20 号部门, 则打印其工资的 1.2 倍,<br>​    30 号部门打印其工资的 1.3 倍数.<br>   <img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/20221006124640465.png" alt="img"></p>
<h2 id="加密与解密函数"><a href="#加密与解密函数" class="headerlink" title="加密与解密函数"></a><strong>加密与解密函数</strong></h2><p>​    加密与解密函数主要用于对数据库中的数据进行加密和解密处理，以防止数据被他人窃取。这些函数在保证数据库安全时非常有用。</p>
<table>
<thead>
<tr>
<th><strong>函数</strong></th>
<th><strong>用法</strong></th>
</tr>
</thead>
<tbody><tr>
<td><em><strong>*PASSWORD(str)*</strong></em></td>
<td><em>*<em>*返回字符串*</em>*<em>str*</em>*<em>的加密版本，*</em>*<em>41*</em>*<em>位长的字符串。加密结果*</em> *<em>不可*</em>*<em>逆*</em> *<em>，常用于用户的密码加密*</em>*</em></td>
</tr>
<tr>
<td><em><strong>*MD5(str)*</strong></em></td>
<td><em>*<em>*返回字符串*</em>*<em>str*</em>*<em>的*</em>*<em>md5*</em>*<em>加密后的值，也是一种加密方式。若参数为*</em>*<em>NULL*</em>*<em>，则会返回*</em>*<em>NULL*</em>*</em></td>
</tr>
<tr>
<td><em><strong>*SHA(str)*</strong></em></td>
<td><em>*<em>*从原明文密码*</em>*<em>str*</em>*<em>计算并返回加密后的密码字符串，当参数为*</em>*<em>NULL*</em>*<em>时，返回*</em>*<em>NULL*</em>*<em>。*</em> *<em>SHA*</em>*<em>加密算法比*</em>*<em>MD5*</em>*<em>更加安全*</em> *<em>。*</em>*</em></td>
</tr>
<tr>
<td><em><strong>*ENCODE(value,password_seed)*</strong></em></td>
<td><em>*<em>*返回使用*</em>*<em>password_seed*</em>*<em>作为加密密码加密*</em>*<em>value*</em>*</em></td>
</tr>
<tr>
<td><em><strong>*DECODE(value,password_seed)*</strong></em></td>
<td><em>*<em>*返回使用*</em>*<em>password_seed*</em>*<em>作为加密密码解密*</em>*<em>value*</em>*</em></td>
</tr>
</tbody></table>
<p>​    可以看到，ENCODE(value,password_seed)函数与DECODE(value,password_seed)函数互为反函数。 <img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/20221006124640481.png" alt="img"></p>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/20221006124641483.png" alt="img"></p>
<p> <img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/20221006124641485.png" alt="img"></p>
<h2 id="MySQL信息函数"><a href="#MySQL信息函数" class="headerlink" title="MySQL信息函数"></a><strong>MySQL信息函数</strong></h2><p>​    MySQL中内置了一些可以查询 MySQL 信息的函数，这些函数主要用于帮助数据库开发或运维人员更好地对数据库进行维护工作。</p>
<table>
<thead>
<tr>
<th><em><strong>*函数*</strong></em></th>
<th><em><strong>*用法*</strong></em></th>
</tr>
</thead>
<tbody><tr>
<td><em><strong>*VERSION()*</strong></em></td>
<td><em>*<em>*返回当前*</em>*<em>MySQL*</em>*<em>的版本号*</em>*</em></td>
</tr>
<tr>
<td><em><strong>*CONNECTION_ID()*</strong></em></td>
<td><em>*<em>*返回当前*</em>*<em>MySQL*</em>*<em>服务器的连接数*</em>*</em></td>
</tr>
<tr>
<td><em>*<em>*DATABASE()*</em>*<em>，*</em>*<em>SCHEMA()*</em>*</em></td>
<td><em>*<em>*返回*</em>*<em>MySQL*</em>*<em>命令行当前所在的数据库*</em>*</em></td>
</tr>
<tr>
<td><em>*<em>*USER()*</em>*<em>，*</em>*<em>CURRENT_USER()*</em>*<em>、*</em>*<em>SYSTEM_USER()*</em>*<em>，*</em>*<em>SESSION_USER()*</em>*</em></td>
<td><em>*<em>*返回当前连接*</em>*<em>MySQL*</em>*<em>的用户名，返回结果格式为*</em>*<em>“*</em>*<em>主机名*</em>**@*</em>*<em>用户名*</em>*<em>”*</em>**</td>
</tr>
<tr>
<td><em><strong>*CHARSET(value)*</strong></em></td>
<td><em>*<em>*返回字符串*</em>*<em>value*</em>*<em>自变量的字符集*</em>*</em></td>
</tr>
<tr>
<td><em><strong>*COLLATION(value)*</strong></em></td>
<td><em>*<em>*返回字符串*</em>*<em>value*</em>*<em>的比较规则*</em>*</em></td>
</tr>
</tbody></table>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/20221006124641502.png" alt="img"></p>
<h2 id="其他函数"><a href="#其他函数" class="headerlink" title="其他函数"></a><strong>其他函数</strong></h2><p>​    MySQL中有些函数无法对其进行具体的分类，但是这些函数在 MySQL 的开发和运维过程中也是不容忽视的。</p>
<table>
<thead>
<tr>
<th><em><strong>*函数*</strong></em></th>
<th><em><strong>*用法*</strong></em></th>
</tr>
</thead>
<tbody><tr>
<td><em><strong>*FORMAT(value,n)*</strong></em></td>
<td><em>*<em>*返回对数字*</em>*<em>value*</em>*<em>进行格式化后的结果数据。*</em>*<em>n*</em>*<em>表示*</em> *<em>四舍五入*</em> *<em>后保留到小数点后*</em>*<em>n位.*</em>*<em>如果*</em>*<em>n*</em>*<em>的值小于或者等于*</em>*<em>0*</em>*<em>，则只保留整数部分*</em>*</em></td>
</tr>
<tr>
<td><em><strong>*CONV(value,from,to)*</strong></em></td>
<td><em>*<em>*将*</em>*<em>value*</em>*<em>的值进行不同进制之间的转换*</em>*</em></td>
</tr>
<tr>
<td><em><strong>*INET_ATON(ipvalue)*</strong></em></td>
<td><em>*<em>*将以点分隔的*</em>*<em>IP*</em>*<em>地址转化为一个数字*</em>*</em></td>
</tr>
<tr>
<td><em><strong>*INET_NTOA(value)*</strong></em></td>
<td><em>*<em>*将数字形式的*</em>*<em>IP*</em>*<em>地址转化为以点分隔的*</em>*<em>IP*</em>*<em>地址*</em>*</em></td>
</tr>
<tr>
<td><em><strong>*BENCHMARK(n,expr)*</strong></em></td>
<td><em>*<em>*将表达式*</em>*<em>expr*</em>*<em>重复执行*</em>*<em>n*</em>*<em>次。用于测试*</em>*<em>MySQL*</em>*<em>处理*</em>*<em>expr*</em>*<em>表达式所耗费的时间*</em>*</em></td>
</tr>
<tr>
<td><em><strong>*CONVERT(value USING char_code)*</strong></em></td>
<td><em>*<em>*将*</em>*<em>value*</em>*<em>所使用的字符编码修改为*</em>*<em>char_code*</em>*</em></td>
</tr>
</tbody></table>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/20221006124642517.png" alt="img"></p>
<p> <img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/20221006124642519.png" alt="img"></p>
<p> <img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/20221006124642521.png" alt="img"></p>
<p> <img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/20221006124643523.png" alt="img"></p>
<h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><h3 id="显示系统时间-注：日期-时间"><a href="#显示系统时间-注：日期-时间" class="headerlink" title="显示系统时间(注：日期+时间)"></a>显示系统时间(注：日期+时间)</h3><p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/20221006124643531.png" alt="img"></p>
<h3 id="查询员工号，姓名，工资，以及工资提高百分之20-后的结果（new-salary）"><a href="#查询员工号，姓名，工资，以及工资提高百分之20-后的结果（new-salary）" class="headerlink" title="查询员工号，姓名，工资，以及工资提高百分之20%后的结果（new salary）"></a>查询员工号，姓名，工资，以及工资提高百分之20%后的结果（new salary）</h3><p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/20221006124643537.png" alt="img"></p>
<h3 id="将员工的姓名按首字母排序，并写出姓名的长度（length）"><a href="#将员工的姓名按首字母排序，并写出姓名的长度（length）" class="headerlink" title="将员工的姓名按首字母排序，并写出姓名的长度（length）"></a>将员工的姓名按首字母排序，并写出姓名的长度（length）</h3><p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/20221006124644543.png" alt="img"></p>
<h3 id="查询员工id-last-name-salary，并作为一个列输出，别名为OUT-PUT"><a href="#查询员工id-last-name-salary，并作为一个列输出，别名为OUT-PUT" class="headerlink" title="查询员工id,last_name,salary，并作为一个列输出，别名为OUT_PUT"></a>查询员工id,last_name,salary，并作为一个列输出，别名为OUT_PUT</h3><p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/20221006124644549.png" alt="img"></p>
<h3 id="查询公司各员工工作的年数、工作的天数，并按工作年数的降序排序"><a href="#查询公司各员工工作的年数、工作的天数，并按工作年数的降序排序" class="headerlink" title="查询公司各员工工作的年数、工作的天数，并按工作年数的降序排序"></a>查询公司各员工工作的年数、工作的天数，并按工作年数的降序排序</h3><p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/20221006124645555.png" alt="img"></p>
<h3 id="查询员工姓名，hire-date-department-id"><a href="#查询员工姓名，hire-date-department-id" class="headerlink" title="查询员工姓名，hire_date , department_id"></a>查询员工姓名，hire_date , department_id</h3><p>​    满足以下条件：雇用时间在 1997 年之后， department_id 为80 或 90 或 110, commission_pct 不为空</p>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/20221006124645563.png" alt="img"></p>
<h3 id="查询公司中入职超过10000天的员工姓名、入职时间"><a href="#查询公司中入职超过10000天的员工姓名、入职时间" class="headerlink" title="查询公司中入职超过10000天的员工姓名、入职时间"></a>查询公司中入职超过10000天的员工姓名、入职时间</h3><p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/20221006124646569.png" alt="img"></p>
<h3 id="做一个查询，产生下面的结果"><a href="#做一个查询，产生下面的结果" class="headerlink" title="做一个查询，产生下面的结果"></a>做一个查询，产生下面的结果</h3><p><last_name> earns <salary> monthly but wants &lt;salary*3&gt;</p>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/20221006124646577.png" alt="img"></p>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/20221006124647579.png" alt="img"></p>
<h3 id="使用case-when，按照下面的条件："><a href="#使用case-when，按照下面的条件：" class="headerlink" title="使用case-when，按照下面的条件："></a>使用case-when，按照下面的条件：</h3><p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/20221006124647585.png" alt="img"></p>
<p> <img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/20221006124647587.png" alt="img"></p>
<h1 id="MySQL-聚合函数"><a href="#MySQL-聚合函数" class="headerlink" title="MySQL 聚合函数"></a>MySQL 聚合函数</h1><h2 id="聚合函数介绍及常见的聚合函数"><a href="#聚合函数介绍及常见的聚合函数" class="headerlink" title="聚合函数介绍及常见的聚合函数"></a><strong>聚合函数介绍及常见的聚合函数</strong></h2><p><strong>什么是聚合函数</strong></p>
<p>​    聚合函数作用于一组数据，并对一组数据返回一个值。</p>
<p><strong>常见的聚合函数类型</strong></p>
<p>​    <strong>AVG()</strong></p>
<p>​    <strong>SUM()</strong></p>
<p>​    <strong>MAX()</strong></p>
<p>​    <strong>MIN()</strong></p>
<p>​    <strong>COUNT()</strong></p>
<p><em><strong>*聚合函数语法*</strong></em></p>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/20221006124648613.png" alt="img"></p>
<p>​     <strong>在MySQL中，聚合函数不能嵌套调用。比如不能出现类似“SUM(AVG(字段名称))”形式的调用。</strong></p>
<h3 id="AVG和SUM函数"><a href="#AVG和SUM函数" class="headerlink" title="AVG和SUM函数"></a><strong>AVG和SUM函数</strong></h3><p>​    可以对<strong>数值型数据</strong>使用AVG 和 SUM 函数。</p>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/20221006124648621.png" alt="img"></p>
<p> <img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/20221006124648623.png" alt="img"></p>
<h3 id="MIN和MAX函数"><a href="#MIN和MAX函数" class="headerlink" title="MIN和MAX函数"></a><strong>MIN和MAX函数</strong></h3><p>​    可以对 <strong>任意数据类型</strong> 的数据使用 MIN 和 MAX 函数。</p>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/20221006124649631.png" alt="img"></p>
<p> <img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/20221006124649633.png" alt="img"></p>
<h3 id="COUNT函数"><a href="#COUNT函数" class="headerlink" title="COUNT函数"></a><strong>COUNT函数</strong></h3><p>​    <strong>COUNT(*)返回表中记录总数，适用于</strong> <em>*<em>*任意数据类型*</em>*<em>。*</em>*</em></p>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/20221006124650641.png" alt="img"></p>
<p> 如果计算表中有多少条记录，如何实现：</p>
<p>​    方式1：COUNT(*)</p>
<p>​    方式2：COUNT(常数)，如COUNT(1)</p>
<p>​    方式3：OCUNT(列名)：<strong>不一定对！</strong></p>
<p><em>*<em>*COUNT(expr)*</em> *<em>返回*</em>*<em>expr*</em>*<em>不为空*</em>*<em>的记录总数。*</em>*</em></p>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/20221006124650657.png" alt="img"></p>
<p> <img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/20221006124651659.png" alt="img"></p>
<p><strong>公式：AVG &#x3D; SUM &#x2F; COUNT 其中AVG,SUM,COUNT都是不计算NULL值的</strong></p>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/20221006124651665.png" alt="img"></p>
<p> <strong>需求：计算公司中的平均奖金率</strong></p>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/20221006124652671.png" alt="img"></p>
<p><strong>问题：用</strong> <strong>count(*)</strong> <strong>，</strong> <strong>count(1)</strong> <strong>，</strong> <strong>count(</strong> <strong>列名</strong> <strong>)</strong> <strong>谁好呢</strong> <strong>?</strong></p>
<p>​    其实，对于MyISAM 引擎的表是没有区别的。这种引擎内部有一计数器在维护着行数。</p>
<p>Innodb 引擎的表用 count(*),count(1) 直接读行数，复杂度是 O(n) ，因为 innodb 真的要去数一遍。但好 于具体的count( 列名 ) 。</p>
<p><strong>问题：能不能使用</strong> <strong>count(</strong> <strong>列名</strong> <strong>)</strong> <strong>替换</strong> <strong>count(*)?</strong></p>
<p>​    不要使用 count( 列名 ) 来替代 count(<em>) ， count(</em>) 是 SQL92 定义的标准统计行数的语法，跟数 据库无关，跟 NULL 和非 NULL 无关。</p>
<p>​    说明：count(*) 会统计值为 NULL 的行，而 count( 列名 ) 不会统计此列为 NULL 值的行。</p>
<h2 id="GROUP-BY"><a href="#GROUP-BY" class="headerlink" title="GROUP BY"></a><strong>GROUP BY</strong></h2><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a><strong>基本使用</strong></h3><p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/20221006124652691.png" alt="img"></p>
<p> <strong>可以使用<strong><strong>GROUP BY</strong></strong>子句将表中的数据分成若干组:</strong></p>
<p>​    <strong>SELECT</strong> <em><strong>*column, group_function(column)*</strong></em></p>
<p>​    <em><strong>*FROM table*</strong></em></p>
<p>​    <em>*<em>*[*</em>*<em>WHERE*</em> *<em>condition]*</em>*</em></p>
<p>​    <em>*<em>*[*</em>*<em>GROUP BY*</em> *<em>group_by_expression]*</em>*</em></p>
<p>​    <em>*<em>*[*</em>*<em>ORDER BY*</em> *<em>column];*</em>*</em></p>
<p>​    <em>*<em>*[*</em>*<em>LIMITE*</em>*</em> [位置偏移量,] 行数 <em><strong>*]*</strong></em></p>
<p><strong>注意：</strong> <strong>WHERE</strong> <strong>一定放在</strong> <strong>FROM</strong> <strong>后面</strong></p>
<p>​    <strong>需求：查询各个部门的平均工资</strong></p>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/20221006124653711.png" alt="img"></p>
<p>​     <strong>需求：查询各个部门的平均工资、最高工资、工资总和、人员个数</strong></p>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/20221006124654717.png" alt="img"></p>
<p> <strong>注意：在SELECT列表中所有未包含在组函数中的列都应该包含在 GROUP BY子句中</strong></p>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/20221006124655721.png" alt="img"></p>
<p> 可以输出数据，但是该数据是错误的</p>
<h3 id="使用多个列分组"><a href="#使用多个列分组" class="headerlink" title="使用多个列分组"></a><strong>使用多个列分组</strong></h3><p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/20221006124655729.png" alt="img"></p>
<p>​    <strong>需求1：查询各个department_id中各个job_id的平均工资</strong></p>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/20221006124655735.png" alt="img"></p>
<p>​     <strong>需求2：查询各个job_id中各个department_id的平均工资</strong><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/20221006124656737.png" alt="img"></p>
<p> 可以看出：需求1与需求2输出的结果是相同的。</p>
<h3 id="GROUP-BY中使用WITH-ROLLUP"><a href="#GROUP-BY中使用WITH-ROLLUP" class="headerlink" title="GROUP BY中使用WITH ROLLUP"></a><strong>GROUP BY中使用WITH ROLLUP</strong></h3><p>​    使用 WITH ROLLUP 关键字之后，在所有查询出的分组记录之后增加一条记录，该记录计算查询出的所有记录的总和，即统计记录数量。</p>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/20221006124656747.png" alt="img"></p>
<p> <strong>注意：当使用ROLLUP时，最好不要同时使用ORDER BY子句进行结果排序，容易造成数据紊乱。</strong></p>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/20221006124657751.png" alt="img"></p>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a><strong>结论</strong></h3><p><strong>结论1：SELECT中出现的非函数字段必须声明在GROUP BY 中。</strong></p>
<p>​       <strong>反之，GROUP BY 中声明的字段可以不出现在SELECT 中。</strong></p>
<p><strong>结论2：GROUP BY 声明在FROM 后面、WHERE后面、ORDER BY 前面、LIMIT前面****。</strong></p>
<p><strong>结论3：当使用ROLLUP时，最好不要同时使用ORDER BY子句进行结果排序，容易造成数</strong></p>
<p>​       <strong>据紊乱。</strong></p>
<h1 id="MySQL-子查询"><a href="#MySQL-子查询" class="headerlink" title="MySQL 子查询"></a>MySQL 子查询</h1><h2 id="子查询介绍"><a href="#子查询介绍" class="headerlink" title="子查询介绍"></a>子查询介绍</h2><p>​    子查询指一个查询语句嵌套在另一个查询语句内部的查询，这个特性从MySQL 4.1开始引入。</p>
<p>​    SQL 中子查询的使用大大增强了 SELECT 查询的能力，因为很多时候查询需要从结果集中获取数据，或者需要从同一个表中先计算得出一个数据结果，然后与这个数据结果（可能是某个标量，也可能是某个集合）进行比较。</p>
<h2 id="需求分析与问题解决"><a href="#需求分析与问题解决" class="headerlink" title="需求分析与问题解决"></a><strong>需求分析与问题解决</strong></h2><h3 id="实际问题"><a href="#实际问题" class="headerlink" title="实际问题"></a><strong>实际问题</strong></h3><p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/20221006124657779.png" alt="img"></p>
<p><strong>需求：谁的工资比 Abel高?</strong></p>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/20221006124658785.png" alt="img"></p>
<p> <img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/20221006124658787.png" alt="img"></p>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/20221006124659789.png" alt="img"></p>
<p> <strong>查询称谓：括号外的查询称为：外查询（主查询）</strong></p>
<p>​          <strong>括号内的查询称为：内查询（子查询）</strong></p>
<p><strong>问题：</strong> 方式2与方式3有好坏之分吗？（方式1为两次查询，不推荐使用）</p>
<p><strong>解答：</strong> 自连接方式好！</p>
<p>​    题目中可以使用子查询，也可以使用自连接。一般情况建议你使用自连接，因为在许多 DBMS 的处理过 程中，对于自连接的处理速度要比子查询快得多。</p>
<p>​    可以这样理解：子查询实际上是通过未知表进行查询后的条件判断，而自连接是通过已知的自身数据表进行条件判断，因此在大部分 DBMS 中都对自连接处理进行了优化。</p>
<h3 id="子查询的基本使用"><a href="#子查询的基本使用" class="headerlink" title="子查询的基本使用"></a><strong>子查询的基本使用</strong></h3><p>​    <em><strong>*子查询的基本语法结构：*</strong></em></p>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/20221006124659807.png" alt="img"></p>
<p>​    <em><strong>*子查询（内查询）在主查询之前一次执行完成。*</strong></em></p>
<p>​    <em><strong>*子查询的结果被主查询（外查询）使用 。*</strong></em></p>
<p>​    </p>
<p>​    <strong>注意事项</strong></p>
<p>​        <em><strong>*1.子查询要包含在括号内*</strong></em></p>
<p>​        <em><strong>*2.将子查询放在比较条件的右侧*</strong></em></p>
<p>​        <em><strong>*3.单行操作符对应单行子查询，多行操作符对应多行子查询*</strong></em></p>
<h3 id="子查询的分类"><a href="#子查询的分类" class="headerlink" title="子查询的分类"></a><strong>子查询的分类</strong></h3><h3 id="分类方式1："><a href="#分类方式1：" class="headerlink" title="分类方式1："></a><strong>分类方式<strong><strong>1</strong></strong>：</strong></h3><p>我们按内查询的<strong>结果返回一条还是多条记录</strong>，将子查询分为 单行子查询 、 多行子查询 。</p>
<p><em><strong>*单行子查询：*</strong></em></p>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/20221006124659831.png" alt="img"></p>
<p><em><strong>*多行子查询：*</strong></em></p>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/20221006124700837.png" alt="img"></p>
<h3 id="分类方式2："><a href="#分类方式2：" class="headerlink" title="分类方式2："></a><strong>分类方式<strong><strong>2</strong></strong>：</strong></h3><p>​    我们按内查询<strong>是否被执行多次</strong>，将子查询划分为 相关 ( 或关联 ) 子查询 和 不相关 ( 或非关联 ) 子查询 。</p>
<p>​    子查询从数据表中查询了数据结果，如果这个数据结果只执行一次，然后这个数据结果作为主查询的条件进行执行，那么这样的子查询叫做不相关子查询。</p>
<p>​    同样，如果子查询需要执行多次，即采用循环的方式，先从外部查询开始，每次都传入子查询进行查询，然后再将结果反馈给外部，这种嵌套的执行方式就称为相关子查询。</p>
<h2 id="单行子查询"><a href="#单行子查询" class="headerlink" title="单行子查询"></a><strong>单行子查询</strong></h2><h3 id="单行比较操作符"><a href="#单行比较操作符" class="headerlink" title="单行比较操作符"></a><strong>单行比较操作符</strong></h3><table>
<thead>
<tr>
<th><strong>操作符</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td><em><strong>*&#x3D;*</strong></em></td>
<td><em><strong>*equal to*</strong></em></td>
</tr>
<tr>
<td><em><strong>*&gt;*</strong></em></td>
<td><em><strong>*greater than*</strong></em></td>
</tr>
<tr>
<td><em><strong>*&gt;&#x3D;*</strong></em></td>
<td><em><strong>*greater than or equal to*</strong></em></td>
</tr>
<tr>
<td><em><strong>*&lt;*</strong></em></td>
<td><em><strong>*less than*</strong></em></td>
</tr>
<tr>
<td><em><strong>*&lt;&#x3D;*</strong></em></td>
<td><em><strong>*less than or equal to*</strong></em></td>
</tr>
<tr>
<td><em><strong>*&lt;&gt;*</strong></em></td>
<td><em><strong>*not equal to*</strong></em></td>
</tr>
</tbody></table>
<h3 id="代码示例-1"><a href="#代码示例-1" class="headerlink" title="代码示例"></a><strong>代码示例</strong></h3><h3 id="需求：查询工资大于149号员工工资的员工的信息"><a href="#需求：查询工资大于149号员工工资的员工的信息" class="headerlink" title="需求：查询工资大于149号员工工资的员工的信息"></a><strong>需求：查询工资大于<strong><strong>149</strong></strong>号员工工资的员工的信息</strong></h3><p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/20221006124700866.png" alt="img"></p>
<h3 id="-1"><a href="#-1" class="headerlink" title=""></a></h3><h3 id="需求：返回job-id与141号员工相同，salary比143号员工多的员工姓名，"><a href="#需求：返回job-id与141号员工相同，salary比143号员工多的员工姓名，" class="headerlink" title="需求：返回job_id与141号员工相同，salary比143号员工多的员工姓名，"></a><strong>需求：返回<strong><strong>job_id</strong></strong>与<strong><strong>141</strong></strong>号员工相同，<strong><strong>salary</strong></strong>比<strong><strong>143</strong></strong>号员工多的员工姓名，</strong></h3><h3 id="job-id-和工资"><a href="#job-id-和工资" class="headerlink" title="job_id****和工资"></a><strong>job_id****和工资</strong></h3><p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/20221006124700874.png" alt="img"></p>
<p> <img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/20221006124701876.png" alt="img"></p>
<h3 id="需求：返回公司工资最少的员工的last-name-job-id和-salary"><a href="#需求：返回公司工资最少的员工的last-name-job-id和-salary" class="headerlink" title="需求：返回公司工资最少的员工的last_name,job_id和****salary"></a><strong>需求：返回公司工资最少的员工的<strong><strong>last_name,job_id</strong></strong>和****salary</strong></h3><p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/20221006124701880.png" alt="img"></p>
<h3 id="需求：查询与141号或174号员工的manager-id和department-id相同的其他员工"><a href="#需求：查询与141号或174号员工的manager-id和department-id相同的其他员工" class="headerlink" title="需求：查询与141号或174号员工的manager_id和department_id相同的其他员工"></a><strong>需求：查询与<strong><strong>141</strong></strong>号或<strong><strong>174</strong></strong>号员工的<strong><strong>manager_id</strong></strong>和<strong><strong>department_id</strong></strong>相同的其他员工</strong></h3><h3 id="的employee-id，manager-id，department-id"><a href="#的employee-id，manager-id，department-id" class="headerlink" title="的employee_id，manager_id，department_id"></a><strong>的employee_id<strong><strong>，</strong></strong>manager_id<strong><strong>，</strong></strong>department_id</strong></h3><p>实现方式 1 ：不成对比较</p>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/20221006124701890.png" alt="img"></p>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/20221006124702892.png" alt="img"></p>
<p> 实现方式2：成对比较</p>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/20221006124702896.png" alt="img"></p>
<h3 id="HAVING-中的子查询"><a href="#HAVING-中的子查询" class="headerlink" title="HAVING 中的子查询"></a><strong>HAVING 中的子查询</strong></h3><p>​    <strong>首先执行子查询。</strong></p>
<p>​    <em><strong>*向主查询中的HAVING** **子句返回结果。*</strong></em></p>
<h3 id="需求：查询最低工资大于110号部门最低工资的部门id和其最低工资"><a href="#需求：查询最低工资大于110号部门最低工资的部门id和其最低工资" class="headerlink" title="需求：查询最低工资大于110号部门最低工资的部门id和其最低工资"></a><strong>需求：查询最低工资大于11<strong><strong>0</strong></strong>号部门最低工资的部门<strong><strong>id</strong></strong>和其最低工资</strong></h3><p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/20221006124702908.png" alt="img"></p>
<h3 id="CASE中的子查询"><a href="#CASE中的子查询" class="headerlink" title="CASE中的子查询"></a><strong>CASE中的子查询</strong></h3><p>​    在CASE 表达式中使用单列子查询：</p>
<h3 id="需求：显式员工的employee-id-last-name和location。其中，若员工"><a href="#需求：显式员工的employee-id-last-name和location。其中，若员工" class="headerlink" title="需求：显式员工的employee_id,last_name和location。其中，若员工"></a><strong>需求：显式员工的<strong><strong>employee_id,last_name</strong></strong>和<strong><strong>location</strong></strong>。其中，若员工</strong></h3><h3 id="department-id与location-id为1800的department-id相同，则-location"><a href="#department-id与location-id为1800的department-id相同，则-location" class="headerlink" title="department_id与location_id为1800的department_id相同，则****location"></a><strong>department_id与<strong><strong>location_id</strong></strong>为<strong><strong>1800</strong></strong>的<strong><strong>department_id</strong></strong>相同，则****location</strong></h3><h3 id="为’Canada’，其余则为’USA’-。"><a href="#为’Canada’，其余则为’USA’-。" class="headerlink" title="为’Canada’，其余则为’USA’****。"></a><strong>为’Canada’<strong><strong>，其余则为</strong></strong>’USA’****。</strong></h3><p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/20221006124703922.png" alt="img"></p>
<h3 id="子查询中的空值问题"><a href="#子查询中的空值问题" class="headerlink" title="子查询中的空值问题"></a><strong>子查询中的空值问题</strong></h3><h2 id="-2"><a href="#-2" class="headerlink" title=""></a><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/20221006124703928.png" alt="img"></h2><p><strong>原因：*<em>子查询不返回任何行*</em></strong> </p>
<h2 id="-3"><a href="#-3" class="headerlink" title=""></a><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/20221006124703932.png" alt="img"></h2><h3 id="非法使用子查询"><a href="#非法使用子查询" class="headerlink" title="非法使用子查询"></a><strong>非法使用子查询</strong></h3><p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/20221006124704936.png" alt="img"></p>
<p> <strong>原因：*<em>多行子查询使用单行比较符*</em></strong></p>
<h2 id="多行子查询"><a href="#多行子查询" class="headerlink" title="多行子查询"></a><strong>多行子查询</strong></h2><p>​    <strong>也称为集合比较子查询</strong></p>
<p>​    <em><strong>*内查询返回多行*</strong></em></p>
<p>​    <em><strong>*使用多行比较操作符*</strong></em></p>
<h3 id="多行比较操作符"><a href="#多行比较操作符" class="headerlink" title="多行比较操作符"></a><strong>多行比较操作符</strong></h3><table>
<thead>
<tr>
<th><em><strong>*操作符*</strong></em></th>
<th><em><strong>*含义*</strong></em></th>
</tr>
</thead>
<tbody><tr>
<td><em><strong>*IN*</strong></em></td>
<td><em>*<em>*等于列表中的*</em>*<em>任意一个*</em>*</em></td>
</tr>
<tr>
<td><em><strong>*ANY*</strong></em></td>
<td><em>*<em>*需要和单行比较操作符一起使用，和子查询返回的*</em>*<em>某一个*</em>*<em>值比较*</em>*</em></td>
</tr>
<tr>
<td><em><strong>*ALL*</strong></em></td>
<td><em>*<em>*需要和单行比较操作符一起使用，和子查询返回的*</em>*<em>所有*</em>*<em>值比较*</em>*</em></td>
</tr>
<tr>
<td><em><strong>*SOME*</strong></em></td>
<td><em>*<em>*实际上是*</em>*<em>ANY*</em>*<em>的别名，作用相同，一般常使用*</em>*<em>ANY*</em>*</em></td>
</tr>
</tbody></table>
<h3 id="代码示例-2"><a href="#代码示例-2" class="headerlink" title="代码示例"></a><strong>代码示例</strong></h3><h3 id="需求：查询每个部门中最低工资的员工号和姓名"><a href="#需求：查询每个部门中最低工资的员工号和姓名" class="headerlink" title="需求：查询每个部门中最低工资的员工号和姓名"></a><strong>需求：查询每个部门中最低工资的员工号和姓名</strong></h3><p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/20221006124704961.png" alt="img"></p>
<h3 id="需求：返回其它job-id中比job-id为‘IT-PROG’部门任一工资低的员工的"><a href="#需求：返回其它job-id中比job-id为‘IT-PROG’部门任一工资低的员工的" class="headerlink" title="需求：返回其它job_id中比job_id为‘IT_PROG’部门任一工资低的员工的"></a><strong>需求：返回其它<strong><strong>job_id</strong></strong>中比<strong><strong>job_id</strong></strong>为<strong><strong>‘IT_PROG’</strong></strong>部门任一工资低的员工的</strong></h3><h3 id="员工号、姓名、job-id-以及-salary"><a href="#员工号、姓名、job-id-以及-salary" class="headerlink" title="员工号、姓名、job_id 以及****salary"></a><strong>员工号、姓名、job_id</strong> <strong>以及****salary</strong></h3><p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/20221006124704969.png" alt="img"></p>
<h3 id="需求：返回其它job-id中比job-id为‘IT-PROG’部门所有工资都低的员工的"><a href="#需求：返回其它job-id中比job-id为‘IT-PROG’部门所有工资都低的员工的" class="headerlink" title="需求：返回其它job_id中比job_id为‘IT_PROG’部门所有工资都低的员工的"></a><strong>需求：返回其它<strong><strong>job_id</strong></strong>中比<strong><strong>job_id</strong></strong>为<strong><strong>‘IT_PROG’</strong></strong>部门所有工资都低的员工的</strong></h3><h3 id="员工号、姓名、job-id以及salary"><a href="#员工号、姓名、job-id以及salary" class="headerlink" title="员工号、姓名、job_id以及salary"></a><strong>员工号、姓名、job_id<strong><strong>以及</strong></strong>salary</strong></h3><p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/20221006124705977.png" alt="img"></p>
<h3 id="需求：查询平均工资最低的部门-id"><a href="#需求：查询平均工资最低的部门-id" class="headerlink" title="需求：查询平均工资最低的部门****id"></a><strong>需求：查询平均工资最低的部门****id</strong></h3><p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/20221006124705981.png" alt="img"></p>
<p> <img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/20221006124705983.png" alt="img"></p>
<p> <img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/20221006124706985.png" alt="img"></p>
<h3 id="空值问题"><a href="#空值问题" class="headerlink" title="空值问题"></a><strong>空值问题</strong></h3><p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/20221006124707991.png" alt="img"></p>
<p> <strong>原因：内查询中存在NULL</strong></p>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/20221006124707995.png" alt="img"></p>
<h2 id="相关子查询"><a href="#相关子查询" class="headerlink" title="相关子查询"></a><strong>相关子查询</strong></h2><h3 id="相关子查询执行流程"><a href="#相关子查询执行流程" class="headerlink" title="相关子查询执行流程"></a><strong>相关子查询执行流程</strong></h3><p>​    如果子查询的执行依赖于外部查询，通常情况下都是因为子查询中的表用到了外部的表，并进行了条件关联，因此每执行一次外部查询，子查询都要重新计算一次，这样的子查询就称之为 关联子查询 。</p>
<p>​    相关子查询按照一行接一行的顺序执行，主查询的每一行都执行一次子查询。</p>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061247081005.png" alt="img"></p>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061247081007.png" alt="img"></p>
<p> 说明：<strong>子查询中使用主查询中的列</strong></p>
<h3 id="代码示例-3"><a href="#代码示例-3" class="headerlink" title="代码示例"></a><strong>代码示例</strong></h3><h3 id="需求：查询员工中工资大于本部门平均工资的员工的last-name-salary和"><a href="#需求：查询员工中工资大于本部门平均工资的员工的last-name-salary和" class="headerlink" title="需求：查询员工中工资大于本部门平均工资的员工的last_name,salary和"></a><strong>需求：查询员工中工资大于本部门平均工资的员工的<strong><strong>last_name,salary</strong></strong>和</strong></h3><h3 id="其department-id"><a href="#其department-id" class="headerlink" title="其department_id"></a><strong>其department_id</strong></h3><p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061247081019.png" alt="img"></p>
<p> <img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061247091021.png" alt="img"></p>
<h3 id="需求：查询员工的-id-salary-按照department-name-排序"><a href="#需求：查询员工的-id-salary-按照department-name-排序" class="headerlink" title="*需求：查询员工的**id,salary,按照department_name* 排序"></a>*<em>需求：查询员工的</em>**<em>id,salary,<strong><strong>按照</strong></strong>department_name</em>* <strong>排序</strong></h3><p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061247091025.png" alt="img"></p>
<h3 id="需求：若employees表中employee-id与job-history表中employee-id相同的-数"><a href="#需求：若employees表中employee-id与job-history表中employee-id相同的-数" class="headerlink" title="需求：若employees表中employee_id与job_history表中employee_id相同的****数"></a><strong>需求：若<strong><strong>employees</strong></strong>表中<strong><strong>employee_id</strong></strong>与<strong><strong>job_history</strong></strong>表中<strong><strong>employee_id</strong></strong>相同的****数</strong></h3><h3 id="目不小于2，输出这些相同id的员工的employee-id-last-name和其-job-id"><a href="#目不小于2，输出这些相同id的员工的employee-id-last-name和其-job-id" class="headerlink" title="目不小于2，输出这些相同id的员工的employee_id,last_name和其****job_id"></a><strong>目不小于2，输出这些相同<strong><strong>id</strong></strong>的员工的<strong><strong>employee_id,last_name</strong></strong>和其****job_id</strong></h3><p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061247111033.png" alt="img"></p>
<h3 id="EXISTS-与-NOT-EXISTS关键字"><a href="#EXISTS-与-NOT-EXISTS关键字" class="headerlink" title="EXISTS 与 NOT EXISTS关键字"></a><strong>EXISTS 与 NOT EXISTS关键字</strong></h3><p>​    关联子查询通常也会和 EXISTS 操作符一起来使用，用来检查在子查询中是否存在满足条件的行。</p>
<p>​    <strong>如果在子查询中不存在满足条件的行：</strong></p>
<p>​        条件返回 FALSE</p>
<p>​        继续在子查询中查找</p>
<p>​    <strong>如果在子查询中存在满足条件的行：</strong></p>
<p>​        不在子查询中继续查找</p>
<p>​        条件返回 TRUE</p>
<p>​    NOT EXISTS关键字表示如果不存在某种条件，则返回 TRUE ，否则返回 FALSE 。</p>
<h3 id="需求：查询公司管理者的employee-id，last-name，job-id，-department-id"><a href="#需求：查询公司管理者的employee-id，last-name，job-id，-department-id" class="headerlink" title="需求：查询公司管理者的employee_id，last_name，job_id，****department_id"></a><strong>需求：查询公司管理者的<strong><strong>employee_id</strong></strong>，<strong><strong>last_name</strong></strong>，<strong><strong>job_id</strong></strong>，****department_id</strong></h3><h3 id="信息"><a href="#信息" class="headerlink" title="信息"></a><strong>信息</strong></h3><p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061247111057.png" alt="img"></p>
<p> <img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061247121059.png" alt="img"></p>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061247121061.png" alt="img"></p>
<h3 id="需求：查询departments表中，不存在于employees表中的部门的-department-id和department-name"><a href="#需求：查询departments表中，不存在于employees表中的部门的-department-id和department-name" class="headerlink" title="需求：查询departments表中，不存在于employees表中的部门的       department_id和department_name"></a>需求：查询departments表中，不存在于employees表中的部门的       department_id和department_name</h3><p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061247131065.png" alt="img"></p>
<p> <img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061247141067.png" alt="img"></p>
<h3 id="相关更新"><a href="#相关更新" class="headerlink" title="相关更新"></a><strong>相关更新</strong></h3><p><strong>语法：</strong></p>
<p>​    <em><strong>*UPDATE** **table1 alias1*</strong></em></p>
<p>​    <em>*<em>*SET*</em> *<em>column &#x3D; (*</em>*<em>SELECT*</em> *<em>expression*</em>*</em></p>
<p>​                 <em><strong>*FROM** **table2 alias2*</strong></em></p>
<p>​                 <em>*<em>*WHERE*</em> *<em>alias1*</em>**.column*</em> *<em>&#x3D; alias2*</em>*<em>.column*</em>*<em>);*</em>**</p>
<p><em><strong>*使用相关子查询依据一个表中的数据更新另一个表的数据。*</strong></em></p>
<h3 id="需求：在employees中增加一个department-name字段，数据为员工对应的"><a href="#需求：在employees中增加一个department-name字段，数据为员工对应的" class="headerlink" title="需求：在employees中增加一个department_name字段，数据为员工对应的"></a><strong>需求：在<strong><strong>employees</strong></strong>中增加一个<strong><strong>department_name</strong></strong>字段，数据为员工对应的</strong></h3><h3 id="部门名称"><a href="#部门名称" class="headerlink" title="部门名称"></a><strong>部门名称</strong></h3><p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061247141087.png" alt="img"></p>
<p> <img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061247141089.png" alt="img"></p>
<h3 id="相关删除"><a href="#相关删除" class="headerlink" title="相关删除"></a><strong>相关删除</strong></h3><p><strong>语法：</strong></p>
<p>​    DELETE FROM table1 alias1</p>
<p>​    WHERE column operator ( SELECT expression</p>
<p>​                         FROM table2 alias2</p>
<p>​                         WHERE alias1 .column &#x3D; alias2 .column );</p>
<p><strong>题目：删除表</strong> <strong>employees</strong> <strong>中，其与</strong> <strong>emp_history</strong> <strong>表皆有的数据</strong></p>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061247151107.png" alt="img"></p>
<h2 id="结论-1"><a href="#结论-1" class="headerlink" title="结论"></a>结论</h2><p><strong>结论：在SELECT语句中，出GROUP BY 与LIMIT之外，其余地方都可以声明子查询</strong></p>
<h2 id="练习-1"><a href="#练习-1" class="headerlink" title="练习"></a>练习</h2><h3 id="查询和Zlotkey相同部门的员工姓名和工资"><a href="#查询和Zlotkey相同部门的员工姓名和工资" class="headerlink" title="查询和Zlotkey相同部门的员工姓名和工资"></a>查询和Zlotkey相同部门的员工姓名和工资</h3><p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061247151119.png" alt="img"></p>
<h3 id="查询工资比公司平均工资高的员工的员工号，姓名和工资。"><a href="#查询工资比公司平均工资高的员工的员工号，姓名和工资。" class="headerlink" title="查询工资比公司平均工资高的员工的员工号，姓名和工资。"></a>查询工资比公司平均工资高的员工的员工号，姓名和工资。</h3><p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061247151123.png" alt="img"></p>
<h3 id="选择工资大于所有JOB-ID-x3D-‘SA-MAN’的员工的工资的员工的last-name-job-id-salary"><a href="#选择工资大于所有JOB-ID-x3D-‘SA-MAN’的员工的工资的员工的last-name-job-id-salary" class="headerlink" title="选择工资大于所有JOB_ID &#x3D; ‘SA_MAN’的员工的工资的员工的last_name, job_id, salary"></a>选择工资大于所有JOB_ID &#x3D; ‘SA_MAN’的员工的工资的员工的last_name, job_id, salary</h3><p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061247161127.png" alt="img"></p>
<h3 id="查询和姓名中包含字母u的员工在相同部门的员工的员工号和姓名"><a href="#查询和姓名中包含字母u的员工在相同部门的员工的员工号和姓名" class="headerlink" title="查询和姓名中包含字母u的员工在相同部门的员工的员工号和姓名"></a>查询和姓名中包含字母u的员工在相同部门的员工的员工号和姓名</h3><p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061247161133.png" alt="img"></p>
<h3 id="查询在部门的location-id为1700的部门工作的员工的员工号"><a href="#查询在部门的location-id为1700的部门工作的员工的员工号" class="headerlink" title="查询在部门的location_id为1700的部门工作的员工的员工号"></a>查询在部门的location_id为1700的部门工作的员工的员工号</h3><p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061247171139.png" alt="img"></p>
<h3 id="查询管理者是King的员工姓名和工资"><a href="#查询管理者是King的员工姓名和工资" class="headerlink" title="查询管理者是King的员工姓名和工资"></a>查询管理者是King的员工姓名和工资</h3><p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061247171145.png" alt="img"></p>
<h3 id="查询工资最低的员工信息-last-name-salary"><a href="#查询工资最低的员工信息-last-name-salary" class="headerlink" title="查询工资最低的员工信息: last_name, salary"></a>查询工资最低的员工信息: last_name, salary</h3><p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061247181151.png" alt="img"></p>
<h3 id="查询平均工资最低的部门信息"><a href="#查询平均工资最低的部门信息" class="headerlink" title="查询平均工资最低的部门信息"></a>查询平均工资最低的部门信息</h3><p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061247181157.png" alt="img"></p>
<p> <img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061247181159.png" alt="img"></p>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061247191161.png" alt="img"></p>
<p> <img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061247191163.png" alt="img"></p>
<h3 id="查询平均工资最低的部门信息和该部门的平均工资（相关子查询）"><a href="#查询平均工资最低的部门信息和该部门的平均工资（相关子查询）" class="headerlink" title="查询平均工资最低的部门信息和该部门的平均工资（相关子查询）"></a>查询平均工资最低的部门信息和该部门的平均工资（相关子查询）</h3><p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061247191169.png" alt="img"></p>
<p> <img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061247201171.png" alt="img"></p>
<p> <img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061247201173.png" alt="img"></p>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061247201175.png" alt="img"></p>
<h3 id="查询平均工资最高的-job-信息"><a href="#查询平均工资最高的-job-信息" class="headerlink" title="查询平均工资最高的 job 信息"></a>查询平均工资最高的 job 信息</h3><p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061247201179.png" alt="img"></p>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061247211181.png" alt="img"></p>
<h3 id="查询平均工资高于公司平均工资的部门有哪些"><a href="#查询平均工资高于公司平均工资的部门有哪些" class="headerlink" title="查询平均工资高于公司平均工资的部门有哪些?"></a>查询平均工资高于公司平均工资的部门有哪些?</h3><p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061247211187.png" alt="img"></p>
<h3 id="查询出公司中所有-manager-的详细信息"><a href="#查询出公司中所有-manager-的详细信息" class="headerlink" title="查询出公司中所有 manager 的详细信息"></a>查询出公司中所有 manager 的详细信息</h3><p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061247221193.png" alt="img"></p>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061247221195.png" alt="img"></p>
<h3 id="各个部门中-最高工资中最低的那个部门的-最低工资是多少"><a href="#各个部门中-最高工资中最低的那个部门的-最低工资是多少" class="headerlink" title="各个部门中 最高工资中最低的那个部门的 最低工资是多少?"></a>各个部门中 最高工资中最低的那个部门的 最低工资是多少?</h3><p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061247221201.png" alt="img"></p>
<h3 id="查询平均工资最高的部门的-manager-的详细信息-last-name"><a href="#查询平均工资最高的部门的-manager-的详细信息-last-name" class="headerlink" title="查询平均工资最高的部门的 manager 的详细信息: last_name,"></a>查询平均工资最高的部门的 manager 的详细信息: last_name,</h3><h3 id="department-id-email-salary"><a href="#department-id-email-salary" class="headerlink" title="department_id, email, salary"></a>department_id, email, salary</h3><p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061247231209.png" alt="img"></p>
<h3 id="查询部门的部门号，其中不包括job-id是”ST-CLERK”的部门号"><a href="#查询部门的部门号，其中不包括job-id是”ST-CLERK”的部门号" class="headerlink" title="查询部门的部门号，其中不包括job_id是”ST_CLERK”的部门号"></a>查询部门的部门号，其中不包括job_id是”ST_CLERK”的部门号</h3><p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061247231215.png" alt="img"></p>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061247231217.png" alt="img"> </p>
<h3 id="选择所有没有管理者的员工的last-name"><a href="#选择所有没有管理者的员工的last-name" class="headerlink" title="选择所有没有管理者的员工的last_name"></a>选择所有没有管理者的员工的last_name</h3><p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061247241221.png" alt="img"></p>
<h3 id="查询员工号、姓名、雇用时间、工资，其中员工的管理者为-‘De-Haan’"><a href="#查询员工号、姓名、雇用时间、工资，其中员工的管理者为-‘De-Haan’" class="headerlink" title="查询员工号、姓名、雇用时间、工资，其中员工的管理者为 ‘De Haan’"></a>查询员工号、姓名、雇用时间、工资，其中员工的管理者为 ‘De Haan’</h3><p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061247241227.png" alt="img"></p>
<h3 id="查询各部门中工资比本部门平均工资高的员工的员工号-姓名和工资"><a href="#查询各部门中工资比本部门平均工资高的员工的员工号-姓名和工资" class="headerlink" title="查询各部门中工资比本部门平均工资高的员工的员工号, 姓名和工资"></a>查询各部门中工资比本部门平均工资高的员工的员工号, 姓名和工资</h3><h3 id="（相关子查询）"><a href="#（相关子查询）" class="headerlink" title="（相关子查询）"></a>（相关子查询）</h3><p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061247241235.png" alt="img"></p>
<h3 id="查询每个部门下的部门人数大于-5-的部门名称（相关子查询）"><a href="#查询每个部门下的部门人数大于-5-的部门名称（相关子查询）" class="headerlink" title="查询每个部门下的部门人数大于 5 的部门名称（相关子查询）"></a>查询每个部门下的部门人数大于 5 的部门名称（相关子查询）</h3><p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061247241241.png" alt="img"></p>
<h3 id="查询每个国家下的部门个数大于-2-的国家编号（相关子查询）"><a href="#查询每个国家下的部门个数大于-2-的国家编号（相关子查询）" class="headerlink" title="查询每个国家下的部门个数大于 2 的国家编号（相关子查询）"></a>查询每个国家下的部门个数大于 2 的国家编号（相关子查询）</h3><p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061247251247.png" alt="img"></p>
<h2 id="HAVING"><a href="#HAVING" class="headerlink" title="HAVING"></a><strong>HAVING</strong></h2><h3 id="基本使用-1"><a href="#基本使用-1" class="headerlink" title="基本使用"></a><strong>基本使用</strong></h3><p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061247251253.png" alt="img"></p>
<p><strong>过滤分组：</strong> <strong>HAVING</strong> <strong>子句</strong></p>
<p>​    <strong>1. 行已经被分组。</strong></p>
<p>​    <em><strong>*2. 使用了聚合函数。*</strong></em></p>
<p>​    <em>*<em>*3. 满足*</em>*<em>HAVING*</em> *<em>子句中条件的分组将被显示。*</em>*</em></p>
<p>​    <em><strong>*4.** **HAVING 不能单独使用，必须要跟 GROUP BY 一起使用，HAVING要放在GROUP       BY后面 。*</strong></em></p>
<p>​    <em><strong>*5.如果过滤条件中使用了聚合函数，则必须使用HAVING来替换WHERE。否则，报错。*</strong></em></p>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061247251269.png" alt="img"></p>
<p> <strong>需求：部门最高工资比10000高的部门</strong></p>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061247251273.png" alt="img"></p>
<p> <img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061247251275.png" alt="img"></p>
<h3 id="WHERE和HAVING的对比"><a href="#WHERE和HAVING的对比" class="headerlink" title="WHERE和HAVING的对比"></a>WHERE和HAVING的对比</h3><p><strong>需求：查询部门id为10，20，30，40这4个部门中最高工资的部门信息</strong></p>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061247251283.png" alt="img"></p>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061247261285.png" alt="img"></p>
<p><strong>建议使用方法1：其效率更高</strong></p>
<p><strong>结论：当过滤条件有聚合函数时，则此过滤条件必须声明在HAVING中。</strong></p>
<p>​      <strong>当过滤条件中没有聚合函数时，则此过滤条件声明在WHERE或HAVING中都可以，</strong></p>
<p>​        <strong>但是，建议声明在WHERE中。</strong></p>
<p><em><strong>*WHERE和HAVING的区别*</strong></em></p>
<p>​    <strong>区别1</strong> <strong>：</strong> <strong>WHERE</strong> <strong>可以直接使用表中的字段作为筛选条件，但不能使用分组中的计算函数作为筛选条件；</strong> <strong>HAVING</strong> <strong>必须要与</strong> <strong>GROUP BY</strong> <strong>配合使用，可以把分组计算的函数和分组字段作为筛选条件。</strong></p>
<p>​    这决定了，在需要对数据进行分组统计的时候，HAVING 可以完成 WHERE 不能完成的任务。这是因为，在查询语法结构中，WHERE 在 GROUP BY 之前，所以无法对分组结果进行筛选。 HAVING 在 GROUP BY 之后，可以使用分组字段和分组中的计算函数，对分组的结果集进行筛选，这个功能是 WHERE 无法完成的。另外，WHERE 排除的记录不再包括在分组中。</p>
<p>​    <strong>区别2</strong> <strong>：如果需要通过连接从关联表中获取需要的数据，</strong> <strong>WHERE</strong> <strong>是先筛选后连接，而</strong> <strong>HAVING</strong> <strong>是先连接</strong> <strong>后筛选。</strong></p>
<p>​     这一点，就决定了在关联查询中， WHERE 比 HAVING 更高效。因为 WHERE 可以先筛选，用一个筛选后的较小数据集和关联表进行连接，这样占用的资源比较少，执行效率也比较高。HAVING 则需要先把结果集准备好，也就是用未被筛选的数据集进行关联，然后对这个大的数据集进行筛选，这样占用的资源就比较多，执行效率也较低。</p>
<p><em><strong>*小结如下：*</strong></em></p>
<table>
<thead>
<tr>
<th></th>
<th><strong>优点</strong></th>
<th><strong>缺点</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>WHERE</strong></td>
<td><em><strong>*先筛选数据再关联，执行效率高*</strong></em></td>
<td><em><strong>*不能使用分组中的计算函数进行筛选*</strong></em></td>
</tr>
<tr>
<td><strong>HAVING</strong></td>
<td><em><strong>*可以使用分组中的计算函数*</strong></em></td>
<td><em><strong>*在最后的结果集中进行筛选，执行效率较低*</strong></em></td>
</tr>
</tbody></table>
<p><strong>开发中的选择：</strong></p>
<p>​    WHERE 和 HAVING 也不是互相排斥的，我们可以在一个查询里面同时使用 WHERE 和 HAVING 。包含分组统计函数的条件用 HAVING ，普通条件用 WHERE 。这样，我们就既利用了 WHERE 条件的高效快速，又发挥了 HAVING 可以使用包含分组统计函数的查询条件的优点。当数据量特别大的时候，运行效率会有很大的差别。</p>
<h2 id="SELECT的执行过程"><a href="#SELECT的执行过程" class="headerlink" title="SELECT的执行过程"></a><strong>SELECT的执行过程</strong></h2><h3 id="查询的结构"><a href="#查询的结构" class="headerlink" title="查询的结构"></a><strong>查询的结构</strong></h3><p><em>*<em>*方式*</em>*<em>1*</em>*<em>：（SQL92语法）*</em>*</em></p>
<p>​    <em>*<em>*SELECT*</em> **…,….,…*</em>**</p>
<p>​    <em>*<em>*FROM*</em> **…,…,….*</em>**</p>
<p>​    <em><strong>*WHERE** **多表的连接条件*</strong></em></p>
<p>​    <em><strong>*AND** **不包含组函数的过滤条件*</strong></em></p>
<p>​    <em>*<em>*GROUP BY*</em> **…,…*</em>**</p>
<p>​    <em><strong>*HAVING** **包含组函数的过滤条件*</strong></em></p>
<p>​    <em>*<em>*ORDER BY*</em> **…*</em> *<em>ASC*</em>*<em>&#x2F;DESC*</em>**</p>
<p>​    <em>*<em>*LIMIT*</em> **…,…*</em>**</p>
<p><em>*<em>*方式*</em>*<em>2*</em>*<em>：*</em>*</em></p>
<p>​    <em>*<em>*SELECT*</em> **…,….,…*</em>**</p>
<p>​    <em>*<em>*FROM*</em> **…*</em> *<em>JOIN*</em> *<em>…*</em>**</p>
<p>​    <em><strong>*ON** **多表的连接条件*</strong></em></p>
<p>​    <em>*<em>*JOIN*</em> **…*</em>**</p>
<p>​    <em>*<em>*ON*</em> **…*</em>**</p>
<p>​    <em><strong>*WHERE** **不包含组函数的过滤条件*</strong></em></p>
<p>​    <em>*<em>*AND*</em>**&#x2F;OR*</em> *<em>不包含组函数的过滤条件*</em>**</p>
<p>​    <em>*<em>*GROUP BY*</em> **…,…*</em>**</p>
<p>​    <em><strong>*HAVING** **包含组函数的过滤条件*</strong></em></p>
<p>​    <em>*<em>*ORDER BY*</em> **…*</em> *<em>ASC*</em>*<em>&#x2F;DESC*</em>**</p>
<p>​    LIMIT …,…</p>
<p><em><strong>*其中：*</strong></em></p>
<p>​    <em>*<em>*（1*</em>*<em>）*</em>*<em>from*</em>*<em>：从哪些表中筛选*</em>*</em></p>
<p>​    <em>*<em>*（*</em>*<em>2*</em>*<em>）*</em>*<em>on*</em>*<em>：关联多表查询时，去除笛卡尔积*</em>*</em></p>
<p>​    <em>*<em>*（*</em>*<em>3*</em>*<em>）*</em>*<em>where*</em>*<em>：从表中筛选的条件*</em>*</em></p>
<p>​    <em>*<em>*（*</em>*<em>4*</em>*<em>）*</em>*<em>group by*</em>*<em>：分组依据*</em>*</em></p>
<p>​    <em>*<em>*（*</em>*<em>5*</em>*<em>）*</em>*<em>having*</em>*<em>：在统计结果中再次筛选*</em>*</em></p>
<p>​    <em>*<em>*（*</em>*<em>6*</em>*<em>）*</em>*<em>order by*</em>*<em>：排序*</em>*</em></p>
<p>​    <em>*<em>*（*</em>*<em>7*</em>*<em>）*</em>*<em>limit*</em>*<em>：分页*</em>*</em></p>
<h3 id="SELECT执行顺序"><a href="#SELECT执行顺序" class="headerlink" title="SELECT执行顺序"></a><strong>SELECT执行顺序</strong></h3><p><em><strong>*需要记住** *<em>SELECT*</em> **查询时的两个顺序：*</strong></em></p>
<p><strong>1.</strong> <strong>关键字的顺序是不能颠倒的：</strong></p>
<p>​    <strong>SELECT … FROM … WHERE … GROUP BY … HAVING … ORDER BY … LIMIT…</strong></p>
<p><strong>2.SELECT</strong> <strong>语句的执行顺序</strong> （在 MySQL 和 Oracle 中， SELECT 执行顺序基本相同）：</p>
<p>​    <strong>FROM -&gt; WHERE -&gt; GROUP BY -&gt; HAVING -&gt; SELECT</strong> <em>*<em>*的字段*</em> **-&gt; DISTINCT -&gt; ORDER BY -&gt; LIMIT*</em>**</p>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061247261394.png" alt="img"></p>
<p><em><strong>*比如你写了一个** *<em>SQL*</em> **语句，那么它的关键字顺序和执行顺序是下面这样的：*</strong></em></p>
<p>​    <em>*<em>*SELECT DISTINCT*</em> *<em>player_id, player_name,*</em> *<em>count*</em>**(*)*</em> *<em>as*</em> *<em>num*</em> *<em>#*</em> *<em>顺序*</em> *<em>5*</em>**</p>
<p>​    <em>*<em>*FROM*</em> *<em>player*</em> *<em>JOIN*</em> *<em>team*</em> *<em>ON*</em> *<em>player*</em>**.team_id*</em> *<em>&#x3D; team*</em>*<em>.team_id*</em> *<em>#*</em> *<em>顺序*</em> *<em>1*</em>**</p>
<p>​    <em>*<em>*WHERE*</em> *<em>height &gt;*</em> *<em>1.80*</em> **#*</em> *<em>顺序*</em> *<em>2*</em>**</p>
<p>​    <em>*<em>*GROUP BY*</em> *<em>player*</em>**.team_id*</em> *<em>#*</em> *<em>顺序*</em> *<em>3*</em>**</p>
<p>​    <em>*<em>*HAVING*</em> *<em>num &gt;*</em> *<em>2*</em> **#*</em> *<em>顺序*</em> *<em>4*</em>**</p>
<p>​    <em>*<em>*ORDER BY*</em> *<em>num*</em> *<em>DESC*</em> **#*</em> *<em>顺序*</em> *<em>6*</em>**</p>
<p>​    <em>*<em>*LIMIT*</em> *<em>2*</em> **#*</em> *<em>顺序*</em> *<em>7*</em>**</p>
<p>​    在 SELECT 语句执行这些步骤的时候，每个步骤都会产生一个 虚拟表 ，然后将这个虚拟表传入下一个步骤中作为输入。需要注意的是，这些步骤隐含在 SQL 的执行过程中，对于我们来说是不可见的。</p>
<h3 id="SQL-的执行原理"><a href="#SQL-的执行原理" class="headerlink" title="SQL 的执行原理"></a><strong>SQL 的执行原理</strong></h3><p>​    SELECT 是先执行 FROM 这一步的。在这个阶段，如果是多张表联查，还会经历下面的几个步骤：</p>
<p>​    \1. 首先先通过 CROSS JOIN 求笛卡尔积，相当于得到虚拟表 vt （</p>
<p>virtual table ） 1-1 ；</p>
<p>​    \2. 通过 ON 进行筛选，在虚拟表 vt1-1 的基础上进行筛选，得到虚拟表 vt1-2 ；</p>
<p>​    \3. 添加外部行。如果我们使用的是左连接、右链接或者全连接，就会涉及到外部行，也就是在虚拟表 vt1-2 的基础上增加外部行，得到虚拟表 vt1-3 。</p>
<p>​    当然如果我们操作的是两张以上的表，还会重复上面的步骤，直到所有表都被处理完为止。这个过程得到是我们的原始数据。</p>
<p>​    当我们拿到了查询数据表的原始数据，也就是最终的虚拟表 vt1 ，就可以在此基础上再进行 WHERE 阶段 。在这个阶段中，会根据 vt1 表的结果进行筛选过滤，得到虚拟表 vt2 。</p>
<p>然后进入第三步和第四步，也就是 GROUP 和 HAVING 阶段 。在这个阶段中，实际上是在虚拟表 vt2 的 基础上进行分组和分组过滤，得到中间的虚拟表 vt3 和 vt4 。</p>
<p>​    当我们完成了条件筛选部分之后，就可以筛选表中提取的字段，也就是进入到 SELECT 和 DISTINCT 阶段 。</p>
<p>​    首先在 SELECT 阶段会提取想要的字段，然后在 DISTINCT 阶段过滤掉重复的行，分别得到中间的虚拟表 vt5- 1 和 vt5 - 2 。</p>
<p>​    当我们提取了想要的字段数据之后，就可以按照指定的字段进行排序，也就是 ORDER BY 阶段 ，得到 虚拟表 vt6 。</p>
<p>​    最后在 vt6 的基础上，取出指定行的记录，也就是 LIMIT 阶段 ，得到最终的结果，对应的是虚拟表 vt7 。</p>
<p>​    当然我们在写 SELECT 语句的时候，不一定存在所有的关键字，相应的阶段就会省略。</p>
<p>​    同时因为 SQL 是一门类似英语的结构化查询语言，所以我们在写 SELECT 语句的时候，还要注意相应的 关键字顺序， <strong>所谓底层运行的原理，就是我们刚才讲到的执行顺序。</strong></p>
<h2 id="练习-2"><a href="#练习-2" class="headerlink" title="练习"></a>练习</h2><h3 id="where子句可否使用组函数进行过滤"><a href="#where子句可否使用组函数进行过滤" class="headerlink" title="where子句可否使用组函数进行过滤?"></a>where子句可否使用组函数进行过滤?</h3><p><strong>回答：不可以</strong></p>
<h3 id="查询公司员工工资的最大值，最小值，平均值，总和"><a href="#查询公司员工工资的最大值，最小值，平均值，总和" class="headerlink" title="查询公司员工工资的最大值，最小值，平均值，总和"></a>查询公司员工工资的最大值，最小值，平均值，总和</h3><p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061247261456.png" alt="img"></p>
<h3 id="查询各job-id的员工工资的最大值，最小值，平均值，总和"><a href="#查询各job-id的员工工资的最大值，最小值，平均值，总和" class="headerlink" title="查询各job_id的员工工资的最大值，最小值，平均值，总和"></a>查询各job_id的员工工资的最大值，最小值，平均值，总和</h3><p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061247271462.png" alt="img"></p>
<h3 id="选择具有各个job-id的员工人数"><a href="#选择具有各个job-id的员工人数" class="headerlink" title="选择具有各个job_id的员工人数"></a>选择具有各个job_id的员工人数</h3><p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061247271468.png" alt="img"></p>
<h3 id="查询员工最高工资和最低工资的差距（DIFFERENCE）"><a href="#查询员工最高工资和最低工资的差距（DIFFERENCE）" class="headerlink" title="查询员工最高工资和最低工资的差距（DIFFERENCE）"></a>查询员工最高工资和最低工资的差距（DIFFERENCE）</h3><p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061247271474.png" alt="img"></p>
<h3 id="查询各个管理者手下员工的最低工资，其中最低工资不能低于6000，没有管理者的员工不计算在内"><a href="#查询各个管理者手下员工的最低工资，其中最低工资不能低于6000，没有管理者的员工不计算在内" class="headerlink" title="查询各个管理者手下员工的最低工资，其中最低工资不能低于6000，没有管理者的员工不计算在内"></a>查询各个管理者手下员工的最低工资，其中最低工资不能低于6000，没有管理者的员工不计算在内</h3><p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061247281480.png" alt="img"></p>
<h3 id="查询所有部门的名字，location-id，员工数量和平均工资，并按平均工资降序"><a href="#查询所有部门的名字，location-id，员工数量和平均工资，并按平均工资降序" class="headerlink" title="查询所有部门的名字，location_id，员工数量和平均工资，并按平均工资降序"></a>查询所有部门的名字，location_id，员工数量和平均工资，并按平均工资降序</h3><p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061247281486.png" alt="img"></p>
<h3 id="查询每个工种中每个部门的部门名、工种名和最低工资"><a href="#查询每个工种中每个部门的部门名、工种名和最低工资" class="headerlink" title="查询每个工种中每个部门的部门名、工种名和最低工资"></a>查询每个工种中每个部门的部门名、工种名和最低工资</h3><p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061247281492.png" alt="img"></p>
<h1 id="MySQL-聚合函数-1"><a href="#MySQL-聚合函数-1" class="headerlink" title="MySQL 聚合函数"></a>MySQL 聚合函数</h1><h2 id="子查询介绍-1"><a href="#子查询介绍-1" class="headerlink" title="子查询介绍"></a>子查询介绍</h2><p>​    子查询指一个查询语句嵌套在另一个查询语句内部的查询，这个特性从MySQL 4.1开始引入。</p>
<p>​    SQL 中子查询的使用大大增强了 SELECT 查询的能力，因为很多时候查询需要从结果集中获取数据，或者需要从同一个表中先计算得出一个数据结果，然后与这个数据结果（可能是某个标量，也可能是某个集合）进行比较。</p>
<h2 id="需求分析与问题解决-1"><a href="#需求分析与问题解决-1" class="headerlink" title="需求分析与问题解决"></a><strong>需求分析与问题解决</strong></h2><h3 id="实际问题-1"><a href="#实际问题-1" class="headerlink" title="实际问题"></a><strong>实际问题</strong></h3><p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061247281508.png" alt="img"></p>
<p><strong>需求：谁的工资比 Abel高?</strong></p>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061247291514.png" alt="img"></p>
<p> <img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061247291516.png" alt="img"></p>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061247291518.png" alt="img"></p>
<p> <strong>查询称谓：括号外的查询称为：外查询（主查询）</strong></p>
<p>​          <strong>括号内的查询称为：内查询（子查询）</strong></p>
<p><strong>问题：</strong> 方式2与方式3有好坏之分吗？（方式1为两次查询，不推荐使用）</p>
<p><strong>解答：</strong> 自连接方式好！</p>
<p>​    题目中可以使用子查询，也可以使用自连接。一般情况建议你使用自连接，因为在许多 DBMS 的处理过 程中，对于自连接的处理速度要比子查询快得多。</p>
<p>​    可以这样理解：子查询实际上是通过未知表进行查询后的条件判断，而自连接是通过已知的自身数据表进行条件判断，因此在大部分 DBMS 中都对自连接处理进行了优化。</p>
<h3 id="子查询的基本使用-1"><a href="#子查询的基本使用-1" class="headerlink" title="子查询的基本使用"></a><strong>子查询的基本使用</strong></h3><p>​    <em><strong>*子查询的基本语法结构：*</strong></em></p>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061247291536.png" alt="img"></p>
<p>​    <em><strong>*子查询（内查询）在主查询之前一次执行完成。*</strong></em></p>
<p>​    <em><strong>*子查询的结果被主查询（外查询）使用 。*</strong></em></p>
<p>​    </p>
<p>​    <strong>注意事项</strong></p>
<p>​        <em><strong>*1.子查询要包含在括号内*</strong></em></p>
<p>​        <em><strong>*2.将子查询放在比较条件的右侧*</strong></em></p>
<p>​        <em><strong>*3.单行操作符对应单行子查询，多行操作符对应多行子查询*</strong></em></p>
<h3 id="子查询的分类-1"><a href="#子查询的分类-1" class="headerlink" title="子查询的分类"></a><strong>子查询的分类</strong></h3><h3 id="分类方式1：-1"><a href="#分类方式1：-1" class="headerlink" title="分类方式1："></a><strong>分类方式<strong><strong>1</strong></strong>：</strong></h3><p>我们按内查询的<strong>结果返回一条还是多条记录</strong>，将子查询分为 单行子查询 、 多行子查询 。</p>
<p><em><strong>*单行子查询：*</strong></em></p>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061247291560.png" alt="img"></p>
<p><em><strong>*多行子查询：*</strong></em></p>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061247301566.png" alt="img"></p>
<h3 id="分类方式2：-1"><a href="#分类方式2：-1" class="headerlink" title="分类方式2："></a><strong>分类方式<strong><strong>2</strong></strong>：</strong></h3><p>​    我们按内查询<strong>是否被执行多次</strong>，将子查询划分为 相关 ( 或关联 ) 子查询 和 不相关 ( 或非关联 ) 子查询 。</p>
<p>​    子查询从数据表中查询了数据结果，如果这个数据结果只执行一次，然后这个数据结果作为主查询的条件进行执行，那么这样的子查询叫做不相关子查询。</p>
<p>​    同样，如果子查询需要执行多次，即采用循环的方式，先从外部查询开始，每次都传入子查询进行查询，然后再将结果反馈给外部，这种嵌套的执行方式就称为相关子查询。</p>
<h2 id="单行子查询-1"><a href="#单行子查询-1" class="headerlink" title="单行子查询"></a><strong>单行子查询</strong></h2><h3 id="单行比较操作符-1"><a href="#单行比较操作符-1" class="headerlink" title="单行比较操作符"></a><strong>单行比较操作符</strong></h3><table>
<thead>
<tr>
<th><strong>操作符</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td><em><strong>*&#x3D;*</strong></em></td>
<td><em><strong>*equal to*</strong></em></td>
</tr>
<tr>
<td><em><strong>*&gt;*</strong></em></td>
<td><em><strong>*greater than*</strong></em></td>
</tr>
<tr>
<td><em><strong>*&gt;&#x3D;*</strong></em></td>
<td><em><strong>*greater than or equal to*</strong></em></td>
</tr>
<tr>
<td><em><strong>*&lt;*</strong></em></td>
<td><em><strong>*less than*</strong></em></td>
</tr>
<tr>
<td><em><strong>*&lt;&#x3D;*</strong></em></td>
<td><em><strong>*less than or equal to*</strong></em></td>
</tr>
<tr>
<td><em><strong>*&lt;&gt;*</strong></em></td>
<td><em><strong>*not equal to*</strong></em></td>
</tr>
</tbody></table>
<h3 id="代码示例-4"><a href="#代码示例-4" class="headerlink" title="代码示例"></a><strong>代码示例</strong></h3><h3 id="需求：查询工资大于149号员工工资的员工的信息-1"><a href="#需求：查询工资大于149号员工工资的员工的信息-1" class="headerlink" title="需求：查询工资大于149号员工工资的员工的信息"></a><strong>需求：查询工资大于<strong><strong>149</strong></strong>号员工工资的员工的信息</strong></h3><p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061247301595.png" alt="img"></p>
<h3 id="-4"><a href="#-4" class="headerlink" title=""></a></h3><h3 id="需求：返回job-id与141号员工相同，salary比143号员工多的员工姓名，-1"><a href="#需求：返回job-id与141号员工相同，salary比143号员工多的员工姓名，-1" class="headerlink" title="需求：返回job_id与141号员工相同，salary比143号员工多的员工姓名，"></a><strong>需求：返回<strong><strong>job_id</strong></strong>与<strong><strong>141</strong></strong>号员工相同，<strong><strong>salary</strong></strong>比<strong><strong>143</strong></strong>号员工多的员工姓名，</strong></h3><h3 id="job-id-和工资-1"><a href="#job-id-和工资-1" class="headerlink" title="job_id****和工资"></a><strong>job_id****和工资</strong></h3><p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061247301603.png" alt="img"></p>
<p> <img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061247301605.png" alt="img"></p>
<h3 id="需求：返回公司工资最少的员工的last-name-job-id和-salary-1"><a href="#需求：返回公司工资最少的员工的last-name-job-id和-salary-1" class="headerlink" title="需求：返回公司工资最少的员工的last_name,job_id和****salary"></a><strong>需求：返回公司工资最少的员工的<strong><strong>last_name,job_id</strong></strong>和****salary</strong></h3><p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061247301609.png" alt="img"></p>
<h3 id="需求：查询与141号或174号员工的manager-id和department-id相同的其他员工-1"><a href="#需求：查询与141号或174号员工的manager-id和department-id相同的其他员工-1" class="headerlink" title="需求：查询与141号或174号员工的manager_id和department_id相同的其他员工"></a><strong>需求：查询与<strong><strong>141</strong></strong>号或<strong><strong>174</strong></strong>号员工的<strong><strong>manager_id</strong></strong>和<strong><strong>department_id</strong></strong>相同的其他员工</strong></h3><h3 id="的employee-id，manager-id，department-id-1"><a href="#的employee-id，manager-id，department-id-1" class="headerlink" title="的employee_id，manager_id，department_id"></a><strong>的employee_id<strong><strong>，</strong></strong>manager_id<strong><strong>，</strong></strong>department_id</strong></h3><p>实现方式 1 ：不成对比较</p>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061247311619.png" alt="img"></p>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061247311621.png" alt="img"></p>
<p> 实现方式2：成对比较</p>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061247311625.png" alt="img"></p>
<h3 id="HAVING-中的子查询-1"><a href="#HAVING-中的子查询-1" class="headerlink" title="HAVING 中的子查询"></a><strong>HAVING 中的子查询</strong></h3><p>​    <strong>首先执行子查询。</strong></p>
<p>​    <em><strong>*向主查询中的HAVING** **子句返回结果。*</strong></em></p>
<h3 id="需求：查询最低工资大于110号部门最低工资的部门id和其最低工资-1"><a href="#需求：查询最低工资大于110号部门最低工资的部门id和其最低工资-1" class="headerlink" title="需求：查询最低工资大于110号部门最低工资的部门id和其最低工资"></a><strong>需求：查询最低工资大于11<strong><strong>0</strong></strong>号部门最低工资的部门<strong><strong>id</strong></strong>和其最低工资</strong></h3><p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061247311637.png" alt="img"></p>
<h3 id="CASE中的子查询-1"><a href="#CASE中的子查询-1" class="headerlink" title="CASE中的子查询"></a><strong>CASE中的子查询</strong></h3><p>​    在CASE 表达式中使用单列子查询：</p>
<h3 id="需求：显式员工的employee-id-last-name和location。其中，若员工-1"><a href="#需求：显式员工的employee-id-last-name和location。其中，若员工-1" class="headerlink" title="需求：显式员工的employee_id,last_name和location。其中，若员工"></a><strong>需求：显式员工的<strong><strong>employee_id,last_name</strong></strong>和<strong><strong>location</strong></strong>。其中，若员工</strong></h3><h3 id="department-id与location-id为1800的department-id相同，则-location-1"><a href="#department-id与location-id为1800的department-id相同，则-location-1" class="headerlink" title="department_id与location_id为1800的department_id相同，则****location"></a><strong>department_id与<strong><strong>location_id</strong></strong>为<strong><strong>1800</strong></strong>的<strong><strong>department_id</strong></strong>相同，则****location</strong></h3><h3 id="为’Canada’，其余则为’USA’-。-1"><a href="#为’Canada’，其余则为’USA’-。-1" class="headerlink" title="为’Canada’，其余则为’USA’****。"></a><strong>为’Canada’<strong><strong>，其余则为</strong></strong>’USA’****。</strong></h3><p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061247311651.png" alt="img"></p>
<h3 id="子查询中的空值问题-1"><a href="#子查询中的空值问题-1" class="headerlink" title="子查询中的空值问题"></a><strong>子查询中的空值问题</strong></h3><h2 id="-5"><a href="#-5" class="headerlink" title=""></a><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061247321657.png" alt="img"></h2><p><strong>原因：*<em>子查询不返回任何行*</em></strong> </p>
<h2 id="-6"><a href="#-6" class="headerlink" title=""></a><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061247321661.png" alt="img"></h2><h3 id="非法使用子查询-1"><a href="#非法使用子查询-1" class="headerlink" title="非法使用子查询"></a><strong>非法使用子查询</strong></h3><p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061247321665.png" alt="img"></p>
<p> <strong>原因：*<em>多行子查询使用单行比较符*</em></strong></p>
<h2 id="多行子查询-1"><a href="#多行子查询-1" class="headerlink" title="多行子查询"></a><strong>多行子查询</strong></h2><p>​    <strong>也称为集合比较子查询</strong></p>
<p>​    <em><strong>*内查询返回多行*</strong></em></p>
<p>​    <em><strong>*使用多行比较操作符*</strong></em></p>
<h3 id="多行比较操作符-1"><a href="#多行比较操作符-1" class="headerlink" title="多行比较操作符"></a><strong>多行比较操作符</strong></h3><table>
<thead>
<tr>
<th><em><strong>*操作符*</strong></em></th>
<th><em><strong>*含义*</strong></em></th>
</tr>
</thead>
<tbody><tr>
<td><em><strong>*IN*</strong></em></td>
<td><em>*<em>*等于列表中的*</em>*<em>任意一个*</em>*</em></td>
</tr>
<tr>
<td><em><strong>*ANY*</strong></em></td>
<td><em>*<em>*需要和单行比较操作符一起使用，和子查询返回的*</em>*<em>某一个*</em>*<em>值比较*</em>*</em></td>
</tr>
<tr>
<td><em><strong>*ALL*</strong></em></td>
<td><em>*<em>*需要和单行比较操作符一起使用，和子查询返回的*</em>*<em>所有*</em>*<em>值比较*</em>*</em></td>
</tr>
<tr>
<td><em><strong>*SOME*</strong></em></td>
<td><em>*<em>*实际上是*</em>*<em>ANY*</em>*<em>的别名，作用相同，一般常使用*</em>*<em>ANY*</em>*</em></td>
</tr>
</tbody></table>
<h3 id="代码示例-5"><a href="#代码示例-5" class="headerlink" title="代码示例"></a><strong>代码示例</strong></h3><h3 id="需求：查询每个部门中最低工资的员工号和姓名-1"><a href="#需求：查询每个部门中最低工资的员工号和姓名-1" class="headerlink" title="需求：查询每个部门中最低工资的员工号和姓名"></a><strong>需求：查询每个部门中最低工资的员工号和姓名</strong></h3><p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061247321690.png" alt="img"></p>
<h3 id="需求：返回其它job-id中比job-id为‘IT-PROG’部门任一工资低的员工的-1"><a href="#需求：返回其它job-id中比job-id为‘IT-PROG’部门任一工资低的员工的-1" class="headerlink" title="需求：返回其它job_id中比job_id为‘IT_PROG’部门任一工资低的员工的"></a><strong>需求：返回其它<strong><strong>job_id</strong></strong>中比<strong><strong>job_id</strong></strong>为<strong><strong>‘IT_PROG’</strong></strong>部门任一工资低的员工的</strong></h3><h3 id="员工号、姓名、job-id-以及-salary-1"><a href="#员工号、姓名、job-id-以及-salary-1" class="headerlink" title="员工号、姓名、job_id 以及****salary"></a><strong>员工号、姓名、job_id</strong> <strong>以及****salary</strong></h3><p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061247321698.png" alt="img"></p>
<h3 id="需求：返回其它job-id中比job-id为‘IT-PROG’部门所有工资都低的员工的-1"><a href="#需求：返回其它job-id中比job-id为‘IT-PROG’部门所有工资都低的员工的-1" class="headerlink" title="需求：返回其它job_id中比job_id为‘IT_PROG’部门所有工资都低的员工的"></a><strong>需求：返回其它<strong><strong>job_id</strong></strong>中比<strong><strong>job_id</strong></strong>为<strong><strong>‘IT_PROG’</strong></strong>部门所有工资都低的员工的</strong></h3><h3 id="员工号、姓名、job-id以及salary-1"><a href="#员工号、姓名、job-id以及salary-1" class="headerlink" title="员工号、姓名、job_id以及salary"></a><strong>员工号、姓名、job_id<strong><strong>以及</strong></strong>salary</strong></h3><p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061247331706.png" alt="img"></p>
<h3 id="需求：查询平均工资最低的部门-id-1"><a href="#需求：查询平均工资最低的部门-id-1" class="headerlink" title="需求：查询平均工资最低的部门****id"></a><strong>需求：查询平均工资最低的部门****id</strong></h3><p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061247331710.png" alt="img"></p>
<p> <img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061247331712.png" alt="img"></p>
<p> <img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061247331714.png" alt="img"></p>
<h3 id="空值问题-1"><a href="#空值问题-1" class="headerlink" title="空值问题"></a><strong>空值问题</strong></h3><p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061247341720.png" alt="img"></p>
<p> <strong>原因：内查询中存在NULL</strong></p>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061247341724.png" alt="img"></p>
<h2 id="相关子查询-1"><a href="#相关子查询-1" class="headerlink" title="相关子查询"></a><strong>相关子查询</strong></h2><h3 id="相关子查询执行流程-1"><a href="#相关子查询执行流程-1" class="headerlink" title="相关子查询执行流程"></a><strong>相关子查询执行流程</strong></h3><p>​    如果子查询的执行依赖于外部查询，通常情况下都是因为子查询中的表用到了外部的表，并进行了条件关联，因此每执行一次外部查询，子查询都要重新计算一次，这样的子查询就称之为 关联子查询 。</p>
<p>​    相关子查询按照一行接一行的顺序执行，主查询的每一行都执行一次子查询。</p>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061247341734.png" alt="img"></p>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061247341736.png" alt="img"></p>
<p> 说明：<strong>子查询中使用主查询中的列</strong></p>
<h3 id="代码示例-6"><a href="#代码示例-6" class="headerlink" title="代码示例"></a><strong>代码示例</strong></h3><h3 id="需求：查询员工中工资大于本部门平均工资的员工的last-name-salary和-1"><a href="#需求：查询员工中工资大于本部门平均工资的员工的last-name-salary和-1" class="headerlink" title="需求：查询员工中工资大于本部门平均工资的员工的last_name,salary和"></a><strong>需求：查询员工中工资大于本部门平均工资的员工的<strong><strong>last_name,salary</strong></strong>和</strong></h3><h3 id="其department-id-1"><a href="#其department-id-1" class="headerlink" title="其department_id"></a><strong>其department_id</strong></h3><p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061247341748.png" alt="img"></p>
<p> <img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061247351750.png" alt="img"></p>
<h3 id="需求：查询员工的-id-salary-按照department-name-排序-1"><a href="#需求：查询员工的-id-salary-按照department-name-排序-1" class="headerlink" title="*需求：查询员工的**id,salary,按照department_name* 排序"></a>*<em>需求：查询员工的</em>**<em>id,salary,<strong><strong>按照</strong></strong>department_name</em>* <strong>排序</strong></h3><p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061247351754.png" alt="img"></p>
<h3 id="需求：若employees表中employee-id与job-history表中employee-id相同的-数-1"><a href="#需求：若employees表中employee-id与job-history表中employee-id相同的-数-1" class="headerlink" title="需求：若employees表中employee_id与job_history表中employee_id相同的****数"></a><strong>需求：若<strong><strong>employees</strong></strong>表中<strong><strong>employee_id</strong></strong>与<strong><strong>job_history</strong></strong>表中<strong><strong>employee_id</strong></strong>相同的****数</strong></h3><h3 id="目不小于2，输出这些相同id的员工的employee-id-last-name和其-job-id-1"><a href="#目不小于2，输出这些相同id的员工的employee-id-last-name和其-job-id-1" class="headerlink" title="目不小于2，输出这些相同id的员工的employee_id,last_name和其****job_id"></a><strong>目不小于2，输出这些相同<strong><strong>id</strong></strong>的员工的<strong><strong>employee_id,last_name</strong></strong>和其****job_id</strong></h3><p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061247351762.png" alt="img"></p>
<h3 id="EXISTS-与-NOT-EXISTS关键字-1"><a href="#EXISTS-与-NOT-EXISTS关键字-1" class="headerlink" title="EXISTS 与 NOT EXISTS关键字"></a><strong>EXISTS 与 NOT EXISTS关键字</strong></h3><p>​    关联子查询通常也会和 EXISTS 操作符一起来使用，用来检查在子查询中是否存在满足条件的行。</p>
<p>​    <strong>如果在子查询中不存在满足条件的行：</strong></p>
<p>​        条件返回 FALSE</p>
<p>​        继续在子查询中查找</p>
<p>​    <strong>如果在子查询中存在满足条件的行：</strong></p>
<p>​        不在子查询中继续查找</p>
<p>​        条件返回 TRUE</p>
<p>​    NOT EXISTS关键字表示如果不存在某种条件，则返回 TRUE ，否则返回 FALSE 。</p>
<h3 id="需求：查询公司管理者的employee-id，last-name，job-id，-department-id-1"><a href="#需求：查询公司管理者的employee-id，last-name，job-id，-department-id-1" class="headerlink" title="需求：查询公司管理者的employee_id，last_name，job_id，****department_id"></a><strong>需求：查询公司管理者的<strong><strong>employee_id</strong></strong>，<strong><strong>last_name</strong></strong>，<strong><strong>job_id</strong></strong>，****department_id</strong></h3><h3 id="信息-1"><a href="#信息-1" class="headerlink" title="信息"></a><strong>信息</strong></h3><p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061247351786.png" alt="img"></p>
<p> <img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061247351788.png" alt="img"></p>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061247361790.png" alt="img"></p>
<h3 id="需求：查询departments表中，不存在于employees表中的部门的-department-id和department-name-1"><a href="#需求：查询departments表中，不存在于employees表中的部门的-department-id和department-name-1" class="headerlink" title="需求：查询departments表中，不存在于employees表中的部门的       department_id和department_name"></a>需求：查询departments表中，不存在于employees表中的部门的       department_id和department_name</h3><p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061247361794.png" alt="img"></p>
<p> <img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061247361796.png" alt="img"></p>
<h3 id="相关更新-1"><a href="#相关更新-1" class="headerlink" title="相关更新"></a><strong>相关更新</strong></h3><p><strong>语法：</strong></p>
<p>​    <em><strong>*UPDATE** **table1 alias1*</strong></em></p>
<p>​    <em>*<em>*SET*</em> *<em>column &#x3D; (*</em>*<em>SELECT*</em> *<em>expression*</em>*</em></p>
<p>​                 <em><strong>*FROM** **table2 alias2*</strong></em></p>
<p>​                 <em>*<em>*WHERE*</em> *<em>alias1*</em>**.column*</em> *<em>&#x3D; alias2*</em>*<em>.column*</em>*<em>);*</em>**</p>
<p><em><strong>*使用相关子查询依据一个表中的数据更新另一个表的数据。*</strong></em></p>
<h3 id="需求：在employees中增加一个department-name字段，数据为员工对应的-1"><a href="#需求：在employees中增加一个department-name字段，数据为员工对应的-1" class="headerlink" title="需求：在employees中增加一个department_name字段，数据为员工对应的"></a><strong>需求：在<strong><strong>employees</strong></strong>中增加一个<strong><strong>department_name</strong></strong>字段，数据为员工对应的</strong></h3><h3 id="部门名称-1"><a href="#部门名称-1" class="headerlink" title="部门名称"></a><strong>部门名称</strong></h3><p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061247361816.png" alt="img"></p>
<p> <img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061247371818.png" alt="img"></p>
<h3 id="相关删除-1"><a href="#相关删除-1" class="headerlink" title="相关删除"></a><strong>相关删除</strong></h3><p><strong>语法：</strong></p>
<p>​    DELETE FROM table1 alias1</p>
<p>​    WHERE column operator ( SELECT expression</p>
<p>​                         FROM table2 alias2</p>
<p>​                         WHERE alias1 .column &#x3D; alias2 .column );</p>
<p><strong>题目：删除表</strong> <strong>employees</strong> <strong>中，其与</strong> <strong>emp_history</strong> <strong>表皆有的数据</strong></p>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061247371836.png" alt="img"></p>
<h2 id="结论-2"><a href="#结论-2" class="headerlink" title="结论"></a>结论</h2><p><strong>结论：在SELECT语句中，出GROUP BY 与LIMIT之外，其余地方都可以声明子查询</strong></p>
<h2 id="练习-3"><a href="#练习-3" class="headerlink" title="练习"></a>练习</h2><h3 id="查询和Zlotkey相同部门的员工姓名和工资-1"><a href="#查询和Zlotkey相同部门的员工姓名和工资-1" class="headerlink" title="查询和Zlotkey相同部门的员工姓名和工资"></a>查询和Zlotkey相同部门的员工姓名和工资</h3><p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061247411848.png" alt="img"></p>
<h3 id="查询工资比公司平均工资高的员工的员工号，姓名和工资。-1"><a href="#查询工资比公司平均工资高的员工的员工号，姓名和工资。-1" class="headerlink" title="查询工资比公司平均工资高的员工的员工号，姓名和工资。"></a>查询工资比公司平均工资高的员工的员工号，姓名和工资。</h3><p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061247421852.png" alt="img"></p>
<h3 id="选择工资大于所有JOB-ID-x3D-‘SA-MAN’的员工的工资的员工的last-name-job-id-salary-1"><a href="#选择工资大于所有JOB-ID-x3D-‘SA-MAN’的员工的工资的员工的last-name-job-id-salary-1" class="headerlink" title="选择工资大于所有JOB_ID &#x3D; ‘SA_MAN’的员工的工资的员工的last_name, job_id, salary"></a>选择工资大于所有JOB_ID &#x3D; ‘SA_MAN’的员工的工资的员工的last_name, job_id, salary</h3><p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061247431856.png" alt="img"></p>
<h3 id="查询和姓名中包含字母u的员工在相同部门的员工的员工号和姓名-1"><a href="#查询和姓名中包含字母u的员工在相同部门的员工的员工号和姓名-1" class="headerlink" title="查询和姓名中包含字母u的员工在相同部门的员工的员工号和姓名"></a>查询和姓名中包含字母u的员工在相同部门的员工的员工号和姓名</h3><p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061247441862.png" alt="img"></p>
<h3 id="查询在部门的location-id为1700的部门工作的员工的员工号-1"><a href="#查询在部门的location-id为1700的部门工作的员工的员工号-1" class="headerlink" title="查询在部门的location_id为1700的部门工作的员工的员工号"></a>查询在部门的location_id为1700的部门工作的员工的员工号</h3><p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061247441868.png" alt="img"></p>
<h3 id="查询管理者是King的员工姓名和工资-1"><a href="#查询管理者是King的员工姓名和工资-1" class="headerlink" title="查询管理者是King的员工姓名和工资"></a>查询管理者是King的员工姓名和工资</h3><p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061247491874.png" alt="img"></p>
<h3 id="查询工资最低的员工信息-last-name-salary-1"><a href="#查询工资最低的员工信息-last-name-salary-1" class="headerlink" title="查询工资最低的员工信息: last_name, salary"></a>查询工资最低的员工信息: last_name, salary</h3><p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061247501880.png" alt="img"></p>
<h3 id="查询平均工资最低的部门信息-1"><a href="#查询平均工资最低的部门信息-1" class="headerlink" title="查询平均工资最低的部门信息"></a>查询平均工资最低的部门信息</h3><p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061247501886.png" alt="img"></p>
<p> <img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061247511888.png" alt="img"></p>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061247511890.png" alt="img"></p>
<p> <img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061247511892.png" alt="img"></p>
<h3 id="查询平均工资最低的部门信息和该部门的平均工资（相关子查询）-1"><a href="#查询平均工资最低的部门信息和该部门的平均工资（相关子查询）-1" class="headerlink" title="查询平均工资最低的部门信息和该部门的平均工资（相关子查询）"></a>查询平均工资最低的部门信息和该部门的平均工资（相关子查询）</h3><p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061247521898.png" alt="img"></p>
<p> <img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061247521900.png" alt="img"></p>
<p> <img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061247521902.png" alt="img"></p>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061247531904.png" alt="img"></p>
<h3 id="1查询平均工资最高的-job-信息"><a href="#1查询平均工资最高的-job-信息" class="headerlink" title="1查询平均工资最高的 job 信息"></a>1查询平均工资最高的 job 信息</h3><p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061247531908.png" alt="img"></p>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061247541910.png" alt="img"></p>
<h3 id="查询平均工资高于公司平均工资的部门有哪些-1"><a href="#查询平均工资高于公司平均工资的部门有哪些-1" class="headerlink" title="查询平均工资高于公司平均工资的部门有哪些?"></a>查询平均工资高于公司平均工资的部门有哪些?</h3><p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061247551916.png" alt="img"></p>
<h3 id="查询出公司中所有-manager-的详细信息-1"><a href="#查询出公司中所有-manager-的详细信息-1" class="headerlink" title="查询出公司中所有 manager 的详细信息"></a>查询出公司中所有 manager 的详细信息</h3><p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061247561922.png" alt="img"></p>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061247571924.png" alt="img"></p>
<h3 id="各个部门中-最高工资中最低的那个部门的-最低工资是多少-1"><a href="#各个部门中-最高工资中最低的那个部门的-最低工资是多少-1" class="headerlink" title="各个部门中 最高工资中最低的那个部门的 最低工资是多少?"></a>各个部门中 最高工资中最低的那个部门的 最低工资是多少?</h3><p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061247591930.png" alt="img"></p>
<h3 id="查询平均工资最高的部门的-manager-的详细信息-last-name-1"><a href="#查询平均工资最高的部门的-manager-的详细信息-last-name-1" class="headerlink" title="查询平均工资最高的部门的 manager 的详细信息: last_name,"></a>查询平均工资最高的部门的 manager 的详细信息: last_name,</h3><h3 id="department-id-email-salary-1"><a href="#department-id-email-salary-1" class="headerlink" title="department_id, email, salary"></a>department_id, email, salary</h3><p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061247591938.png" alt="img"></p>
<h3 id="查询部门的部门号，其中不包括job-id是”ST-CLERK”的部门号-1"><a href="#查询部门的部门号，其中不包括job-id是”ST-CLERK”的部门号-1" class="headerlink" title="查询部门的部门号，其中不包括job_id是”ST_CLERK”的部门号"></a>查询部门的部门号，其中不包括job_id是”ST_CLERK”的部门号</h3><p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061247591944.png" alt="img"></p>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061248001946.png" alt="img"> </p>
<h3 id="选择所有没有管理者的员工的last-name-1"><a href="#选择所有没有管理者的员工的last-name-1" class="headerlink" title="选择所有没有管理者的员工的last_name"></a>选择所有没有管理者的员工的last_name</h3><p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061248001950.png" alt="img"></p>
<h3 id="查询员工号、姓名、雇用时间、工资，其中员工的管理者为-‘De-Haan’-1"><a href="#查询员工号、姓名、雇用时间、工资，其中员工的管理者为-‘De-Haan’-1" class="headerlink" title="查询员工号、姓名、雇用时间、工资，其中员工的管理者为 ‘De Haan’"></a>查询员工号、姓名、雇用时间、工资，其中员工的管理者为 ‘De Haan’</h3><p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061248001956.png" alt="img"></p>
<h3 id="查询各部门中工资比本部门平均工资高的员工的员工号-姓名和工资-1"><a href="#查询各部门中工资比本部门平均工资高的员工的员工号-姓名和工资-1" class="headerlink" title="查询各部门中工资比本部门平均工资高的员工的员工号, 姓名和工资"></a>查询各部门中工资比本部门平均工资高的员工的员工号, 姓名和工资</h3><h3 id="（相关子查询）-1"><a href="#（相关子查询）-1" class="headerlink" title="（相关子查询）"></a>（相关子查询）</h3><p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061248011964.png" alt="img"></p>
<h3 id="查询每个部门下的部门人数大于-5-的部门名称（相关子查询）-1"><a href="#查询每个部门下的部门人数大于-5-的部门名称（相关子查询）-1" class="headerlink" title="查询每个部门下的部门人数大于 5 的部门名称（相关子查询）"></a>查询每个部门下的部门人数大于 5 的部门名称（相关子查询）</h3><p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061248011970.png" alt="img"></p>
<h3 id="查询每个国家下的部门个数大于-2-的国家编号（相关子查询）-1"><a href="#查询每个国家下的部门个数大于-2-的国家编号（相关子查询）-1" class="headerlink" title="查询每个国家下的部门个数大于 2 的国家编号（相关子查询）"></a>查询每个国家下的部门个数大于 2 的国家编号（相关子查询）</h3><p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061248011976.png" alt="img"></p>
<h1 id="MySQL-创建和管理表"><a href="#MySQL-创建和管理表" class="headerlink" title="MySQL 创建和管理表"></a>MySQL 创建和管理表</h1><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a><strong>基础知识</strong></h2><h3 id="一条数据存储的过程"><a href="#一条数据存储的过程" class="headerlink" title="一条数据存储的过程"></a><strong>一条数据存储的过程</strong></h3><p>​    存储数据是处理数据的第一步 。只有正确地把数据存储起来，我们才能进行有效的处理和分析。否则，只能是一团乱麻，无从下手。</p>
<p>​    那么，怎样才能把用户各种经营相关的、纷繁复杂的数据，有序、高效地存储起来呢？ 在 MySQL 中，一个完整的数据存储过程总共有 4 步，分别是创建数据库、确认字段、创建数据表、插入数据。</p>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061248011988.png" alt="img"></p>
<p>​    我们要先创建一个数据库，而不是直接创建数据表呢？</p>
<p>​    因为从系统架构的层次上看，MySQL 数据库系统从大到小依次是 数据库服务器 、 数据库 、 数据表 、数据表的 行与列 。</p>
<p>​    MySQL 数据库服务器之前已经安装。所以，我们就从创建数据库开始。</p>
<h3 id="标识符命名规则"><a href="#标识符命名规则" class="headerlink" title="标识符命名规则"></a><strong>标识符命名规则</strong></h3><p>​    <em>*<em>*1.数据库名、表名不得超过30*</em>*<em>个字符，变量名限制为*</em>*<em>29*</em>*<em>个*</em>*</em></p>
<p>​    <em>*<em>*2.必须只能包含 A–Z, a–z, 0–9, _*</em>*<em>共*</em>*<em>63*</em>*<em>个字符*</em>*</em></p>
<p>​    <em><strong>*3.数据库名、表名、字段名等对象名中间不要包含空格*</strong></em></p>
<p>​    <em>*<em>*4.同一个MySQL*</em>*<em>软件中，数据库不能同名；同一个库中，表不能重名；同一个表中，字段不能重名*</em>*</em></p>
<p>​    <em>*<em>*5.必须保证你的字段没有和保留字、数据库系统或常用方法冲突。如果坚持使用，请在SQL*</em>*<em>语句中使用&#96;*</em>*<em>（着重号）引起来*</em>*</em></p>
<p>​    <em><strong>*6.保持字段名和类型的一致性：在命名字段并为其指定数据类型的时候一定要保证一致性，假如数据类型在一个表里是整数，那在另一个表里可就别变成字符型了*</strong></em></p>
<h3 id="MySQL中的数据类型"><a href="#MySQL中的数据类型" class="headerlink" title="MySQL中的数据类型"></a><strong>MySQL中的数据类型</strong></h3><table>
<thead>
<tr>
<th><em>*<em>*</em>*类型****</em>*</th>
<th><em>*<em>*</em>*类型举例****</em>*</th>
</tr>
</thead>
<tbody><tr>
<td>整数类型</td>
<td>TINYINT、SMALLINT、MEDIUMINT、<em>*<em>*</em>*INT(****</em><em><em>*<em>*</em>*或****</em>***<em>*</em>*INTEGER)**</em>***、BIGINT</td>
</tr>
<tr>
<td>浮点类型</td>
<td>FLOAT、DOUBLE</td>
</tr>
<tr>
<td>定点数类型</td>
<td><em>*<em>*</em>*DECIMAL****</em>*</td>
</tr>
<tr>
<td>位类型</td>
<td>BIT</td>
</tr>
<tr>
<td>日期时间类型</td>
<td>YEAR、TIME、**<em>*</em>*DATE******、DATETIME、TIMESTAMP</td>
</tr>
<tr>
<td>文本字符串类型</td>
<td>CHAR、**<em>*</em>*VARCHAR******、TINYTEXT、TEXT、MEDIUMTEXT、LONGTEXT</td>
</tr>
<tr>
<td>枚举类型</td>
<td>ENUM</td>
</tr>
<tr>
<td>集合类型</td>
<td>SET</td>
</tr>
<tr>
<td>二进制字符串类型</td>
<td>BINARY、VARBINARY、TINYBLOB、BLOB、MEDIUMBLOB、LONGBLOB</td>
</tr>
<tr>
<td>JSON类型</td>
<td>JSON对象、JSON数组</td>
</tr>
<tr>
<td>空间数据类型</td>
<td>单值：GEOMETRY、POINT、LINESTRING、POLYGON；集合：MULTIPOINT、MULTILINESTRING、MULTIPOLYGON、GEOMETRYCOLLECTION</td>
</tr>
</tbody></table>
<p><em><strong>*其中，常用的几类类型介绍如下：*</strong></em></p>
<table>
<thead>
<tr>
<th><strong>数据类型</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td><em><strong>*INT*</strong></em></td>
<td><em>*<em>*从*</em>**-2^31*</em>*<em>到*</em>*<em>2^31-1*</em>*<em>的整型数据。存储大小为*</em> *<em>4*</em>*<em>个字节*</em>**</td>
</tr>
<tr>
<td><em><strong>*CHAR(size)*</strong></em></td>
<td><em>*<em>*定长字符数据。若未指定，默认为*</em>*<em>1*</em>*<em>个字符，最大长度*</em>*<em>255*</em>*</em></td>
</tr>
<tr>
<td><em><strong>*VARCHAR(size)*</strong></em></td>
<td><em>*<em>*可变长字符数据，根据字符串实际长度保存，*</em>*<em>必须指定长度*</em>*</em></td>
</tr>
<tr>
<td><em><strong>*FLOAT(M,D)*</strong></em></td>
<td><em>*<em>*单精度，占用*</em>*<em>4*</em>*<em>个字节，*</em>*<em>M&#x3D;*</em>*<em>整数位*</em>**+*</em>*<em>小数位，*</em>*<em>D&#x3D;*</em>*<em>小数位。*</em> *<em>D&lt;&#x3D;M&lt;&#x3D;255,0&lt;&#x3D;D&lt;&#x3D;30*</em>*<em>， 默认*</em>*<em>M+D&lt;&#x3D;6*</em>**</td>
</tr>
<tr>
<td><em><strong>*DOUBLE(M,D)*</strong></em></td>
<td><em>*<em>*双精度，占用*</em>*<em>8*</em>*<em>个字节，*</em>*<em>D&lt;&#x3D;M&lt;&#x3D;255,0&lt;&#x3D;D&lt;&#x3D;30*</em>*<em>，默认*</em>*<em>M+D&lt;&#x3D;15*</em>*</em></td>
</tr>
<tr>
<td><em><strong>*DECIMAL(M,D)*</strong></em></td>
<td><em>*<em>*高精度小数，占用*</em>*<em>M+2*</em>*<em>个字节，*</em>*<em>D&lt;&#x3D;M&lt;&#x3D;65*</em>*<em>，*</em>*<em>0&lt;&#x3D;D&lt;&#x3D;30*</em>*<em>，最大取值范围与*</em>*<em>DOUBLE*</em>*<em>相同。*</em>*</em></td>
</tr>
<tr>
<td><em><strong>*DATE*</strong></em></td>
<td><em>*<em>*日期型数据，格式*</em>**’YYYY-MM-DD’*</em>**</td>
</tr>
<tr>
<td><em><strong>*BLOB*</strong></em></td>
<td><em>*<em>*二进制形式的长文本数据，最大可达*</em>*<em>4G*</em>*</em></td>
</tr>
<tr>
<td><em><strong>*TEXT*</strong></em></td>
<td><em>*<em>*长文本数据，最大可达*</em>*<em>4G*</em>*</em></td>
</tr>
</tbody></table>
<h2 id="创建和管理数据库"><a href="#创建和管理数据库" class="headerlink" title="创建和管理数据库"></a><strong>创建和管理数据库</strong></h2><h3 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a><strong>创建数据库</strong></h3><p><em>*<em>*方式*</em>*<em>1*</em>*<em>：创建数据库*</em>*</em></p>
<p>​    <em><strong>*CREATE DATABASE** **数据库名;*</strong></em></p>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061248012050.png" alt="img"></p>
<p><em>*<em>*方式*</em>*<em>2*</em>*<em>：创建数据库并指定字符集*</em>*</em></p>
<p>​    <strong>CREATE DATABASE</strong>  <em>*<em>*数据库名*</em> *<em>CHARACTER SET*</em> *<em>字符集*</em>**;*</em>**</p>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061248022056.png" alt="img"></p>
<p><em>*<em>*方式*</em>*<em>3*</em>*<em>：判断数据库是否已经存在，不存在则创建数据库（*</em> *<em>推荐*</em> *<em>）*</em>*</em></p>
<p>​    <em>*<em>*CREATE DATABASE IF NOT EXISTS*</em> *<em>数据库名*</em>**;*</em>**</p>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061248022064.png" alt="img"></p>
<p> <img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061248032066.png" alt="img"></p>
<h3 id="使用数据库"><a href="#使用数据库" class="headerlink" title="使用数据库"></a><strong>使用数据库</strong></h3><h4 id="查看当前所有的数据库"><a href="#查看当前所有的数据库" class="headerlink" title="查看当前所有的数据库"></a><strong>查看当前所有的数据库</strong></h4><p><strong>语法：</strong></p>
<p>​    <strong>SHOW DATABASES</strong> <em>*<em>*;*</em> **#*</em>*<em>有一个*</em>*<em>S*</em>** <strong>，代表多个数据库</strong></p>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061248032076.png" alt="img"></p>
<h4 id="使用-x2F-切换数据库"><a href="#使用-x2F-切换数据库" class="headerlink" title="使用&#x2F;切换数据库"></a>使用&#x2F;切换数据库</h4><p><em><strong>*语法：*</strong></em></p>
<p>​    <strong>USE</strong> <em>*<em>*数据库名*</em>**;*</em>**</p>
<h4 id="查看当前正在使用的数据库"><a href="#查看当前正在使用的数据库" class="headerlink" title="查看当前正在使用的数据库"></a>查看当前正在使用的数据库</h4><p><em><strong>*语法：*</strong></em></p>
<p>​     <em>*<em>*SELECT DATABASE*</em>**();*</em> *<em>#*</em>*<em>使用的一个*</em> *<em>mysql*</em> *<em>中的全局函数*</em>**</p>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061248032090.png" alt="img"></p>
<h4 id="查看指定库下的表"><a href="#查看指定库下的表" class="headerlink" title="查看指定库下的表"></a>查看指定库下的表</h4><p><em><strong>*语法：*</strong></em></p>
<p>​    <em>*<em>*SHOW TABLES 【FROM*</em> *<em>数据库名】*</em>**; # 查看【指定数据库中的】所有表*</em>**</p>
<p>​    <em><strong>*SHOW TABLE 表名 【FROM** **数据库名】;# 查看【指定数据库中的】指定的表*</strong></em></p>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061248032100.png" alt="img"></p>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061248042102.png" alt="img"></p>
<h4 id="查看数据库的创建信息"><a href="#查看数据库的创建信息" class="headerlink" title="查看数据库的创建信息"></a>查看数据库的创建信息</h4><p><em><strong>*语法：*</strong></em>   </p>
<p>​    <strong>SHOW CREATE DATABASE</strong> <em>*<em>*数据库名*</em>**;*</em>**</p>
<p>​    <em><strong>*或者：*</strong></em></p>
<p>​    <em>*<em>*SHOW CREATE DATABASE*</em> *<em>数据库名*</em>*<em>\G*</em>*</em></p>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061248042114.png" alt="img"></p>
<h3 id="修改数据库"><a href="#修改数据库" class="headerlink" title="修改数据库"></a><strong>修改数据库</strong></h3><h4 id="更改数据库字符集"><a href="#更改数据库字符集" class="headerlink" title="更改数据库字符集"></a><strong>更改数据库字符集</strong></h4><p><strong>语法：</strong></p>
<p>​    <strong>ALTER DATABASE</strong> <em>*<em>*数据库名*</em> *<em>CHARACTER SET*</em> *<em>字符集*</em>**;*</em> *<em>#*</em>*<em>比如：*</em>*<em>gbk*</em>*<em>、*</em>*<em>utf8*</em>*<em>等*</em>**</p>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061248042124.png" alt="img"></p>
<p>​    <em><strong>*注意：DATABASE 不能改名。一些可视化工具可以改名，它是建新库，把所有表复制到新库，再删旧库完成的。*</strong></em></p>
<h3 id="删除数据库"><a href="#删除数据库" class="headerlink" title="删除数据库"></a><strong>删除数据库</strong></h3><p><em>*<em>*方式*</em>*<em>1*</em>*<em>：删除指定的数据库，若数据库不存在，则报错。*</em>*</em></p>
<p>​    <em>*<em>*DROP DATABASE*</em> *<em>数据库名*</em>**;*</em>**</p>
<p><em>*<em>*方式*</em>*<em>2*</em>*<em>：删除指定的数据库（*</em> *<em>推荐*</em> *<em>）*</em>*</em></p>
<p>​    <em><strong>*DROP DATABASE IF EXISTS** **数据库名，若数据库不存在，则默默结束，不会报错。*</strong></em></p>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061248052140.png" alt="img"></p>
<h2 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a><strong>创建表</strong></h2><h3 id="创建方式1"><a href="#创建方式1" class="headerlink" title="创建方式1"></a><strong>创建方式1</strong></h3><p><strong>必须具备：</strong></p>
<p>​    1.CREATE TABLE权限</p>
<p>​    2.存储空间</p>
<p><strong>语法格式：</strong></p>
<p>​    <strong>CREATE TABLE</strong> <em>*<em>*[*</em>*<em>IF NOT EXISTS*</em>**]*</em> *<em>表名*</em>*<em>(*</em>**</p>
<p>​    <em>*<em>*字段1,*</em> *<em>数据类型*</em> **[*</em>*<em>约束条件*</em>*<em>] [*</em>*<em>默认值*</em>*<em>],*</em>**</p>
<p>​    <em>*<em>*字段2,*</em> *<em>数据类型*</em> **[*</em>*<em>约束条件*</em>*<em>] [*</em>*<em>默认值*</em>*<em>],*</em>**</p>
<p>​    <em>*<em>*字段3,*</em> *<em>数据类型*</em> **[*</em>*<em>约束条件*</em>*<em>] [*</em>*<em>默认值*</em>*<em>],*</em>**</p>
<p>​    <em><strong>*……*</strong></em></p>
<p>​    <em>*<em>*[表约束条件*</em>**]*</em>**</p>
<p>​    <em><strong>*);*</strong></em></p>
<p>​    <strong>加上了IF NOT EXISTS</strong> <em><strong>*关键字，则表示：如果当前数据库中不存在要创建的数据表，则创建数据表；*</strong></em></p>
<p>​    <em><strong>*如果当前数据库中已经存在要创建的数据表，则忽略建表语句，不再创建数据表。*</strong></em></p>
<p><strong>必须指定：</strong></p>
<p>​    1.表名</p>
<p>​    2.列名( 或字段名 ) ，数据类型， <strong>长度</strong></p>
<p><strong>可选指定：</strong></p>
<p>​    1.约束条件</p>
<p>​    2.默认值</p>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061248052186.png" alt="img"></p>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061248052188.png" alt="img"></p>
<p><strong>注：</strong></p>
<p>​    <strong>1.MySQL在执行建表语句时，将id字段的类型设置为int(11)，这里的11实际上是int类型指定的显示宽度，默认的显示宽度为11。也可以在创建数据表的时候指定数据的显示宽度。</strong></p>
<p>​    <strong>2.在MySQL 8.x版本中，不再推荐为INT类型指定显示长度，并在未来的版本中可能去掉这样的语法。</strong></p>
<h3 id="创建方式2"><a href="#创建方式2" class="headerlink" title="创建方式2"></a><strong>创建方式2</strong></h3><p>​    使用 AS subquery 选项， <strong>将创建表和插入数据结合起来</strong></p>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061248052200.png" alt="img"></p>
<p>​    指定的列和子查询中的列要一一对应</p>
<p>​    通过列名和默认值定义列</p>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061248062206.png" alt="img"></p>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061248062208.png" alt="img"></p>
<h4 id="练习1：创建一个表emplooyees-copy-实现对employees表的复制，包括数据"><a href="#练习1：创建一个表emplooyees-copy-实现对employees表的复制，包括数据" class="headerlink" title="练习1：创建一个表emplooyees_copy,实现对employees表的复制，包括数据"></a>练习1：创建一个表emplooyees_copy,实现对employees表的复制，包括数据</h4><p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061248072212.png" alt="img"></p>
<h4 id="练习2：创建一个表emplooyees-blank-实现对employees表的复制，不包括数据"><a href="#练习2：创建一个表emplooyees-blank-实现对employees表的复制，不包括数据" class="headerlink" title="练习2：创建一个表emplooyees_blank,实现对employees表的复制，不包括数据"></a>练习2：创建一个表emplooyees_blank,实现对employees表的复制，不包括数据</h4><p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061248072216.png" alt="img"></p>
<h2 id="修改表"><a href="#修改表" class="headerlink" title="修改表"></a><strong>修改表</strong></h2><p>修改表指的是修改数据库中已经存在的数据表的结构。</p>
<p><strong>使用</strong> <em><strong>*ALTER TABLE*</strong></em> <strong>语句可以实现：</strong></p>
<p>​    <strong>1.向已有的表中添加列</strong></p>
<p>​    <em><strong>*2.修改现有表中的列*</strong></em></p>
<p>​    <em><strong>*3.删除现有表中的列*</strong></em></p>
<p>​    <em><strong>*4.重命名现有表中的列*</strong></em></p>
<h3 id="追加一个列"><a href="#追加一个列" class="headerlink" title="追加一个列"></a><strong>追加一个列</strong></h3><p><strong>语法格式如下：</strong></p>
<p>​    <strong>ALTER TABLE</strong> <em>*<em>*表名*</em> *<em>ADD*</em> *<em>【*</em>*<em>COLUMN*</em>*<em>】 字段名 字段类型 【*</em>*<em>FIRST|*</em>*<em>AFTER*</em> *<em>字段名】*</em>**;*</em>**</p>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061248072240.png" alt="img"></p>
<p> <img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061248082242.png" alt="img"></p>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061248082244.png" alt="img"></p>
<h3 id="修改一个列"><a href="#修改一个列" class="headerlink" title="修改一个列"></a><strong>修改一个列</strong></h3><p><em>*<em>*可以修改列的*</em>*<em>数据类型，长度、默认值和位置*</em>*</em></p>
<p><em><strong>*修改字段数据类型、长度、默认值、位置的语法格式如下：*</strong></em></p>
<p>​    <em><strong>*ALTER TABLE** **表名*</strong></em></p>
<p>​    <em>*<em>*MODIFY*</em> *<em>【*</em>*<em>COLUMN*</em>*<em>】 字段名*</em>*<em>1*</em> *<em>字段类型 【*</em>*<em>DEFAULT*</em> *<em>默认值】【*</em>*<em>FIRST|*</em>*<em>AFTER*</em> *<em>字段名2】*</em>**;*</em>**</p>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061248082258.png" alt="img"></p>
<h3 id="重命名一个列"><a href="#重命名一个列" class="headerlink" title="重命名一个列"></a><strong>重命名一个列</strong></h3><p>​    <em><strong>*使用 CHANGE old_column new_column dataType*</strong></em> <strong>子句重命名列。</strong></p>
<p><em><strong>*语法格式如下：*</strong></em></p>
<p>​    <strong>ALTER TABLE</strong> <em>*<em>*表名*</em> *<em>CHANGE*</em> *<em>【*</em>*<em>column*</em>*<em>】 列名 新列名 新数据类型*</em>**;*</em>**</p>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061248092268.png" alt="img"></p>
<h3 id="删除一个列"><a href="#删除一个列" class="headerlink" title="删除一个列"></a><strong>删除一个列</strong></h3><p><em><strong>*删除表中某个字段的语法格式如下：*</strong></em></p>
<p>​    <em>*<em>*ALTER TABLE*</em> *<em>表名*</em> *<em>DROP*</em> *<em>【*</em>*<em>COLUMN*</em>*<em>】字段名;*</em>*</em></p>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061248092278.png" alt="img"></p>
<h2 id="重命名表"><a href="#重命名表" class="headerlink" title="重命名表"></a><strong>重命名表</strong></h2><p><em>*<em>*方式一：使用*</em>*<em>RENAME*</em>*</em></p>
<p>​    <strong>语法格式：</strong></p>
<p>​        <em><strong>*REMANE TABLE 表名*</strong></em></p>
<p>​        <strong>TO 新表名；</strong></p>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061248092290.png" alt="img"></p>
<p> <strong><em>*方式二：*</em> 使用ALTER</strong></p>
<p>​     <strong>语法格式：</strong></p>
<p>​        <em><strong>*ALTER TABLE 表名*</strong></em></p>
<p>​        <strong>RENAME 【TO】 新表名；</strong></p>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061248102300.png" alt="img"></p>
<h2 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a><strong>删除表</strong></h2><p>​    在MySQL 中，当一张数据表 没有与其他任何数据表形成关联关系 时，可以将<strong>当前数据表直接删除。</strong></p>
<p>​    <strong>数据和结构都被删除</strong></p>
<p>​    <em><strong>*所有正在运行的相关事务被提交*</strong></em></p>
<p>​    <em><strong>*所有相关索引被删除*</strong></em></p>
<p>​     <em><strong>*DROP TABLE 语句不能回滚（即无法撤销。删除了就找不回来了，除非有备份）*</strong></em></p>
<p><em><strong>*语法格式：*</strong></em></p>
<p>​    <em>*<em>*DROP TABLE*</em> **[*</em>*<em>IF EXISTS*</em>*<em>]*</em> *<em>数据表*</em>*<em>1 [,*</em> *<em>数据表*</em>*<em>2, …,*</em> *<em>数据表*</em>*<em>n];*</em>**</p>
<p>IF EXISTS 的含义为：如果当前数据库中存在相应的数据表，则删除数据表；如果当前数据库中不存 在相应的数据表，则忽略删除语句，不再执行删除数据表的操作。</p>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061248102324.png" alt="img"></p>
<h2 id="清空表"><a href="#清空表" class="headerlink" title="清空表"></a><strong>清空表</strong></h2><h3 id="TRUNCATE-TABLE语句"><a href="#TRUNCATE-TABLE语句" class="headerlink" title="TRUNCATE TABLE语句"></a><strong>TRUNCATE TABLE语句</strong></h3><p><strong>TRUNCATE TABLE</strong> <strong>语</strong> <strong>句：</strong></p>
<p>​    <em><strong>*1.删除表中所有的数据,保留表结构*</strong></em></p>
<p>​    <em><strong>*2.释放表的存储空间*</strong></em></p>
<p><strong>语法格式：</strong></p>
<p>​    <em><strong>*TRUNCATE TABLE** **表名;*</strong></em></p>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061248102342.png" alt="img"></p>
<h3 id="DELETE-FROM语句："><a href="#DELETE-FROM语句：" class="headerlink" title="DELETE FROM语句："></a><strong>DELETE FROM语句：</strong></h3><p><strong>语法格式：</strong></p>
<p>​     <strong>DELETE FROM</strong> <em><strong>*表名;(可以加过滤条件，表示删除部分数据)*</strong></em></p>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061248112352.png" alt="img"></p>
<h3 id="对比-TRUNCATE-TABLE-与-DELETE-FROM"><a href="#对比-TRUNCATE-TABLE-与-DELETE-FROM" class="headerlink" title="对比 TRUNCATE TABLE 与 DELETE FROM"></a>对比 TRUNCATE TABLE 与 DELETE FROM</h3><h4 id="对比-TRUNCATE-TABLE-与-DELETE-FROM-1"><a href="#对比-TRUNCATE-TABLE-与-DELETE-FROM-1" class="headerlink" title="对比 TRUNCATE TABLE 与 DELETE FROM"></a>对比 TRUNCATE TABLE 与 DELETE FROM</h4><p><strong>相同点： 都可以实现对表中所有数据的删除，同时保留数据结构</strong></p>
<p><strong>不同点：</strong></p>
<p>​    <em><strong>*TRUNCATE TABLE：一旦执行此操作，表数据全部删除。同时，数据是不可以回滚的*</strong></em></p>
<p>​    <em><strong>*DELETE FROM：一旦执行此操作，表数据可以全部删除（不带where）。同时，数据*</strong></em></p>
<p>​                   <em><strong>*是可以实现回滚的*</strong></em></p>
<p><em><strong>*说明：*</strong></em></p>
<p>​    <em>*<em>*1.TRUNCATE TABLE 比*</em> *<em>DELETE*</em> *<em>速度快，且使用的系统和事务日志资源少，但*</em> *<em>TRUNCATE*</em> *<em>无 事务且不触发 TRIGGER*</em>*<em>，有可能造成事故，故*</em>*<em>不建议在开发代码中使用此语句。*</em>*</em></p>
<p>​    <em><strong>*2.TRUNCATE TABLE 在功能上与不带** *<em>WHERE*</em> *<em>子句的*</em> *<em>DELETE*</em> **语句相同。*</strong></em></p>
<h4 id="DCL中的COMMIT和ROLLBACK拓展"><a href="#DCL中的COMMIT和ROLLBACK拓展" class="headerlink" title="DCL中的COMMIT和ROLLBACK拓展"></a>DCL中的COMMIT和ROLLBACK拓展</h4><p>COMMIT : 提交数据。一旦执行此操作，则数据被永久的保存在了数据库中，意味着数据不</p>
<p>​         可以回滚。</p>
<p>ROLLBACK : 一旦执行此操作，则可以实现数据回滚。回滚到最近一次COMMIT之后。</p>
<h4 id="DDL-与-DML-说明"><a href="#DDL-与-DML-说明" class="headerlink" title="DDL 与 DML 说明"></a>DDL 与 DML 说明</h4><p>​    1.DDL的操作一旦执行，就不可以回滚。指令SET autocommit &#x3D; FALSE 对DDL操作失效（因为在执行完DDL操作之后，一定会执行一此COMMIT。而此COMMIT操作不受</p>
<p>SET autocommit &#x3D; FALSE 影响的）</p>
<p>​    2.DML的默认操作情况，一旦执行，也是不可以回滚的。但是，如果在执行DML之前，执行了 SET autocommit &#x3D; FALSE ，则执行操作就可以实现回滚。</p>
<h4 id="TRUNCATE-TABLE-与-DELETE-FROM回滚演示"><a href="#TRUNCATE-TABLE-与-DELETE-FROM回滚演示" class="headerlink" title="TRUNCATE TABLE 与 DELETE FROM回滚演示"></a>TRUNCATE TABLE 与 DELETE FROM回滚演示</h4><p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061248122394.png" alt="img"></p>
<p> <img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061248122396.png" alt="img"></p>
<h2 id="内容拓展"><a href="#内容拓展" class="headerlink" title="内容拓展"></a><strong>内容拓展</strong></h2><h3 id="拓展1：阿里巴巴《Java开发手册》之MySQL字段命名"><a href="#拓展1：阿里巴巴《Java开发手册》之MySQL字段命名" class="headerlink" title="拓展1：阿里巴巴《Java开发手册》之MySQL字段命名"></a><strong>拓展1：阿里巴巴《Java开发手册》之MySQL字段命名</strong></h3><p>【 强制 】表名、字段名必须使用小写字母或数字，禁止出现数字开头，禁止两个下划线中间</p>
<p>​        只出 现数字。数据库字段名的修改代价很大，因为无法进行预发布，所以字段名</p>
<p>​        称需要慎重考虑。</p>
<p>​            正例：aliyun_admin，rdc_config ， level3_name</p>
<p>​            反例：AliyunAdmin，rdcConfig ， level_3_name</p>
<p>【 强制 】禁用保留字，如 desc 、 range 、 match 、 delayed 等，请参考 MySQL 官方保留</p>
<p>​        字。</p>
<p>【 强制 】表必备三字段： id, gmt_create, gmt_modified 。</p>
<p>​        说明：其中 id 必为主键，类型为 BIGINT UNSIGNED 、单表时自增、步长为 1 。</p>
<p>​              gmt_create, gmt_modified 的类型均为 DATETIME 类型，前者现在时表示</p>
<p>​              主动式创建，后者过去分词表示被动式更新</p>
<p>【 推荐 】表的命名最好是遵循 “ 业务名称 _ 表的作用 ” 。</p>
<p>​        正例：alipay_task 、 force_project 、 trade_config</p>
<p>【 推荐 】库名与应用名称尽量一致。</p>
<p>【参考】合适的字符存储长度，不但节约数据库表空间、节约索引存储，更重要的是提升检</p>
<p>​        索速度。</p>
<p>​        正例：无符号值可以避免误存负数，且扩大了表示范围。</p>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061248132438.png" alt="img"></p>
<h3 id="拓展2：如何理解清空表、删除表等操作需谨慎？！"><a href="#拓展2：如何理解清空表、删除表等操作需谨慎？！" class="headerlink" title="拓展2：如何理解清空表、删除表等操作需谨慎？！"></a><strong>拓展2：如何理解清空表、删除表等操作需谨慎？！</strong></h3><p>​    表删除 操作将把表的定义和表中的数据一起删除，并且 MySQL 在执行删除操作时，不会有任何的确认信 息提示，因此执行删除操时应当慎重。在删除表前，最好对表中的数据进行 备份 ，这样当操作失误时可 以对数据进行恢复，以免造成无法挽回的后果。</p>
<p>​    同样的，在使用 ALTER TABLE 进行表的基本修改操作时，在执行操作过程之前，也应该确保对数据进 行完整的 备份 ，因为数据库的改变是 无法撤销 的，如果添加了一个不需要的字段，可以将其删除；相 同的，如果删除了一个需要的列，该列下面的所有数据都将会丢失。</p>
<h3 id="拓展3：MySQL8新特性—DDL的原子化"><a href="#拓展3：MySQL8新特性—DDL的原子化" class="headerlink" title="拓展3：MySQL8新特性—DDL的原子化"></a><strong>拓展3：MySQL8新特性—DDL的原子化</strong></h3><p>​    在MySQL 8.0 版本中， InnoDB 表的 DDL 支持事务完整性，即 DDL 操作要么成功要么回滚 。 DDL 操作回滚日志写入到data dictionary 数据字典表 mysql.innodb_ddl_log （该表是隐藏的表，通过 show tables 无法看到）中，用于回滚操作。通过设置参数，可将DDL 操作日志打印输出到 MySQL 错误日志中。</p>
<p>分别在 MySQL 5.7 版本和 MySQL 8.0 版本中创建数据库和数据表，结果如下：</p>
<p><em>*<em>*（1）在*</em>*<em>MySQL 5.7*</em>*<em>版本中，测试：*</em>*</em></p>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061248132456.png" alt="img"></p>
<p> 从结果可以看出，虽然删除操作时报错了，但是仍然删除了数据表book1</p>
<p><em>*<em>*（2）在*</em>*<em>MySQL 8.0*</em>*<em>版本中，测试如下：*</em>*</em></p>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061248132464.png" alt="img"></p>
<p> 从结果可以看出，数据表book1并没有被删除。</p>
<h2 id="练习-4"><a href="#练习-4" class="headerlink" title="练习"></a>练习</h2><h3 id="创建数据库test01-office-指明字符集为utf8。并在此数据库下执行下述操作"><a href="#创建数据库test01-office-指明字符集为utf8。并在此数据库下执行下述操作" class="headerlink" title="创建数据库test01_office,指明字符集为utf8。并在此数据库下执行下述操作"></a>创建数据库test01_office,指明字符集为utf8。并在此数据库下执行下述操作</h3><p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061248132472.png" alt="img"></p>
<h3 id="创建表dept01"><a href="#创建表dept01" class="headerlink" title="创建表dept01"></a>创建表dept01</h3><p>&#x2F;*</p>
<p>字段 类型</p>
<p>id INT(7)</p>
<p>NAME VARCHAR(25)</p>
<p>*&#x2F;</p>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061248142488.png" alt="img"></p>
<h3 id="将表departments中的数据插入新表dept02中"><a href="#将表departments中的数据插入新表dept02中" class="headerlink" title="将表departments中的数据插入新表dept02中"></a>将表departments中的数据插入新表dept02中</h3><p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061248142494.png" alt="img"></p>
<h3 id="创建表emp01"><a href="#创建表emp01" class="headerlink" title="创建表emp01"></a>创建表emp01</h3><p>&#x2F;*</p>
<p>字段 类型</p>
<p>id INT(7)</p>
<p>first_name VARCHAR (25)</p>
<p>last_name VARCHAR(25)</p>
<p>dept_id INT(7)</p>
<p>*&#x2F;</p>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061248142512.png" alt="img"></p>
<h3 id="将emp01中列last-name的长度增加到50"><a href="#将emp01中列last-name的长度增加到50" class="headerlink" title="将emp01中列last_name的长度增加到50"></a>将emp01中列last_name的长度增加到50</h3><p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061248152518.png" alt="img"></p>
<h3 id="根据表employees创建emp02"><a href="#根据表employees创建emp02" class="headerlink" title="根据表employees创建emp02"></a>根据表employees创建emp02</h3><p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061248152524.png" alt="img"></p>
<h3 id="删除表emp01"><a href="#删除表emp01" class="headerlink" title="删除表emp01"></a>删除表emp01</h3><p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061248152530.png" alt="img"></p>
<h3 id="将表emp02重命名为emp01"><a href="#将表emp02重命名为emp01" class="headerlink" title="将表emp02重命名为emp01"></a>将表emp02重命名为emp01</h3><p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061248152536.png" alt="img"></p>
<h3 id="在表dept02和emp01中添加新列test-column，并检查所作的操作"><a href="#在表dept02和emp01中添加新列test-column，并检查所作的操作" class="headerlink" title="在表dept02和emp01中添加新列test_column，并检查所作的操作"></a>在表dept02和emp01中添加新列test_column，并检查所作的操作</h3><p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061248162542.png" alt="img"></p>
<h3 id="直接删除表emp01中的列-department-id"><a href="#直接删除表emp01中的列-department-id" class="headerlink" title="直接删除表emp01中的列 department_id"></a>直接删除表emp01中的列 department_id</h3><p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061248162548.png" alt="img"></p>
<h1 id="MySQL-数据处理之增删改"><a href="#MySQL-数据处理之增删改" class="headerlink" title="MySQL 数据处理之增删改"></a>MySQL 数据处理之增删改</h1><h2 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a><strong>插入数据</strong></h2><h3 id="方式1：VALUES的方式添加"><a href="#方式1：VALUES的方式添加" class="headerlink" title="方式1：VALUES的方式添加"></a><strong>方式1：VALUES的方式添加</strong></h3><p>​    <em>*<em>*使用这种语法一次只能向表中插入*</em>*<em>一条*</em>*<em>数据。*</em>*</em></p>
<h4 id="情况1：为表的所有字段按默认顺序插入数据"><a href="#情况1：为表的所有字段按默认顺序插入数据" class="headerlink" title="情况1：为表的所有字段按默认顺序插入数据"></a><strong>情况1：为表的所有字段按默认顺序插入数据</strong></h4><p><strong>语法格式:</strong></p>
<p>​    <em><strong>*INSERT INTO 表名*</strong></em></p>
<p>​    <em><strong>*VALUES (value1,value2,….);*</strong></em></p>
<p>​    值列表中需要为表的每一个字段指定值，并且值的顺序必须和数据表中字段定义时的顺序相同。</p>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061248162568.png" alt="img"></p>
<h4 id="情况2：为表的指定字段插入数据"><a href="#情况2：为表的指定字段插入数据" class="headerlink" title="情况2：为表的指定字段插入数据"></a><strong>情况2：为表的指定字段插入数据</strong></h4><p><strong>语法格式：</strong></p>
<p>​    <em>*<em>*INSERT INTO*</em> *<em>表名*</em>**(column1 [, column2, …, columnn])*</em>**</p>
<p>​    <em>*<em>*VALUES*</em> **(value1 [,value2, …, valuen]);*</em>**</p>
<p>​     为表的指定字段插入数据，就是在INSERT语句中只向部分字段中插入值，而其他字段的值为表定义时的默认值。</p>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061248172582.png" alt="img"></p>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061248172584.png" alt="img"></p>
<h4 id="情况3：同时插入多条记录"><a href="#情况3：同时插入多条记录" class="headerlink" title="情况3：同时插入多条记录"></a><strong>情况3：同时插入多条记录</strong></h4><p>​    <em><strong>*INSERT语句可以同时向数据表中插入多条记录，插入时指定多个值列表，每个值列表之间用逗号分隔开。*</strong></em></p>
<p><strong>语法格式：</strong></p>
<p>​    <strong>INSERT INTO table_name</strong></p>
<p>​    <em><strong>*VALUES*</strong></em></p>
<p>​    <em><strong>*(value1 [,value2, …, valuen]),*</strong></em></p>
<p>​    <em><strong>*(value1 [,value2, …, valuen]),*</strong></em></p>
<p>​    <em><strong>*……*</strong></em></p>
<p>​    <em><strong>*(value1 [,value2, …, valuen]);*</strong></em></p>
<p>​    或</p>
<p>​    <strong>INSERT INTO table_name</strong> <em><strong>*(column1 [, column2, …, columnn])*</strong></em></p>
<p>​    <em><strong>*VALUES*</strong></em></p>
<p>​    <em><strong>*(value1 [,value2, …, valuen]),*</strong></em></p>
<p>​    <em><strong>*(value1 [,value2, …, valuen]),*</strong></em></p>
<p>​    <em><strong>*……*</strong></em></p>
<p>​    <em><strong>*(value1 [,value2, …, valuen]);*</strong></em></p>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061248172618.png" alt="img"></p>
<p>说明：</p>
<p>​    1.使用INSERT同时插入多条记录时，MySQL会返回一些在执行单行插入时没有的额外信息，这些信息的含 义如下： ●　Records：表明插入的记录条数。 ●　Duplicates：表明插入时被忽略的记录，原因可能是这 些记录包含了重复的主键值。 ●　Warnings：表明有问题的数据值，例如发生数据类型转换。</p>
<p>​    *<em>2.*<em>一个同时插入多行记录的INSERT*</em>*<em>语句等同于多个单行插入的*</em>*<em>INSERT*</em>*<em>语句，但是多行的*</em>*<em>INSERT*</em>*<em>语句 在处理过程中*</em> *<em>效率更高*</em> *<em>。因为*</em>*<em>MySQL*</em>*<em>执行单条*</em>*<em>INSERT*</em>*<em>语句插入多行数据比使用多条*</em>*<em>INSERT*</em>*<em>语句 快，所以在插入多条记录时最好选择使用单条INSERT*</em>*<em>语句的方式插入。*</em></em>*</p>
<h4 id="小结："><a href="#小结：" class="headerlink" title="小结："></a><strong>小结：</strong></h4><p>​    <em>*<em>*1.*</em> *<em>VALUES*</em> *<em>也可以写成*</em> *<em>VALUE*</em> *<em>，但是*</em>*<em>VALUES*</em>*<em>是标准写法。*</em>*</em></p>
<p>​    <em><strong>*2. 字符和日期型数据应包含在单引号中。*</strong></em></p>
<h3 id="方式2：将查询结果插入到表中"><a href="#方式2：将查询结果插入到表中" class="headerlink" title="方式2：将查询结果插入到表中"></a><strong>方式2：将查询结果插入到表中</strong></h3><p>​    INSERT还可以将 SELECT 语句查询的结果插入到表中，此时不需要把每一条记录的值一个一个输入，只需 要使用一条INSERT 语句和一条 SELECT 语句组成的组合语句即可快速地从一个或多个表中向一个表中插入 多行。</p>
<p><strong>语法格式：</strong></p>
<p>​    <em><strong>*INSERT INTO** **目标表名*</strong></em></p>
<p>​    <em><strong>*(tar_column1 [, tar_column2, …, tar_columnn])*</strong></em></p>
<p>​    <em><strong>*SELECT*</strong></em></p>
<p>​    <em><strong>*(src_column1 [, src_column2, …, src_columnn])*</strong></em></p>
<p>​    <em><strong>*FROM** **源表名*</strong></em></p>
<p>​    <em>*<em>*[*</em>*<em>WHERE condition*</em>**]*</em>**</p>
<p><strong>说明：</strong></p>
<p>​    <em><strong>*1.在 INSERT** **语句中加入子查询。*</strong></em></p>
<p>​    <em><strong>*2.不必书写 VALUES** **子句。*</strong></em></p>
<p>​    <em><strong>*3.子查询中的值列表应与 INSERT** **子句中的列名对应。*</strong></em></p>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061248182660.png" alt="img"></p>
<p><strong>注意：</strong></p>
<p>​    <strong>1.查询字段的数据类型必须要与添加到的表的字段的数据类型一一对应</strong></p>
<p>​    <strong>2.添加到的表的字段的长度不能低于查询字段，否则存在添加不成功的风险。</strong></p>
<h2 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a><strong>更新数据</strong></h2><p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061248182670.png" alt="img"></p>
<p> <em><strong>*使用** *<em>UPDATE*</em> **语句更新数据。语法如下：*</strong></em></p>
<p>​     <strong>UPDATE table_name</strong></p>
<p>​    <strong>SET column1&#x3D;value1, column2&#x3D;value2, … , column&#x3D;valuen</strong></p>
<p>​    <strong>[WHERE condition]</strong></p>
<p>可以一次更新 <strong>多条</strong> 数据。</p>
<p>如果需要回滚数据，需要保证在 DML 前，进行设置： <strong>SET AUTOCOMMIT &#x3D; FALSE;</strong></p>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061248192684.png" alt="img"></p>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061248192686.png" alt="img"></p>
<p><strong>注：在添加、修改或删除数据时，是可能存在不成功的。（可能时由于约束的影响）</strong></p>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061248192690.png" alt="img"></p>
<h2 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a><strong>删除数据</strong></h2><p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061248202696.png" alt="img"></p>
<p><em><strong>*使用** *<em>DELETE*</em> **语句从表中删除数据，语法格式如下：*</strong></em></p>
<p>​    <strong>DELETE FROM table_name</strong></p>
<p>​    <em>*<em>*[*</em>*<em>WHERE*</em> **&lt;****condition**** **&gt;];</em>*</p>
<p>​    <em>*<em>*table_name指定要执行删除操作的表；*</em>*<em>“[WHERE ]”*</em>*<em>为可选参数，指定删除条件，如果没有*</em>*<em>WHERE*</em>*<em>子句， DELETE语句将删除表中的所有记录。*</em>*</em></p>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061248202708.png" alt="img"></p>
<p><strong>注：在添加、修改或删除数据时，是可能存在不成功的。（可能时由于约束的影响）</strong></p>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061248212714.png" alt="img"></p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a><strong>小结</strong></h2><p>​    <strong>1.DML操作在默认情况下，执行完以后都会自动提交数据，如果希望执行完以后，不自动提交数据，则需要使用SET autocommit &#x3D; FALSE;</strong></p>
<p>​    <em><strong>*2.在添加、修改或删除数据时，是可能存在不成功的。（可能时由于约束的影响）*</strong></em></p>
<p>​    <strong>3.基本语法：</strong></p>
<p>​       <strong>添加：方式1：</strong></p>
<p>​            <em><strong>*INSERT INTO 表名*</strong></em></p>
<p>​            <strong>VALUES (value1,value2,….);</strong></p>
<p>​            <em><strong>*方式2：*</strong></em></p>
<p>​            <em><strong>*INSERT INTO 目标表名*</strong></em> <strong>(tar_column1 [, tar_column2, …, tar_columnn])</strong></p>
<p>​            <strong>SELECT</strong> <strong>(src_column1 [, src_column2, …, src_columnn])</strong></p>
<p>​            <strong>FROM 源表名</strong></p>
<p>​            <strong>[WHERE condition]</strong></p>
<p>​      <strong>更新（修改）：</strong></p>
<p>​            <strong>UPDATE table_name</strong></p>
<p>​            <strong>SET column1&#x3D;value1, column2&#x3D;value2, … , column&#x3D;valuen</strong></p>
<p>​            <strong>[WHERE condition]</strong></p>
<p>​       <strong>删除：</strong>            </p>
<p>​             <strong>DELETE FROM table_name</strong></p>
<p>​            <strong>[WHERE <condition>];</strong></p>
<p>​            </p>
<h2 id="mysql8-0新特性-计算列"><a href="#mysql8-0新特性-计算列" class="headerlink" title="mysql8.0新特性:计算列"></a>mysql8.0新特性:计算列</h2><p>​    什么叫计算列呢？简单来说就是某一列的值是通过别的列计算得来的。例如，a 列值为 1 、 b 列值为 2 ， c 列 不需要手动插入，定义a+b 的结果为 c 的值，那么 c 就是计算列，是通过别的列计算得来的。</p>
<p>​    在MySQL 8.0 中， CREATE TABLE 和 ALTER TABLE 中都支持增加计算列。下面以 CREATE TABLE 为例进行讲解。</p>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061248212764.png" alt="img"></p>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061248212766.png" alt="img"></p>
<h2 id="练习-5"><a href="#练习-5" class="headerlink" title="练习"></a>练习</h2><h3 id="创建数据库dbtest11"><a href="#创建数据库dbtest11" class="headerlink" title="创建数据库dbtest11"></a>创建数据库dbtest11</h3><p>CREATE DATABASE IF NOT EXISTS dbtest11 CHARACTER SET ‘utf8’ ;</p>
<h3 id="运行以下脚本创建表my-employees"><a href="#运行以下脚本创建表my-employees" class="headerlink" title="运行以下脚本创建表my_employees"></a>运行以下脚本创建表my_employees</h3><p>USE dbtest11;</p>
<p>CREATE TABLE my_employees(</p>
<p> id INT ( 10 ),</p>
<p> first_name VARCHAR ( 10 ),</p>
<p> last_name VARCHAR ( 10 ),</p>
<p> userid VARCHAR ( 10 ),</p>
<p> salary DOUBLE ( 10 , 2 )</p>
<p>);</p>
<p>CREATE TABLE users(</p>
<p> id INT ,</p>
<p> userid VARCHAR ( 10 ),</p>
<p> department_id INT</p>
<p>);</p>
<h3 id="显示表my-employees的结构"><a href="#显示表my-employees的结构" class="headerlink" title="显示表my_employees的结构"></a>显示表my_employees的结构</h3><p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061248212806.png" alt="img"></p>
<h3 id="向my-employees表中插入下列数据"><a href="#向my-employees表中插入下列数据" class="headerlink" title="向my_employees表中插入下列数据"></a>向my_employees表中插入下列数据</h3><p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061248222812.png" alt="img"></p>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061248222816.png" alt="img"></p>
<h3 id="向users表中插入数据"><a href="#向users表中插入数据" class="headerlink" title="向users表中插入数据"></a>向users表中插入数据</h3><p>1 Rpatel 10</p>
<p>2 Bdancs 10</p>
<p>3 Bbiri 20</p>
<p>4 Cnewman 30</p>
<p>5 Aropebur 40</p>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061248222832.png" alt="img"></p>
<h3 id="将3号员工的last-name修改为“drelxer”"><a href="#将3号员工的last-name修改为“drelxer”" class="headerlink" title="将3号员工的last_name修改为“drelxer”"></a>将3号员工的last_name修改为“drelxer”</h3><p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061248222838.png" alt="img"></p>
<h3 id="将所有工资少于900的员工的工资修改为1000"><a href="#将所有工资少于900的员工的工资修改为1000" class="headerlink" title="将所有工资少于900的员工的工资修改为1000"></a>将所有工资少于900的员工的工资修改为1000</h3><p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061248232844.png" alt="img"></p>
<h3 id="将userid为Bbiri的user表和my-employees表的记录全部删除"><a href="#将userid为Bbiri的user表和my-employees表的记录全部删除" class="headerlink" title="将userid为Bbiri的user表和my_employees表的记录全部删除"></a>将userid为Bbiri的user表和my_employees表的记录全部删除</h3><p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061248232850.png" alt="img"></p>
<h3 id="删除my-employees、users表所有数据"><a href="#删除my-employees、users表所有数据" class="headerlink" title="删除my_employees、users表所有数据"></a>删除my_employees、users表所有数据</h3><p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061248232856.png" alt="img"></p>
<h3 id="检查所作的修正"><a href="#检查所作的修正" class="headerlink" title="检查所作的修正"></a>检查所作的修正</h3><p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061248242862.png" alt="img"></p>
<h3 id="清空表my-employees"><a href="#清空表my-employees" class="headerlink" title="清空表my_employees"></a>清空表my_employees</h3><p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061248242868.png" alt="img"></p>
<h1 id="MySQL中的数据类型-1"><a href="#MySQL中的数据类型-1" class="headerlink" title="MySQL中的数据类型"></a><strong>MySQL中的数据类型</strong></h1><table>
<thead>
<tr>
<th><em><strong>*类型*</strong></em></th>
<th><em><strong>*类型举例*</strong></em></th>
</tr>
</thead>
<tbody><tr>
<td><em><strong>*整数类型*</strong></em></td>
<td><em>*<em>*TINYINT*</em>*<em>、*</em>*<em>SMALLINT*</em>*<em>、*</em>*<em>MEDIUMINT*</em>*<em>、*</em>*<em>INT(*</em>*<em>或*</em>*<em>INTEGER)*</em>*<em>、*</em>*<em>BIGINT*</em>*</em></td>
</tr>
<tr>
<td><em><strong>*浮点类型*</strong></em></td>
<td><em>*<em>*FLOAT*</em>*<em>、*</em>*<em>DOUBLE*</em>*</em></td>
</tr>
<tr>
<td><em><strong>*定点数类型*</strong></em></td>
<td><em><strong>*DECIMAL*</strong></em></td>
</tr>
<tr>
<td><em><strong>*位类型*</strong></em></td>
<td><em><strong>*BIT*</strong></em></td>
</tr>
<tr>
<td><em><strong>*日期时间类型*</strong></em></td>
<td><em>*<em>*YEAR*</em>*<em>、*</em>*<em>TIME*</em>*<em>、*</em>*<em>DATE*</em>*<em>、*</em>*<em>DATETIME*</em>*<em>、*</em>*<em>TIMESTAMP*</em>*</em></td>
</tr>
<tr>
<td><em><strong>*文本字符串类型*</strong></em></td>
<td><em>*<em>*CHAR*</em>*<em>、*</em>*<em>VARCHAR*</em>*<em>、*</em>*<em>TINYTEXT*</em>*<em>、*</em>*<em>TEXT*</em>*<em>、*</em>*<em>MEDIUMTEXT*</em>*<em>、*</em>*<em>LONGTEXT*</em>*</em></td>
</tr>
<tr>
<td><em><strong>*枚举类型*</strong></em></td>
<td><em><strong>*ENUM*</strong></em></td>
</tr>
<tr>
<td><em><strong>*集合类型*</strong></em></td>
<td><em><strong>*SET*</strong></em></td>
</tr>
<tr>
<td><em><strong>*二进制字符串类型*</strong></em></td>
<td><em>*<em>*BINARY*</em>*<em>、*</em>*<em>VARBINARY*</em>*<em>、*</em>*<em>TINYBLOB*</em>*<em>、*</em>*<em>BLOB*</em>*<em>、*</em>*<em>MEDIUMBLOB*</em>*<em>、*</em>*<em>LONGBLOB*</em>*</em></td>
</tr>
<tr>
<td><em>*<em>*JSON*</em>*<em>类型*</em>*</em></td>
<td><em>*<em>*JSON*</em>*<em>对象、*</em>*<em>JSON*</em>*<em>数组*</em>*</em></td>
</tr>
<tr>
<td><em><strong>*空间数据类型*</strong></em></td>
<td><em>*<em>*单值类型：*</em>*<em>GEOMETRY*</em>*<em>、*</em>*<em>POINT*</em>*<em>、*</em>*</em>         <em>*<em>*LINESTRING、*</em>*<em>POLYGON*</em>*<em>；*</em>*</em><em>*<em>*集合类型：*</em>*<em>MULTIPOINT*</em>*<em>、*</em>*</em>         <em><strong>*MULTILINESTRING、*</strong></em>             <em><strong>*MULTIPOLYGON、*</strong></em>          <em><strong>*GEOMETRYCOLLECTION*</strong></em></td>
</tr>
</tbody></table>
<p>常见数据类型的属性，如下：</p>
<table>
<thead>
<tr>
<th><strong>MySQL关键字</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td><em><strong>*NULL*</strong></em></td>
<td><em>*<em>*数据列可包含*</em>*<em>NULL*</em>*<em>值*</em>*</em></td>
</tr>
<tr>
<td><em><strong>*NOT NULL*</strong></em></td>
<td><em>*<em>*数据列不允许包含*</em>*<em>NULL*</em>*<em>值*</em>*</em></td>
</tr>
<tr>
<td><em><strong>*DEFAULT*</strong></em></td>
<td><em><strong>*默认值*</strong></em></td>
</tr>
<tr>
<td><em><strong>*PRIMARY KEY*</strong></em></td>
<td><em><strong>*主键*</strong></em></td>
</tr>
<tr>
<td><em><strong>*AUTO_INCREMENT*</strong></em></td>
<td><em><strong>*自动递增，适用于整数类型*</strong></em></td>
</tr>
<tr>
<td><em><strong>*UNSIGNED*</strong></em></td>
<td><em><strong>*无符号*</strong></em></td>
</tr>
<tr>
<td><strong>CHARACTER SET name</strong></td>
<td><strong>指定一个字符集</strong></td>
</tr>
</tbody></table>
<p><strong>CHARACTER SET name使用：</strong></p>
<p><strong>1.创建数据库时指定字符集</strong></p>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061248242902.png" alt="img"></p>
<p> <strong>2.创建表的时候，指明表的的字符集</strong></p>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061248252906.png" alt="img"></p>
<p> <strong>3.创建表，指明字段时，可以指定字段的字符集</strong></p>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061248252910.png" alt="img"></p>
<h2 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a><strong>整数类型</strong></h2><h3 id="类型介绍"><a href="#类型介绍" class="headerlink" title="类型介绍"></a><strong>类型介绍</strong></h3><p>​    整数类型一共有 <strong>5</strong> 种，包括 <em>*<em>*TINYINT*</em>*<em>、*</em>*<em>SMALLINT*</em>*<em>、*</em>*<em>MEDIUMINT*</em>*<em>、*</em>*<em>INT*</em>*<em>（*</em>*</em></p>
<p><em>*<em>*INTEGER*</em>*<em>）和*</em> *<em>BIGINT*</em>*<em>。*</em>*</em></p>
<p>​    它们的区别如下表所示：</p>
<table>
<thead>
<tr>
<th><em>*<em>*</em>*整数类型****</em>*</th>
<th><em>*<em>*</em>*字节****</em>*</th>
<th><em>*<em>*</em>*有符号数取值范围****</em>*</th>
<th><em>*<em>*</em>*无符号数取值范围****</em>*</th>
</tr>
</thead>
<tbody><tr>
<td>TINYINT</td>
<td>1</td>
<td>-128~127</td>
<td>0~255</td>
</tr>
<tr>
<td>SMALLINT</td>
<td>2</td>
<td>-32768~32767</td>
<td>0~65535</td>
</tr>
<tr>
<td>MEDIUMINT</td>
<td>3</td>
<td>-8388608~8388607</td>
<td>0~16777215</td>
</tr>
<tr>
<td>INT、INTEGER</td>
<td>4</td>
<td>-2147483648~2147483647</td>
<td>0~4294967295</td>
</tr>
<tr>
<td>BIGINT</td>
<td>8</td>
<td>-9223372036854775808 ~9223372036854775807</td>
<td>0~18446744073709551615</td>
</tr>
</tbody></table>
<p>如代码：</p>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061248252934.png" alt="img"></p>
<p>如代码：</p>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061248252940.png" alt="img"></p>
<p> MySQL8.0演示结果：</p>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061248262946.png" alt="img"></p>
<p> MySQL5.7演示结果：</p>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061248262950.png" alt="img"></p>
<p> <strong>创建表、指明字段时，若未指明整型数据类型的长度，以上分别为各个类型的默认长度。</strong></p>
<p> <em>*<em>*MySQL8*</em>*<em>中不再显式范围*</em>*</em></p>
<h3 id="可选属性"><a href="#可选属性" class="headerlink" title="可选属性"></a><strong>可选属性</strong></h3><p><strong>整数类型的可选属性有三个：</strong></p>
<h4 id="M"><a href="#M" class="headerlink" title="M"></a><strong>M</strong></h4><p>​    M : 表示显示宽度， M 的取值范围是 (0, 255) 。例如， int(5) ：当数据宽度小于 5 位的时候在数字前面需要用字符填满宽度。该项功能需要配合“ ZEROFILL ” 使用，表示用 “0” 填满宽度，否则指定显示宽度无效。</p>
<p>​     如果设置了显示宽度，那么插入的数据宽度超过显示宽度限制，会不会截断或插入失败？</p>
<p>​    答案：不会对插入的数据有任何影响，还是按照类型的实际宽度进行保存，即 <em><strong>*显示宽度与类型可以存储的值范围无关*</strong></em> 。 <strong>从</strong> <strong>MySQL 8.0.17</strong> <strong>开始，整数数据类型不推荐使用显示宽度属性。</strong></p>
<p>​    整型数据类型可以在定义表结构时指定所需要的显示宽度，如果不指定，则系统为每一种类型指定默认的宽度值。</p>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061248262970.png" alt="img"></p>
<h4 id="UNSIGNED"><a href="#UNSIGNED" class="headerlink" title="UNSIGNED"></a><strong>UNSIGNED</strong></h4><p>​    UNSIGNED : 无符号类型（非负），所有的整数类型都有一个可选的属性 UNSIGNE （无符号属性），无符号整数类型的最小取值为0 。所以，如果需要在 MySQL 数据库中保存非负整数值时，可以将整数类型设置为无符号类型。</p>
<p>​    int类型默认显示宽度为 int(11) ，无符号 int 类型默认显示宽度为 int(10) 。</p>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061248262980.png" alt="img"></p>
<h4 id="ZEROFILL"><a href="#ZEROFILL" class="headerlink" title="ZEROFILL"></a><strong>ZEROFILL</strong></h4><p>​    ZEROFILL : 0 填充 , （如果某列是 ZEROFILL ，那么 MySQL 会自动为当前列添加 UNSIGNED 属性），如果指定了ZEROFILL 只是表示不够 M 位时，用 0 在左边填充，如果超过 M 位，只要不超过数据存储范围即可。</p>
<p>​    原来，在 int(M) 中， M 的值跟 int(M) 所占多少存储空间并无任何关系。 int(3) 、 int(4) 、 int(8) 在磁盘上都是占用 4 bytes 的存储空间。也就是说， <strong>int(M)</strong> <strong>，必须和</strong> <strong>UNSIGNED ZEROFILL</strong> <strong>一起使用才有意义。</strong> 如果整数值超过M 位，就按照实际位数存储。只是无须再用字符 0 进行填充</p>
<h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a><strong>适用场景</strong></h3><p>​    <strong>TINYINT</strong> ：一般用于枚举数据，比如系统设定取值范围很小且固定的场景。</p>
<p>​    <strong>SMALLINT</strong> ：可以用于较小范围的统计数据，比如统计工厂的固定资产库存数量等。</p>
<p>​    <strong>MEDIUMINT</strong> ：用于较大整数的计算，比如车站每日的客流量等。</p>
<p>​    <strong>INT</strong>、 <em><strong>*INTEGER*</strong></em> ：取值范围足够大，一般情况下不用考虑超限问题，用得最多。比如商品编号。</p>
<p>​    <strong>BIGINT</strong> ：只有当你处理特别巨大的整数时才会用到。比如双十一的交易量、大型门户网站点击量、证券公司衍生产品持仓等。</p>
<h3 id="如何选择？"><a href="#如何选择？" class="headerlink" title="如何选择？"></a><strong>如何选择？</strong></h3><p>​    在评估用哪种整数类型的时候，你需要考虑 存储空间 和 可靠性 的平衡问题：一方 面，用占用字节数少的整数类型可以节省存储空间；另一方面，要是为了节省存储空间， 使用的整数类型取值范围太小，一旦遇到超出取值范围的情况，就可能引起 系统错误 ，影响可靠性。</p>
<p>​    举个例子，商品编号采用的数据类型是 INT 。原因就在于，客户门店中流通的商品种类较多，而且，每天都有旧商品下架，新商品上架，这样不断迭代，日积月累。</p>
<p>如果使用 SMALLINT 类型，虽然占用字节数比 INT 类型的整数少，但是却不能保证数据不会超出范围65535。相反，使用 INT ，就能确保有足够大的取值范围，不用担心数据超出范围影响可靠性的问题。</p>
<p>​    你要注意的是，在实际工作中， <strong>系统故障产生的成本远远超过增加几个字段存储空间所产生的成本</strong> 。因此，我建议你首先确保数据不会超过取值范围，在这个前提之下，再去考虑如何节省存储空间。</p>
<h2 id="浮点类型"><a href="#浮点类型" class="headerlink" title="浮点类型"></a><strong>浮点类型</strong></h2><h3 id="类型介绍-1"><a href="#类型介绍-1" class="headerlink" title="类型介绍"></a><strong>类型介绍</strong></h3><p>​    浮点数和定点数类型的特点是可以 处理小数 ，你可以把整数看成小数的一个特例。因此，浮点数和定点数的使用场景，比整数大多了。 MySQL 支持的浮点数类型，分别是 <strong>FLOAT、DOUBLE、REAL。</strong></p>
<p>​    FLOAT 表示单精度浮点数；</p>
<p>​    DOUBLE 表示双精度浮点数；</p>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061248263024.png" alt="img"></p>
<p>​    REAL默认就是 DOUBLE 。如果你把 SQL 模式设定为启用 “ REAL_AS_FLOAT ” ，那 么， MySQL 就认为 REAL 是 FLOAT 。如果要启用 “REAL_AS_FLOAT” ，可以通过以下 SQL <strong>语句实现：SET sql_mode &#x3D; “REAL_AS_FLOAT”;</strong></p>
<p><strong>问题</strong> <strong>1</strong> <strong>：</strong> FLOAT 和 DOUBLE 这两种数据类型的区别是啥呢？</p>
<p>​    SET sql_mode &#x3D; “REAL_AS_FLOAT”; FLOAT 占用字节数少，取值范围小； DOUBLE 占用字节数多，取值范围也大。</p>
<p><strong>问题</strong> <strong>2</strong> <strong>：</strong> 为什么浮点数类型的无符号数取值范围，只相当于有符号数取值范围的一半，也就是只相当于有符号数取值范围大于等于零的部分呢？</p>
<p>​    MySQL 存储浮点数的格式为： 符号 (S) 、 尾数 (M) 和 阶码 (E) 。因此，无论有没有符号， MySQL 的浮点数都会存储表示符号的部分。因此， 所谓的无符号数取值范围，其实就是有符号数取值范围大于等于零的部分</p>
<p><strong>3.2</strong> <strong>数据精度说明</strong></p>
<p>​    对于浮点类型，在MySQL 中单精度值使用 4 个字节，双精度值使用 8 个字节。</p>
<p>​    MySQL允许使用 非标准语法 （其他数据库未必支持，因此如果涉及到数据迁移，则最好不要这么用）： FLOAT(M,D) 或 DOUBLE(M,D) 。这里， M 称为 精度 ， D 称为 标度 。 <strong>(M,D)中 M&#x3D;整数位+小数位，D&#x3D;小数位。 D&lt;&#x3D;M&lt;&#x3D;255，0&lt;&#x3D;D&lt;&#x3D;30。</strong></p>
<p>​    例如，定义为FLOAT(5,2) 的一个列可以显示为 -999.99-999.99 。如果超过这个范围会报错。</p>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061248273050.png" alt="img"></p>
<p>​    FLOAT和 DOUBLE 类型在不指定 (M,D) 时，默认会按照实际的精度（由实际的硬件和操作系统决定）来显示。</p>
<p>​    <strong>说明：浮点类型，也可以加</strong> <em>*<em>*UNSIGNED*</em> *<em>，但是不会改变数据范围，例如：*</em>*<em>FLOAT(3,2) UNSIGNED*</em>*<em>仍然只能表示0-9.99*</em>*<em>的范围。*</em>*</em></p>
<p>​    不管是否显式设置了精度(M,D) ，这里 MySQL 的处理方案如下：</p>
<p>​        <strong>如果存储时，整数部分超出了范围，MySQL就会报错，不允许存这样的值</strong></p>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061248273060.png" alt="img"></p>
<p>​        </p>
<p>​        <em><strong>*如果存储时，小数点部分若超出范围，就分以下情况：*</strong></em></p>
<p>​            <em>*<em>*若四舍五入后，整数部分没有超出范围，则只警告，但能成功操作并四舍五入删除多余的小数位后保存。例如在FLOAT(5,2)*</em>*<em>列内插入*</em>*<em>999.009*</em>*<em>，近似结果是*</em>*<em>999.01*</em>*<em>。*</em>*</em></p>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061248273070.png" alt="img"></p>
<p>​            <em>*<em>*若四舍五入后，整数部分超出范围，则MySQL报错，并拒绝处理。如FLOAT(5,2)*</em>*<em>列内插入999.995和*</em>**-999.995*</em>*<em>都会报错。*</em>**</p>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061248283076.png" alt="img"></p>
<p>​    <strong>从MySQL 8.0.17</strong> <strong>开始，</strong> <strong>FLOAT(M,D)</strong> <strong>和</strong> <strong>DOUBLE(M,D)</strong> <strong>用法在官方文档中已经明确不推荐使用</strong> ，将来可能被移除。另外，关于浮点型FLOAT 和 DOUBLE 的 <em><strong>*UNSIGNED*</strong></em> 也不推荐使用了，将来也可能被移除。</p>
<h3 id="精度误差说明"><a href="#精度误差说明" class="headerlink" title="精度误差说明"></a><strong>精度误差说明</strong></h3><p>​    浮点数类型有个缺陷，就是不精准。下面我来重点解释一下为什么 MySQL 的浮点数不够精准。比如，我们设计一个表，有f1 这个字段，插入值分别为 0.47,0.44,0.19 ，我们期待的运行结果是： 0.47 + 0.44 + 0.19 &#x3D;1.1。</p>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061248283086.png" alt="img"></p>
<p>而使用 sum之后查询， 查询结果 1.0999999999999999 。虽然误差很小，但确实有误差。 你也可以尝试把数据类型 改成 FLOAT ，然后运行求和查询，得到的是， 1.0999999940395355 。显然，误差更大了。</p>
<p><em><strong>*那么，为什么会存在这样的误差呢？问题还是出在 MySQL** **对浮点类型数据的存储方式上。*</strong></em></p>
<p>​    MySQL 用 4 个字节存储 FLOAT 类型数据，用 8 个字节来存储 DOUBLE 类型数据。无论哪个，都是采用二 进制的方式来进行存储的。比如 9.625 ，用二进制来表达，就是 1001.101 ，或者表达成 1.001101×2^3 。如果尾数不是 0 或 5 （比如 9.624 ），你就无法用一个二进制数来精确表达。进而，就只好在取值允许的范围内进行四舍五入。</p>
<p>​    在编程中，如果用到浮点数，要特别注意误差问题， <strong>因为浮点数是不准确的，所以我们要避免使用“&#x3D;”来判断两个数是否相等。</strong> 同时，在一些对精确度要求较高的项目中，千万不要使用浮点数，不然会导致结 果错误，甚至是造成不可挽回的损失。</p>
<p><em><strong>*那么，MySQL*</strong></em> <strong>有没有精准的数据类型呢？</strong></p>
<p>​    当然有，这就是定点数类型： DECIMAL 。</p>
<h2 id="定点数类型"><a href="#定点数类型" class="headerlink" title="定点数类型"></a><strong>定点数类型</strong></h2><h3 id="类型介绍-2"><a href="#类型介绍-2" class="headerlink" title="类型介绍"></a><strong>类型介绍</strong></h3><p>​    MySQL中的定点数类型只有 DECIMAL 一种类型。</p>
<table>
<thead>
<tr>
<th><em>*<em>*</em>*数据类型****</em>*</th>
<th><em>*<em>*</em>*字节数****</em>*</th>
<th><em>*<em>*</em>*含义****</em>*</th>
</tr>
</thead>
<tbody><tr>
<td><strong>DECIMAL(M,D)</strong>,DEC,NUMERIC</td>
<td>M+2字节</td>
<td>有效范围由M和D决定</td>
</tr>
</tbody></table>
<p>​    <strong>使用 DECIMAL(M,D)</strong> <em>*<em>*的方式表示高精度小数。其中，*</em>*<em>M*</em>*<em>被称为精度，*</em>*<em>D*</em>*<em>被称为标度。*</em>*<em>0&lt;&#x3D;M&lt;&#x3D;65*</em>*<em>， 0&lt;&#x3D;D&lt;&#x3D;30，*</em>*<em>D&lt;M*</em>*<em>。*</em>*</em></p>
<p>​    例如，定义DECIMAL （5,2）的类型，表示该列取值范围是 -999.99~999.99 。</p>
<p>​    <strong>DECIMAL(M,D)的最大取值范围与</strong> <strong>DOUBLE</strong> <strong>类型一样</strong> ，但是有效的数据范围是由 M 和 D 决定的。</p>
<p>​    DECIMAL 的存储空间并不是固定的，由精度值 M 决定，总共占用的存储空间为 M+2 个字节。也就是说，在一些对精度要求不高的场景下，比起占用同样字节长度的定点数，浮点数表达的数值范围可以更大一些。</p>
<p>​    定点数在MySQL 内部是以 字符串 的形式进行存储，这就决定了它一定是精准的。</p>
<h4 id="当DECIMAL类型不指定精度和标度时，其默认为DECIMAL-10-0-。"><a href="#当DECIMAL类型不指定精度和标度时，其默认为DECIMAL-10-0-。" class="headerlink" title="当DECIMAL类型不指定精度和标度时，其默认为DECIMAL(10,0)。"></a><strong>当DECIMAL类型不指定精度和标度时，其默认为DECIMAL(10,0)。</strong></h4><p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061248283122.png" alt="img"></p>
<p>​    </p>
<h4 id="当数据的精度超出了定点数类型的精度范围时，则MySQL同样会进行四舍五入处理。"><a href="#当数据的精度超出了定点数类型的精度范围时，则MySQL同样会进行四舍五入处理。" class="headerlink" title="当数据的精度超出了定点数类型的精度范围时，则MySQL同样会进行四舍五入处理。"></a><strong>当数据的精度超出了定点数类型的精度范围时，则MySQL同样会进行四舍五入处理。</strong></h4><p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061248293128.png" alt="img"></p>
<p>​     </p>
<h4 id="当整数部分超出范围时，同样会报错。"><a href="#当整数部分超出范围时，同样会报错。" class="headerlink" title="*当整数部分超出范围时，同样会报错。*"></a><em><strong>*当整数部分超出范围时，同样会报错。*</strong></em></h4><p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061248293134.png" alt="img"></p>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061248293136.png" alt="img"></p>
<h3 id="浮点数-vs-定点数"><a href="#浮点数-vs-定点数" class="headerlink" title="浮点数 vs 定点数"></a><strong>浮点数 vs 定点数</strong></h3><p>​    浮点数相对于定点数的优点是在长度一定的情况下，浮点类型取值范围大，但是不精准，适用于需要取值范围大，又可以容忍微小误差的科学计算场景（比如计算化学、分子建模、流体动力学等）</p>
<p>​    定点数类型取值范围相对小，但是精准，没有误差，适合于对精度要求极高的场景 （比如涉及金额计算的场景）</p>
<p>​     <strong>（ 由于 DECIMAL 数据类型的精准性，在项目中，除了极少数（比如商品编号）用到整数类型外，其他的数值都用的是 DECIMAL，原因就是这个项目所处的零售行业，要求精准，一分钱也不能差。）</strong></p>
<h2 id="位类型：BIT"><a href="#位类型：BIT" class="headerlink" title="位类型：BIT"></a>位类型：BIT</h2><p>​    <em>*<em>*BIT类型中存储的是二进制值，类似*</em>*<em>010110*</em>*<em>。*</em>*</em></p>
<table>
<thead>
<tr>
<th><em><strong>*二进制字符串类型*</strong></em></th>
<th><em><strong>*长度*</strong></em></th>
<th><em><strong>*长度范围*</strong></em></th>
<th><em><strong>*占用空间*</strong></em></th>
</tr>
</thead>
<tbody><tr>
<td><em><strong>*BIT(M)*</strong></em></td>
<td><em><strong>*M*</strong></em></td>
<td><em><strong>*1 &lt;&#x3D; M &lt;&#x3D; 64*</strong></em></td>
<td><em>*<em>*约为*</em>**(M + 7)&#x2F;8*</em>*<em>个字节*</em>**</td>
</tr>
</tbody></table>
<p>​    <strong>BIT类型，如果没有指定</strong> <em>*<em>*(M)*</em>*<em>，默认是*</em>*<em>1*</em>*<em>位。这个*</em>*<em>1*</em>*<em>位，表示只能存*</em>*<em>1*</em>*<em>位的二进制值。这里*</em>**(M)*</em>*<em>是表示二进制的位数，位数最小值为1*</em>*<em>，最大值为*</em>*<em>64*</em>*<em>。*</em>**</p>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061248293158.png" alt="img"></p>
<p> <img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061248293160.png" alt="img"></p>
<p>​     </p>
<p>​    <em><strong>*注意：在向BIT类型的字段中插入数据时，一定要确保插入的数据在BIT类型支持的范围内。*</strong></em></p>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061248303166.png" alt="img"></p>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061248303168.png" alt="img"></p>
<p>​    <strong>使用SELECT</strong><em>*<em>*命令查询位字段时，可以用*</em> *<em>BIN() 、OCT()*</em>*<em>或*</em> *<em>HEX()*</em> *<em>函数进行读取；也可以+0读取十进制的数据*</em>*</em></p>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061248303174.png" alt="img"></p>
<h2 id="日期与时间类型"><a href="#日期与时间类型" class="headerlink" title="日期与时间类型"></a><strong>日期与时间类型</strong></h2><p>​    日期与时间是重要的信息，在我们的系统中，几乎所有的数据表都用得到。原因是客户需要知道数据的时间标签，从而进行数据查询、统计和处理。</p>
<p>​    MySQL有多种表示日期和时间的数据类型，不同的版本可能有所差异， MySQL8.0 版本支持的日期和时间类型主要有：<strong>YEAR</strong> <em>*<em>*类型、*</em>*<em>TIME*</em>*<em>类型、*</em>*<em>DATE*</em>*<em>类型、*</em>*<em>DATETIME*</em>*<em>类型和*</em>*<em>TIMESTAMP*</em>*<em>类型。*</em>*</em></p>
<p>​    <strong>YEAR</strong> <em><strong>*类型通常用来表示** **年*</strong></em></p>
<p>​    <em><strong>*DATE** *<em>类型通常用来表示*</em> **年、月、日*</strong></em></p>
<p>​    <em><strong>*TIME** *<em>类型通常用来表示*</em> **时、分、秒*</strong></em></p>
<p>​    <em><strong>*DATETIME** *<em>类型通常用来表示*</em> **年、月、日、时、分、秒*</strong></em></p>
<p>​    <em>*<em>*TIMESTAMP*</em> *<em>类型通常用来表示带*</em>*<em>时区*</em>*<em>的*</em> *<em>年、月、日、时、分、秒*</em>*</em></p>
<p><strong>建议写日期时间类型的数据时都加上当引号。</strong></p>
<table>
<thead>
<tr>
<th><em><strong>*类型*</strong></em></th>
<th><em><strong>*名称*</strong></em></th>
<th><em><strong>*字节*</strong></em></th>
<th><em><strong>*日期格式*</strong></em></th>
<th><em><strong>*最小值*</strong></em></th>
<th><em><strong>*最大值*</strong></em></th>
</tr>
</thead>
<tbody><tr>
<td><em><strong>*YEAR*</strong></em></td>
<td><em><strong>*年*</strong></em></td>
<td><em><strong>*1*</strong></em></td>
<td><em>*<em>*YYYY*</em>*<em>或*</em>*<em>YY*</em>*</em></td>
<td><em><strong>*1901*</strong></em></td>
<td><em><strong>*2155*</strong></em></td>
</tr>
<tr>
<td><em><strong>*TIME*</strong></em></td>
<td><em><strong>*时间*</strong></em></td>
<td><em><strong>*3*</strong></em></td>
<td><em><strong>*HH:MM:SS*</strong></em></td>
<td><em><strong>*-838:59:59*</strong></em></td>
<td><em><strong>*838:59:59*</strong></em></td>
</tr>
<tr>
<td><em><strong>*DATE*</strong></em></td>
<td><em><strong>*日期*</strong></em></td>
<td><em><strong>*3*</strong></em></td>
<td><em><strong>*YYYY-MM-DD*</strong></em></td>
<td><em><strong>*1000-01-01*</strong></em></td>
<td><em><strong>*9999-12-03*</strong></em></td>
</tr>
<tr>
<td><em><strong>*DATETIME*</strong></em></td>
<td><em><strong>*日期 时间*</strong></em></td>
<td><em><strong>*8*</strong></em></td>
<td><em><strong>*YYYY-MM-DD HH:MM:SS*</strong></em></td>
<td><em><strong>*1000-01-01 00:00:00*</strong></em></td>
<td><em><strong>*9999-12-31 23:59:59*</strong></em></td>
</tr>
<tr>
<td><em><strong>*TIMESTAMP*</strong></em></td>
<td><em><strong>*日期 时间*</strong></em></td>
<td><em><strong>*4*</strong></em></td>
<td><em><strong>*YYYY-MM-DD*</strong></em><em><strong>*HH:MM:SS*</strong></em></td>
<td><em><strong>*1970-01-01*</strong></em><em><strong>*00:00:00 UTC*</strong></em></td>
<td><em><strong>*2038-01-19*</strong></em><em><strong>*03:14:07UTC*</strong></em></td>
</tr>
</tbody></table>
<p>​    可以看到，不同数据类型表示的时间内容不同、取值范围不同，而且占用的字节数也不一样，你要根据实际需要灵活选取。</p>
<p>​    为什么时间类型 TIME 的取值范围不是 -23:59:59 ～ 23:59:59 呢？原因是 MySQL 设计的 TIME 类型，不光表示一天之内的时间，而且可以用来表示一个时间间隔，这个时间间隔可以超过 24 小时。</p>
<h3 id="YEAR类型"><a href="#YEAR类型" class="headerlink" title="YEAR类型"></a><strong>YEAR类型</strong></h3><p>​    YEAR类型用来表示年份，在所有的日期时间类型中所占用的存储空间最小，只需要 1 个字节 的存储空间。<strong>YEAR</strong> <em>*<em>*默认格式就是*</em>*<em>“YYYY”*</em>*<em>，没必要写成*</em>*<em>YEAR(4).*</em>*</em></p>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061248303212.png" alt="img"></p>
<p><em>*<em>*在MySQL*</em>*<em>中，*</em>*<em>YEAR*</em>*<em>有以下几种存储格式：*</em>*</em></p>
<p>​    <em>*<em>*1.以4*</em>*<em>位*</em>*<em>字符串或数字格式*</em>*<em>表示*</em>*<em>YEAR*</em>*<em>类型，其格式为*</em>*<em>YYYY*</em>*<em>，最小值为*</em>*<em>1901*</em>*<em>，最大值为*</em>*<em>2155*</em>*<em>。*</em>*</em></p>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061248313218.png" alt="img"></p>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061248313220.png" alt="img"></p>
<p>​    </p>
<p>​    <em>*<em>*2.以2位*</em>*<em>字符串格式*</em>*<em>表示*</em>*<em>YEAR*</em>*<em>类型，最小值为*</em>*<em>00*</em>*<em>，最大值为*</em>*<em>99*</em>*<em>。*</em>*</em></p>
<p>​        当取值为01到69时，表示 2001 到 2069；</p>
<p>​        当取值为70到99 时，表示 1970 到 1999；</p>
<p>​        当取值 整数 的0或00 添加的话，那么是 0000年；</p>
<p>​        当取值是日期&#x2F;字符串的’0’ 添加的话，是 2000年。</p>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061248313234.png" alt="img"></p>
<p>​    <strong>从MySQL5.5.27</strong> <strong>开始，</strong> <strong>2</strong> <strong>位格式的</strong> <strong>YEAR</strong> <strong>已经不推荐使用</strong> 。</p>
<p>​    从MySQL 8.0.19 开始，不推荐使用指定显示宽度的 YEAR(4) 数据类型。</p>
<h3 id="DATE类型"><a href="#DATE类型" class="headerlink" title="DATE类型"></a><strong>DATE类型</strong></h3><p>​    DATE类型表示日期，没有时间部分，格式为 YYYY - MM - DD ，其中， <em>*<em>*YYYY*</em>*<em>表示年份，*</em>*<em>MM*</em>*<em>表示月份，*</em>*<em>DD*</em>*</em> <strong>表示日期。</strong>需要 3 个字节 的存储空间。在向 DATE 类型的字段插入数据时，同样需要满足一定的格式条件。</p>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061248323246.png" alt="img"></p>
<p>​    1.以 YYYY - MM - DD 格式或者 YYYYMMDD 格式表示的字符串日期，其最小取值为 1000-01-01 ，最大取值为 9999-12-03。 <em>*<em>*YYYYMMDD*</em>*<em>格式会被转化为*</em>*<em>YYYY-MM-DD*</em>*<em>格式。*</em>*</em></p>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061248323252.png" alt="img"></p>
<p>​    2.以 YY - MM - DD 格式或者 YYMMDD 格式表示的字符串日期，此格式中，年份为两位数值或字符串满足YEAR类型的格式条件为：当年份取值为 00 到 69 时，会被转化为 2000 到 2069 ；当年份取值为 70 到 99时，会被转化为1970 到 1999 。(不建议使用)</p>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061248323258.png" alt="img"></p>
<p>​    <strong>3.使用</strong> <em><strong>*CURRENT_DATE()** *<em>或者*</em> *<em>NOW()*</em> **函数，会插入当前系统的日期。*</strong></em></p>
<p> <img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061248323266.png" alt="img"></p>
<h3 id="TIME类型"><a href="#TIME类型" class="headerlink" title="TIME类型"></a><strong>TIME类型</strong></h3><p>​    TIME类型用来表示时间，不包含日期部分。在 MySQL 中，需要 3 个字节 的存储空间来存储 TIME 类型的数据，可以使用“HH:MM:SS” 格式来表示 TIME 类型，其中， <em>*<em>*HH*</em>*<em>表示小时，*</em>*<em>MM*</em>*<em>表示分钟，*</em>*<em>SS*</em>*<em>表示秒。*</em>*</em></p>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061248333274.png" alt="img"></p>
<p>​    在MySQL 中，向 TIME 类型的字段插入数据时，也可以使用几种不同的格式。</p>
<p>​    <strong>1.可以使用带有冒号的字符串</strong>，比如’ D HH:MM:SS’ ‘(推荐)、’ HH:MM:SS ‘(推荐) 、 ‘ HH:MM ‘ 、 ‘ D HH:MM ‘ 、 ‘ D HH ‘ 或 ‘ SS ‘ 格式，都能被正 确地插入TIME 类型的字段中。<strong>其中</strong> <em>*<em>*D*</em>*<em>表示天，其最小值为*</em>*<em>0*</em>*<em>，最大值为*</em>*<em>34*</em>*</em> <strong>。</strong>如果使用带有 D 格式的字符串 插入TIME 类型的字段时<strong>，</strong> <em>*<em>*D*</em>*<em>会被转化为小时，计算格式为*</em>*<em>D*24+HH*</em>*</em> <strong>。</strong>当使用带有冒号并且不带 D 的字符串表示时间时，表示当天的时间，比如12:10 表示 12:10:00 ，而不是 00:12:10 。</p>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061248333282.png" alt="img"></p>
<p>​    <strong>2.可以使用不带有冒号的字符串或者数字</strong>，格式为’ HHMMSS ‘ 或者 HHMMSS 。如果插入一个不合法的字符串或者数字， MySQL 在存储数据时，会将其自动转化为00:00:00 进行存储。比如 1210 ， MySQL 会将最右边的两位解析成秒，表示 00:12:10，而不是 12:10:00.</p>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061248333288.png" alt="img"></p>
<p>​    <strong>3.使用</strong> <em><strong>*CURRENT_TIME()** *<em>或者*</em> *<em>NOW()*</em> **，会插入当前系统的时间。*</strong></em></p>
<p> <img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061248333294.png" alt="img"></p>
<h3 id="DATETIME类型"><a href="#DATETIME类型" class="headerlink" title="DATETIME类型"></a><strong>DATETIME类型</strong></h3><p>​    DATETIME类型在所有的日期时间类型中占用的存储空间最大，总共需要 8 个字节的存储空间。在格式上为DATE 类型和 TIME 类型的组合，可以表示为 YYYY - MM - DD HH:MM:SS ，其中 YYYY 表示年份， MM 表示月份，DD 表示日期， HH 表示小时， MM 表示分钟， SS 表示秒。</p>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061248343302.png" alt="img"></p>
<p>在向 DATETIME 类型的字段插入数据时，同样需要满足一定的格式条件。</p>
<p>​    </p>
<p>​    <strong>1.以</strong> <em>*<em>*YYYY*</em>**-*</em>*<em>MM*</em>*<em>-*</em>*<em>DD HH:MM:SS*</em> *<em>格式或者*</em> *<em>YYYYMMDDHHMMSS*</em> *<em>格式的字符串插入*</em>*<em>DATETIME*</em>** <strong>类型的字段</strong>时，最小值为1000-01-01 00:00:00 ，最大值为 9999-12-03 23:59:59 。</p>
<p>​    以YYYYMMDDHHMMSS 格式的数字插入 DATETIME 类型的字段时，会被转化为 YYYY-MM-DD HH:MM:SS格式。</p>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061248343314.png" alt="img"></p>
<p>​    <strong>2.以</strong> <em>*<em>*YY*</em>**-*</em>*<em>MM*</em>*<em>-*</em>*<em>DD HH:MM:SS*</em> *<em>格式或者*</em> *<em>YYMMDDHHMMSS*</em> *<em>格式的字符串插入*</em>*<em>DATETIME*</em>** <strong>类型的字段</strong>时，两位 数的年份规则符合YEAR 类型的规则， 00 到 69 表示 2000 到 2069 ； 70 到 99 表示 1970 到 1999 。</p>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061248343320.png" alt="img"></p>
<p>​    <strong>3.使用函数</strong> <em>*<em>*CURRENT_TIMESTAMP()*</em> *<em>和*</em> *<em>NOW()*</em> *<em>，可以向*</em>*<em>DATETIME*</em>*<em>类型的字段插入系统的当前日期和时间。*</em>*</em></p>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061248353326.png" alt="img"></p>
<h3 id="TIMESTAMP类型"><a href="#TIMESTAMP类型" class="headerlink" title="TIMESTAMP类型"></a><strong>TIMESTAMP类型</strong></h3><p>​    TIMESTAMP类型也可以表示日期时间，其显示格式与 DATETIME 类型相同，都是 YYYY - MM - DD HH:MM:SS ，需要 4 个字节的存储空间。但是 TIMESTAMP 存储的时间范围比 DATETIME 要小很多，只能存储 “1970-01-01 00:00:01 UTC”到 “2038-01-19 03:14:07 UTC” 之间的时间。其中， UTC 表示世界统一时间，也叫作世界标准时间。</p>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061248353334.png" alt="img"> </p>
<p>​    </p>
<p>​     <em><strong>*存储数据的时候需要对当前时间所在的时区进行转换，查询数据的时候再将时间转换回当前的时区。因此，使用TIMESTAMP存储的同一个时间值，在不同的时区查询时会显示不同的时间。*</strong></em></p>
<p><em>*<em>*向TIMESTAMP*</em>*<em>类型的字段插入数据时，有不同的插入方式：*</em>*</em></p>
<p>​    1.插入的数据格式满足 <strong>YYYY（YY）-MM-DD HH:MM:SS</strong> <em><strong>*和*</strong></em></p>
<p><strong>YYYY（YY）MMDDHHMMSS</strong> ，当两位数值的年份同样符合YEAR类型的规则条件，只不过表示的时间范围要小很多。</p>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061248363346.png" alt="img"></p>
<p>​    \2. 插入的数据格式也可以满足<strong>YYYY（YY）@MM@DD@HH@MM@SS,也具有一定的可读性。</strong></p>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061248363352.png" alt="img"></p>
<p>​    <strong>3.使用函数</strong> <em>*<em>*CURRENT_TIMESTAMP()*</em> *<em>和*</em> *<em>NOW()*</em> *<em>，可以向TIMESTAMP*</em>*<em>类型的字段插入系统的当前日期和时间。*</em>*</em></p>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061248363358.png" alt="img"></p>
<p>​     <strong>如果向TIMESTAMP类型的字段插入的时间超出了TIMESTAMP类型的范围，则MySQL会抛出错误信息。</strong></p>
<h3 id="TIMESTAMP和DATETIME的区别"><a href="#TIMESTAMP和DATETIME的区别" class="headerlink" title="TIMESTAMP和DATETIME的区别"></a><strong>TIMESTAMP和DATETIME的区别</strong></h3><p>​    <strong>1.TIMESTAMP存储空间比较小，表示的日期时间范围也比较小底层存储方式不同，TIMESTAMP</strong> <em>*<em>*底层存储的是毫秒值，距离*</em>*<em>1970-1-1 0:0:0 0*</em>*<em>毫秒的毫秒值。*</em>*</em></p>
<p>​    <strong>2.两个日期比较大小或日期计算时，TIMESTAMP</strong> <em><strong>*更方便、更快。*</strong></em></p>
<p>​    </p>
<p>​    <em>*<em>*3.TIMESTAMP和时区有关。TIMESTAMP*</em>*<em>会根据用户的时区不同，显示不同的结果。而*</em>*<em>DATETIME*</em>*<em>则只能反映出插入时当地的时区，其他时区的人查看数据必然会有误差的。*</em>*</em></p>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061248373374.png" alt="img"></p>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061248373376.png" alt="img"></p>
<h3 id="开发中经验"><a href="#开发中经验" class="headerlink" title="开发中经验"></a><strong>开发中经验</strong></h3><p>​    用得最多的日期时间类型，就是 DATETIME 。虽然 MySQL 也支持 YEAR （年）、 TIME （时间）、 DATE（日期），以及 TIMESTAMP 类型，但是在实际项目中，尽量用 DATETIME 类型。因为这个数据类型 包括了完整的日期和时间信息，取值范围也最大，使用起来比较方便。毕竟，如果日期时间信息分散在 好几个字段，很不容易记，而且查询的时候，SQL 语句也会更加复杂。</p>
<p>​    此外，一般存注册时间、商品发布时间等，不建议使用DATETIME 存储，而是使用 时间戳 ，因为DATETIME虽然直观，但不便于计算。</p>
<p>​    获取时间戳的函数： <em><strong>*UNIX_TIMESTAMP()*</strong></em></p>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061248373388.png" alt="img"></p>
<h2 id="文本字符串类型"><a href="#文本字符串类型" class="headerlink" title="文本字符串类型"></a><strong>文本字符串类型</strong></h2><p>​    在实际的项目中，我们还经常遇到一种数据，就是字符串数据。</p>
<p>​    MySQL中，文本字符串总体上分为 CHAR 、 VARCHAR 、 TINYTEXT 、 TEXT 、 MEDIUMTEXT 、 LONGTEXT 、 ENUM(枚举类型) 、 SET（集合类型） 等类型。</p>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061248383398.png" alt="img"></p>
<h3 id="CHAR与VARCHAR类型"><a href="#CHAR与VARCHAR类型" class="headerlink" title="CHAR与VARCHAR类型"></a><strong>CHAR与VARCHAR类型</strong></h3><p>​    <strong>CHAR和</strong> <em>*<em>*VARCHAR*</em>*<em>类型都可以存储比较短的字符串。*</em>*</em></p>
<table>
<thead>
<tr>
<th><em><strong>*字符串*</strong></em><em><strong>*(*</strong></em><em><strong>*文本*</strong></em><em><strong>*)*</strong></em><em><strong>*类型*</strong></em></th>
<th><em><strong>*特点*</strong></em></th>
<th><em><strong>*长度*</strong></em></th>
<th><em><strong>*长度范围*</strong></em></th>
<th><em><strong>*占用的存储空间*</strong></em></th>
</tr>
</thead>
<tbody><tr>
<td><em><strong>*CHAR(M)*</strong></em></td>
<td><em><strong>*固定长度*</strong></em></td>
<td><em><strong>*M*</strong></em></td>
<td><em><strong>*0&lt;&#x3D;M&lt;&#x3D;255*</strong></em></td>
<td><em>*<em>*M*</em>*<em>个字节*</em>*</em></td>
</tr>
<tr>
<td><em><strong>*VARCHAR(M)*</strong></em></td>
<td><em><strong>*可变长度*</strong></em></td>
<td><em><strong>*M*</strong></em></td>
<td><em><strong>*0&lt;&#x3D;M&lt;&#x3D;65535*</strong></em></td>
<td><em>*<em>*(*</em>*<em>实际长度*</em>**+1)*</em>*<em>个字节*</em>**</td>
</tr>
</tbody></table>
<h4 id="CHAR类型"><a href="#CHAR类型" class="headerlink" title="CHAR类型"></a><strong>CHAR类型</strong></h4><p>​    定义CHAR类型字段时，声明的字段长度即为CHAR类型字段所占的存储空间的字节数。</p>
<p>​    <strong>CHAR(M) 类型一般需要预先定义字符串长度。如果不指定</strong> <em>*<em>*(M)*</em>*<em>，则表示长度默认是*</em>*<em>1*</em>*<em>个字符。*</em>*</em></p>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061248383415.png" alt="img"></p>
<p>​    <strong>插入字符串时，数据的时间长度不能大于CHAR声明的长度。</strong></p>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061248383419.png" alt="img"></p>
<p>​    <strong>如果保存时，数据的实际长度比CHAR</strong> <em>*<em>*类型声明的长度小，则会在*</em> *<em>右侧填充*</em> *<em>空格以达到指定的长度。当MySQL*</em>*<em>检索*</em>*<em>CHAR*</em>*<em>类型的数据时，*</em>*<em>CHAR*</em>*<em>类型的字段会去除尾部的空格。*</em>*</em></p>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061248393423.png" alt="img"></p>
<h4 id="VARCHAR类型："><a href="#VARCHAR类型：" class="headerlink" title="VARCHAR类型："></a><strong>VARCHAR类型：</strong></h4><p>​     MySQL4.0版本以下，varchar(20)：指的是20字节，如果存放UTF8汉字时，只能存6个（每个汉字3字 节） ；MySQL5.0版本以上，varchar(20)：指的是20字符。</p>
<p>​    <strong>VARCHAR类型的字段所占用的存储空间为字符串实际长度加1个字节。</strong></p>
<p>​    </p>
<p>​    VARCHAR(M) 定义时， 必须指定 长度 M ，否则报错。</p>
<p>​     <img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061248393435.png" alt="img"></p>
<p>​    检索VARCHAR 类型的字段数据时，会保留数据尾部的空格。</p>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061248403439.png" alt="img"></p>
<h4 id="哪些情况使用-CHAR-或-VARCHAR-更好"><a href="#哪些情况使用-CHAR-或-VARCHAR-更好" class="headerlink" title="哪些情况使用 CHAR 或 VARCHAR 更好"></a><strong>哪些情况使用 CHAR 或 VARCHAR 更好</strong></h4><table>
<thead>
<tr>
<th><em><strong>*类型*</strong></em></th>
<th><em><strong>*特点*</strong></em></th>
<th><em><strong>*空间上*</strong></em></th>
<th><em><strong>*时间上*</strong></em></th>
<th><em><strong>*适用场景*</strong></em></th>
</tr>
</thead>
<tbody><tr>
<td><em><strong>*CHAR(M)*</strong></em></td>
<td><em><strong>*固定长度*</strong></em></td>
<td><em><strong>*浪费存储空间*</strong></em></td>
<td><em><strong>*效率高*</strong></em></td>
<td><em><strong>*存储不大，速度要求高*</strong></em></td>
</tr>
<tr>
<td><em><strong>*VARCHAR(M)*</strong></em></td>
<td><em><strong>*可变长度*</strong></em></td>
<td><em><strong>*节省存储空间*</strong></em></td>
<td><em><strong>*效率低*</strong></em></td>
<td><em>*<em>*非*</em>*<em>CHAR*</em>*<em>的情况*</em>*</em></td>
</tr>
</tbody></table>
<p><em>*<em>*情况*</em>*<em>1*</em>*</em> ：存储很短的信息。比如门牌号码 101 ， 201…… 这样很短的信息应该用 char ，因为 varchar 还要占个byte用于存储信息长度，本来打算节约存储的，结果得不偿失。</p>
<p><em>*<em>*情况*</em>*<em>2*</em>*</em> ：固定长度的。比如使用 uuid 作为主键，那用 char 应该更合适。因为他固定长度， varchar 动态根据长度的特性就消失了，而且还要占个长度信息。</p>
<p><em>*<em>*情况*</em>*<em>3*</em>*</em> ：十分频繁改变的 column 。因为 varchar 每次存储都要有额外的计算，得到长度等工作，如果一个非常频繁改变的，那就要有很多的精力用于计算，而这些对于char 来说是不需要的.</p>
<p><em>*<em>*情况*</em>*<em>4*</em>*</em> ：具体存储引擎中的情况：</p>
<p>​    MyISAM 数据存储引擎和数据列： MyISAM 数据表，最好使用固定长度 (CHAR) 的数据列代替可变长度(VARCHAR) 的数据列。这样使得整个表静态化，从而使 数据检索更快 ，用空间换时间。</p>
<p>​    MEMORY 存储引擎和数据列： MEMORY 数据表目前都使用固定长度的数据行存储，因此无论使用CHAR或 VARCHAR 列都没有关系，两者都是作为 CHAR 类型处理的。</p>
<p>​    InnoDB 存储引擎，建议使用 VARCHAR 类型。因为对于 InnoDB 数据表，内部的行存储格式并没有区 分固定长度和可变长度列（所有数据行都使用指向数据列值的头指针），而且 <strong>主要影响性能的因素</strong> <strong>是数据行使用的存储总量</strong> ，由于 char 平均占用的空间多于 varchar ，所以除了简短并且固定长度的,其他考虑varchar 。这样节省空间，对磁盘 I&#x2F;O 和数据存储总量比较好。</p>
<h3 id="TEXT类型"><a href="#TEXT类型" class="headerlink" title="TEXT类型"></a><strong>TEXT类型</strong></h3><p>​    在MySQL 中， TEXT 用来保存文本类型的字符串，总共包含 4 种类型，分别为  <em>*<em>*TINYTEXT*</em>*<em>、*</em>*<em>TEXT*</em>*<em>、 MEDIUMTEXT 和*</em> *<em>LONGTEXT*</em>*</em>  类型。</p>
<p>​    在向TEXT 类型的字段保存和查询数据时，系统自动按照实际长度存储，不需要预先定义长度。这一点和VARCHAR类型相同。</p>
<p>​    每种TEXT 类型保存的数据长度和所占用的存储空间不同，如下：</p>
<table>
<thead>
<tr>
<th><em><strong>*文本字符串类*</strong></em><em><strong>*型*</strong></em></th>
<th><em><strong>*特点*</strong></em></th>
<th><em><strong>*长度*</strong></em></th>
<th><em><strong>*长度范围*</strong></em></th>
<th><em><strong>*占用的存储空间*</strong></em></th>
</tr>
</thead>
<tbody><tr>
<td><em><strong>*TINYTEXT*</strong></em></td>
<td><em>*<em>*小文本*</em>*<em>、*</em>*<em>可变长*</em>*<em>度*</em>*</em></td>
<td><em><strong>*L*</strong></em></td>
<td><em><strong>*0&lt;&#x3D;L&lt;&#x3D;255*</strong></em></td>
<td><em>*<em>*L+2*</em>*<em>个字节*</em>*</em></td>
</tr>
<tr>
<td><em><strong>*TEXT*</strong></em></td>
<td><em><strong>*文本、可变长度*</strong></em></td>
<td><em><strong>*L*</strong></em></td>
<td><em><strong>*0&lt;&#x3D;L&lt;&#x3D;65535*</strong></em></td>
<td><em>*<em>*L+2*</em>*<em>个字节*</em>*</em></td>
</tr>
<tr>
<td><em><strong>*MEDIUMTEXT*</strong></em></td>
<td><em><strong>*中等文本、可变长度*</strong></em></td>
<td><em><strong>*L*</strong></em></td>
<td><em><strong>*0&lt;&#x3D;L&lt;&#x3D;16777215*</strong></em></td>
<td><em>*<em>*L+3*</em>*<em>个字节*</em>*</em></td>
</tr>
<tr>
<td><em><strong>*LONGTEXT*</strong></em></td>
<td><em><strong>*大文本、可变长度*</strong></em></td>
<td><em><strong>*L*</strong></em></td>
<td><em>*<em>*0&lt;&#x3D;L&lt;&#x3D;4294967295*</em>*<em>（相当于*</em>*<em>4GB*</em>*<em>）*</em>*</em></td>
<td><em>*<em>*L+4*</em>*<em>个字节*</em>*</em></td>
</tr>
</tbody></table>
<p>​    <strong>由于实际存储的长度不确定，MySQL</strong> <strong>不允许</strong> <strong>TEXT</strong> <strong>类型的字段做主键</strong> 。遇到这种情况，你只能采用CHAR(M)，或者 VARCHAR(M) 。</p>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061248403479.png" alt="img"></p>
<p> <em>*<em>*在保存和查询数据时，并没有删除*</em>*<em>TEXT*</em>*<em>类型的数据尾部的空格。*</em>*</em></p>
<h3 id="开发中经验-1"><a href="#开发中经验-1" class="headerlink" title="开发中经验"></a><strong>开发中经验</strong></h3><p>​    TEXT文本类型，可以存比较大的文本段，搜索速度稍慢，因此如果不是特别大的内容，建议使用 CHAR ， VARCHAR来代替。还有 <em><strong>*TEXT*</strong></em> <strong>类型不用加默认值</strong>，加了也没用。而且 text 和 blob 类型的数据删除后容易导致 “空洞”，使得文件碎片比较多，所以频繁使用的表不建议包含 TEXT 类型字段，建议单独分出去，单独用 一个表。</p>
<h2 id="ENUM类型"><a href="#ENUM类型" class="headerlink" title="ENUM类型"></a><strong>ENUM类型</strong></h2><p>​    ENUM类型也叫作枚举类型， ENUM 类型的取值范围需要在定义字段时进行指定。设置字段值时， <strong>ENUM类型只允许从成员中选取单个值，不能一次选取多个值。</strong></p>
<p>​    其所需要的存储空间由定义ENUM 类型时指定的成员个数决定。</p>
<table>
<thead>
<tr>
<th><em><strong>*文本字符串类型*</strong></em></th>
<th><em><strong>*长度*</strong></em></th>
<th><em><strong>*长度范围*</strong></em></th>
<th><em><strong>*占用的存储空间*</strong></em></th>
</tr>
</thead>
<tbody><tr>
<td><em><strong>*ENUM*</strong></em></td>
<td><em><strong>*L*</strong></em></td>
<td><em><strong>*1&lt;&#x3D;L&lt;&#x3D;65535*</strong></em></td>
<td><em>*<em>*1*</em>*<em>或*</em>*<em>2*</em>*<em>个字节*</em>*</em></td>
</tr>
</tbody></table>
<p>​    <strong>1. 当ENUM</strong> <em>*<em>*类型包含*</em>*<em>1*</em>*<em>～*</em>*<em>255*</em>*<em>个成员时，需要*</em>*<em>1*</em>*<em>个字节的存储空间；*</em>*</em></p>
<p>​    <em>*<em>*2. 当ENUM*</em>*<em>类型包含*</em>*<em>256*</em>*<em>～*</em>*<em>65535*</em>*<em>个成员时，需要*</em>*<em>2*</em>*<em>个字节的存储空间。*</em>*</em></p>
<p>​    <em>*<em>*3. ENUM类型的成员个数的上限为*</em>*<em>65535*</em>*<em>个。*</em>*</em></p>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061248403503.png" alt="img"></p>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061248413505.png" alt="img"></p>
<h2 id="SET类型"><a href="#SET类型" class="headerlink" title="SET类型"></a>SET类型</h2><p>​    SET表示一个字符串对象，可以包含 0 个或多个成员，但成员个数的上限为 64 。设置字段值时， <strong>可以取 取值范围内的 0 个或多个值。</strong></p>
<p>​    当SET 类型包含的成员个数不同时，其所占用的存储空间也是不同的，具体如下：</p>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061248413515.png" alt="img"></p>
<p>​    SET类型在存储数据时成员个数越多，其占用的存储空间越大。注意： SET 类型在选取成员时， <strong>可以一次选择多个成员</strong> ，这一点与ENUM 类型不同。</p>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061248413519.png" alt="img"></p>
<p> 举例：</p>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061248423523.png" alt="img"></p>
<h2 id="二进制字符串类型"><a href="#二进制字符串类型" class="headerlink" title="二进制字符串类型"></a><strong>二进制字符串类型</strong></h2><p>​    MySQL中的二进制字符串类型主要存储一些二进制数据，比如可以存储图片、音频和视频等二进制数据。</p>
<p>​    MySQL中支持的二进制字符串类型主要包括 <em>*<em>*BINARY*</em>*<em>、*</em>*<em>VARBINARY*</em>*<em>、*</em>*<em>TINYBLOB*</em>*<em>、*</em>*<em>BLOB*</em>*<em>、*</em>*<em>MEDIUMBLOB*</em>*</em> <strong>和 LONGBLOB</strong>类型。</p>
<h3 id="BINARY与VARBINARY类型"><a href="#BINARY与VARBINARY类型" class="headerlink" title="BINARY与VARBINARY类型"></a><strong>BINARY与VARBINARY类型</strong></h3><p>​    <strong>BINARY和</strong> <em>*<em>*VARBINARY*</em> *<em>类似于*</em> *<em>CHAR*</em>*<em>和*</em>*<em>VARCHAR*</em>*</em> ，只是它们存储的是二进制字符串。</p>
<p>​    BINARY (M)为固定长度的二进制字符串， M 表示最多能存储的 <em><strong>*字节数*</strong></em> ，取值范围是 0~255 个字符。 <strong>如果未指定(M)，表示只能存储</strong> <strong>1个字节</strong> 。</p>
<p>​    例如BINARY (8) ，表示最多能存储 8 个字节，如果字段值不足 (M) 个字节，将在右边填充’\0’ 以补齐指定长度。</p>
<p>​    VARBINARY (M)为可变长度的二进制字符串， M 表示最多能存储的 <strong>字节数</strong> ，总字节数不能超过行的字节长度限制65535 ，另外还要考虑额外字节开销， VARBINARY 类型的数据除了存储数据本身外，还需要 1 或 2 个字节来存储数据的字节数。</p>
<p>​     <strong>VARBINARY类型 必须</strong> <strong>指定(M)</strong> <strong>，否则报错。</strong></p>
<table>
<thead>
<tr>
<th><em><strong>*二进制字符串类型*</strong></em></th>
<th><em><strong>*特点*</strong></em></th>
<th><em><strong>*值的长度*</strong></em></th>
<th><em><strong>*占用空间*</strong></em></th>
</tr>
</thead>
<tbody><tr>
<td><em><strong>*BINARY(M)*</strong></em></td>
<td><em><strong>*固定长度*</strong></em></td>
<td><em>*<em>*M*</em>*<em>（*</em>*<em>0&lt;&#x3D;M&lt;&#x3D;255*</em>*<em>）*</em>*</em></td>
<td><em>*<em>*M*</em>*<em>个字节*</em>*</em></td>
</tr>
<tr>
<td><em><strong>*VARBINARY(M)*</strong></em></td>
<td><em><strong>*可变长度*</strong></em></td>
<td><em>*<em>*M*</em>*<em>（*</em>*<em>0&lt;&#x3D;M&lt;&#x3D;65535*</em>*<em>）*</em>*</em></td>
<td><em>*<em>*M+1*</em>*<em>个字节*</em>*</em></td>
</tr>
</tbody></table>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061248423550.png" alt="img"></p>
<p> <img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061248433552.png" alt="img"></p>
<h3 id="BLOB类型"><a href="#BLOB类型" class="headerlink" title="BLOB类型"></a><strong>BLOB类型</strong></h3><p>​    BLOB是一个 二进制大对象 ，可以容纳可变数量的数据。</p>
<p>​    MySQL中的 BLOB 类型包括 <em>*<em>*TINYBLOB*</em>*<em>、*</em>*<em>BLOB*</em>*<em>、*</em>*<em>MEDIUMBLOB*</em>*<em>和*</em>*</em> <strong>LONGBLOB</strong> 4 种类型，它们可容纳值的最大长度不同。可以存储一个二进制的大对象，比如 图片 、 音频 和 视频 等。</p>
<p>​    需要注意的是，在实际工作中，往往不会在MySQL 数据库中使用 BLOB 类型存储大对象数据，通常会将图片、音频和视频文件存储到 服务器的磁盘上 ，并将图片、音频和视频的访问路径存储到 MySQL 中。</p>
<table>
<thead>
<tr>
<th><em><strong>*二进制字符串类型*</strong></em></th>
<th><em><strong>*值的长度*</strong></em></th>
<th><em><strong>*长度范围*</strong></em></th>
<th><em><strong>*占用空间*</strong></em></th>
</tr>
</thead>
<tbody><tr>
<td><em><strong>*TINYBLOB*</strong></em></td>
<td><em><strong>*L*</strong></em></td>
<td><em><strong>*0&lt;&#x3D;L&lt;&#x3D;255*</strong></em></td>
<td><em>*<em>*L+1*</em>*<em>个字节*</em>*</em></td>
</tr>
<tr>
<td><em><strong>*BLOB*</strong></em></td>
<td><em><strong>*L*</strong></em></td>
<td><em>*<em>*0&lt;&#x3D;L&lt;&#x3D;65535*</em>*<em>（相当于*</em>*<em>64KB*</em>*<em>）*</em>*</em></td>
<td><em>*<em>*L+2*</em>*<em>个字节*</em>*</em></td>
</tr>
<tr>
<td><em><strong>*MEDIUMBLOB*</strong></em></td>
<td><em><strong>*L*</strong></em></td>
<td><em>*<em>*0&lt;&#x3D;L&lt;&#x3D;16777215*</em>*<em>（相当于*</em>*<em>16MB*</em>*<em>）*</em>*</em></td>
<td><em>*<em>*L+3*</em>*<em>个字节*</em>*</em></td>
</tr>
<tr>
<td><em><strong>*LONGBLOB*</strong></em></td>
<td><em><strong>*L*</strong></em></td>
<td><em>*<em>*0&lt;&#x3D;L&lt;&#x3D;4294967295*</em>*<em>（相当于*</em>*<em>4GB*</em>*<em>）*</em>*</em></td>
<td><em>*<em>*L+4*</em>*<em>个字节*</em>*</em></td>
</tr>
</tbody></table>
<h2 id="-7"><a href="#-7" class="headerlink" title=""></a></h2><h3 id="TEXT和BLOB的使用注意事项："><a href="#TEXT和BLOB的使用注意事项：" class="headerlink" title="TEXT和BLOB的使用注意事项："></a><strong>TEXT和BLOB的使用注意事项：</strong></h3><p>在使用 text 和 blob 字段类型时要注意以下几点，以便更好的发挥数据库的性能。</p>
<p>​    ① BLOB 和 TEXT 值也会引起自己的一些问题，特别是执行了大量的删除或更新操作的时候。删除这种值会在数据表中留下很大的” 空洞 “ ，以后填入这些 “ 空洞 “ 的记录可能长度不同。为了提高性能，建议定期使用 OPTIMIZE TABLE 功能对这类表进行 碎片整理 。</p>
<p>​    ② 如果需要对大文本字段进行模糊查询，MySQL 提供了 前缀索引 。但是仍然要在不必要的时候避免检索大型的BLOB 或 TEXT 值。例如， SELECT * 查询就不是很好的想法，除非你能够确定作为约束条件的WHERE子句只会找到所需要的数据行。否则，你可能毫无目的地在网络上传输大量的值。</p>
<p>​    ③ 把BLOB 或 TEXT 列 分离到单独的表 中。在某些环境中，如果把这些数据列移动到第二张数据表中，可以让你把原数据表中的数据列转换为固定长度的数据行格式，那么它就是有意义的。这会 减少主表中的碎片 ，使你得到固定长度数据行的性能优势。它还使你在主数据表上运行 SELECT * 查询的时候不会通过网络传输大量的BLOB 或 TEXT 值。</p>
<h2 id="JSON-类型"><a href="#JSON-类型" class="headerlink" title="JSON 类型"></a><strong>JSON 类型</strong></h2><p>​    JSON（JavaScript Object Notation）是一种轻量级的 数据交换格式 。简洁和清晰的层次结构使得 JSON 成为理想的数据交换语言。它易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率。 <strong>JSON</strong> <strong>可以将</strong> <strong>JavaScript</strong> <strong>对象中表示的一组数据转换为字符串，然后就可以在网络或者程序之间轻</strong> <strong>松地传递这个字符串，并在需要的时候将它还原为各编程语言所支持的数据格式。</strong></p>
<p>​    在MySQL 5.7 中，就已经支持 JSON 数据类型。在 MySQL 8.x 版本中， JSON 类型提供了可以进行自动验证的 JSON文档和优化的存储结构，使得在 MySQL 中存储和读取 JSON 类型的数据更加方便和高效。</p>
<p>​    创建数据表，表中包含一个JSON类型的字段 js ：</p>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061248433591.png" alt="img"></p>
<p>​     </p>
<p>​    向表中插入JSON数据：</p>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061248443597.png" alt="img"></p>
<p> <em>*<em>*当需要检索*</em>*<em>JSON*</em>*<em>类型的字段中数据的某个具体值时，可以使用*</em>*<em>“-&gt;”*</em>*<em>和*</em>*<em>“-&gt;&gt;”*</em>*<em>符号：*</em>*</em></p>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061248453603.png" alt="img"></p>
<h2 id="空间类型（了解）"><a href="#空间类型（了解）" class="headerlink" title="空间类型（了解）"></a><strong>空间类型（了解）</strong></h2><p>​    MySQL 空间类型扩展支持地理特征的生成、存储和分析。这里的地理特征表示世界上具有位置的任何东西，可以是一个实体，例如一座山；可以是空间，例如一座办公楼；也可以是一个可定义的位置。</p>
<p>​    例如一个十字路口等等。MySQL中使用 Geometry （几何） 来表示所有地理特征。 Geometry 指一个点或点的集合，代表世界上任何具有位置的事物。</p>
<p>​    MySQL的空间数据类型（Spatial Data Type）对应于 OpenGIS 类，包括单值类型： <em>*<em>*GEOMETRY*</em>*<em>、*</em>*<em>POINT*</em>*<em>、 LINESTRING、*</em>*<em>POLYGON*</em>*</em> 以及集合类型： <em>*<em>*MULTIPOINT*</em>*<em>、*</em>*<em>MULTILINESTRING*</em>*<em>、*</em>*<em>MULTIPOLYGON*</em>*</em> <strong>、 GEOMETRYCOLLECTION</strong> 。</p>
<table>
<thead>
<tr>
<th><em><strong>*类型*</strong></em></th>
<th><em><strong>*类型举例*</strong></em></th>
</tr>
</thead>
<tbody><tr>
<td><em><strong>*空间数据类型*</strong></em></td>
<td><em>*<em>*单值类型：*</em>*<em>GEOMETRY*</em>*<em>、*</em>*<em>POINT*</em>*<em>、*</em>*</em>         <em>*<em>*LINESTRING、*</em>*<em>POLYGON*</em>*<em>；*</em>*</em><em>*<em>*集合类型：*</em>*<em>MULTIPOINT*</em>*<em>、*</em>*</em>         <em><strong>*MULTILINESTRING、*</strong></em>             <em><strong>*MULTIPOLYGON、*</strong></em>          <em><strong>*GEOMETRYCOLLECTION*</strong></em></td>
</tr>
</tbody></table>
<p>​    Geometry是所有空间集合类型的基类，其他类型如POINT 、 LINESTRING 、 POLYGON 都是 Geometry 的子类。</p>
<p>​    Point，顾名思义就是点，有一个坐标值。</p>
<p>​    例如POINT(121.213342 31.234532) ， POINT(30 10) ，坐标值支持DECIMAL 类型，经度（longitude）在前，维度（latitude）在后，用空格分隔。</p>
<p>​    LineString，线，由一系列点连接而成。如果线从头至尾没有交叉，那就是简单的</p>
<p>（simple）；如果起点和终点重叠，那就是封闭的（closed）。</p>
<p>​    例如LINESTRING(30 10,10 30,40 40)，点与点之间用逗号分隔，一个点中的经纬度用空格分隔，与 POINT 格式一致。</p>
<p>​    Polygon，多边形。可以是一个实心平面形，即没有内部边界，也可以有空洞，类似纽扣。最 简单的就是只有一个外边界的情况。</p>
<p>​    例如POLYGON((0 0,10 0,10 10, 0 10))。</p>
<p>下面展示几种常见的几何图形元素：</p>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061248453639.png" alt="img"></p>
<p>​    MultiPoint、 MultiLineString 、 MultiPolygon 、 GeometryCollection 这 4 种类型都是集合类，是多个Point、 LineString 或 Polygon 组合而成。</p>
<p>下面展示的是多个同类或异类几何图形元素的组合：</p>
<p><img src="/2022/10/06/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%AD)/202210061248463647.png" alt="img"></p>
<h2 id="小结及选择建议"><a href="#小结及选择建议" class="headerlink" title="小结及选择建议"></a><strong>小结及选择建议</strong></h2><p>​    在定义数据类型时，如果确定是 整数 ，就用 INT ； 如果是 小数 ，一定用定点数类型</p>
<p>DECIMAL(M,D) ； 如果是日期与时间，就用 DATETIME 。</p>
<p>这样做的好处是，首先确保你的系统不会因为数据类型定义出错。不过，凡事都是有两面的，可靠性 好，并不意味着高效。比如，TEXT 虽然使用方便，但是效率不如 CHAR(M) 和 VARCHAR(M) 。</p>
<p>​    关于字符串的选择，建议参考如下阿里巴巴的《Java开发手册》规范：</p>
<p><strong>阿里巴巴《</strong> <strong>Java</strong> <strong>开发手册》之</strong> <strong>MySQL</strong> <strong>数据库：</strong></p>
<p>​    任何字段如果为非负数，必须是 UNSIGNED</p>
<p>​    【 强制 】小数类型为 DECIMAL ，禁止使用 FLOAT 和 DOUBLE 。</p>
<p>说明：在存储的时候， FLOAT 和 DOUBLE 都存在精度损失的问题，很可能在比较值的时候，得到不正确的结果。如果存储的数据范围超过 DECIMAL 的范围，建议将数据拆成整数和小数并 分开存储。</p>
<p>​    【 强制 】如果存储的字符串长度几乎相等，使用 CHAR 定长字符串类型。</p>
<p>​    【 强制 】 VARCHAR 是可变长字符串，不预先分配存储空间，长度不要超过 5000 。如果存储长度大 于此值，定义字段类型为 TEXT ，独立出来一张表，用主键来对应，避免影响其它字段索引效率。</p>
]]></content>
      <categories>
        <category>MySQL学习</category>
        <category>MySQL基础篇</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL基础篇(下)</title>
    <url>/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/</url>
    <content><![CDATA[<h1 id="MySQL-约束"><a href="#MySQL-约束" class="headerlink" title="MySQL 约束"></a>MySQL 约束</h1><h2 id="约束-constraint-概述"><a href="#约束-constraint-概述" class="headerlink" title="约束(constraint)概述"></a><strong>约束(constraint)概述</strong></h2><h3 id="为什么需要约束-–-为了保证数据的完整性"><a href="#为什么需要约束-–-为了保证数据的完整性" class="headerlink" title="为什么需要约束 – 为了保证数据的完整性"></a><strong>为什么需要约束 –</strong> <strong>为了保证数据的完整性</strong></h3><p>​    <strong>数据完整性</strong>（Data Integrity）是指数据的精确性（Accuracy）和可靠性（Reliability）。它是防止数据库中 存在不符合语义规定的数据和防止因错误信息的输入输出造成无效操作或错误信息而提出的。</p>
<p>​    为了保证数据的完整性，SQL 规范以约束的方式对 <strong>表数据进行额外的条件限制</strong> 。从以下四个方面考虑：</p>
<p>​    实体完整性（Entity Integrity ） ：例如，同一个表中，不能存在两条完全相同无法区分的记录</p>
<p>​    域完整性（Domain Integrity ） ：例如：年龄范围 0-120 ，性别范围 “ 男 &#x2F; 女 ”</p>
<p>​    引用完整性（Referential Integrity ） ：例如：员工所在部门，在部门表中要能找到这个部门</p>
<p>​    用户自定义完整性（User - defined Integrity ） ：例如：用户名唯一、密码不能为空等，本部门经理的工资不得高于本部门职工的平均工资的5 倍。</p>
<h3 id="什么是约束-–-对表中字段的限制"><a href="#什么是约束-–-对表中字段的限制" class="headerlink" title="什么是约束 – 对表中字段的限制"></a>什么是约束 – 对表中字段的限制</h3><p>​    约束是表级的强制规定。</p>
<p>​    可以在 <strong>创建表时规定约束（通过</strong> <strong>CREATE TABLE</strong> <strong>语句）</strong> ，或者在 <strong>表创建之后通过</strong> <strong>ALTER TABLE</strong> <strong>语句规定</strong></p>
<p><strong>约束</strong> 。</p>
<p>​    </p>
<h3 id="约束的分类"><a href="#约束的分类" class="headerlink" title="约束的分类"></a><strong>约束的分类</strong></h3><p><strong>根据约束数据列的限制，</strong> 约束可分为：</p>
<p>​    <strong>单列约束</strong> ：每个约束只约束一列</p>
<p>​    <strong>多列约束</strong> ：每个约束可约束多列数据</p>
<p><strong>根据约束的作用范围</strong> ，约束可分为：</p>
<p>​    <strong>列级约束</strong> ：只能作用在一个列上，跟在列的定义后面</p>
<p>​    <strong>表级约束</strong> ：可以作用在多个列上，不与列一起，而是单独定义</p>
<table>
<thead>
<tr>
<th></th>
<th><em><strong>*位置*</strong></em></th>
<th><em><strong>*支持的约束类型*</strong></em></th>
<th><em><strong>*是否可以起约束名*</strong></em></th>
</tr>
</thead>
<tbody><tr>
<td><em><strong>*列级约束：*</strong></em></td>
<td>列的后面</td>
<td>语法都支持，但外键没有效果</td>
<td>不可以</td>
</tr>
<tr>
<td><em><strong>*表级约束：*</strong></em></td>
<td>所有列的下面</td>
<td>默认和非空不支持，其他支持</td>
<td>可以（主键没有效果）</td>
</tr>
</tbody></table>
<p><strong>根据约束起的作用</strong> ，约束可分为：</p>
<p>​    <strong>1. NOT NULL 非空约束，规定某个字段不能为空</strong></p>
<p>​    <strong>2. UNIQUE 唯一约束</strong>，<strong>规定某个字段在整个表中是唯一的</strong></p>
<p>​    <strong>3. PRIMARY KEY 主键(非空且唯一)约束</strong></p>
<p>​    <strong>4. FOREIGN KEY 外键约束</strong></p>
<p>​    <strong>5. CHECK 检查约束</strong></p>
<p>​    <strong>6. DEFAULT 默认值约束</strong></p>
<p><em>*<em>*注意： MySQL不支持*</em>*<em>check*</em>*<em>约束，但可以使用*</em>*<em>check*</em>*<em>约束，而没有任何效果*</em>*</em></p>
<p>查看某个表已有的约束 ：</p>
<p>​    # information_schema数据库名（系统库）</p>
<p>​    # table_constraints表名称（专门存储各个表的约束）</p>
<p>​    <em>*<em>*SELECT*</em> ***</em>* *<em>FROM*</em> *<em>information_schema*</em>*<em>.table_constraints*</em>**</p>
<p>​    <em>*<em>*WHERE table_name*</em> **&#x3D;*</em> *<em>‘*</em>*<em>表名称*</em>*<em>‘*</em>*<em>;*</em>**</p>
<p><img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/2022100712384373.png" alt="img"></p>
<h2 id="非空约束（NOT-NULL）"><a href="#非空约束（NOT-NULL）" class="headerlink" title="非空约束（NOT NULL）"></a><strong>非空约束（NOT NULL）</strong></h2><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a><strong>作用</strong></h3><p>​    <strong>限定某个字段&#x2F;</strong> <em><strong>*某列的值不允许为空*</strong></em></p>
<p><img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/2022100712384385.png" alt="img"></p>
<h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a><strong>关键字</strong></h3><p>​    <strong>NOT NULL</strong></p>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a><strong>特点</strong></h3><p>​    <em>*<em>*1. 默认，所有的类型的值都可以是NULL*</em>*<em>，包括*</em>*<em>INT*</em>*<em>、*</em>*<em>FLOAT*</em>*<em>等数据类型*</em>*</em></p>
<p>​    <em><strong>*2. 非空约束只能出现在表对象的列上，只能某个列单独限定非空，不能组合非空*</strong></em></p>
<p>​        <em><strong>*（只有列级约束，没有表级约束）*</strong></em></p>
<p>​    <em><strong>*3. 一个表可以有很多列都分别限定了非空*</strong></em></p>
<p>​    <em>*<em>*4. 空字符串’’*</em>*<em>不等于*</em>*<em>NULL*</em>*<em>，*</em>*<em>0*</em>*<em>也不等于*</em>*<em>NULL*</em>*</em></p>
<h3 id="添加非空约束"><a href="#添加非空约束" class="headerlink" title="添加非空约束"></a><strong>添加非空约束</strong></h3><h4 id="在CREATE-TABLE-时添加非空约束"><a href="#在CREATE-TABLE-时添加非空约束" class="headerlink" title="在CREATE TABLE 时添加非空约束"></a>在CREATE TABLE 时添加非空约束</h4><p><strong>语法格式：</strong></p>
<p>​    <strong>CREATE TABLE</strong> <em><strong>*表名称(*</strong></em></p>
<p>​        <em><strong>*字段名 数据类型,*</strong></em></p>
<p>​        <em><strong>*字段名 数据类型** **NOT NULL,*</strong></em></p>
<p>​        <em><strong>*字段名 数据类型** **NOT NULL*</strong></em></p>
<p>​    <em><strong>*);*</strong></em></p>
<p><em><strong>*举例：*</strong></em></p>
<p><img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/20221007123843123.png" alt="img"></p>
<p> <img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/20221007123844125.png" alt="img"></p>
<p><img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/20221007123844127.png" alt="img"></p>
<h4 id="在ALTER-TABLE-时添加非空约束"><a href="#在ALTER-TABLE-时添加非空约束" class="headerlink" title="在ALTER TABLE 时添加非空约束"></a>在ALTER TABLE 时添加非空约束</h4><p> <strong>语法格式：</strong></p>
<p>​    <em>*<em>*alter table*</em> *<em>表名称*</em> *<em>modify*</em> *<em>字段名 数据类型*</em> *<em>not*</em> *<em>null*</em>**;*</em>**</p>
<p>​    </p>
<p><em><strong>*举例：*</strong></em></p>
<p><img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/20221007123844141.png" alt="img"></p>
<h3 id="删除非空约束"><a href="#删除非空约束" class="headerlink" title="删除非空约束"></a><strong>删除非空约束</strong></h3><p><strong>语法格式：</strong>   </p>
<p>​    <strong>1.alter table</strong> <em>*<em>*表名称*</em> *<em>modify*</em> *<em>字段名 数据类型*</em> *<em>NULL*</em>**;*</em> *<em>#*</em>*<em>去掉*</em>*<em>not null*</em>*<em>，相当于修改某个非注解字段，该字段允 许为空*</em>**</p>
<p>​    <em>*<em>*2.alter table*</em> *<em>表名称*</em> *<em>modify*</em> *<em>字段名 数据类型*</em>**;*</em> *<em>#*</em>*<em>去掉*</em>*<em>not null*</em>*<em>，相当于修改某个非注解字段，该字段允许为空*</em>**</p>
<p><strong>举例：</strong></p>
<p><img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/20221007123844155.png" alt="img"></p>
<h2 id="唯一性约束-UNIQUE-或-UNIQUE-KEY"><a href="#唯一性约束-UNIQUE-或-UNIQUE-KEY" class="headerlink" title="唯一性约束(UNIQUE 或 UNIQUE KEY)"></a><strong>唯一性约束(UNIQUE 或 UNIQUE KEY)</strong></h2><h3 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a><strong>作用</strong></h3><p>​    <strong>用来限制某个字段&#x2F;</strong> <em><strong>*某列的值不能重复。*</strong></em></p>
<p><img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/20221007123845165.png" alt="img"></p>
<h3 id="关键字-1"><a href="#关键字-1" class="headerlink" title="关键字"></a>关键字</h3><p>​    <em><strong>*UNIQUE*</strong></em></p>
<h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a><strong>特点</strong></h3><p>​    <strong>1.同一个表可以有多个唯一约束。</strong></p>
<p>​    <em><strong>*2.唯一约束可以是某一个列的值唯一，也可以多个列组合的值唯一。*</strong></em></p>
<p>​    <em><strong>*3.唯一性约束允许列值为空。并且允许存在多个NULL值。*</strong></em></p>
<p>​    <em><strong>*4.在创建唯一约束的时候，如果不给唯一约束命名，就默认和列名相同。*</strong></em></p>
<p>​    <em><strong>*5.MySQL会给唯一约束的列上默认创建一个唯一索引。*</strong></em></p>
<h3 id="添加唯一约束"><a href="#添加唯一约束" class="headerlink" title="添加唯一约束"></a><strong>添加唯一约束</strong></h3><h4 id="在CREATE-TABLE-时添加唯一约束"><a href="#在CREATE-TABLE-时添加唯一约束" class="headerlink" title="在CREATE TABLE 时添加唯一约束"></a>在CREATE TABLE 时添加唯一约束</h4><p><strong>语法格式：</strong></p>
<p>​    <strong>1.列级约束</strong></p>
<p>​    <strong>create table</strong> <em>*<em>*表名称*</em>**(*</em>**</p>
<p>​    <em><strong>*字段名 数据类型,*</strong></em></p>
<p>​    <em>*<em>*字段名 数据类型*</em> *<em>unique*</em>**,*</em>**</p>
<p>​    <em>*<em>*字段名 数据类型*</em> *<em>unique key*</em>**,*</em>**</p>
<p>​    <em><strong>*字段名 数据类型*</strong></em></p>
<p>​    <em><strong>*);*</strong></em></p>
<p>​    <em><strong>*2.表级约束*</strong></em></p>
<p>​    <strong>create table</strong> <em>*<em>*表名称*</em>**(*</em>**</p>
<p>​    <em><strong>*字段名 数据类型,*</strong></em></p>
<p>​    <em><strong>*字段名 数据类型,*</strong></em></p>
<p>​    <em><strong>*字段名 数据类型,*</strong></em></p>
<p>​    <em>*<em>*[*</em>*<em>constraint*</em> *<em>约束名*</em>**]*</em> *<em>unique key*</em>*<em>(*</em>*<em>字段名*</em>*<em>)*</em>**</p>
<p>​    <em><strong>*);*</strong></em></p>
<p><strong>举例：</strong></p>
<p><img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/20221007123845221.png" alt="img"></p>
<p> <img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/20221007123845223.png" alt="img"></p>
<p><img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/20221007123845225.png" alt="img"></p>
<h4 id="在ALTER-TABLE-时添加唯一约束"><a href="#在ALTER-TABLE-时添加唯一约束" class="headerlink" title="在ALTER TABLE 时添加唯一约束"></a>在ALTER TABLE 时添加唯一约束</h4><p><strong>语法格式：</strong></p>
<p>​    <strong>1. *<em>alter table*</em> *<em>表名称*</em></strong></p>
<p>​      <em>*<em>*add*</em> **[*</em>*<em>constraint*</em> *<em>约束名*</em>*<em>]*</em> *<em>unique key*</em>*<em>(*</em>*<em>字段列表*</em>*<em>);*</em>**</p>
<p>​    <em><strong>*2.** *<em>alter table*</em> **表名称*</strong></em></p>
<p>​      <em>*<em>*modify*</em> *<em>字段名 字段类型*</em> *<em>unique*</em>**;*</em>**</p>
<p>注：字段列表中如果是一个字段，表示该列的值唯一。如果是两个或更多个字段，那么复合唯一，即多个字段的组合是唯一的</p>
<p><strong>举例：</strong></p>
<p><img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/20221007123846245.png" alt="img"></p>
<p><img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/20221007123846247.png" alt="img"></p>
<h4 id="添加复合唯一性约束"><a href="#添加复合唯一性约束" class="headerlink" title="添加复合唯一性约束"></a>添加复合唯一性约束</h4><p><em><strong>*语法格式：*</strong></em></p>
<p>​    <em><strong>*1.在 create table 时添加复合唯一约束*</strong></em></p>
<p>​        <em>*<em>*create table*</em> *<em>表名称*</em>**(*</em>**</p>
<p>​        <em><strong>*字段名 数据类型,*</strong></em></p>
<p>​        <em><strong>*字段名 数据类型,*</strong></em></p>
<p>​        <em><strong>*字段名 数据类型,*</strong></em></p>
<p>​         <em>*<em>*[*</em>*<em>constraint*</em> *<em>约束名*</em>**]*</em> *<em>unique key*</em>*<em>(*</em>*<em>字段列表*</em>*<em>)*</em>**</p>
<p>​        <em><strong>*);*</strong></em></p>
<p>​    <em><strong>*2. 在 alter table 时添加复合唯一约束*</strong></em></p>
<p>​        <em><strong>*alter table** **表名称*</strong></em></p>
<p>​        <em>*<em>*add*</em> **[*</em>*<em>constraint*</em> *<em>约束名*</em>*<em>]*</em> *<em>unique key*</em>*<em>(*</em>*<em>字段列表*</em>*<em>);*</em>**</p>
<p>​    <strong>字段列表中写的是多个字段名，多个字段名用逗号分隔，表示那么是复合唯一，即多</strong></p>
<p><em><strong>*个字段的组合是唯一的*</strong></em></p>
<p><strong>举例：</strong></p>
<p><img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/20221007123846281.png" alt="img"></p>
<p> <img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/20221007123847283.png" alt="img"></p>
<p> <img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/20221007123847285.png" alt="img"></p>
<p><strong>删除唯一约束</strong></p>
<p>​    <strong>1.添加唯一性约束的列上也会自动创建唯一索引。</strong></p>
<p>​    <em><strong>*2.删除唯一约束只能通过删除唯一索引的方式删除。*</strong></em></p>
<p>​    <em><strong>*3.删除时需要指定唯一索引名，唯一索引名就和唯一约束名一样。*</strong></em></p>
<p>​    <em><strong>*4.如果创建唯一约束时未指定名称，如果是单列，就默认和列名相同；*</strong></em></p>
<p>​      <em><strong>*如果是组合列，那么默认和() 中排在第一个的列名相同。*</strong></em></p>
<p>​      <em><strong>*也可以是自定义唯一性约束名。*</strong></em></p>
<p><strong>语法格式：</strong></p>
<p>​    <strong>ALTER TABLE USER</strong></p>
<p>​    <em>*<em>*DROP INDEX*</em> *<em>约束名*</em>**;*</em>**</p>
<p><strong>查看表从索引：</strong></p>
<p>​    <strong>show index from 表名称</strong> <em><strong>*;*</strong></em></p>
<p><img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/20221007123847315.png" alt="img"></p>
<p><strong>举例：</strong></p>
<p><img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/20221007123848321.png" alt="img"></p>
<p><img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/20221007123848323.png" alt="img"></p>
<h2 id="PRIMARY-KEY-约束（主键约束）"><a href="#PRIMARY-KEY-约束（主键约束）" class="headerlink" title="PRIMARY KEY 约束（主键约束）"></a><strong>PRIMARY KEY 约束（主键约束）</strong></h2><h3 id="作用-2"><a href="#作用-2" class="headerlink" title="作用"></a><strong>作用</strong></h3><p>​    <strong>用来唯一标识表中的一行记录。</strong></p>
<h3 id="关键字-2"><a href="#关键字-2" class="headerlink" title="关键字"></a><strong>关键字</strong></h3><p>​    <strong>primary key</strong></p>
<h3 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a><strong>特点</strong></h3><p>​    <em>*<em>*主键约束相当于*</em>*<em>唯一约束*</em>**+*</em>*<em>非空约束的组合*</em>*<em>，主键约束列不允许重复，也不允许出现空值。*</em>**</p>
<p><img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/20221007123849341.png" alt="img"></p>
<p>​    \1. 一个表最多只能有一个主键约束，建立主键约束可以在列级别创建，也可以在表级别上创建。</p>
<p>​    \2. 主键约束对应着表中的一列或者多列（复合主键）</p>
<p>​    \3. 如果是多列组合的复合主键约束，那么这些列都不允许为空值，并且组合的值不允许重复。</p>
<p>​    <strong>4. MySQL的主键名总是</strong> <strong>PRIMARY</strong> ，就算自己命名了主键约束名也没用。</p>
<p>​    \5. 当创建主键约束时，系统默认会在所在的列或列组合上建立对应的 <strong>主键索引</strong> （能够根据主键查询的，就根据主键查询，效率更高）。如果删除主键约束了，主键约束对应的索引就自动删除了。</p>
<p>​    \6. 需要注意的一点是，不要修改主键字段的值。因为主键是数据记录的唯一标识，如果修改了主键的值，就有可能会破坏数据的完整性</p>
<h3 id="添加主键约束"><a href="#添加主键约束" class="headerlink" title="添加主键约束"></a><strong>添加主键约束</strong></h3><h4 id="在CREATE-TABLE-时添加主键约束"><a href="#在CREATE-TABLE-时添加主键约束" class="headerlink" title="在CREATE TABLE 时添加主键约束"></a>在CREATE TABLE 时添加主键约束</h4><p><strong>语法格式：</strong></p>
<p>​    <strong>1.列级模式</strong></p>
<p>​        <em>*<em>*create table*</em> *<em>表名称*</em>**(*</em>**</p>
<p>​        <em>*<em>*字段名 数据类型*</em> *<em>primary key*</em>**,*</em> *<em>#*</em>*<em>列级模式*</em>**</p>
<p>​        <em><strong>*字段名 数据类型,*</strong></em></p>
<p>​        <em><strong>*字段名 数据类型*</strong></em></p>
<p>​        <em><strong>*);*</strong></em></p>
<p>​    <em><strong>*2.表级模式（注：*</strong></em> <strong>MySQL的主键名总是</strong> <strong>PRIMARY</strong> ，就算自定义了主键约束名也没用 <em><strong>*）*</strong></em></p>
<p>​        <em>*<em>*create table*</em> *<em>表名称*</em>**(*</em>**</p>
<p>​        <em><strong>*字段名 数据类型,*</strong></em></p>
<p>​        <em><strong>*字段名 数据类型,*</strong></em></p>
<p>​        <em><strong>*字段名 数据类型,*</strong></em></p>
<p>​        <em>*<em>*[*</em>*<em>constraint*</em> *<em>约束名*</em>**]*</em> *<em>primary key*</em>*<em>(*</em>*<em>字段名*</em>*<em>)*</em> *<em>#*</em>*<em>表级模式*</em>**</p>
<p>​        <em><strong>*);*</strong></em></p>
<p><em><strong>*举例：*</strong></em></p>
<p><img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/20221007123849391.png" alt="img"></p>
<p><img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/20221007123850393.png" alt="img"></p>
<p><img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/20221007123850395.png" alt="img"></p>
<h4 id="在CREATE-TABLE-时添加复合主键约束"><a href="#在CREATE-TABLE-时添加复合主键约束" class="headerlink" title="在CREATE TABLE 时添加复合主键约束"></a>在CREATE TABLE 时添加复合主键约束</h4><p>​    <em><strong>*多列组合的复合主键约束，那么这些列都不允许为空值，并且组合的值不允许重复。*</strong></em></p>
<p><strong>语法格式：</strong></p>
<p>​    <strong>create table</strong> <em>*<em>*表名称*</em>**(*</em>**</p>
<p>​    <em><strong>*字段名 数据类型,*</strong></em></p>
<p>​    <em><strong>*字段名 数据类型,*</strong></em></p>
<p>​    <em><strong>*字段名 数据类型,*</strong></em></p>
<p>​    <em>*<em>*primary key*</em>**(*</em>*<em>字段名*</em>*<em>1,*</em>*<em>字段名*</em>*<em>2)*</em>**</p>
<p>​    <em><strong>*);*</strong></em></p>
<p><em>*<em>*字段*</em>*<em>1*</em>*<em>和字段*</em>*<em>2*</em>*<em>的组合是唯一的，也可以有更多个字段*</em>*</em></p>
<p><strong>举例：</strong></p>
<p><img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/20221007123850419.png" alt="img"></p>
<p><img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/20221007123851421.png" alt="img"></p>
<h4 id="在-ALTER-TABLE-时添加（复合）主键约束"><a href="#在-ALTER-TABLE-时添加（复合）主键约束" class="headerlink" title="在 ALTER TABLE 时添加（复合）主键约束"></a>在 ALTER TABLE 时添加（复合）主键约束</h4><p>​    <strong>字段列表可以是一个字段，也可以是多个字段，如果是多个字段的话，是复合主键</strong></p>
<p><strong>语法格式：</strong></p>
<p>​    <em><strong>*1. ALTER TABLE** *<em>表名称*</em> *<em>MODIFY*</em> *<em>字段名 数据类型*</em> **PRIMARY KEY;*</strong></em></p>
<p>​    <em>*<em>*2. ALTER TABLE*</em> *<em>表名称*</em> *<em>ADD PRIMARY KEY*</em>**(*</em>*<em>字段列表*</em>*<em>);*</em>** </p>
<p><strong>举例：</strong></p>
<p><img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/20221007123851439.png" alt="img"></p>
<h3 id="删除主键约束"><a href="#删除主键约束" class="headerlink" title="删除主键约束"></a><strong>删除主键约束</strong></h3><p>​    <strong>删除主键约束，不需要指定主键名，因为一个表只有一个主键，</strong> <strong>删除主键约束后，非空还存在。</strong> <strong>（但在实际开发中，不会去删除表中的主键约束）</strong></p>
<p><strong>语法格式：</strong></p>
<p>​     <em><strong>*alter table** **表名称*</strong></em></p>
<p>​    <em>*<em>*drop primary key*</em>**;*</em>**</p>
<p><strong>举例：</strong></p>
<p><img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/20221007123851455.png" alt="img"></p>
<h2 id="自增列：AUTO-INCREMENT"><a href="#自增列：AUTO-INCREMENT" class="headerlink" title="自增列：AUTO_INCREMENT"></a><strong>自增列：AUTO_INCREMENT</strong></h2><h3 id="作用-3"><a href="#作用-3" class="headerlink" title="作用"></a><strong>作用</strong></h3><p>​    <em><strong>*某个字段的值自增*</strong></em></p>
<h3 id="关键字-3"><a href="#关键字-3" class="headerlink" title="关键字"></a><strong>关键字</strong></h3><p>​    <em><strong>*auto_increment*</strong></em></p>
<h3 id="特点和要求"><a href="#特点和要求" class="headerlink" title="特点和要求"></a><strong>特点和要求</strong></h3><p>​    <strong>1. *<em>一个表最多只能有一个自增长列*</em></strong></p>
<p>​    <em><strong>*2. 当需要产生唯一标识符或顺序值时，可设置自增长*</strong></em></p>
<p>​    <em><strong>*3. 自增长列约束的列必须是键列（主键列，唯一键列）*</strong></em></p>
<p>​    <em><strong>*4. 自增约束的列的数据类型必须是整数类型*</strong></em></p>
<p>​    <em>*<em>*5. 如果自增列指定了*</em> *<em>0*</em> *<em>和*</em> *<em>null*</em>*<em>，会在当前最大值的基础上自增；如果自增列手动指定了具体值，直接 赋值为具体值*</em>*</em></p>
<h3 id="添加自增约束"><a href="#添加自增约束" class="headerlink" title="添加自增约束"></a><strong>添加自增约束</strong></h3><h4 id="在CREATE-TABLE-时添加自增约束"><a href="#在CREATE-TABLE-时添加自增约束" class="headerlink" title="在CREATE TABLE 时添加自增约束"></a>在CREATE TABLE 时添加自增约束</h4><p><strong>语法格式：</strong></p>
<p>​        <strong>create table</strong> <em>*<em>*表名称*</em>**(*</em>**</p>
<p>​        <em>*<em>*字段名 数据类型*</em> *<em>primary key auto_increment*</em>**,*</em>**</p>
<p>​        <em><strong>*字段名 数据类型 ,*</strong></em></p>
<p>​        <em><strong>*字段名 数据类型 ,*</strong></em></p>
<p>​        <em><strong>*字段名 数据类型*</strong></em> </p>
<p>​        <em><strong>*);*</strong></em></p>
<p>​        <em>*<em>*create table*</em> *<em>表名称*</em>**(*</em>**</p>
<p>​        <em><strong>*字段名 数据类型 ,*</strong></em></p>
<p>​        <em>*<em>*字段名 数据类型*</em> *<em>unique key auto_increment*</em>**,*</em>**</p>
<p>​        <em><strong>*字段名 数据类型*</strong></em> </p>
<p>​        <em><strong>*);*</strong></em></p>
<p><strong>举例：</strong></p>
<p>非法创建：</p>
<p><img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/20221007123852513.png" alt="img"></p>
<p> 正确创建方式：</p>
<p><img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/20221007123852517.png" alt="img"></p>
<p>插入数据: </p>
<p><img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/20221007123853521.png" alt="img"></p>
<p> 特殊情况(不推荐此写法)：</p>
<p><img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/20221007123853525.png" alt="img"></p>
<h4 id="在-ALTER-TABLE-时添加自增约束"><a href="#在-ALTER-TABLE-时添加自增约束" class="headerlink" title="在 ALTER TABLE 时添加自增约束"></a>在 ALTER TABLE 时添加自增约束</h4><p><strong>语法格式：</strong></p>
<p>​    <strong>alter table</strong> <em><strong>*表名称*</strong></em></p>
<p>​    <em>*<em>*modify*</em> *<em>字段名 数据类型*</em> *<em>auto_increment*</em>**;*</em>**</p>
<p><strong>举例：</strong></p>
<p><img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/20221007123853539.png" alt="img"></p>
<h3 id="删除自增约束"><a href="#删除自增约束" class="headerlink" title="删除自增约束"></a><strong>删除自增约束</strong></h3><p><strong>语法格式：</strong></p>
<p>​    <em>*<em>*alter table*</em> *<em>表名称*</em> *<em>modify*</em> *<em>字段名 数据类型*</em>**;*</em>**</p>
<p><strong>举例：</strong></p>
<p><img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/20221007123853551.png" alt="img"></p>
<h3 id="MySQL-8-0新特性—自增变量的持久化"><a href="#MySQL-8-0新特性—自增变量的持久化" class="headerlink" title="MySQL 8.0新特性—自增变量的持久化"></a><strong>MySQL 8.0新特性—自增变量的持久化</strong></h3><p>​    在MySQL 8.0 之前，自增主键 AUTO_INCREMENT 的值如果大于 max(primary key)+1 ，在 MySQL 重启后，会重 置AUTO_INCREMENT&#x3D;max(primary key)+1 ，这种现象在某些情况下会导致业务主键冲突或者其他难以发 现的问题。 下面通过案例来对比不同的版本中自增变量是否持久化。</p>
<p><strong>案例：</strong></p>
<p>​    <strong>对于MySQL5.7版本：</strong> </p>
<p><img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/20221007123854561.png" alt="img"></p>
<p><img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/20221007123854563.png" alt="img"></p>
<p> 然后重启MySQL57服务器：（以管理员的身份运行）</p>
<p><img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/20221007123854567.png" alt="img"></p>
<p> <img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/20221007123854569.png" alt="img"></p>
<p>​    从结果可以看出，新插入的0 值分配的是 4 ，按照重启前的操作逻辑，此处应该分配 6 。出现上述结果的主要原因是自增主键没有持久化。</p>
<p>​     在MySQL 5.7系统中，对于自增主键的分配规则，是由 InnoDB 数据字典内部一个 计数器 来决定的，而该计数器只在 内存中维护 ，并不会持久化到磁盘中。当数据库重启时，该<strong>计数器会被初始化。</strong></p>
<p>​     <strong>对于MySQL8.0版本：</strong> </p>
<p><img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/20221007123854579.png" alt="img"></p>
<p><img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/20221007123855581.png" alt="img"></p>
<p> 然后重启MySQL80服务器：（以管理员的身份运行）</p>
<p><img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/20221007123855585.png" alt="img"></p>
<p> <img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/20221007123855587.png" alt="img"></p>
<p>​    从结果可以看出，自增变量已经持久化了。</p>
<p>​    MySQL 8.0将自增主键的计数器持久化到 重做日志 中。每次计数器发生改变，都会将其写入重做日志中。如果数据库重启，InnoDB 会根据重做日志中的信息来初始化计数器的内存值。</p>
<h2 id="FOREIGN-KEY-约束"><a href="#FOREIGN-KEY-约束" class="headerlink" title="FOREIGN KEY 约束"></a><strong>FOREIGN KEY 约束</strong></h2><h3 id="作用-4"><a href="#作用-4" class="headerlink" title="作用"></a><strong>作用</strong></h3><p>​    <strong>限定某个表的某个字段的引用完整性。</strong></p>
<p>​    比如：员工表的员工所在部门的选择，必须在部门表能找到对应的部分。</p>
<p><img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/20221007123856603.png" alt="img"></p>
<h3 id="关键字-4"><a href="#关键字-4" class="headerlink" title="关键字"></a><strong>关键字</strong></h3><p>​    <strong>FOREIGN KEY</strong></p>
<h3 id="主表和从表-x2F-父表和子表"><a href="#主表和从表-x2F-父表和子表" class="headerlink" title="主表和从表&#x2F;父表和子表"></a><strong>主表和从表&#x2F;父表和子表</strong></h3><p>​    <strong>主表（父表）：被引用的表，被参考的表</strong></p>
<p>​    <em><strong>*从表（子表）：引用别人的表，参考别人的表*</strong></em></p>
<p>​    例如：员工表的员工所在部门这个字段的值要参考部门表：部门表是主表，员工表是从表。</p>
<p>​    例如：学生表、课程表、选课表：选课表的学生和课程要分别参考学生表和课程表，学生表和课程表是主表，选课表是从表。</p>
<h3 id="特点-3"><a href="#特点-3" class="headerlink" title="特点"></a><strong>特点</strong></h3><p>​    <strong>1. 从表的外键列，</strong> <strong>必须引用&#x2F;参考主表的主键或唯一约束的列</strong></p>
<p>​      <em><strong>*因为被依赖&#x2F;被参考的值必须是唯一的*</strong></em></p>
<p>​    <em>*<em>*2. 在创建外键约束时，如果不给外键约束命名，*</em>*<em>默认名不是列名，而是自动产生一个外键名*</em>*<em>（例如 student_ibfk_1;），也可以指定外键约束名。*</em>*</em></p>
<p>​    <em><strong>*3.** **创建(CREATE)表时就指定外键约束的话，先创建主表，再创建从表*</strong></em></p>
<p>​    <em><strong>*4.** **删表时，先删从表（或先删除外键约束），再删除主表*</strong></em></p>
<p>​    <em><strong>*5.** **当主表的记录被从表参照时，主表的记录将不允许删除，如果要删除数据，需要先删除从表中依赖 该记录的数据，然后才可以删除主表的数据*</strong></em></p>
<p>​    <em>*<em>*6. 在“从表*</em>*<em>”*</em>*<em>中指定外键约束，并且*</em>*<em>一个表可以建立多个外键约束*</em>*</em></p>
<p>​    <em>*<em>*7. 从表的外键列与主表被参照的列名字可以不相同，但是*</em>*<em>数据类型*</em>*<em>必须一样，逻辑意义一致。如果类型不一样，创建子表时，就会出现错误。*</em>*</em></p>
<p>​    <strong>8.</strong> <em>*<em>*当创建外键约束时，系统默认会在所在的列上建立对应的普通索引*</em>*<em>。但是索引名是外键的约束名。（根据外键查询效率很高）*</em>*</em></p>
<p>​    <em><strong>*9.** *<em>删除外键约束后，必须*</em> *<em>手动*</em> **删除对应的索引*</strong></em></p>
<h3 id="添加外键约束"><a href="#添加外键约束" class="headerlink" title="添加外键约束"></a>添加外键约束</h3><h4 id="在-create-table-时添加外键约束"><a href="#在-create-table-时添加外键约束" class="headerlink" title="在 create table 时添加外键约束"></a>在 create table 时添加外键约束</h4><p><strong>语法格式：</strong></p>
<p>​     <strong>create table</strong> <em><strong>*主表名称(*</strong></em></p>
<p>​    <em>*<em>*字段1 数据类型*</em> *<em>primary key*</em>**,*</em>**</p>
<p>​    <em><strong>*字段2 数据类型*</strong></em></p>
<p>​    <em><strong>*);*</strong></em></p>
<p>​    <em><strong>*create table** **从表名称(*</strong></em></p>
<p>​    <em>*<em>*字段1 数据类型*</em> *<em>primary key*</em>**,*</em>**</p>
<p>​    <em><strong>*字段2 数据类型,*</strong></em></p>
<p>​    <em>*<em>*[*</em>*<em>CONSTRAINT*</em> **&lt;****外键约束名称****&gt;]*</em> *<em>FOREIGN KEY*</em>*<em>（从表的某个字段*</em>*<em>)*</em> *<em>references*</em> *<em>主表名*</em>*<em>(*</em>*<em>被参考字段) [*</em>*<em>on update*</em> *<em>xx][*</em>*<em>on delete*</em> *<em>xx];*</em>**</p>
<p>​    <em><strong>*);*</strong></em> </p>
<p><strong>– FOREIGN KEY: 在表级指定子表中的列</strong></p>
<p><strong>– REFERENCES: 标示在父表中的列</strong></p>
<p><em>*<em>*(*</em>*<em>从表的某个字段*</em>**)*</em>*<em>的数据类型必须与主表名*</em>*<em>(*</em>*<em>被参考字段*</em>*<em>)*</em>*<em>的数据类型一致，逻辑意义也一样*</em>**</p>
<p><em>*<em>*(*</em>*<em>从表的某个字段*</em>**)*</em>*<em>的字段名可以与主表名*</em>*<em>(*</em>*<em>被参考字段*</em>*<em>)*</em>*<em>的字段名一样，也可以不一样*</em>**</p>
<p><strong>举例：</strong></p>
<p>正确的创建方式：</p>
<p><img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/20221007123856679.png" alt="img"></p>
<p><img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/20221007123857681.png" alt="img"></p>
<p> 错误的创建方式：</p>
<p><img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/20221007123857685.png" alt="img"></p>
<p> 添加数据：</p>
<p><img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/20221007123857689.png" alt="img"></p>
<p> 修改数据：</p>
<p><img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/20221007123858693.png" alt="img"></p>
<p> 删除数据：</p>
<p><img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/20221007123858697.png" alt="img"></p>
<h4 id="在ALTER-TABLE-时添加外键约束"><a href="#在ALTER-TABLE-时添加外键约束" class="headerlink" title="在ALTER TABLE 时添加外键约束"></a>在ALTER TABLE 时添加外键约束</h4><p>​    一般情况下，表与表的关联都是提前设计好了的，因此，会在创建表的时候就把外键约束定义好。不过，如果需要修改表的设计（比如添加新的字段，增加新的关联关系），但没有预先定义外键约束，那么，就要用修改表的方式来补充定义。</p>
<p><em><strong>*语法格式：*</strong></em></p>
<p>​    <em><strong>*ALTER TABLE** **从表名*</strong></em></p>
<p>​    <em>*<em>*ADD*</em> **[*</em>*<em>CONSTRAINT*</em> *<em>约束名*</em>*<em>]*</em> *<em>FOREIGN KEY*</em> *<em>(*</em>*<em>从表的字段*</em>*<em>)*</em> *<em>REFERENCES*</em> *<em>主表名*</em>*<em>(*</em>*<em>被引用 字段) [*</em>*<em>on update*</em> *<em>xx][*</em>*<em>on delete*</em> *<em>xx];*</em>**</p>
<p><img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/20221007123859713.png" alt="img"></p>
<h3 id="约束等级（级联）"><a href="#约束等级（级联）" class="headerlink" title="约束等级（级联）"></a><strong>约束等级（级联）</strong></h3><p>​    <em><strong>*1. Cascade*</strong></em> <strong>方式</strong> ：在父表上 update&#x2F;delete 记录时，同步 update&#x2F;delete 掉子表的匹配记录</p>
<p>​    <em><strong>*2. Set null方式*</strong></em> ：在父表上 update&#x2F;delete 记录时，将子表上匹配记录的列设为 null ，但是要注意子 表的外键列不能为not null</p>
<p>​    \3. No action方式 ：如果子表中有匹配的记录，则不允许对父表对应候选键进行 update&#x2F;delete 操作</p>
<p>​    4 .Restrict方式 （默认） ：同no action ， 都是立即检查外键约束</p>
<p>​    \5. Set default方式 （在可视化工具 SQLyog 中可能显示空白）：父表有变更时，子表将外键列设置成一个默认的值，但Innodb 不能识别</p>
<p>​    <em><strong>*如果没有指定等级，就相当于Restrict方式。*</strong></em></p>
<p>​    <em><strong>*对于外键约束，最好是采用:** *<em>ON UPDATE CASCADE ON DELETE RESTRICT*</em> **的方式。*</strong></em></p>
<p><strong>举例：（以 *<em>on update cascade on delete set null*</em></strong>  **<em>*为例*<em>）</em></em></p>
<p>1.创建表</p>
<p><img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/20221007123859737.png" alt="img"></p>
<p>2.添加数据</p>
<p><img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/20221007123859741.png" alt="img"></p>
<p>3.修改数据 </p>
<p><img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/20221007123859745.png" alt="img"></p>
<p>4.删除数据 </p>
<p><img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/20221007123900749.png" alt="img"></p>
<h3 id="删除外键约束"><a href="#删除外键约束" class="headerlink" title="删除外键约束"></a><strong>删除外键约束</strong></h3><p><strong>流程如下：</strong></p>
<p><em>*<em>*(*</em>*<em>1*</em>**)*</em>*<em>第一步先查看约束名和删除外键约束*</em>**</p>
<p>​    <em><strong>*#查看某个表的约束名*</strong></em></p>
<p>​    <em>*<em>*SELECT*</em> ***</em>* *<em>FROM*</em> *<em>information_schema*</em>*<em>.table_constraints*</em>**</p>
<p>​    <em>*<em>*WHERE table_name*</em> **&#x3D;*</em> *<em>‘*</em>*<em>表名称*</em>*<em>‘*</em>*<em>;*</em>**</p>
<p>​    <em><strong>*ALTER TABLE** **从表名*</strong></em></p>
<p>​    <em>*<em>*DROP FOREIGN KEY*</em> *<em>外键约束名*</em>**;*</em>**</p>
<p>（ <em>*<em>*2*</em>*<em>）第二步查看索引名和删除索引。（注意，只能手动删除）*</em>*</em></p>
<p>​    <em>*<em>*#*</em>*<em>查看某个表的索引名*</em>*</em></p>
<p>​    <em>*<em>*SHOW INDEX FROM*</em> *<em>表名称*</em>**;*</em>**</p>
<p>​    <em>*<em>*ALTER TABLE*</em> *<em>从表名*</em> *<em>DROP INDEX*</em> *<em>索引名*</em>**;*</em>**</p>
<p><em><strong>*注意：** *<em>删除外键约束后，必须*</em> *<em>手动*</em> **删除对应的索引*</strong></em></p>
<p><strong>举例：</strong></p>
<p><img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/20221007123900781.png" alt="img"></p>
<h3 id="开发场景"><a href="#开发场景" class="headerlink" title="开发场景"></a><strong>开发场景</strong></h3><p><strong>问题</strong> <strong>1</strong> <strong>：如果两个表之间有关系（一对一、一对多），比如：员工表和部门表（一对多），它们之间是否</strong> <strong>一定要建外键约束？</strong></p>
<p>​    答：不是的</p>
<p><strong>问题</strong> <strong>2</strong> <strong>：建和不建外键约束有什么区别？</strong></p>
<p>​    答：建外键约束，你的操作（创建表、删除表、添加、修改、删除）会受到限制，从语法层面受到限制。</p>
<p>​    例如：在员工表中不可能添加一个员工信息，它的部门的值在部门表中找不到。</p>
<p>​    不建外键约束，你的操作（创建表、删除表、添加、修改、删除）不受限制，要保证数据的 引用完整 性 ，只能依 靠程序员的自觉 ，或者是 在 Java 程序中进行限定 。例如：在员工表中，可以添加一个员工的信息，它的部门指定为一个完全不存在的部门。</p>
<p><strong>问题</strong> <strong>3</strong> <strong>：那么建和不建外键约束和查询有没有关系？</strong></p>
<p>​    答：没有</p>
<p><strong>拓展：</strong></p>
<p>​    在 MySQL 里，外键约束是有成本的，需要消耗系统资源。对于大并发的 SQL 操作，有可能会不适 合。比如大型网站的中央数据库，可能会 因为外键约束的系统开销而变得非常慢 。所以， MySQL 允 许你不使用系统自带的外键约束，在 应用层面 完成检查数据一致性的逻辑。也就是说，即使你不 用外键约束，也要想办法通过应用层面的附加逻辑，来实现外键约束的功能，确保数据的一致性。</p>
<h3 id="阿里开发规范"><a href="#阿里开发规范" class="headerlink" title="阿里开发规范"></a><strong>阿里开发规范</strong></h3><p><em><strong>*【** *<em>强制*</em> **】不得使用外键与级联，一切外键概念必须在应用层解决。*</strong></em></p>
<p>​    </p>
<p>​    说明：（概念解释）学生表中的 student_id 是主键，那么成绩表中的 student_id 则为外键。如果更新学 生表中的 student_id ，同时触发成绩表中的 student_id 更新，即为级联更新。外键与级联更新适用于 单机低并发 ，不适合 分布式 、 高并发集群 ；级联更新是强阻塞，存在数据库 更新风暴 的风险；外键影响 数据库的 插入速度 。</p>
<h2 id="CHECK-约束"><a href="#CHECK-约束" class="headerlink" title="CHECK 约束"></a><strong>CHECK 约束</strong></h2><h3 id="作用-5"><a href="#作用-5" class="headerlink" title="作用"></a><strong>作用</strong></h3><p>​    检<strong>查某个字段的值是否符号xx</strong> <em><strong>*要求，一般指的是值的范围*</strong></em></p>
<h3 id="关键字-5"><a href="#关键字-5" class="headerlink" title="关键字"></a><strong>关键字</strong></h3><p>​    <em><strong>*CHECK*</strong></em></p>
<h3 id="说明：MySQL-5-7-不支持"><a href="#说明：MySQL-5-7-不支持" class="headerlink" title="说明：MySQL 5.7 不支持"></a><strong>说明：MySQL 5.7 不支持</strong></h3><p>​    <strong>MySQL5.7 可以使用</strong> <em>*<em>*check*</em>*<em>约束，但*</em>*<em>check*</em>*<em>约束对数据验证没有任何作用。添加数据时，没有任何错误或警告。*</em>*</em></p>
<p>​    <em>*<em>*MySQL 8.0*</em>*<em>中可以使用*</em>*<em>check*</em>*<em>约束了*</em>*</em> 。</p>
<h3 id="添加CHECK-约束"><a href="#添加CHECK-约束" class="headerlink" title="添加CHECK 约束"></a>添加<strong>CHECK 约束</strong></h3><p><img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/20221007123900833.png" alt="img"></p>
<h2 id="DEFAULT约束"><a href="#DEFAULT约束" class="headerlink" title="DEFAULT约束"></a><strong>DEFAULT约束</strong></h2><h3 id="作用-6"><a href="#作用-6" class="headerlink" title="作用"></a><strong>作用</strong></h3><p>​    <strong>给某个字段&#x2F;</strong> <em><strong>*某列指定默认值，一旦设置默认值，在插入数据时，如果此字段没有显式赋值，则赋值为默认值。*</strong></em></p>
<h3 id="关键字-6"><a href="#关键字-6" class="headerlink" title="关键字"></a><strong>关键字</strong></h3><p>​    <strong>DEFAULT</strong></p>
<h3 id="添加默认值约束"><a href="#添加默认值约束" class="headerlink" title="添加默认值约束"></a>添加默认值约束</h3><h4 id="在-CREATE-TABLE时添加默认值约束"><a href="#在-CREATE-TABLE时添加默认值约束" class="headerlink" title="在 CREATE TABLE时添加默认值约束"></a>在 CREATE TABLE时添加默认值约束</h4><p><strong>语法格式：</strong></p>
<p>​    <strong>方式1：</strong></p>
<p>​        <strong>create table</strong> <em>*<em>*表名称*</em>**(*</em>**</p>
<p>​        <em>*<em>*字段名 数据类型*</em> *<em>primary key*</em>**,*</em>**</p>
<p>​        <em>*<em>*字段名 数据类型*</em> *<em>unique key not*</em> *<em>null*</em>**,*</em>**</p>
<p>​        <em>*<em>*字段名 数据类型*</em> *<em>unique key*</em>**,*</em>**</p>
<p>​        <em>*<em>*字段名 数据类型*</em> *<em>not*</em> *<em>null*</em> *<em>default*</em> *<em>默认值*</em>**,*</em>**</p>
<p>​        <em><strong>*);*</strong></em></p>
<p>​    <strong>方式2：</strong></p>
<p>​        <strong>create table</strong> <em>*<em>*表名称*</em>**(*</em>**</p>
<p>​        <em>*<em>*字段名 数据类型*</em> *<em>default*</em> *<em>默认值*</em> **,*</em>**</p>
<p>​        <em>*<em>*字段名 数据类型*</em> *<em>not*</em> *<em>null*</em> *<em>default*</em> *<em>默认值*</em>**,*</em>**</p>
<p>​        <em>*<em>*字段名 数据类型*</em> *<em>not*</em> *<em>null*</em> *<em>default*</em> *<em>默认值*</em>**,*</em>**</p>
<p>​        <em>*<em>*primary key*</em>**(*</em>*<em>字段名*</em>*<em>),*</em>**</p>
<p>​        <em>*<em>*unique key*</em>**(*</em>*<em>字段名*</em>*<em>)*</em>**</p>
<p>​        <em><strong>*);*</strong></em></p>
<p>​    <em><strong>*说明：默认值约束一般不在唯一键和主键列上加*</strong></em></p>
<p><strong>举例：</strong></p>
<p><img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/20221007123900887.png" alt="img"></p>
<h4 id="在-ALTER-TABLE时添加默认值约束"><a href="#在-ALTER-TABLE时添加默认值约束" class="headerlink" title="在 ALTER TABLE时添加默认值约束"></a>在 ALTER TABLE时添加默认值约束</h4><p><strong>语法格式：</strong></p>
<p>​    <strong>alter table</strong> <em>*<em>*表名称*</em> *<em>modify*</em> *<em>字段名 数据类型*</em> *<em>default*</em> *<em>默认值*</em>**;*</em>**</p>
<p>​    <em><strong>*alter table** *<em>表名称*</em> *<em>modify*</em> *<em>字段名 数据类型*</em> *<em>default*</em> *<em>默认值*</em> *<em>not*</em> **null*</strong></em> <strong>;</strong></p>
<p><em><strong>*注：*</strong></em></p>
<p>​    *<em>1.*<em>如果这个字段原来有非空约束，你还保留非空约束，那么在加默认值约束时，还得保留非空约束，否则非空约束就被*</em>*<em>删除了。*</em></em>*</p>
<p>​    <em>*<em>*2.同理，在给某个字段加非空约束也一样，如果这个字段原来有默认值约束，你想保留，也要在modify*</em>*<em>语句中保留默认值约束，否则就删除了。*</em>*</em></p>
<p><strong>举例：</strong></p>
<p><img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/20221007123901907.png" alt="img"></p>
<h3 id="删除默认值约束"><a href="#删除默认值约束" class="headerlink" title="删除默认值约束"></a><strong>删除默认值约束</strong></h3><p><strong>语法格式：</strong></p>
<p>​    <em><strong>*1.删除默认值约束，也不保留非空约束*</strong></em></p>
<p>​        <strong>alter table</strong> <em>*<em>*表名称*</em> *<em>modify*</em> *<em>字段名 数据类型*</em> **;*</em>**</p>
<p>​    <em><strong>*2.删除默认值约束，保留非空约束*</strong></em></p>
<p>​        <strong>alter table</strong> <em><strong>*表名称** *<em>modify*</em> *<em>字段名 数据类型*</em> *<em>not*</em> **null*</strong></em> <strong>;</strong> </p>
<p><strong>举例：</strong></p>
<p><img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/20221007123901925.png" alt="img"></p>
<h2 id="面试"><a href="#面试" class="headerlink" title="面试"></a><strong>面试</strong></h2><p><strong>面试</strong> <strong>1</strong> <strong>、为什么建表时，加</strong> <strong>not null default ‘’</strong> <strong>或</strong> <strong>default 0</strong></p>
<p>​    答：不想让表中出现null 值。</p>
<p><strong>面试</strong> <strong>2</strong> <strong>、为什么不想要</strong> <strong>null</strong> <strong>的值</strong></p>
<p>​    答: （1）不好比较。 null 是一种特殊值，比较时只能用专门的 is null 和 is not null 来比较。碰到运算符，通常返回null 。</p>
<p>​      （2）效率不高。影响提高索引效果。因此，我们往往在建表时 not null default ‘’ 或 default 0</p>
<p><strong>面试</strong> <strong>3</strong> <strong>、带</strong> <strong>AUTO_INCREMENT</strong> <strong>约束的字段值是从</strong> <strong>1</strong> <strong>开始的吗？</strong></p>
<p>​    <strong>在MySQL</strong> <em>*<em>*中，默认*</em>*<em>AUTO_INCREMENT*</em>*<em>的初始 值是1*</em>*<em>，每新增一条记录，字段值自动加*</em>*<em>1*</em>*</em> <strong>。</strong>设置自增属性（AUTO_INCREMENT）的时候，还可以指定第 一条插入记录的自增字段的值，这样新插入的记录的自增字段值从初始值开始递增，如在表中插入第一 条记录，同时指定id 值为 5 ，则以后插入的记录的 id 值就会从 6 开始往上增加。添加主键约束时，往往需要 设置字段自动增加属性。</p>
<p><strong>面试</strong> <strong>4</strong> <strong>、并不是每个表都可以任意选择存储引擎？</strong> 外键约束（</p>
<p>​    <strong>FOREIGN KEY）不能跨引擎使用。(主表和从表用的引擎要相同)</strong></p>
<p>​    MySQL支持多种存储引擎，每一个表都可以指定一个不同的存储引擎，需要注意的是：外键约束是用来保证数据的参照完整性的，如果表之间需要关联外键，却指定了不同的存储引擎，那么这些表之间是不能创建外键约束的。所以说，存储引擎的选择也不完全是随意的。</p>
<h1 id="MySQL-约束练习"><a href="#MySQL-约束练习" class="headerlink" title="MySQL 约束练习"></a>MySQL 约束练习</h1><h2 id="练习1"><a href="#练习1" class="headerlink" title="练习1"></a><strong>练习1</strong></h2><p>已经存在数据库 test04_emp ，两张表 emp2 和 dept2</p>
<p><img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/20221007123901957.png" alt="img"></p>
<h3 id="向表emp2的id列中添加PRIMARY-KEY约束"><a href="#向表emp2的id列中添加PRIMARY-KEY约束" class="headerlink" title="向表emp2的id列中添加PRIMARY KEY约束"></a>向表emp2的id列中添加PRIMARY KEY约束</h3><p><img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/20221007123902963.png" alt="img"></p>
<h3 id="向表dept2的id列中添加PRIMARY-KEY约束"><a href="#向表dept2的id列中添加PRIMARY-KEY约束" class="headerlink" title="向表dept2的id列中添加PRIMARY KEY约束"></a>向表dept2的id列中添加PRIMARY KEY约束</h3><p><img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/20221007123902969.png" alt="img"></p>
<h3 id="向表emp2中添加列dept-id，并在其中定义FOREIGN-KEY约束，与之相关联的列是dept2表中的id列。"><a href="#向表emp2中添加列dept-id，并在其中定义FOREIGN-KEY约束，与之相关联的列是dept2表中的id列。" class="headerlink" title="向表emp2中添加列dept_id，并在其中定义FOREIGN KEY约束，与之相关联的列是dept2表中的id列。"></a>向表emp2中添加列dept_id，并在其中定义FOREIGN KEY约束，与之相关联的列是dept2表中的id列。</h3><p><img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/20221007123902975.png" alt="img"></p>
<h2 id="练习2"><a href="#练习2" class="headerlink" title="练习2"></a><strong>练习2</strong></h2><p>承接《第11章_数据处理之增删改》的综合案例。</p>
<h3 id="创建数据库test01-library2"><a href="#创建数据库test01-library2" class="headerlink" title="创建数据库test01_library2"></a>创建数据库test01_library2</h3><p><img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/20221007123902987.png" alt="img"></p>
<h3 id="创建表-books，表结构如下："><a href="#创建表-books，表结构如下：" class="headerlink" title="创建表 books，表结构如下："></a>创建表 books，表结构如下：</h3><p><img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/20221007123903993.png" alt="img"></p>
<p><img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/20221007123903997.png" alt="img"></p>
<h3 id="使用ALTER语句给books按如下要求增加相应的约束"><a href="#使用ALTER语句给books按如下要求增加相应的约束" class="headerlink" title="使用ALTER语句给books按如下要求增加相应的约束"></a>使用ALTER语句给books按如下要求增加相应的约束</h3><h3 id=""><a href="#" class="headerlink" title=""></a><img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/202210071239031001.png" alt="img"></h3><p><img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/202210071239041003.png" alt="img"></p>
<h2 id="练习3"><a href="#练习3" class="headerlink" title="练习3"></a>练习3</h2><h3 id="创建数据库test04-company"><a href="#创建数据库test04-company" class="headerlink" title="创建数据库test04_company  "></a>创建数据库test04_company  <img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/202210071239041009.png" alt="img"></h3><h3 id="-1"><a href="#-1" class="headerlink" title=""></a></h3><h3 id="按照下表给出的表结构在test04-company数据库中创建两个数据表offices和employees"><a href="#按照下表给出的表结构在test04-company数据库中创建两个数据表offices和employees" class="headerlink" title="按照下表给出的表结构在test04_company数据库中创建两个数据表offices和employees  "></a>按照下表给出的表结构在test04_company数据库中创建两个数据表offices和employees  <img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/202210071239041013.png" alt="img"></h3><p><img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/202210071239041015.png" alt="img"></p>
<p><img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/202210071239051017.png" alt="img"></p>
<h3 id="将表employees的mobile字段修改到officeCode字段后面"><a href="#将表employees的mobile字段修改到officeCode字段后面" class="headerlink" title="将表employees的mobile字段修改到officeCode字段后面"></a>将表employees的mobile字段修改到officeCode字段后面</h3><p><img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/202210071239051023.png" alt="img"></p>
<h3 id="将表employees的birth字段改名为employee-birth"><a href="#将表employees的birth字段改名为employee-birth" class="headerlink" title="将表employees的birth字段改名为employee_birth"></a>将表employees的birth字段改名为employee_birth</h3><p><img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/202210071239051029.png" alt="img"></p>
<h3 id="修改sex字段，数据类型为CHAR-1-，非空约束"><a href="#修改sex字段，数据类型为CHAR-1-，非空约束" class="headerlink" title="修改sex字段，数据类型为CHAR(1)，非空约束"></a>修改sex字段，数据类型为CHAR(1)，非空约束</h3><p><img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/202210071239051035.png" alt="img"></p>
<h3 id="删除字段note"><a href="#删除字段note" class="headerlink" title="删除字段note"></a>删除字段note</h3><p><img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/202210071239061041.png" alt="img"></p>
<h3 id="增加字段名favoriate-activity，数据类型为VARCHAR-100"><a href="#增加字段名favoriate-activity，数据类型为VARCHAR-100" class="headerlink" title="增加字段名favoriate_activity，数据类型为VARCHAR(100)"></a>增加字段名favoriate_activity，数据类型为VARCHAR(100)</h3><p><img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/202210071239061047.png" alt="img"></p>
<h3 id="将表employees名称修改为employees-info"><a href="#将表employees名称修改为employees-info" class="headerlink" title="将表employees名称修改为employees_info"></a>将表employees名称修改为employees_info</h3><p><img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/202210071239061053.png" alt="img"></p>
<h2 id="2-拓展练习"><a href="#2-拓展练习" class="headerlink" title="2.拓展练习"></a>2.拓展练习</h2><h3 id="创建数据库：test-company"><a href="#创建数据库：test-company" class="headerlink" title="创建数据库：test_company"></a>创建数据库：test_company</h3><p><img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/202210071239071061.png" alt="img"></p>
<h3 id="在此数据库下创建如下3表，数据类型，宽度，是否为空根据实际情况自己定义。"><a href="#在此数据库下创建如下3表，数据类型，宽度，是否为空根据实际情况自己定义。" class="headerlink" title="在此数据库下创建如下3表，数据类型，宽度，是否为空根据实际情况自己定义。"></a>在此数据库下创建如下3表，数据类型，宽度，是否为空根据实际情况自己定义。</h3><p>A ． 部门表（department ） ：部门编号（depid），部门名称（depname），部门简介（deinfo）；其中 部门编号为主键。</p>
<p>B ． 雇员表（emoloyee ） ：雇员编号（empid），姓名（name），性别（sex），职称（title），出生日 期（birthday），所在部门编号（depid）；其中</p>
<p>​    </p>
<p>​    雇员编号为主键；</p>
<p>​    部门编号为外键，外键约束等级为（on update cascade 和on delete set null ）；</p>
<p>​    性别默认为男；</p>
<p>C ． 工资表（salary ） ：雇员编号（empid），基本工资（basesalary），职务工资（titlesalary），扣 除（deduction）。其中雇员编号为主键。</p>
<p><img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/202210071239071083.png" alt="img"></p>
<h3 id="给工资表（salary）的雇员编号（empid）增加外键约束，外键约束等级为（on-update-cascade-和on-delete-cascade）"><a href="#给工资表（salary）的雇员编号（empid）增加外键约束，外键约束等级为（on-update-cascade-和on-delete-cascade）" class="headerlink" title="给工资表（salary）的雇员编号（empid）增加外键约束，外键约束等级为（on update cascade 和on delete cascade）"></a>给工资表（salary）的雇员编号（empid）增加外键约束，外键约束等级为（on update cascade 和on delete cascade）</h3><p><img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/202210071239071089.png" alt="img"></p>
<h3 id="添加数据如下："><a href="#添加数据如下：" class="headerlink" title="添加数据如下："></a>添加数据如下：</h3><p><img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/202210071239071095.png" alt="img"></p>
<p><img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/202210071239081097.png" alt="img"></p>
<p> <img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/202210071239081099.png" alt="img"></p>
<p> <img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/202210071239081101.png" alt="img"></p>
<p><img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/202210071239081103.png" alt="img"> </p>
<p> <img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/202210071239091105.png" alt="img"></p>
<h3 id="查询出每个雇员的雇员编号，姓名，职称，所在部门名称，应发工资（基本工资-职务工资），实发工资（基本工资-职务工资-扣除）。"><a href="#查询出每个雇员的雇员编号，姓名，职称，所在部门名称，应发工资（基本工资-职务工资），实发工资（基本工资-职务工资-扣除）。" class="headerlink" title="查询出每个雇员的雇员编号，姓名，职称，所在部门名称，应发工资（基本工资+职务工资），实发工资（基本工资+职务工资-扣除）。"></a>查询出每个雇员的雇员编号，姓名，职称，所在部门名称，应发工资（基本工资+职务工资），实发工资（基本工资+职务工资-扣除）。</h3><p><img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/202210071239091111.png" alt="img"></p>
<h3 id="查询销售部门的雇员姓名及其基本工资"><a href="#查询销售部门的雇员姓名及其基本工资" class="headerlink" title="查询销售部门的雇员姓名及其基本工资"></a>查询销售部门的雇员姓名及其基本工资</h3><p><img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/202210071239091117.png" alt="img"></p>
<h3 id="查询姓“张”且年龄小于40的员工的全部信息和年龄"><a href="#查询姓“张”且年龄小于40的员工的全部信息和年龄" class="headerlink" title="查询姓“张”且年龄小于40的员工的全部信息和年龄"></a>查询姓“张”且年龄小于40的员工的全部信息和年龄</h3><p><img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/202210071239101123.png" alt="img"></p>
<h3 id="查询所有男员工的基本工资和职务工资"><a href="#查询所有男员工的基本工资和职务工资" class="headerlink" title="查询所有男员工的基本工资和职务工资"></a>查询所有男员工的基本工资和职务工资</h3><p><img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/202210071239101129.png" alt="img"></p>
<h3 id="查询基本工资低于2000的员工姓名和职称、所在部门名称"><a href="#查询基本工资低于2000的员工姓名和职称、所在部门名称" class="headerlink" title="查询基本工资低于2000的员工姓名和职称、所在部门名称"></a>查询基本工资低于2000的员工姓名和职称、所在部门名称</h3><p><img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/202210071239101135.png" alt="img"> </p>
<h3 id="查询员工总数"><a href="#查询员工总数" class="headerlink" title="查询员工总数"></a>查询员工总数</h3><p><img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/202210071239101139.png" alt="img"></p>
<h3 id="查询部门总数"><a href="#查询部门总数" class="headerlink" title="查询部门总数"></a>查询部门总数</h3><p><img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/202210071239111145.png" alt="img"></p>
<h3 id="查询应发工资的平均工资和最高工资、最低工资"><a href="#查询应发工资的平均工资和最高工资、最低工资" class="headerlink" title="查询应发工资的平均工资和最高工资、最低工资"></a>查询应发工资的平均工资和最高工资、最低工资</h3><p><img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/202210071239111151.png" alt="img"></p>
<h3 id="按照部门统计应发工资的平均工资"><a href="#按照部门统计应发工资的平均工资" class="headerlink" title="按照部门统计应发工资的平均工资"></a>按照部门统计应发工资的平均工资</h3><p><img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/202210071239111157.png" alt="img"></p>
<h3 id="找出部门基本工资的平均工资低于2000的"><a href="#找出部门基本工资的平均工资低于2000的" class="headerlink" title="找出部门基本工资的平均工资低于2000的"></a>找出部门基本工资的平均工资低于2000的</h3><p><img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/202210071239121163.png" alt="img"></p>
<h3 id="按照员工编号、姓名、基本工资、职务工资、扣除，并按照职务升序排列，如果职务工资相同，再按照基本工资升序排列"><a href="#按照员工编号、姓名、基本工资、职务工资、扣除，并按照职务升序排列，如果职务工资相同，再按照基本工资升序排列" class="headerlink" title="按照员工编号、姓名、基本工资、职务工资、扣除，并按照职务升序排列，如果职务工资相同，再按照基本工资升序排列"></a>按照员工编号、姓名、基本工资、职务工资、扣除，并按照职务升序排列，如果职务工资相同，再按照基本工资升序排列</h3><p><img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/202210071239121169.png" alt="img"></p>
<h3 id="查询员工编号、姓名，出生日期，及年龄段。其中，如果80年之前出生的，定为”老年“；80后定为”中年“，90后定为”青壮年“"><a href="#查询员工编号、姓名，出生日期，及年龄段。其中，如果80年之前出生的，定为”老年“；80后定为”中年“，90后定为”青壮年“" class="headerlink" title="查询员工编号、姓名，出生日期，及年龄段。其中，如果80年之前出生的，定为”老年“；80后定为”中年“，90后定为”青壮年“"></a>查询员工编号、姓名，出生日期，及年龄段。其中，如果80年之前出生的，定为”老年“；80后定为”中年“，90后定为”青壮年“</h3><p><img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/202210071239121175.png" alt="img"></p>
<h3 id="查询所有的员工信息，和他所在的部门名称"><a href="#查询所有的员工信息，和他所在的部门名称" class="headerlink" title="查询所有的员工信息，和他所在的部门名称"></a>查询所有的员工信息，和他所在的部门名称</h3><p><img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/202210071239131181.png" alt="img"></p>
<h3 id="查询所有部门信息，和该部门的员工信息"><a href="#查询所有部门信息，和该部门的员工信息" class="headerlink" title="查询所有部门信息，和该部门的员工信息"></a>查询所有部门信息，和该部门的员工信息</h3><p><img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/202210071239131187.png" alt="img"></p>
<h3 id="查询所有职位中含“工程师”的男员工的人数"><a href="#查询所有职位中含“工程师”的男员工的人数" class="headerlink" title="查询所有职位中含“工程师”的男员工的人数"></a>查询所有职位中含“工程师”的男员工的人数</h3><p><img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/202210071239131193.png" alt="img"></p>
<h3 id="查询每个部门的男生和女生的人数和平均基本工资"><a href="#查询每个部门的男生和女生的人数和平均基本工资" class="headerlink" title="查询每个部门的男生和女生的人数和平均基本工资"></a>查询每个部门的男生和女生的人数和平均基本工资</h3><p><img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/202210071239131199.png" alt="img"></p>
<h1 id="MySQL-视图"><a href="#MySQL-视图" class="headerlink" title="MySQL 视图"></a>MySQL 视图</h1><h2 id="常见的数据库对象"><a href="#常见的数据库对象" class="headerlink" title="常见的数据库对象"></a><strong>常见的数据库对象</strong></h2><table>
<thead>
<tr>
<th><em><strong>*对象*</strong></em></th>
<th><em><strong>*描述*</strong></em></th>
</tr>
</thead>
<tbody><tr>
<td><em>*<em>*表*</em>**(TABLE)*</em>**</td>
<td><em><strong>*表是存储数据的逻辑单元，以行和列的形式存在，列就是字段，行就是记录*</strong></em></td>
</tr>
<tr>
<td><em><strong>*数据字典*</strong></em></td>
<td><em>*<em>*就是系统表，存放数据库相关信息的表。系统表的数据通常由数据库系统维护，*</em>*<em>程序员通常不应该修改，只可查看*</em>*</em></td>
</tr>
<tr>
<td><em>*<em>*约束*</em>**(CONSTRAINT)*</em>**</td>
<td><em><strong>*执行数据校验的规则，用于保证数据完整性的规则*</strong></em></td>
</tr>
<tr>
<td><strong>视图(VIEW)</strong></td>
<td><strong>一个或者多个数据表里的数据的逻辑显示，视图并不存储数据</strong></td>
</tr>
<tr>
<td><em>*<em>*索引*</em>**(INDEX)*</em>**</td>
<td><em><strong>*用于提高查询性能，相当于书的目录*</strong></em></td>
</tr>
<tr>
<td><em>*<em>*存储过程*</em>**(PROCEDURE)*</em>**</td>
<td><em><strong>*用于完成一次完整的业务处理，没有返回值，但可通过传出参数将多个值传给调用环境*</strong></em></td>
</tr>
<tr>
<td><em>*<em>*存储函数*</em>**(FUNCTION)*</em>**</td>
<td><em><strong>*用于完成一次特定的计算，具有一个返回值*</strong></em></td>
</tr>
<tr>
<td><em>*<em>*触发器*</em>**(TRIGGER)*</em>**</td>
<td><em>*<em>*相当于一个事件监听器，当数据库发生特定事件后，触发器被触发，完成相应的*</em>*<em>处理*</em>*</em></td>
</tr>
</tbody></table>
<h2 id="视图概述"><a href="#视图概述" class="headerlink" title="视图概述"></a><strong>视图概述</strong></h2><p><img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/202210071239141218.png" alt="img"></p>
<h3 id="为什么使用视图？"><a href="#为什么使用视图？" class="headerlink" title="为什么使用视图？"></a><strong>为什么使用视图？</strong></h3><p>​    视图一方面可以帮我们使用表的一部分而不是所有的表，另一方面也可以针对不同的用户制定不同的查询视图。</p>
<p>​    比如，针对一个公司的销售人员，我们只想给他看部分数据，而某些特殊的数据，比如采购的价格，则不会提供给他。再比如，人员薪酬是个敏感的字段，那么只给某个级别以上的人员开放，其他人的查询视图中则不提供这个字段。</p>
<p>​    刚才讲的只是视图的一个使用场景，实际上视图还有很多作用。最后，我们总结视图的优点。</p>
<h3 id="视图的理解"><a href="#视图的理解" class="headerlink" title="视图的理解"></a><strong>视图的理解</strong></h3><p>​    视图是一种 虚拟表 ，本身是 不具有数据 的，占用很少的内存空间，它是 SQL 中的一个重要概念。</p>
<p>​    <strong>视图建立在已有表的基础上</strong> , 视图赖以建立的这些表称为 <strong>基表</strong> 。</p>
<p><img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/202210071239141236.png" alt="img"></p>
<p>​    <strong>视图的创建和删除只影响视图本身，不影响对应的基表。但是当对视图中的数据进行增加、删除和修改操作时，数据表中的数据会相应地发生变化，反之亦然。</strong></p>
<p>​    向视图提供数据内容的语句为 SELECT 语句 , 可以将视图理解为 <strong>存储起来的</strong> <strong>SELECT</strong> <strong>语句</strong> <strong>（</strong> 在数据库中，视图不会保存数据，数据真正保存在数据表中。当对视图中的数据进行增加、删 除和修改操作时，数据表中的数据会相应地发生变化；反之亦然。 ）</p>
<p>​    视图，是向用户提供基表数据的另一种表现形式。通常情况下，小型项目的数据库可以不使用视图，但是在大型项目中，以及数据表比较复杂的情况下，视图的价值就凸显出来了，它可以帮助我们把经常查询的结果集放到虚拟表中，提升使用效率。理解和使用起来都非常方便。</p>
<p>总结：</p>
<p><img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/202210071239151252.png" alt="img"></p>
<h2 id="创建视图"><a href="#创建视图" class="headerlink" title="创建视图"></a><strong>创建视图</strong></h2><p><strong>语法格式：</strong></p>
<p>​    <strong>在 CREATE VIEW 语句中嵌入子查询</strong></p>
<p>​        <strong>CREATE</strong> <em>*<em>*[*</em>*<em>OR REPLACE*</em>**]*</em>**</p>
<p>​        <em>*<em>*[*</em>*<em>ALGORITHM*</em> **&#x3D; {UNDEFINED | MERGE | TEMPTABLE}]*</em>**</p>
<p>​        <em>*<em>*VIEW*</em> *<em>视图名称*</em> **[(*</em>*<em>字段列表*</em>*<em>)]*</em>**</p>
<p>​        <em><strong>*AS** **查询语句*</strong></em></p>
<p>​        <em>*<em>*[*</em>*<em>WITH*</em> **[*</em>*<em>CASCADED*</em>*<em>|*</em>*<em>LOCAL*</em>*<em>]*</em> *<em>CHECK OPTION*</em>*<em>]*</em>**</p>
<p>​    <strong>精简版：</strong></p>
<p>​        <strong>CREATE VIEW</strong> <em><strong>*视图名称*</strong></em></p>
<p>​        <em><strong>*AS** **查询语句*</strong></em></p>
<p><strong>查询视图语法：</strong></p>
<p>​     <strong>SELECT 字段列表 FROM 视图名称;</strong></p>
<p>准备工作：</p>
<p><img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/202210071239151284.png" alt="img"></p>
<h3 id="创建单表视图"><a href="#创建单表视图" class="headerlink" title="创建单表视图"></a><strong>创建单表视图</strong></h3><h3 id="情况1：视图中的字段与基表中的字段有对应关系"><a href="#情况1：视图中的字段与基表中的字段有对应关系" class="headerlink" title="情况1：视图中的字段与基表中的字段有对应关系"></a><strong>情况1：视图中的字段与基表中的字段有对应关系</strong></h3><p><img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/202210071239151292.png" alt="img"></p>
<p>​    </p>
<p>​    <strong>定义视图中字段名称的方式1： 查询语句中字段的别名会作为视图中的字段名</strong></p>
<p><img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/202210071239161298.png" alt="img"></p>
<p>​     <strong>定义视图中字段名称的方式2：创建视图时 视图名称 后的子段列表为字段名</strong></p>
<p>​    <strong>（前提：小括号里的字段列表需要与SELECT 后的字段列表 一 一对应）</strong></p>
<p><img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/202210071239161306.png" alt="img"></p>
<p>​    </p>
<h3 id="情况二：视图中的字段在基表中可能没有对应的字段"><a href="#情况二：视图中的字段在基表中可能没有对应的字段" class="headerlink" title="情况二：视图中的字段在基表中可能没有对应的字段"></a>情况二：视图中的字段在基表中可能没有对应的字段</h3><p><img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/202210071239161314.png" alt="img"></p>
<p>​    <strong>说明1</strong><em>*<em>*：实际上就是我们在*</em> *<em>SQL*</em> *<em>查询语句的基础上封装了视图*</em> *<em>VIEW*</em>*<em>，这样就会基于*</em> *<em>SQL*</em> *<em>语句的结果集形成一张虚拟表。*</em>*</em></p>
<p>​    <em>*<em>*说明2：在创建视图时，没有在视图名后面指定字段列表，则视图中字段列表默认和*</em>*<em>SELECT*</em>*<em>语句中的字段列表一致。如果SELECT*</em>*<em>语句中给字段取了别名，那么视图中的字段名和别名相同。*</em>*</em></p>
<h3 id="创建多表联合视图"><a href="#创建多表联合视图" class="headerlink" title="创建多表联合视图"></a><strong>创建多表联合视图</strong></h3><p>​    <strong>本质为多表查询后的结果来创建视图</strong></p>
<p><img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/202210071239171330.png" alt="img"></p>
<h3 id="利用视图对数据进行格式化"><a href="#利用视图对数据进行格式化" class="headerlink" title="利用视图对数据进行格式化"></a><strong>利用视图对数据进行格式化</strong></h3><p>​    <strong>我们经常需要输出某个格式的内容，比如我们想输出员工对应的 部门名和其对应的部门号，对应格式为</strong> <strong>:last_name,department_name(department_id)</strong> <strong>，就可以使用视图来完成数据格式化的操作：</strong></p>
<p><img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/202210071239171340.png" alt="img"></p>
<h3 id="基于视图创建视图"><a href="#基于视图创建视图" class="headerlink" title="基于视图创建视图"></a><strong>基于视图创建视图</strong></h3><p>当我们创建好一张视图之后，还可以在它的基础上继续创建视图。</p>
<p><img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/202210071239181350.png" alt="img"></p>
<h2 id="查看视图"><a href="#查看视图" class="headerlink" title="查看视图"></a><strong>查看视图</strong></h2><h3 id="查看数据库的表对象、视图对象"><a href="#查看数据库的表对象、视图对象" class="headerlink" title="查看数据库的表对象、视图对象"></a>查看数据库的表对象、视图对象</h3><p><strong>语法:</strong> </p>
<p>​    <em>*<em>*SHOW TABLES*</em>**;*</em>**</p>
<p><img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/202210071239181362.png" alt="img"></p>
<h3 id="查看视图的结构"><a href="#查看视图的结构" class="headerlink" title="查看视图的结构"></a>查看视图的结构</h3><p><em>*<em>*语法*</em>*<em>：*</em>*</em></p>
<p>​    <em>*<em>*DESC*</em> **&#x2F;*</em> *<em>DESCRIBE*</em> *<em>视图名称*</em>*<em>;*</em>**</p>
<p><img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/202210071239181372.png" alt="img"></p>
<h3 id="查看视图的属性信息"><a href="#查看视图的属性信息" class="headerlink" title="查看视图的属性信息"></a>查看视图的属性信息</h3><p>​     <em><strong>*查看视图信息（显示数据表的存储引擎、版本、数据行数和数据大小等）*</strong></em></p>
<p><em><strong>*语法：*</strong></em></p>
<p>​    <strong>SHOW TABLE STATUS LIKE</strong> <em>*<em>*‘*</em>*<em>视图名称*</em>**’*</em>*<em>\G*</em>**</p>
<p><img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/202210071239191384.png" alt="img"></p>
<p>​     执行结果显示，注释Comment为VIEW，说明该表为视图，其他的信息为NULL，说明这是一个虚表。</p>
<h3 id="查看视图的详细定义信息"><a href="#查看视图的详细定义信息" class="headerlink" title="查看视图的详细定义信息"></a>查看视图的详细定义信息</h3><p><strong>语法：</strong></p>
<p>​    <em>*<em>*SHOW CREATE VIEW*</em> *<em>视图名称*</em>**;*</em>**</p>
<p><img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/202210071239191396.png" alt="img"></p>
<h2 id="更新视图的数据"><a href="#更新视图的数据" class="headerlink" title="更新视图的数据"></a><strong>更新视图的数据</strong></h2><h3 id="一般情况，可以更新的数据"><a href="#一般情况，可以更新的数据" class="headerlink" title="一般情况，可以更新的数据"></a><strong>一般情况，可以更新的数据</strong></h3><p>​    <strong>MySQL支持使用</strong> <em>*<em>*INSERT*</em>*<em>、*</em>*<em>UPDATE*</em>*<em>和*</em>*<em>DELETE*</em>*<em>语句对视图中的数据进行插入、更新和删除操作。当视图中的数据发生变化时，数据表中的数据也会发生变化，反之亦然。*</em>*</em></p>
<p><img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/202210071239191408.png" alt="img"></p>
<p><img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/202210071239201410.png" alt="img"> </p>
<h3 id="不可更新的视图"><a href="#不可更新的视图" class="headerlink" title="不可更新的视图"></a><strong>不可更新的视图</strong></h3><p>​    要使视图可更新，视图中的行和底层基本表中的行之间必须存在 <strong>一对一</strong> 的关系。另外当视图定义出现如下情况时，视图不支持更新操作：</p>
<p>​    <strong>1 .在定义视图的时候指定了“ALGORITHM &#x3D; TEMPTABLE”</strong> <em>*<em>*，视图将不支持*</em>*<em>INSERT*</em>*<em>和*</em>*<em>DELETE*</em>*<em>操作；*</em>*</em></p>
<p>​    <em>*<em>*2. 视图中不包含基表中所有被定义为非空又未指定默认值的列，视图将不支持INSERT*</em>*<em>操作；*</em>*</em></p>
<p>​    <em>*<em>*3. 在定义视图的SELECT*</em>*<em>语句中使用了*</em> *<em>JOIN*</em>*<em>联合查询*</em> *<em>，视图将不支持*</em>*<em>INSERT*</em>*<em>和*</em>*<em>DELETE*</em>*<em>操作；*</em>*</em></p>
<p>​    <em>*<em>*4. 在定义视图的SELECT*</em>*<em>语句后的字段列表中使用了*</em> *<em>数学表达式*</em> *<em>或*</em> *<em>子查询*</em> *<em>，视图将不支持*</em>*<em>INSERT*</em>*<em>，也不支持UPDATE*</em>*<em>使用了数学表达式、子查询的字段值；*</em>*</em></p>
<p>​    <em>*<em>*5. 在定义视图的SELECT*</em>*<em>语句后的字段列表中使用*</em> *<em>DISTINCT*</em> *<em>、*</em> *<em>聚合函数*</em> *<em>、*</em> *<em>GROUP BY*</em> *<em>、*</em> *<em>HAVING*</em> *<em>、*</em>*<em>UNION*</em> *<em>等，视图将不支持*</em>*<em>INSERT*</em>*<em>、*</em>*<em>UPDATE*</em>*<em>、*</em>*<em>DELETE*</em>*<em>；*</em>*</em></p>
<p>​    <em>*<em>*6. 在定义视图的SELECT*</em>*<em>语句中包含了子查询，而子查询中引用了*</em>*<em>FROM*</em>*<em>后面的表，视图将不支持 INSERT、*</em>*<em>UPDATE*</em>*<em>、*</em>*<em>DELETE*</em>*<em>；*</em>*</em></p>
<p>​    <em><strong>*7. 视图定义基于一个** *<em>不可更新视图*</em> **；*</strong></em></p>
<p>​    <em><strong>*8. 常量视图。*</strong></em></p>
<p><strong>举例：</strong></p>
<p><img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/202210071239201438.png" alt="img"></p>
<h2 id="修改、删除视图"><a href="#修改、删除视图" class="headerlink" title="修改、删除视图"></a><strong>修改、删除视图</strong></h2><h3 id="修改视图"><a href="#修改视图" class="headerlink" title="修改视图"></a><strong>修改视图</strong></h3><p><em>*<em>*方式*</em>*<em>1*</em>*<em>：使用*</em>*<em>CREATE*</em> *<em>OR REPLACE*</em> *<em>VIEW*</em> *<em>子句*</em>*<em>修改视图*</em>*</em></p>
<p>​    <strong>CREATE OR REPLACE VIEW</strong> <em><strong>*视图名称[(字段列表)]*</strong></em></p>
<p>​    <em><strong>*AS*</strong></em></p>
<p>​    <strong>查询语句；</strong></p>
<p><em>*<em>*说明：*</em>*<em>CREATE VIEW*</em> *<em>子句中各列的别名应和子查询中各列相对应。*</em>*</em></p>
<p><strong>举例：</strong></p>
<p><img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/202210071239201462.png" alt="img"></p>
<p><em>*<em>*方式*</em>*<em>2*</em>*<em>：*</em>*<em>ALTER VIEW*</em>*</em></p>
<p><em><strong>*修改视图的语法是：*</strong></em>    </p>
<p>​    <strong>ALTER VIEW</strong> <em><strong>*视图名称*</strong></em></p>
<p>​    <em><strong>*AS*</strong></em></p>
<p>​    <em><strong>*查询语句；*</strong></em></p>
<p><strong>举例：</strong></p>
<p><img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/202210071239211478.png" alt="img"></p>
<h3 id="删除视图"><a href="#删除视图" class="headerlink" title="删除视图"></a><strong>删除视图</strong></h3><p>​    <strong>删除视图只是删除视图的定义，并不会删除基表的数据。</strong></p>
<p><strong>语法格式：</strong></p>
<p>​    <strong>1.</strong>  <em>*<em>*DROP VIEW [ IF EXISTS ]*</em> *<em>视图名称*</em>**;*</em>**</p>
<p>​    *<em>2. *<em>DROP VIEW [ IF EXISTS ]*</em> *<em>视图名称*</em>*<em>1,*</em>*<em>视图名称*</em>*<em>2,*</em>*<em>视图名称*</em>*<em>3,…;*</em></em>*</p>
<p><em>*<em>*说明：基于视图*</em>*<em>a*</em>*<em>、*</em>*<em>b*</em>*<em>创建了新的视图*</em>*<em>c*</em>*<em>，如果将视图*</em>*<em>a*</em>*<em>或者视图*</em>*<em>b*</em>*<em>删除，会导致视图*</em>*<em>c*</em>*<em>的查询失败。这样的视图c*</em>*<em>需要手动删除或修改，否则影响使用。*</em>*</em></p>
<p><strong>举例：</strong></p>
<p><img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/202210071239211498.png" alt="img"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><h3 id="视图优点"><a href="#视图优点" class="headerlink" title="视图优点"></a><strong>视图优点</strong></h3><h4 id="操作简单"><a href="#操作简单" class="headerlink" title="操作简单"></a><strong>操作简单</strong></h4><p>​    将经常使用的查询操作定义为视图，可以使开发人员不需要关心视图对应的数据表的结构、表与表之间的关联关系，也不需要关心数据表之间的业务逻辑和查询条件，而只需要简单地操作视图即可，极大简化了开发人员对数据库的操作。</p>
<h4 id="减少数据冗余"><a href="#减少数据冗余" class="headerlink" title="减少数据冗余"></a><strong>减少数据冗余</strong></h4><p>​    视图跟实际数据表不一样，它存储的是查询语句。所以，在使用的时候，我们要通过定义视图的查询语句来获取结果集。而视图本身不存储数据，不占用数据存储的资源，减少了数据冗余。</p>
<h4 id="数据安全"><a href="#数据安全" class="headerlink" title="数据安全"></a><strong>数据安全</strong></h4><p>​    MySQL将用户对数据的 访问限制 在某些数据的结果集上，而这些数据的结果集可以使用视图来实现。用户不必直接查询或操作数据表。这也可以理解为视图具有 隔离性 。视图相当于在用户和实际的数据表之间加了一层虚拟表。</p>
<p><img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/202210071239211518.png" alt="img"></p>
<p>​    同时，MySQL 可以根据权限将用户对数据的访问限制在某些视图上， <strong>用户不需要查询数据表，可以直接</strong> <strong>通过视图获取数据表中的信息</strong> 。这在一定程度上保障了数据表中数据的安全性。</p>
<h4 id="适应灵活多变的需求"><a href="#适应灵活多变的需求" class="headerlink" title="适应灵活多变的需求"></a><strong>适应灵活多变的需求</strong></h4><p>​    当业务系统的需求发生变化后，如果需要改动数据表的结构，则工作量相对较</p>
<p>大，可以使用视图来减少改动的工作量。这种方式在实际工作中使用得比较多。</p>
<h4 id="能够分解复杂的查询逻辑"><a href="#能够分解复杂的查询逻辑" class="headerlink" title="能够分解复杂的查询逻辑"></a><strong>能够分解复杂的查询逻辑</strong></h4><p>​    数据库中如果存在复杂的查询逻辑，则可以将问题进行分解，创建多个视图获取数据，再将创建的多个视图结合起来，完成复杂的查询逻辑。</p>
<h3 id="视图不足"><a href="#视图不足" class="headerlink" title="视图不足"></a>视图不足</h3><p>​    如果我们在实际数据表的基础上创建了视图，那么， <strong>如果实际数据表的结构变更了，我们就需要及时对</strong> <strong>相关的视图进行相应的维护</strong> 。特别是嵌套的视图（就是在视图的基础上创建视图），维护会变得比较复杂， 可读性不好 ，容易变成系统的潜在隐患。因为创建视图的 SQL 查询可能会对字段重命名，也可能包含复杂的逻辑，这些都会增加维护的成本。</p>
<p>实际项目中，如果视图过多，会导致数据库维护成本的问题。</p>
<p>​    所以，在创建视图的时候，你要结合实际项目需求，综合考虑视图的优点和不足，这样才能正确使用视图，使系统整体达到最优。</p>
<h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><h3 id="练习1-1"><a href="#练习1-1" class="headerlink" title="练习1"></a>练习1</h3><h4 id="使用表employees创建视图employee-vu，其中包括姓名（LAST-NAME），员工号（EMPLOYEE-ID），部门-号-DEPARTMENT-ID"><a href="#使用表employees创建视图employee-vu，其中包括姓名（LAST-NAME），员工号（EMPLOYEE-ID），部门-号-DEPARTMENT-ID" class="headerlink" title="使用表employees创建视图employee_vu，其中包括姓名（LAST_NAME），员工号（EMPLOYEE_ID），部门 号(DEPARTMENT_ID)"></a>使用表employees创建视图employee_vu，其中包括姓名（LAST_NAME），员工号（EMPLOYEE_ID），部门 号(DEPARTMENT_ID)</h4><p><img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/202210071239211552.png" alt="img"></p>
<h4 id="显示视图的结构"><a href="#显示视图的结构" class="headerlink" title="显示视图的结构"></a>显示视图的结构</h4><p><img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/202210071239221556.png" alt="img"></p>
<h4 id="查询视图中的全部内容"><a href="#查询视图中的全部内容" class="headerlink" title="查询视图中的全部内容"></a>查询视图中的全部内容</h4><p><img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/202210071239221562.png" alt="img"></p>
<h4 id="将视图中的数据限定在部门号是80的范围内"><a href="#将视图中的数据限定在部门号是80的范围内" class="headerlink" title="将视图中的数据限定在部门号是80的范围内"></a>将视图中的数据限定在部门号是80的范围内</h4><p><img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/202210071239221568.png" alt="img"></p>
<h3 id="练习2-1"><a href="#练习2-1" class="headerlink" title="练习2"></a>练习2</h3><p>给定:</p>
<p><img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/202210071239231576.png" alt="img"></p>
<h4 id="创建视图emp-v1-要求查询电话号码以‘011’开头的员工姓名和工资、邮箱"><a href="#创建视图emp-v1-要求查询电话号码以‘011’开头的员工姓名和工资、邮箱" class="headerlink" title="创建视图emp_v1,要求查询电话号码以‘011’开头的员工姓名和工资、邮箱"></a>创建视图emp_v1,要求查询电话号码以‘011’开头的员工姓名和工资、邮箱</h4><p><img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/202210071239231580.png" alt="img"></p>
<h4 id="要求将视图-emp-v1-修改为查询电话号码以‘011’开头的并且邮箱中包含-e-字符的员工姓名和邮箱、电话号码"><a href="#要求将视图-emp-v1-修改为查询电话号码以‘011’开头的并且邮箱中包含-e-字符的员工姓名和邮箱、电话号码" class="headerlink" title="要求将视图 emp_v1 修改为查询电话号码以‘011’开头的并且邮箱中包含 e 字符的员工姓名和邮箱、电话号码 "></a>要求将视图 emp_v1 修改为查询电话号码以‘011’开头的并且邮箱中包含 e 字符的员工姓名和邮箱、电话号码 <img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/202210071239231584.png" alt="img"></h4><h4 id="向-emp-v1-插入一条记录，是否可以？"><a href="#向-emp-v1-插入一条记录，是否可以？" class="headerlink" title="向 emp_v1 插入一条记录，是否可以？"></a>向 emp_v1 插入一条记录，是否可以？</h4><p><em><strong>*不可以，employees表中含有 emp_v1中不存在 的NOT NULL字段*</strong></em></p>
<h4 id="修改emp-v1中员工的工资，每人涨薪1000"><a href="#修改emp-v1中员工的工资，每人涨薪1000" class="headerlink" title="修改emp_v1中员工的工资，每人涨薪1000"></a>修改emp_v1中员工的工资，每人涨薪1000</h4><p><img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/202210071239241594.png" alt="img"></p>
<h4 id="删除emp-v1中姓名为Olsen的员工"><a href="#删除emp-v1中姓名为Olsen的员工" class="headerlink" title="删除emp_v1中姓名为Olsen的员工"></a>删除emp_v1中姓名为Olsen的员工</h4><p><img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/202210071239241600.png" alt="img"></p>
<h4 id="创建视图emp-v2，要求查询部门的最高工资高于-12000-的部门id和其最高工资"><a href="#创建视图emp-v2，要求查询部门的最高工资高于-12000-的部门id和其最高工资" class="headerlink" title="创建视图emp_v2，要求查询部门的最高工资高于 12000 的部门id和其最高工资"></a>创建视图emp_v2，要求查询部门的最高工资高于 12000 的部门id和其最高工资</h4><p><img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/202210071239241606.png" alt="img"></p>
<h4 id="向-emp-v2-中插入一条记录，是否可以？"><a href="#向-emp-v2-中插入一条记录，是否可以？" class="headerlink" title="向 emp_v2 中插入一条记录，是否可以？"></a>向 emp_v2 中插入一条记录，是否可以？</h4><p><strong>不可以，emp_v2中含有聚合函数处理过的字段</strong></p>
<h4 id="删除刚才的emp-v2-和-emp-v1"><a href="#删除刚才的emp-v2-和-emp-v1" class="headerlink" title="删除刚才的emp_v2 和 emp_v1"></a>删除刚才的emp_v2 和 emp_v1</h4><p><img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/202210071239241616.png" alt="img"></p>
<h1 id="MySQL-存储过程与函数"><a href="#MySQL-存储过程与函数" class="headerlink" title="MySQL 存储过程与函数"></a>MySQL 存储过程与函数</h1><h2 id="存储过程概述"><a href="#存储过程概述" class="headerlink" title="存储过程概述"></a><strong>存储过程概述</strong></h2><h3 id="理解"><a href="#理解" class="headerlink" title="理解"></a><strong>理解</strong></h3><p><strong>含义</strong> ：存储过程的英文是 Stored Procedure 。它的思想很简单，就是一组经过 预先编译 的 SQL 语句的封装。</p>
<p><strong>执行过程：</strong> 存储过程预先存储在 MySQL 服务器上，需要执行的时候，客户端只需要向服务器端发出调用存储过程的命令，服务器端就可以把预先存储好的这一系列 SQL 语句全部执行。</p>
<p><strong>好处</strong> ：</p>
<p>​    <strong>1、简化操作，提高了</strong> <em>*<em>*sql*</em>*<em>语句的重用性，减少了开发程序员的压力*</em>*</em></p>
<p>​    <em><strong>*2、减少操作过程中的失误，提高效率*</strong></em></p>
<p>​    <em><strong>*3、减少网络传输量（客户端不需要把所有的** *<em>SQL*</em> **语句通过网络发给服务器）*</strong></em></p>
<p>​    <em><strong>*4、减少了** *<em>SQL*</em> **语句暴露在网上的风险，也提高了数据查询的安全性*</strong></em></p>
<p><strong>和视图、函数的对比</strong> ：</p>
<p>​    它和视图有着同样的优点，清晰、安全，还可以减少网络传输量。不过它和视图不同，视图是 虚拟表 ，通常不对底层数据表直接操作，而存储过程是程序化的 SQL ，可以 直接操作底层数据表 ，相比于面向集合的操作方式，能够实现一些更复杂的数据处理。</p>
<p>​    一旦存储过程被创建出来，使用它就像使用函数一样简单，我们直接通过调用存储过程名即可。相较于函数，存储过程是 没有返回值 的。</p>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a><strong>分类</strong></h3><p>存储过程的参数类型可以是 IN 、 OUT 和 INOUT 。根据这点分类如下：</p>
<p>​    <strong>1、没有参数（无参数无返回）</strong></p>
<p>​    <em><strong>*2、仅仅带** *<em>IN*</em> **类型（有参数无返回）*</strong></em></p>
<p>​    <em><strong>*3、仅仅带** *<em>OUT*</em> **类型（无参数有返回）*</strong></em></p>
<p>​    <em>*<em>*4、既带*</em> *<em>IN*</em> *<em>又带*</em> *<em>OUT*</em>*<em>（有参数有返回）*</em>*</em></p>
<p>​    <em>*<em>*5、带*</em> *<em>INOUT*</em>*<em>（有参数有返回）*</em>*</em></p>
<p>注意：IN、OUT、INOUT 都可以在一个存储过程中带多个。</p>
<h2 id="创建与调用存储过程"><a href="#创建与调用存储过程" class="headerlink" title="创建与调用存储过程"></a><strong>创建与调用存储过程</strong></h2><h3 id="创建存储过程语法及其分析"><a href="#创建存储过程语法及其分析" class="headerlink" title="创建存储过程语法及其分析"></a><strong>创建存储过程语法及其分析</strong></h3><p><em><strong>*语法：*</strong></em></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> 存储过程名(<span class="keyword">IN</span><span class="operator">|</span><span class="keyword">OUT</span><span class="operator">|</span><span class="keyword">INOUT</span> 参数名 参数类型,...)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[characteristics ...]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        存储过程体</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure>

<p>类似于 Java 中的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">修饰符 返回类型 方法名(参数类型 参数名,...)&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        方法体;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>说明：</strong></p>
<p><em>*<em>*1*</em>*<em>、参数前面的符号的意思*</em>*</em></p>
<p>​    <em><strong>*IN** **：当前参数为输入参数，也就是表示入参；*</strong></em></p>
<p>​    <em><strong>*存储过程只是读取这个参数的值。如果没有定义参数种类，** *<em>默认就是*</em> *<em>IN*</em> **，表示输入参数。*</strong></em></p>
<p>​    <em><strong>*OUT** **：当前参数为输出参数，也就是表示出参；*</strong></em></p>
<p>​    <em><strong>*执行完成之后，调用这个存储过程的客户端或者应用程序就可以读取这个参数返回的值了。*</strong></em></p>
<p>​    <em><strong>*INOUT** **：当前参数既可以为输入参数，也可以为输出参数。<img src="https://latex.codecogs.com/gif.latex?%7B%5Ccolor%7BTeal%7D%20%5Ccdot%20%5Ccdot%20%5Ccdot%20%7D" alt="{\color{Teal} \cdot \cdot \cdot }">*</strong></em></p>
<p>2 、形参类型可以是 MySQL 数据库中的任意类型。</p>
<p>3 、 characteristics 表示创建存储过程时指定的对存储过程的约束条件，其取值信息如下：</p>
<blockquote>
<p><em><strong>*LANGUAGE SQL*</strong></em></p>
<p><em>*<em>*| [*</em>*<em>NOT*</em>**]*</em> *<em>DETERMINISTIC*</em>**</p>
<p><em>*<em>*| {*</em> *<em>CONTAINS SQL*</em> **|*</em> *<em>NO SQL*</em> *<em>|*</em> *<em>READS SQL DATA*</em> *<em>|*</em> *<em>MODIFIES SQL DATA*</em> *<em>}*</em>**</p>
<p><em>*<em>*|*</em> *<em>SQL SECURITY*</em> **{ DEFINER |*</em> *<em>INVOKER*</em> *<em>}*</em>**</p>
<p><em>*<em>*|*</em> *<em>COMMENT*</em> **’string’*</em>**</p>
</blockquote>
<p>​    <img src="https://latex.codecogs.com/gif.latex?%5Cbullet" alt="\bullet"> LANGUAGE SQL ：说明存储过程执行体是由 SQL 语句组成的，当前系统支持的语言为 SQL 。 </p>
<p>​    <img src="https://latex.codecogs.com/gif.latex?%5Cbullet" alt="\bullet"> [NOT] DETERMINISTIC ：指明存储过程执行的结果是否确定。 DETERMINISTIC 表示结果是确定的。每次执行存储过程时，相同的输入会得到相同的输出。NOT DETERMINISTIC 表示结果是不确定的，相同的输入可能得到不同的输出。如果没有指定任意一个值，<strong>默认为NOT DETERMINISTIC</strong> <em><strong>*。*</strong></em> </p>
<p>​    <img src="https://latex.codecogs.com/gif.latex?%5Cbullet" alt="\bullet"> { CONTAINS SQL | NO SQL | READS SQL DATA | MODIFIES SQL DATA } ：指明子程序使 用SQL 语句的限制。</p>
<p>​        （1） CONTAINS SQL 表示当前存储过程的子程序包含SQL 语句，但是并不包含读写数</p>
<p>​                          据的SQL语句；</p>
<p>​        （2） NO SQL 表示当前存储过程的子程序中不包含任何SQL语句；</p>
<p>​        （3） READS SQL DATA 表示当前存储过程的子程序中包含读数据的SQL语句；</p>
<p>​        （4） MODIFIES SQL DATA 表示当前存储过程的子程序中包含写数据的SQL语句。</p>
<p>​        （5）<strong>默认情况下，系统会指定为CONTAINS SQL。</strong></p>
<p>​     <img src="https://latex.codecogs.com/gif.latex?%5Cbullet" alt="\bullet"> SQL SECURITY { DEFINER | INVOKER } ：执行当前存储过程的权限，即指明哪些用户能够执行当前存储过程。</p>
<p>​        （1） DEFINER 表示只有当前存储过程的创建者或者定义者才能执行当前存储过程；</p>
<p>​        （2） INVOKER 表示拥有当前存储过程的访问权限的用户能够执行当前存储过程。</p>
<p>​        （3）如果没有设置相关的值，则MySQL默认指定值为DEFINER 。</p>
<p>​     <img src="https://latex.codecogs.com/gif.latex?%5Cbullet" alt="\bullet"> COMMENT ‘string’ ：注释信息，可以用来描述存储过程。</p>
<p><em>*<em>*4*</em>*<em>、存储过程体中可以有多条*</em> *<em>SQL*</em> *<em>语句，如果仅仅一条*</em>*<em>SQL*</em> *<em>语句，则可以省略*</em> *<em>BEGIN*</em> *<em>和*</em> *<em>END*</em>*</em></p>
<p>编写存储过程并不是一件简单的事情，可能存储过程中需要复杂的 SQL 语句。</p>
<blockquote>
<p>\1. BEGIN …END ： BEGIN…END 中间包含了多个语句，每个语句都以（ ; ）号为结束符。</p>
<p>\2. DECLARE ： DECLARE 用来声明变量，使用的位置在于 BEGIN …END 语句中间，而且需要在其他语句使用之前进行变量的声明。</p>
<p>\3. SET ：赋值语句，用于对变量进行赋值。</p>
<p>\4. SELECT … INTO ：把从数据表中查询的结果存放到变量中，也就是为变量赋值。</p>
</blockquote>
<p><em>*<em>*5*</em>*<em>、需要设置新的结束标记*</em>*</em></p>
<blockquote>
<p>DELIMITER 新的结束标记</p>
</blockquote>
<p>​    因为MySQL 默认的语句结束符号为分号 ‘;’ 。为了避免与存储过程中 SQL 语句结束符相冲突，需要使用 DELIMITER改变存储过程的结束符。</p>
<p>​    比如：“DELIMITER &#x2F;&#x2F;” 语句的作用是将 MySQL 的结束符设置为 &#x2F;&#x2F; ，并以 “END &#x2F;&#x2F;” 结束存储过程。存储过程定 义完毕之后再使用“DELIMITER ;” 恢复默认结束符。 DELIMITER 也可以指定其他符号作为结束符。</p>
<p>​    当使用DELIMITER 命令时，应该避免使用反斜杠（‘\’）字符，因为反斜线是 MySQL 的转义字符。</p>
<p>示例：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">DELIMITER $</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> 存储过程名(<span class="keyword">IN</span><span class="operator">|</span><span class="keyword">OUT</span><span class="operator">|</span><span class="keyword">INOUT</span> 参数名 参数类型,...)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[characteristics ...]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">BEGIN</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">sql</span>语句<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">sql</span>语句<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">END</span> $</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">DELIMITER $</span><br></pre></td></tr></table></figure>

<p>​    <em>*<em>*如果你用的是 Navicat 工具，那么在编写存储过程的时候，*</em>*<em>Navicat*</em> *<em>会自动设置*</em> *<em>DELIMITER*</em> *<em>为其他符号，我们不需要再进行 DELIMITER*</em> *<em>的操作。*</em>*</em></p>
<h3 id="调用存储过程语法"><a href="#调用存储过程语法" class="headerlink" title="调用存储过程语法"></a>调用存储过程语法</h3><p>​    <strong>存储过程有多种调用方法。存储过程必须使用CALL</strong> <em>*<em>*语句调用，并且存储过程和数据库相关，如果要执行其他数据库中的存储过程，需要指定数据库名称，例如CALL dbname.procname*</em>*<em>。*</em>*</em></p>
<p><strong>语法：</strong></p>
<blockquote>
<p><em>*<em>*CALL*</em> *<em>存储过程名*</em>**(*</em>*<em>实参列表*</em>*<em>)*</em>**</p>
</blockquote>
<p><strong>格式：</strong></p>
<p>​     <em>*<em>*1*</em>*<em>、调用*</em>*<em>in*</em>*</em> <strong>模式的参数：</strong></p>
<blockquote>
<p>​     <em>*<em>*CALL*</em> *<em>sp1(*</em>**’*</em>*<em>值*</em>*<em>‘*</em>*<em>);*</em>**</p>
</blockquote>
<p>​    <em><strong>*或*</strong></em></p>
<blockquote>
<p>​    <em><strong>*SET @name :&#x3D; ‘值’； （:&#x3D; 为赋值符）*</strong></em></p>
<p>​    <em>*<em>*CALL*</em> *<em>sp1(*</em>**’*</em>*<em>值*</em>*<em>‘*</em>*<em>);*</em>**</p>
</blockquote>
<p>​    <strong>2、调用</strong> <em>*<em>*out*</em>*<em>模式的参数：*</em>*</em>     </p>
<blockquote>
<p>​    <em>*<em>*[ SET*</em> **@name*</em>*<em>; ]*</em>**</p>
<p>​    <em>*<em>*CALL*</em> *<em>sp1(*</em>**@name*</em>*<em>);*</em>**</p>
<p>​    <em>*<em>*SELECT*</em> **@name*</em>*<em>;*</em>**</p>
</blockquote>
<p>​    <strong>3、调用</strong> <em>*<em>*inout*</em>*<em>模式的参数：*</em>*</em></p>
<blockquote>
<p>​    <strong>SET</strong> <em>*<em>*@name*</em>**&#x3D;*</em>*<em>值*</em>*<em>;*</em>**</p>
<p>​    <em>*<em>*CALL*</em> *<em>sp1(*</em>**@name*</em>*<em>);*</em>**</p>
<p>​    <em>*<em>*SELECT*</em> **@name*</em>*<em>;*</em>**</p>
</blockquote>
<h3 id="代码举例"><a href="#代码举例" class="headerlink" title="代码举例"></a><strong>代码举例</strong></h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 准备工作</span><br><span class="line"><span class="keyword">CREATE</span> DATABASE dbtest15;</span><br><span class="line">USE dbtest15;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> emps </span><br><span class="line"><span class="keyword">As</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> atguigudb.employees ;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> depts</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> atguigudb.departments;</span><br></pre></td></tr></table></figure>

<h4 id="举例-1-：创建存储过程-select-all-emps-，查看-emps-表的所有数据"><a href="#举例-1-：创建存储过程-select-all-emps-，查看-emps-表的所有数据" class="headerlink" title="**举例**1**：创建存储过程**select_all_emps()**，查看* *emps* *表的所有数据**"></a><em>*<em>*举例*</em>*<em>1*</em>*<em>：创建存储过程*</em>*<em>select_all_emps()*</em>*<em>，查看*</em> *<em>emps*</em> *<em>表的所有数据*</em>*</em></h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 类型<span class="number">1</span>：无参的存储过程</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 举例<span class="number">1</span>：创建存储过程select_all_emps()，查看 emps 表的所有数据</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">DELIMITER $</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> select_all_emps()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">BEGIN</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> emps;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">END</span> $</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 调用存储过程</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">CALL</span> select_all_emps();</span><br></pre></td></tr></table></figure>

<p>调用结果：</p>
<p><img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/202210071239251933.png" alt="img"></p>
<p><em>*<em>*举例*</em>*<em>2*</em>*<em>：创建存储过程*</em>*<em>avg_employee_salary()，返回emps中所有员工的平均工资*</em>*</em></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 举例<span class="number">2</span>：创建存储过程avg_employee_salary()，返回emps中所有员工的平均工资</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> avg_employee_salary()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">BEGIN</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="keyword">SELECT</span> <span class="built_in">AVG</span>(salary) <span class="keyword">AS</span> avg_sal</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="keyword">FROM</span> emps;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>

<p>调用结果：</p>
<p><img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/202210071239251981.png" alt="img"></p>
<h4 id="举例3-：创建存储过程-show-max-salary-，用来查看-“emps”表的最高薪资值。"><a href="#举例3-：创建存储过程-show-max-salary-，用来查看-“emps”表的最高薪资值。" class="headerlink" title="**举例3**：创建存储过程**show_max_salary()**，用来查看**“emps”表的最高薪资值。**"></a><em>*<em>*举例3*</em>*<em>：创建存储过程*</em>*<em>show_max_salary()*</em>*<em>，用来查看*</em>*<em>“emps”表的最高薪资值。*</em>*</em></h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 举例<span class="number">3</span>：创建存储过程show_max_salary()，用来查看“emps”表的最高薪资值。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> show_max_salary()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">BEGIN</span> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="keyword">SELECT</span> <span class="built_in">MAX</span>(salary) <span class="keyword">AS</span> max_sal</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="keyword">FROM</span> emps;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 调用</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">CALL</span> show_max_salary();</span><br></pre></td></tr></table></figure>

<p>调用结果：</p>
<p><img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/202210071239252041.png" alt="img"></p>
<h4 id="举例-4-：创建存储过程-show-min-salary-，查看-“emps”-表的最低薪资值。并将最低薪资通过-OUT-参数-“ms”-输出"><a href="#举例-4-：创建存储过程-show-min-salary-，查看-“emps”-表的最低薪资值。并将最低薪资通过-OUT-参数-“ms”-输出" class="headerlink" title="**举例**4**：创建存储过程**show_min_salary()**，查看**“emps”**表的最低薪资值。并将最低薪资通过**OUT**参数**“ms” 输出:**"></a><em>*<em>*举例*</em>*<em>4*</em>*<em>：创建存储过程*</em>*<em>show_min_salary()*</em>*<em>，查看*</em>*<em>“emps”*</em>*<em>表的最低薪资值。并将最低薪资通过*</em>*<em>OUT*</em>*<em>参数*</em>*<em>“ms” 输出:*</em>*</em></h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 类型<span class="number">2</span>：带有<span class="keyword">OUT</span>参数的存储过程</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#举例<span class="number">4</span>：创建存储过程show_min_salary()，查看“emps”表的最低薪资值。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 并将最低薪资通过<span class="keyword">OUT</span>参数“ms” 输出:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">DELIMITER $</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> show_min_salary(<span class="keyword">OUT</span> ms <span class="keyword">DOUBLE</span>(<span class="number">8</span>,<span class="number">2</span>)) #注意这里ms数据类型要与emps中salary相同</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">BEGIN</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="keyword">SELECT</span> <span class="built_in">MIN</span>(salary) <span class="keyword">INTO</span> ms  #用<span class="keyword">INTO</span>将数据插入ms中</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="keyword">FROM</span> emps;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">END</span> $</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 调用带有<span class="keyword">OUT</span>参数的存储过程</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">CALL</span> show_min_salary(<span class="variable">@ms</span>) # <span class="variable">@ms</span> 为变量</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 查看此变量</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="variable">@ms</span>;</span><br></pre></td></tr></table></figure>

<p>查看结果为：</p>
<p><img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/202210071239262121.png" alt="img"></p>
<h4 id="举例-5-：创建存储过程-show-someone-salary-，查看-“emps”-表的某个员工的薪资，并用-IN-参数-empname输入员工姓名。"><a href="#举例-5-：创建存储过程-show-someone-salary-，查看-“emps”-表的某个员工的薪资，并用-IN-参数-empname输入员工姓名。" class="headerlink" title="**举例**5**：创建存储过程**show_someone_salary()**，查看**“emps”**表的某个员工的薪资，并用**IN**参数**empname输入员工姓名。**"></a><em>*<em>*举例*</em>*<em>5*</em>*<em>：创建存储过程*</em>*<em>show_someone_salary()*</em>*<em>，查看*</em>*<em>“emps”*</em>*<em>表的某个员工的薪资，并用*</em>*<em>IN*</em>*<em>参数*</em>*<em>empname输入员工姓名。*</em>*</em></h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 类型<span class="number">3</span>：带有<span class="keyword">IN</span>参数的存储过程</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 举例<span class="number">5</span>：创建存储过程show_someone_salary()，</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 查看“emps”表的某个员工的薪资，并用<span class="keyword">IN</span>参数empname输入员工姓名。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">DELIMITER $</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#注empname数据类型要与emps中last_name的数据类型相同</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> show_someone_salary(<span class="keyword">IN</span> empname <span class="type">VARCHAR</span>(<span class="number">25</span>)) </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">BEGIN</span> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="keyword">SELECT</span> last_name,salary</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="keyword">FROM</span> emps</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="keyword">WHERE</span> last_name <span class="operator">=</span> empname;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">END</span> $</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 调用带有<span class="keyword">IN</span>参数的存储过程</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 方式<span class="number">1</span>：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">SET</span> <span class="variable">@empname</span> <span class="operator">=</span> <span class="string">&#x27;Abel&#x27;</span>; #给变量<span class="variable">@empname</span>赋值</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">CALL</span> show_someone_salary(<span class="variable">@empname</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 方式<span class="number">2</span>：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">CALL</span> show_someone_salary(<span class="string">&#x27;Abel&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>调用结果：</p>
<p><img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/202210071239262217.png" alt="img"></p>
<h4 id="举例-6-：创建存储过程-show-someone-salary2-，查看-“emps”-表的某个员工的薪资，并用-IN-参数-empname输入员工姓名，用OUT-参数-empsalary-输出员工薪资。"><a href="#举例-6-：创建存储过程-show-someone-salary2-，查看-“emps”-表的某个员工的薪资，并用-IN-参数-empname输入员工姓名，用OUT-参数-empsalary-输出员工薪资。" class="headerlink" title="**举例**6**：创建存储过程**show_someone_salary2()**，查看**“emps”**表的某个员工的薪资，并用**IN**参数**empname输入员工姓名，用OUT**参数**empsalary**输出员工薪资。**"></a><em>*<em>*举例*</em>*<em>6*</em>*<em>：创建存储过程*</em>*<em>show_someone_salary2()*</em>*<em>，查看*</em>*<em>“emps”*</em>*<em>表的某个员工的薪资，并用*</em>*<em>IN*</em>*<em>参数*</em>*<em>empname输入员工姓名，用OUT*</em>*<em>参数*</em>*<em>empsalary*</em>*<em>输出员工薪资。*</em>*</em></h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 类型<span class="number">3</span>：带有 <span class="keyword">IN</span> 和 <span class="keyword">OUT</span> 的参数的存储过程</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 举例<span class="number">6</span>：创建存储过程show_someone_salary2()，查看“emps”表的某个员工的薪资，</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 并用<span class="keyword">IN</span>参数empname输入员工姓名，用<span class="keyword">OUT</span>参数empsalary输出员工薪资。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> show_someone_salary2(<span class="keyword">IN</span> empname <span class="type">VARCHAR</span>(<span class="number">25</span>),<span class="keyword">OUT</span> empsalary <span class="keyword">DOUBLE</span>(<span class="number">8</span>,<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">BEGIN</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="keyword">SELECT</span> salary <span class="keyword">INTO</span> empsalary</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="keyword">FROM</span> emps</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="keyword">WHERE</span> last_name <span class="operator">=</span> empname;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 调用带有 <span class="keyword">IN</span> 和 <span class="keyword">OUT</span> 的参数的存储过程</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">SET</span> <span class="variable">@empname</span> <span class="operator">=</span> <span class="string">&#x27;Abel&#x27;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">CALL</span> show_someone_salary2(<span class="variable">@empname</span>,<span class="variable">@empsalary</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="variable">@empsalary</span>;</span><br></pre></td></tr></table></figure>

<p>查询结果：</p>
<p><img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/202210071239262297.png" alt="img"></p>
<h4 id="举例-7-：创建存储过程-show-mgr-name-，查询某个员工领导的姓名，并用-INOUT-参数-“empname”-输入员工姓名，输出领导的姓名。"><a href="#举例-7-：创建存储过程-show-mgr-name-，查询某个员工领导的姓名，并用-INOUT-参数-“empname”-输入员工姓名，输出领导的姓名。" class="headerlink" title="**举例**7**：创建存储过程**show_mgr_name()**，查询某个员工领导的姓名，并用**INOUT**参数**“empname”**输入员工姓名，输出领导的姓名。**"></a><em>*<em>*举例*</em>*<em>7*</em>*<em>：创建存储过程*</em>*<em>show_mgr_name()*</em>*<em>，查询某个员工领导的姓名，并用*</em>*<em>INOUT*</em>*<em>参数*</em>*<em>“empname”*</em>*<em>输入员工姓名，输出领导的姓名。*</em>*</em></h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 类型<span class="number">4</span>：带有 <span class="keyword">INOUT</span> 的参数的存储过程</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 举例<span class="number">7</span>：创建存储过程show_mgr_name()，查询某个员工领导的姓名，</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 并用<span class="keyword">INOUT</span>参数“empname”输入员工姓名，输出领导的姓名。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> show_mgr_name(<span class="keyword">INOUT</span> empname <span class="type">VARCHAR</span>(<span class="number">25</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">BEGIN</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="keyword">SELECT</span> last_name <span class="keyword">INTO</span> empname</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="keyword">FROM</span> emps</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="keyword">WHERE</span> employee_id <span class="operator">=</span> (</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">												<span class="keyword">SELECT</span> manager_id </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">												<span class="keyword">FROM</span> emps</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">												<span class="keyword">WHERE</span> last_name <span class="operator">=</span> empname</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">												);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 调用 带有 <span class="keyword">INOUT</span> 的参数的存储过程</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">SET</span> <span class="variable">@empname</span> <span class="operator">=</span> <span class="string">&#x27;Abel&#x27;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">CALL</span> show_mgr_name(<span class="variable">@empname</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="variable">@empname</span>;</span><br></pre></td></tr></table></figure>

<p>查询结果：</p>
<p><img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/202210071239262393.png" alt="img"></p>
<p>​    <em><strong>*如果你用的是 Navicat 工具，那么在编写存储过程的时候，Navicat 会自动设置 DELIMITER 为其他符号，我们不需要再进行 DELIMITER 的操作。*</strong></em></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 如果你用的是 Navicat 工具，那么在编写存储过程的时候，Navicat 会自动设置 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># DELIMITER 为其他符号，我们不需要再进行 DELIMITER 的操作。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> show_mgr_name2(<span class="keyword">INOUT</span> empname <span class="type">VARCHAR</span>(<span class="number">25</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">BEGIN</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="keyword">SELECT</span> last_name <span class="keyword">INTO</span> empname</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="keyword">FROM</span> emps</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="keyword">WHERE</span> employee_id <span class="operator">=</span> (</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">												<span class="keyword">SELECT</span> manager_id </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">												<span class="keyword">FROM</span> emps</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">												<span class="keyword">WHERE</span> last_name <span class="operator">=</span> empname</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">												);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">END</span> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 直接调用</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">SET</span> <span class="variable">@empname</span> <span class="operator">=</span> <span class="string">&#x27;Abel&#x27;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">CALL</span> show_mgr_name(<span class="variable">@empname</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="variable">@empname</span>;</span><br></pre></td></tr></table></figure>

<p>查询结果：</p>
<p><img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/202210071239272467.png" alt="img"></p>
<h3 id="如何调试"><a href="#如何调试" class="headerlink" title="如何调试"></a><strong>如何调试</strong></h3><p>​    在 MySQL 中，存储过程不像普通的编程语言（比如 VC++ 、 Java 等）那样有专门的集成开发环境。因此，你可以通过 SELECT 语句，把程序执行的中间结果查询出来，来调试一个 SQL 语句的正确性。调试成功之后，把 SELECT 语句后移到下一个 SQL 语句之后，再调试下一个 SQL 语句。这样 逐步推进 ，就可以完成对存储过程中所有操作的调试了。当然，你也可以把存储过程中的 SQL 语句复制出来，逐段单独调试。</p>
<h2 id="存储函数的使用"><a href="#存储函数的使用" class="headerlink" title="存储函数的使用"></a><strong>存储函数的使用</strong></h2><p>​    前面学习了很多函数，使用这些函数可以对数据进行的各种处理操作，极大地提高用户对数据库的管理效率。MySQL支持自定义函数，定义好之后，调用方式与调用 MySQL 预定义的系统函数一样。</p>
<h3 id="创建存储函数的语法及其分析"><a href="#创建存储函数的语法及其分析" class="headerlink" title="创建存储函数的语法及其分析"></a><strong>创建存储函数的语法及其分析</strong></h3><p>​    学过的函数：LENGTH 、 SUBSTR 、 CONCAT 等</p>
<p>语法格式：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> 函数名(参数名 参数类型,...)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">RETURNS</span> 返回值类型</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[characteristics ...]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">BEGIN</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    函数体 #函数体中肯定有 <span class="keyword">RETURN</span> 语句</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">END</span></span><br></pre></td></tr></table></figure>

<p><strong>说明：</strong></p>
<p>​    <strong>1、参数列表：指定参数为</strong> <em>*<em>*IN*</em>*<em>、*</em>*<em>OUT*</em>*<em>或*</em>*<em>INOUT*</em>*<em>只对*</em>*<em>PROCEDURE*</em>*<em>是合法的，*</em>*<em>FUNCTION*</em>*<em>中总是默认为*</em>*<em>IN*</em>*<em>参数。*</em>*</em></p>
<p>​    <em>*<em>*2、*</em>*<em>RETURNS type*</em> *<em>语句表示函数返回数据的类型；*</em>*</em></p>
<p>​    <em>*<em>*RETURNS子句只能对*</em>*<em>FUNCTION*</em>*<em>做指定，对函数而言这是*</em> *<em>强制*</em> *<em>的。它用来指定函数的返回类型，而且函数体必须包含一个*</em> *<em>RETURN value*</em> *<em>语句。*</em>*</em></p>
<p>​    <em>*<em>*3、*</em>*<em>characteristic*</em> *<em>创建函数时指定的对函数的约束。取值与创建存储过程时相同，这里不再赘述。*</em>*</em></p>
<p>​    </p>
<p>​    <strong>注意：</strong></p>
<p>​        若在创建存储函数中报错“ you might want to use the less safe         log_bin_trust_function_creators variable ”，表示缺少部分的 <em><strong>*characteristic*</strong></em> （ 特征</p>
<p>​        值），有两种处理方法：</p>
<p>​            <strong>方式1：加上必要的函数特性</strong></p>
<blockquote>
<p>​            <strong>[NOT] DETERMINISTIC”和</strong></p>
<p>​            <strong>{CONTAINS SQL | NO SQL | READS SQL DATA | MODIFIES SQLDATA}</strong></p>
</blockquote>
<p>​            <strong>方式</strong> <em>*<em>*2*</em>*<em>：在创建存储函数前加声明：*</em>*</em></p>
<blockquote>
<p>​             <em>*<em>*SET GLOBAL*</em> *<em>log_bin_trust_function_creators &#x3D;*</em> *<em>1*</em>**;*</em>**</p>
</blockquote>
<p>​    <em>*<em>*4、函数体也可以用*</em>*<em>BEGIN…END*</em>*<em>来表示*</em>*<em>SQL*</em>*<em>代码的开始和结束。如果函数体只有一条语句，也可以省略BEGIN…END。*</em>*</em></p>
<h3 id="调用存储函数"><a href="#调用存储函数" class="headerlink" title="调用存储函数"></a><strong>调用存储函数</strong></h3><p>​    在MySQL 中，存储函数的使用方法与 MySQL 内部函数的使用方法是一样的。换言之，用户自己定义的存储函数与MySQL 内部函数是一个性质的。</p>
<p>​    区别在于，存储函数是 用户自己定义 的，而内部函数是 MySQL的 开发者定义 的.</p>
<p><em><strong>*语法格式：*</strong></em></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 函数名(实参列表);</span><br></pre></td></tr></table></figure>

<h3 id="代码举例-1"><a href="#代码举例-1" class="headerlink" title="代码举例"></a><strong>代码举例</strong></h3><h4 id="举例-1-：-创建存储函数，名称为email-by-name-，参数定义为空，该函数查询-Abel-的-email-，并返回，数据类型为字符串型。"><a href="#举例-1-：-创建存储函数，名称为email-by-name-，参数定义为空，该函数查询-Abel-的-email-，并返回，数据类型为字符串型。" class="headerlink" title="**举例**1**：* *创建存储函数，名称为email_by_name()**，参数定义为空，该函数查询**Abel**的**email**，并返回，数据类型为字符串型。**"></a><em>*<em>*举例*</em>*<em>1*</em>*<em>：*</em> *<em>创建存储函数，名称为email_by_name()*</em>*<em>，参数定义为空，该函数查询*</em>*<em>Abel*</em>*<em>的*</em>*<em>email*</em>*<em>，并返回，数据类型为字符串型。*</em>*</em></h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># <span class="number">2.</span>存储函数</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 举例<span class="number">1</span>：创建存储函数，名称为email_by_name()，参数定义为空，</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#        该函数查询Abel的email，并返回，数据类型为字符串型。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">DELIMITER $</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> email_by_name()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">RETURNS</span> <span class="type">VARCHAR</span>(<span class="number">25</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	#设置特征值</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">DETERMINISTIC</span> # 指明存储过程执行的结果为确定的</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">READS</span> <span class="keyword">SQL</span> DATA # 设置<span class="keyword">SQL</span>语句可读</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">BEGIN</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="keyword">RETURN</span> (<span class="keyword">SELECT</span> email</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">						<span class="keyword">FROM</span> emps</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">						<span class="keyword">WHERE</span> last_name <span class="operator">=</span> <span class="string">&#x27;Abel&#x27;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">END</span> $</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 调用存储函数</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> email_by_name();</span><br></pre></td></tr></table></figure>

<p>调用结果为：</p>
<p><img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/202210071239272639.png" alt="img"></p>
<h4 id="举例2：-创建存储函数，名称为email-by-id-，参数传入emp-id，该函数查询emp-id的email，并返回，数据类型为字符串型。"><a href="#举例2：-创建存储函数，名称为email-by-id-，参数传入emp-id，该函数查询emp-id的email，并返回，数据类型为字符串型。" class="headerlink" title="举例2： 创建存储函数，名称为email_by_id()，参数传入emp_id，该函数查询emp_id的email，并返回，数据类型为字符串型。"></a><strong>举例<strong><strong>2</strong></strong>：</strong> 创建存储函数，名称为email_by_id()，参数传入emp_id，该函数查询emp_id的email，并返回，数据类型为字符串型。</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 举例<span class="number">2</span>：创建存储函数，名称为email_by_id()，参数传入emp_id，</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#				 该函数查询emp_id的email，并返回，数据类型为字符串型。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 在创建函数前声明：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> log_bin_trust_function_creators <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> email_by_id(emp_id <span class="type">INT</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">RETURNS</span> <span class="type">VARCHAR</span>(<span class="number">25</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">BEGIN</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="keyword">RETURN</span> (<span class="keyword">SELECT</span> email <span class="keyword">FROM</span> emps <span class="keyword">WHERE</span> employee_id <span class="operator">=</span> emp_id);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 调用</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 方式<span class="number">1</span>：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> email_by_id(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 方式<span class="number">2</span>：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">SET</span> <span class="variable">@emp</span>_id <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> email_by_id(<span class="variable">@emp</span>_id)</span><br></pre></td></tr></table></figure>

<p>调用结果：</p>
<p><img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/202210071239272739.png" alt="img"></p>
<h4 id="举例3：-创建存储函数count-by-id-，参数传入dept-id，该函数查询dept-id部门的员工人数，并返回，数据类型为整型。"><a href="#举例3：-创建存储函数count-by-id-，参数传入dept-id，该函数查询dept-id部门的员工人数，并返回，数据类型为整型。" class="headerlink" title="举例3： 创建存储函数count_by_id()，参数传入dept_id，该函数查询dept_id部门的员工人数，并返回，数据类型为整型。"></a><strong>举例<strong><strong>3</strong></strong>：</strong> 创建存储函数count_by_id()，参数传入dept_id，该函数查询dept_id部门的员工人数，并返回，数据类型为整型。</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 举例<span class="number">3</span>：创建存储函数count_by_id()，参数传入dept_id，</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#				 该函数查询dept_id部门的员工人数，并返回，数据类型为整型。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> count_by_id(dept_id <span class="type">INT</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">RETURNS</span> <span class="type">INT</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">BEGIN</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="keyword">RETURN</span> (<span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> emps <span class="keyword">WHERE</span> department_id <span class="operator">=</span> dept_id);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 调用</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> count_by_id(<span class="number">90</span>);</span><br></pre></td></tr></table></figure>

<p>调用结果：</p>
<p><img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/202210071239282803.png" alt="img"></p>
<h3 id="对比存储函数和存储过程"><a href="#对比存储函数和存储过程" class="headerlink" title="对比存储函数和存储过程"></a><strong>对比存储函数和存储过程</strong></h3><blockquote>
<table>
<thead>
<tr>
<th></th>
<th><em><strong>*关键字*</strong></em></th>
<th><em><strong>*调用语法*</strong></em></th>
<th><em><strong>*返回值*</strong></em></th>
<th><em><strong>*应用场景*</strong></em></th>
</tr>
</thead>
<tbody><tr>
<td><em><strong>*存储过程*</strong></em></td>
<td><em><strong>*PROCEDURE*</strong></em></td>
<td><em>*<em>*CALL*</em> *<em>存储过程*</em>**()*</em>**</td>
<td><em>*<em>*理解为有*</em>*<em>0*</em>*<em>个或多个*</em>*</em></td>
<td><em><strong>*一般用于更新*</strong></em></td>
</tr>
<tr>
<td><em><strong>*存储函数*</strong></em></td>
<td><em><strong>*FUNCTION*</strong></em></td>
<td><em>*<em>*SELECT*</em> *<em>函数*</em>**()*</em>**</td>
<td><em><strong>*只能是一个*</strong></em></td>
<td><em><strong>*一般用于查询结果为一个值并返回值*</strong></em></td>
</tr>
</tbody></table>
</blockquote>
<p>​    此外， <strong>存储函数可以放在查询语句中使用，存储过程不行</strong> 。反之，存储过程的功能更加强大，包括能够执行对表的操作（比如创建表，删除表等）和事务操作，这些功能是存储函数不具备的。</p>
<h2 id="存储过程和函数的查看、修改、删除"><a href="#存储过程和函数的查看、修改、删除" class="headerlink" title="存储过程和函数的查看、修改、删除"></a><strong>存储过程和函数的查看、修改、删除</strong></h2><h3 id="查看"><a href="#查看" class="headerlink" title="查看"></a><strong>查看</strong></h3><p>创建完之后，怎么知道我们创建的存储过程、存储函数是否成功了呢？</p>
<p>​    MySQL存储了存储过程和函数的状态信息，用户可以使用 SHOW STATUS 语句或 SHOW CREATE 语句来查看，也可直接从系统的information_schema 数据库中查询。这里介绍 3 种方法。</p>
<h4 id="使用SHOW-CREATE语句查看存储过程和函数的创建信息"><a href="#使用SHOW-CREATE语句查看存储过程和函数的创建信息" class="headerlink" title="使用SHOW CREATE语句查看存储过程和函数的创建信息"></a><strong>使用SHOW CREATE语句查看存储过程和函数的创建信息</strong></h4><p><em><strong>*语法结构：*</strong></em></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> &#123;<span class="keyword">PROCEDURE</span> <span class="operator">|</span> <span class="keyword">FUNCTION</span>&#125; 存储过程名或函数名</span><br></pre></td></tr></table></figure>

<p>举例：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 存储过程、函数的查看</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 方式<span class="number">1</span>：使用<span class="keyword">SHOW</span> <span class="keyword">CREATE</span> 语句查看存储过程和函数的创建信息</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> show_max_salary\G</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p><img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/202210071239282846.png" alt="img"></p>
<h4 id="使用SHOW-STATUS语句查看存储过程和函数的状态信息"><a href="#使用SHOW-STATUS语句查看存储过程和函数的状态信息" class="headerlink" title="使用SHOW STATUS语句查看存储过程和函数的状态信息"></a><strong>使用SHOW STATUS语句查看存储过程和函数的状态信息</strong></h4><p>语法结构：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> &#123;<span class="keyword">PROCEDURE</span> <span class="operator">|</span> <span class="keyword">FUNCTION</span>&#125; STATUS [<span class="keyword">LIKE</span> <span class="string">&#x27;pattern&#x27;</span>]</span><br></pre></td></tr></table></figure>

<p>​    这个语句返回子程序的特征，如数据库、名字、类型、创建者及创建和修改日期。</p>
<p>​    [LIKE ‘pattern’]：匹配存储过程或函数的名称，可以省略。当省略不写时，会列出MySQL数据库中存在的 所有存储过程或函数的信息。</p>
<p>举例1：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 方式<span class="number">2</span>：使用<span class="keyword">SHOW</span> STATUS语句查看存储过程和函数的状态信息</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">FUNCTION</span> STATUS;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p><img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/202210071239282874.png" alt="img"></p>
<p> 举例2：</p>
<p><img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/202210071239292878.png" alt="img"></p>
<h4 id="从information-schema-Routines表中查看存储过程和函数的信息"><a href="#从information-schema-Routines表中查看存储过程和函数的信息" class="headerlink" title="从information_schema.Routines表中查看存储过程和函数的信息"></a><strong>从information_schema.Routines表中查看存储过程和函数的信息</strong></h4><p>​     MySQL 中存储过程和函数的信息存储在 information_schema 数据库下的 Routines 表中。可以通过查询该表 的记录来查询存储过程和函数的信息。</p>
<p><strong>语法格式：</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> information_schema.Routines </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">WHERE</span> ROUTINE_NAME<span class="operator">=</span><span class="string">&#x27;存储过程或函数的名&#x27;</span> [<span class="keyword">AND</span> ROUTINE_TYPE <span class="operator">=</span> &#123;<span class="string">&#x27;PROCEDURE|FUNCTION&#x27;</span>&#125;];</span><br></pre></td></tr></table></figure>

<p>说明：如果在 MySQL 数据库中存在存储过程和函数名称相同的情况，最好指定 ROUTINE_TYPE 查询条件来指明查询的是存储过程还是函数。</p>
<p>举例：</p>
<p><img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/202210071239292898.png" alt="img"></p>
<h3 id="修改"><a href="#修改" class="headerlink" title="修改"></a><strong>修改</strong></h3><p>​    修改存储过程或函数，不影响存储过程或函数功能，只是修改相关特性。使用ALTER 语句实现。</p>
<p><em><strong>*语法格式：*</strong></em></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> &#123;<span class="keyword">PROCEDURE</span> <span class="operator">|</span> <span class="keyword">FUNCTION</span>&#125; 存储过程或函数的名 [characteristic ...]</span><br></pre></td></tr></table></figure>

<p>​    其中，characteristic 指定存储过程或函数的特性，其取值信息与创建存储过程、函数时的取值信息略有不同。</p>
<blockquote>
<p><em>*<em>*{*</em> *<em>CONTAINS SQL*</em> **|*</em> *<em>NO SQL*</em> *<em>|*</em> *<em>READS SQL DATA*</em> *<em>|*</em> *<em>MODIFIES SQL DATA*</em> *<em>}*</em>**</p>
<p><em>*<em>*|*</em> *<em>SQL SECURITY*</em> **{ DEFINER |*</em> *<em>INVOKER*</em> *<em>}*</em>**</p>
<p><em>*<em>*|*</em> *<em>COMMENT*</em> **’string*</em>**</p>
</blockquote>
<p>​    <em>*<em>*<img src="https://latex.codecogs.com/gif.latex?%5Cbullet" alt="\bullet"> CONTAINS SQL*</em> *<em>，表示子程序包含*</em>*<em>SQL*</em>*<em>语句，但不包含读或写数据的语句。*</em>*</em></p>
<p>​    <em>*<em>*<img src="https://latex.codecogs.com/gif.latex?%5Cbullet" alt="\bullet"> NO SQL*</em> *<em>，表示子程序中不包含*</em>*<em>SQL*</em>*<em>语句。*</em>*</em></p>
<p>​    <em><strong>*<img src="https://latex.codecogs.com/gif.latex?%5Cbullet" alt="\bullet"> READS SQL DATA** **，表示子程序中包含读数据的语句。*</strong></em></p>
<p>​    <em><strong>*<img src="https://latex.codecogs.com/gif.latex?%5Cbullet" alt="\bullet"> MODIFIES SQL DATA** **，表示子程序中包含写数据的语句。*</strong></em></p>
<p>​    <em><strong>*<img src="https://latex.codecogs.com/gif.latex?%5Cbullet" alt="\bullet"> SQL SECURITY { DEFINER | INVOKER }** **，指明谁有权限来执行。*</strong></em> </p>
<p>​        <em><strong>*<img src="https://latex.codecogs.com/gif.latex?%5Ccirc" alt="\circ">** *<em>DEFINER*</em> **，表示只有定义者自己才能够执行。*</strong></em> </p>
<p>​        <em><strong>*<img src="https://latex.codecogs.com/gif.latex?%5Ccirc" alt="\circ">** *<em>INVOKER*</em> **，表示调用者可以执行。*</strong></em></p>
<p>​    <em><strong>*<img src="https://latex.codecogs.com/gif.latex?%5Cbullet" alt="\bullet"> COMMENT ‘string’** **，表示注释信息。*</strong></em></p>
<p>​    修改存储过程使用ALTER PROCEDURE 语句，修改存储函数使用 ALTER FUNCTION 语句。但是，这两个语句的结构是一样的，语句中的所有参数也是一样的。</p>
<p>举例：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 存储过程、函数的修改</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">FUNCTION</span> email_by_id </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">COMMENT <span class="string">&#x27;输入员工id查看其emial&#x27;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">FUNCTION</span> STATUS <span class="keyword">LIKE</span> <span class="string">&#x27;email_by_id&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p><img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/202210071239292964.png" alt="img"></p>
<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a><strong>删除</strong></h3><p>​    删除存储过程和函数，可以使用DROP 语句</p>
<p><em><strong>*语法结构：*</strong></em></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> &#123;<span class="keyword">PROCEDURE</span> <span class="operator">|</span> <span class="keyword">FUNCTION</span>&#125; [IF <span class="keyword">EXISTS</span>] 存储过程或函数的名</span><br></pre></td></tr></table></figure>

<p>​    IF EXISTS：如果程序或函数不存储，它可以防止发生错误，产生一个用 SHOW WARNINGS 查看的警告。</p>
<p>举例：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 存储过程、函数的删除</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">PROCEDURE</span> show_max_salary;</span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">PROCEDURE</span> STATUS;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p><img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/202210071239302990.png" alt="img"></p>
<h2 id="关于存储过程使用的争议"><a href="#关于存储过程使用的争议" class="headerlink" title="关于存储过程使用的争议"></a><strong>关于存储过程使用的争议</strong></h2><p>​    尽管存储过程有诸多优点，但是对于存储过程的使用， <strong>一直都存在着很多争议</strong> ，比如有些公司对于大型项目要求使用存储过程，而有些公司在手册中明确禁止使用存储过程，为什么这些公司对存储过程的使用需求差别这么大呢？</p>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a><strong>优点</strong></h3><p>​    <strong>1、存储过程可以一次编译多次使用。</strong> 存储过程只在创建时进行编译，之后的使用都不需要重新编译，这就提升了 SQL 的执行效率。</p>
<p>​    <strong>2、可以减少开发工作量。</strong> 将代码 封装 成模块，实际上是编程的核心思想之一，这样可以把复杂的问题拆解成不同的模块，然后模块之间可以 重复使用 ，在减少开发工作量的同时，还能保证代码的结构清晰。</p>
<p>​    <strong>3、存储过程的安全性强。</strong> 我们在设定存储过程的时候可以 设置对用户的使用权限 ，这样就和视图一样具有较强的安全性。</p>
<p>​    <strong>4、可以减少网络传输量。</strong> 因为代码封装到存储过程中，每次使用只需要调用存储过程即可，这样就减少了网络传输量。</p>
<p>​    <strong>5、良好的封装性。</strong> 在进行相对复杂的数据库操作时，原本需要使用一条一条的 SQL 语句，可能要连接多次数据库才能完成的操作，现在变成了一次存储过程，只需要 连接一次即可 。</p>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a><strong>缺点</strong></h3><p>​    基于上面这些优点，不少大公司都要求大型项目使用存储过程，比如微软、IBM 等公司。但是国内的阿里并不推荐开发人员使用存储过程，这是为什么呢？</p>
<blockquote>
<p><strong>阿里开发规范</strong></p>
<p>【强制】禁止使用存储过程，存储过程难以调试和扩展，更没有移植性。</p>
</blockquote>
<p>存储过程虽然有诸如上面的好处，但缺点也是很明显的。</p>
<p>​    <strong>1、可移植性差。</strong> 存储过程不能跨数据库移植，比如在 MySQL 、 Oracle 和 SQL Server 里编写的存储过程，在换成其他数据库时都需要重新编写。</p>
<p>​    <strong>2、调试困难。</strong> 只有少数 DBMS 支持存储过程的调试。对于复杂的存储过程来说，开发和维护都不容易。虽然也有一些第三方工具可以对存储过程进行调试，但要收费。</p>
<p>​    <strong>3、存储过程的版本管理很困难。</strong> 比如数据表索引发生变化了，可能会导致存储过程失效。我们在开发软件的时候往往需要进行版本管理，但是存储过程本身没有版本控制，版本迭代更新的时候很麻烦。</p>
<p>​    <strong>4、它不适合高并发的场景。</strong> 高并发的场景需要减少数据库的压力，有时数据库会采用分库分表的方式，而且对可扩展性要求很高，在这种情况下，存储过程会变得难以维护， 增加数据库的压力 ，显然就不适用了。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>​    <strong>存储过程既方便，又有局限性。尽管不同的公司对存储过程的态度不一，但是对于我们开发人员来说，不论怎样，掌握存储过程都是必备的技能之一。</strong></p>
<h2 id="练习-1"><a href="#练习-1" class="headerlink" title="练习"></a>练习</h2><h3 id="存储过程练习"><a href="#存储过程练习" class="headerlink" title="存储过程练习"></a><strong>存储过程练习</strong></h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 存储过程练习</span><br><span class="line">#<span class="number">0.</span>准备工作</span><br><span class="line"><span class="keyword">CREATE</span> DATABASE test15_pro_func;</span><br><span class="line">USE test15_pro_func;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> admin(</span><br><span class="line">id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY AUTO_INCREMENT,</span><br><span class="line">user_name <span class="type">VARCHAR</span>(<span class="number">15</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">pwd <span class="type">VARCHAR</span>(<span class="number">25</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> beauty(</span><br><span class="line">id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY AUTO_INCREMENT,</span><br><span class="line">NAME <span class="type">VARCHAR</span>(<span class="number">15</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">phone <span class="type">VARCHAR</span>(<span class="number">15</span>) <span class="keyword">UNIQUE</span>,</span><br><span class="line">birth <span class="type">DATE</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> beauty(NAME,phone,birth)</span><br><span class="line"><span class="keyword">VALUES</span></span><br><span class="line">(<span class="string">&#x27;朱茵&#x27;</span>,<span class="string">&#x27;13201233453&#x27;</span>,<span class="string">&#x27;1982-02-12&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;孙燕姿&#x27;</span>,<span class="string">&#x27;13501233653&#x27;</span>,<span class="string">&#x27;1980-12-09&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;田馥甄&#x27;</span>,<span class="string">&#x27;13651238755&#x27;</span>,<span class="string">&#x27;1983-08-21&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;邓紫棋&#x27;</span>,<span class="string">&#x27;17843283452&#x27;</span>,<span class="string">&#x27;1991-11-12&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;刘若英&#x27;</span>,<span class="string">&#x27;18635575464&#x27;</span>,<span class="string">&#x27;1989-05-18&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;杨超越&#x27;</span>,<span class="string">&#x27;13761238755&#x27;</span>,<span class="string">&#x27;1994-05-11&#x27;</span>);</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> beauty;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/202210071239303065.png" alt="img"></p>
<h4 id="创建存储过程insert-user-实现传入用户名和密码，插入到admin表中"><a href="#创建存储过程insert-user-实现传入用户名和密码，插入到admin表中" class="headerlink" title="创建存储过程insert_user(),实现传入用户名和密码，插入到admin表中"></a>创建存储过程insert_user(),实现传入用户名和密码，插入到admin表中</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#<span class="number">1.</span> 创建存储过程insert_user(),实现传入用户名和密码，插入到admin表中</span><br><span class="line"></span><br><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> insert_user(<span class="keyword">IN</span> username <span class="type">VARCHAR</span>(<span class="number">15</span>),<span class="keyword">IN</span> password <span class="type">VARCHAR</span>(<span class="number">25</span>))</span><br><span class="line">	<span class="keyword">BEGIN</span> </span><br><span class="line"></span><br><span class="line">		<span class="keyword">INSERT</span> <span class="keyword">INTO</span> admin(user_name,pwd)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">VALUES</span>(username,password);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>



<h4 id="创建存储过程get-phone-实现传入女神编号，返回女神姓名和女神电话"><a href="#创建存储过程get-phone-实现传入女神编号，返回女神姓名和女神电话" class="headerlink" title="创建存储过程get_phone(),实现传入女神编号，返回女神姓名和女神电话"></a>创建存储过程get_phone(),实现传入女神编号，返回女神姓名和女神电话</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#<span class="number">2.</span> 创建存储过程get_phone(),实现传入女神编号，返回女神姓名和女神电话</span><br><span class="line"></span><br><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> get_phone(<span class="keyword">IN</span> id <span class="type">INT</span>,<span class="keyword">OUT</span> name <span class="type">VARCHAR</span>(<span class="number">15</span>),<span class="keyword">OUT</span> phone <span class="type">VARCHAR</span>(<span class="number">15</span>))</span><br><span class="line"></span><br><span class="line">	<span class="keyword">BEGIN</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">SELECT</span> b.name,b.phone <span class="keyword">INTO</span> name,phone</span><br><span class="line"></span><br><span class="line">		<span class="keyword">FROM</span> beauty b</span><br><span class="line"></span><br><span class="line">		<span class="keyword">WHERE</span> b.id <span class="operator">=</span> id;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br><span class="line"># 调用</span><br><span class="line"></span><br><span class="line"><span class="keyword">SET</span> <span class="variable">@id</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line"><span class="keyword">CALL</span> get_phone(<span class="variable">@id</span>,<span class="variable">@name</span>,<span class="variable">@phone</span>);</span><br><span class="line"><span class="keyword">SELECT</span> <span class="variable">@name</span>,<span class="variable">@phone</span>;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p><img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/202210071239303115.png" alt="img"></p>
<h4 id="创建存储过程date-diff-，实现传入两个女神生日，返回日期间隔大小"><a href="#创建存储过程date-diff-，实现传入两个女神生日，返回日期间隔大小" class="headerlink" title="创建存储过程date_diff()，实现传入两个女神生日，返回日期间隔大小"></a>创建存储过程date_diff()，实现传入两个女神生日，返回日期间隔大小</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#<span class="number">3.</span> 创建存储过程date_diff()，实现传入两个女神生日，返回日期间隔大小 </span><br><span class="line"></span><br><span class="line">DELIMITER $</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> date_diff(<span class="keyword">IN</span> birth1 <span class="type">DATE</span>,<span class="keyword">IN</span> birth2 <span class="type">DATE</span>,<span class="keyword">OUT</span> <span class="keyword">result</span> <span class="type">INT</span>)</span><br><span class="line">	<span class="keyword">BEGIN</span></span><br><span class="line">		<span class="keyword">SELECT</span> DATEDIFF(birth1,birth2) <span class="keyword">INTO</span> <span class="keyword">result</span>;</span><br><span class="line">	<span class="keyword">END</span> $ </span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br><span class="line">#调用 </span><br><span class="line"></span><br><span class="line"><span class="keyword">SET</span> <span class="variable">@birth1</span> <span class="operator">=</span> <span class="string">&#x27;1992-09-08&#x27;</span>; </span><br><span class="line"><span class="keyword">SET</span> <span class="variable">@birth2</span> <span class="operator">=</span> <span class="string">&#x27;1989-01-03&#x27;</span>; </span><br><span class="line"><span class="keyword">CALL</span> date_diff(<span class="variable">@birth1</span>,<span class="variable">@birth2</span>,<span class="variable">@result</span>); </span><br><span class="line"><span class="keyword">SELECT</span> <span class="variable">@result</span>;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p><img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/202210071239313139.png" alt="img"></p>
<h4 id="创建存储过程format-date-实现传入一个日期，格式化成xx年xx月xx日并"><a href="#创建存储过程format-date-实现传入一个日期，格式化成xx年xx月xx日并" class="headerlink" title="创建存储过程format_date(),实现传入一个日期，格式化成xx年xx月xx日并"></a>创建存储过程format_date(),实现传入一个日期，格式化成xx年xx月xx日并</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#<span class="number">4.</span> 创建存储过程format_date(),实现传入一个日期，格式化成xx年xx月xx日并 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> format_date(<span class="keyword">IN</span> mydate <span class="type">DATE</span>)</span><br><span class="line">	<span class="keyword">BEGIN</span></span><br><span class="line">		<span class="keyword">SELECT</span> DATE_FORMAT(mydate,<span class="string">&#x27;%y年%m月%d&#x27;</span>);</span><br><span class="line">	<span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line">DELIMITER ;</span><br><span class="line"># 调用</span><br><span class="line"><span class="keyword">SET</span> <span class="variable">@mydate</span> <span class="operator">=</span> <span class="string">&#x27;1992-09-08&#x27;</span>;</span><br><span class="line"><span class="keyword">CALL</span> format_date(<span class="variable">@mydate</span>);</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p><img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/202210071239313163.png" alt="img"></p>
<h4 id="创建存储过程beauty-limit-，根据传入的起始索引和条目数，查询女神表的记录"><a href="#创建存储过程beauty-limit-，根据传入的起始索引和条目数，查询女神表的记录" class="headerlink" title="创建存储过程beauty_limit()，根据传入的起始索引和条目数，查询女神表的记录"></a>创建存储过程beauty_limit()，根据传入的起始索引和条目数，查询女神表的记录</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#<span class="number">5.</span> 创建存储过程beauty_limit()，根据传入的起始索引和条目数，查询女神表的记录 </span><br><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> beauty_limit(<span class="keyword">IN</span> <span class="keyword">first</span> <span class="type">INT</span>,<span class="keyword">IN</span> num <span class="type">INT</span>)</span><br><span class="line">	<span class="keyword">BEGIN</span></span><br><span class="line">		<span class="keyword">SELECT</span> <span class="operator">*</span> </span><br><span class="line">		<span class="keyword">FROM</span> beauty</span><br><span class="line">		LIMIT <span class="keyword">first</span>,num;</span><br><span class="line">	<span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line">DELIMITER ;</span><br><span class="line"><span class="keyword">CALL</span> beauty_limit(<span class="number">1</span>,<span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p><img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/202210071239313182.png" alt="img"></p>
<h4 id="传入a和b两个值，最终a和b都翻倍并返回"><a href="#传入a和b两个值，最终a和b都翻倍并返回" class="headerlink" title="传入a和b两个值，最终a和b都翻倍并返回"></a>传入a和b两个值，最终a和b都翻倍并返回</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># <span class="number">6.</span> 传入a和b两个值，最终a和b都翻倍并返回 </span><br><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> add_INT(<span class="keyword">INOUT</span> a <span class="type">INT</span>,<span class="keyword">INOUT</span> b <span class="type">INT</span>)</span><br><span class="line">	<span class="keyword">BEGIN</span></span><br><span class="line">		<span class="keyword">SET</span> a <span class="operator">=</span> a <span class="operator">*</span> <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">SET</span> b <span class="operator">=</span> b <span class="operator">*</span> <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br><span class="line"><span class="keyword">SET</span> <span class="variable">@a</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line"><span class="keyword">SET</span> <span class="variable">@b</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line"><span class="keyword">CALL</span> add_INT(<span class="variable">@a</span>,<span class="variable">@b</span>);</span><br><span class="line"><span class="keyword">SELECT</span> <span class="variable">@a</span>,<span class="variable">@b</span> ;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/202210071239313202.png" alt="img"></p>
<h4 id="删除题目5的存储过程"><a href="#删除题目5的存储过程" class="headerlink" title="删除题目5的存储过程"></a>删除题目5的存储过程</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#<span class="number">7.</span> 删除题目<span class="number">5</span>的存储过程 </span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">PROCEDURE</span> beauty_limit;</span><br></pre></td></tr></table></figure>

<h4 id="查看题目6中存储过程的信息"><a href="#查看题目6中存储过程的信息" class="headerlink" title="查看题目6中存储过程的信息"></a>查看题目6中存储过程的信息</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#<span class="number">8.</span> 查看题目<span class="number">6</span>中存储过程的信息</span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> add_INT;</span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">PROCEDURE</span> STATUS <span class="keyword">LIKE</span> <span class="string">&#x27;add_INT&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="存储函数练习"><a href="#存储函数练习" class="headerlink" title="存储函数练习"></a><strong>存储函数练习</strong></h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 存储函数练习</span><br><span class="line">#<span class="number">0.</span> 准备工作</span><br><span class="line">USE test15_pro_func;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> emps</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> atguigudb.`employees`;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> depts</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> atguigudb.`departments`;</span><br></pre></td></tr></table></figure>

<h4 id="创建函数get-count-返回公司的员工个数"><a href="#创建函数get-count-返回公司的员工个数" class="headerlink" title="创建函数get_count(),返回公司的员工个数"></a>创建函数get_count(),返回公司的员工个数</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#<span class="number">1.</span> 创建函数get_count(),返回公司的员工个数</span><br><span class="line"></span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> log_bin_trust_function_creators <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> get_count()</span><br><span class="line"></span><br><span class="line"><span class="keyword">RETURNS</span> <span class="type">INT</span></span><br><span class="line">	<span class="keyword">BEGIN</span> </span><br><span class="line">		<span class="keyword">RETURN</span>(<span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> emps);</span><br><span class="line">	<span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line">DELIMITER ;</span><br><span class="line"><span class="keyword">SELECT</span> get_count();</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p><img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/202210071239313253.png" alt="img"></p>
<h4 id="创建函数ename-salary-根据员工姓名，返回它的工资"><a href="#创建函数ename-salary-根据员工姓名，返回它的工资" class="headerlink" title="创建函数ename_salary(),根据员工姓名，返回它的工资"></a>创建函数ename_salary(),根据员工姓名，返回它的工资</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#<span class="number">2.</span> 创建函数ename_salary(),根据员工姓名，返回它的工资</span><br><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> ename_salary(ename <span class="type">VARCHAR</span>(<span class="number">25</span>))</span><br><span class="line"><span class="keyword">RETURNS</span> <span class="keyword">DOUBLE</span>(<span class="number">8</span>,<span class="number">2</span>)</span><br><span class="line">	<span class="keyword">BEGIN</span></span><br><span class="line">		<span class="keyword">RETURN</span>(<span class="keyword">SELECT</span> salary <span class="keyword">FROM</span> emps <span class="keyword">WHERE</span> last_name <span class="operator">=</span> ename);</span><br><span class="line">	<span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line">DELIMITER ;</span><br><span class="line"><span class="keyword">SELECT</span> ename_salary(<span class="string">&#x27;Abel&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p>​    <img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/202210071239313272.png" alt="img"></p>
<h4 id="创建函数dept-sal-根据部门名，返回该部门的平均工资"><a href="#创建函数dept-sal-根据部门名，返回该部门的平均工资" class="headerlink" title="创建函数dept_sal() ,根据部门名，返回该部门的平均工资"></a>创建函数dept_sal() ,根据部门名，返回该部门的平均工资</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#<span class="number">3.</span> 创建函数dept_sal() ,根据部门名，返回该部门的平均工资</span><br><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> dept_sal(depid <span class="type">INT</span>)</span><br><span class="line"><span class="keyword">RETURNS</span> <span class="keyword">DOUBLE</span>(<span class="number">8</span>,<span class="number">2</span>)</span><br><span class="line">	<span class="keyword">BEGIN</span></span><br><span class="line">		<span class="keyword">RETURN</span> (<span class="keyword">SELECT</span> <span class="built_in">AVG</span>(salary) <span class="keyword">FROM</span> emps <span class="keyword">WHERE</span> department_id <span class="operator">=</span> depid);</span><br><span class="line">	<span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line">DELIMITER ;</span><br><span class="line"><span class="keyword">SELECT</span> dept_sal(<span class="number">50</span>);</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p><img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/202210071239323294.png" alt="img"></p>
<h4 id="创建函数add-float-，实现传入两个float，返回二者之和"><a href="#创建函数add-float-，实现传入两个float，返回二者之和" class="headerlink" title="创建函数add_float()，实现传入两个float，返回二者之和"></a>创建函数add_float()，实现传入两个float，返回二者之和</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#<span class="number">4.</span> 创建函数add_float()，实现传入两个<span class="type">float</span>，返回二者之和</span><br><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> add_float(float1 <span class="type">FLOAT</span>,float2 <span class="type">FLOAT</span>)</span><br><span class="line"><span class="keyword">RETURNS</span> <span class="type">FLOAT</span></span><br><span class="line">	<span class="keyword">BEGIN</span></span><br><span class="line">		<span class="keyword">RETURN</span>(<span class="keyword">SELECT</span> float1 <span class="operator">+</span> float2);</span><br><span class="line">	<span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line">DELIMITER ;</span><br><span class="line"><span class="keyword">SELECT</span> add_float(<span class="number">5.2</span>,<span class="number">6.9</span>);</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p><img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/202210071239323315.png" alt="img"></p>
<h1 id="MySQL-变量、流程控制与游标练习"><a href="#MySQL-变量、流程控制与游标练习" class="headerlink" title="MySQL 变量、流程控制与游标练习"></a>MySQL 变量、流程控制与游标练习</h1><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a><strong>变量</strong></h2><p>准备工作：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#<span class="number">0.</span>准备工作</span><br><span class="line"><span class="keyword">CREATE</span> DATABASE test16_var_cur;</span><br><span class="line"></span><br><span class="line">use test16_var_cur;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> employees</span><br><span class="line"></span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> atguigudb.`employees`;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> departments</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> atguigudb.`departments`;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> log_bin_trust_function_creators <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<h3 id="创建函数get-count-返回公司的员工个数-1"><a href="#创建函数get-count-返回公司的员工个数-1" class="headerlink" title="创建函数get_count(),返回公司的员工个数"></a>创建函数get_count(),返回公司的员工个数</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#无参有返回</span><br><span class="line"></span><br><span class="line">#<span class="number">1.</span> 创建函数get_count(),返回公司的员工个数</span><br><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> get_count()</span><br><span class="line"><span class="keyword">RETURNS</span> <span class="type">INT</span></span><br><span class="line">		<span class="keyword">BEGIN</span></span><br><span class="line">			# 声明局部变量</span><br><span class="line">			<span class="keyword">DECLARE</span> emp_count <span class="type">INT</span>;</span><br><span class="line">			<span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">INTO</span> emp_count</span><br><span class="line">			<span class="keyword">FROM</span> employees；</span><br><span class="line">			<span class="keyword">RETURN</span> emp_count;</span><br><span class="line">		<span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line">DELIMITER ;</span><br><span class="line"><span class="keyword">SELECT</span> get_count(); #<span class="number">107</span></span><br></pre></td></tr></table></figure>

<h3 id="创建函数ename-salary-根据员工姓名，返回它的工资-1"><a href="#创建函数ename-salary-根据员工姓名，返回它的工资-1" class="headerlink" title="创建函数ename_salary(),根据员工姓名，返回它的工资"></a>创建函数ename_salary(),根据员工姓名，返回它的工资</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#有参有返回</span><br><span class="line">#<span class="number">2.</span> 创建函数ename_salary(),根据员工姓名，返回它的工资</span><br><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> ename_salary(emp_name <span class="type">VARCHAR</span>(<span class="number">25</span>))</span><br><span class="line"><span class="keyword">RETURNS</span> <span class="keyword">DOUBLE</span>(<span class="number">8</span>,<span class="number">2</span>)</span><br><span class="line">		<span class="keyword">BEGIN</span></span><br><span class="line">			# 声明局部变量</span><br><span class="line">			<span class="keyword">DECLARE</span> emp_sal <span class="keyword">DOUBLE</span>(<span class="number">8</span>,<span class="number">2</span>);</span><br><span class="line">			<span class="keyword">SELECT</span> salary <span class="keyword">INTO</span> emp_sal</span><br><span class="line">			<span class="keyword">FROM</span> employees</span><br><span class="line">			<span class="keyword">WHERE</span> last_name <span class="operator">=</span> emp_name;</span><br><span class="line">			<span class="keyword">RETURN</span> emp_sal;</span><br><span class="line">		<span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line">DELIMITER ;</span><br><span class="line"><span class="keyword">SELECT</span> ename_salary(<span class="string">&#x27;Abel&#x27;</span>); #<span class="number">12000.00</span></span><br></pre></td></tr></table></figure>

<h3 id="创建函数dept-sal-根据部门名，返回该部门的平均工资-1"><a href="#创建函数dept-sal-根据部门名，返回该部门的平均工资-1" class="headerlink" title="创建函数dept_sal() ,根据部门名，返回该部门的平均工资"></a>创建函数dept_sal() ,根据部门名，返回该部门的平均工资</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#<span class="number">3.</span> 创建函数dept_sal() ,根据部门名，返回该部门的平均工资</span><br><span class="line"></span><br><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> dept_sal(dept_name <span class="type">VARCHAR</span>(<span class="number">30</span>))</span><br><span class="line"><span class="keyword">RETURNS</span> <span class="keyword">DOUBLE</span></span><br><span class="line">		<span class="keyword">BEGIN</span> </span><br><span class="line">				<span class="keyword">DECLARE</span> dept_sal <span class="keyword">DOUBLE</span>;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">SELECT</span> <span class="built_in">AVG</span>(salary) <span class="keyword">INTO</span> dept_sal</span><br><span class="line">				<span class="keyword">FROM</span> employees e <span class="keyword">JOIN</span> departments d</span><br><span class="line">				<span class="keyword">ON</span> e.department_id <span class="operator">=</span> d.department_id</span><br><span class="line">				<span class="keyword">WHERE</span> department_name <span class="operator">=</span> dept_name;</span><br><span class="line">				<span class="keyword">RETURN</span> dept_sal;</span><br><span class="line">		<span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line">DELIMITER ;</span><br><span class="line"><span class="keyword">SELECT</span> dept_sal(<span class="string">&#x27;IT&#x27;</span>); #<span class="number">5760</span></span><br></pre></td></tr></table></figure>

<h3 id="创建函数add-float-，实现传入两个float，返回二者之和-1"><a href="#创建函数add-float-，实现传入两个float，返回二者之和-1" class="headerlink" title="创建函数add_float()，实现传入两个float，返回二者之和"></a>创建函数add_float()，实现传入两个float，返回二者之和</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#<span class="number">4.</span> 创建函数add_float()，实现传入两个<span class="type">float</span>，返回二者之和</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> add_float(f1 <span class="type">FLOAT</span>,f2 <span class="type">FLOAT</span>)</span><br><span class="line"><span class="keyword">RETURNS</span> <span class="type">FLOAT</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">BEGIN</span></span><br><span class="line">				<span class="keyword">DECLARE</span> sum <span class="type">FLOAT</span>;</span><br><span class="line">				<span class="keyword">SET</span> sum <span class="operator">=</span> f1 <span class="operator">+</span> f2;</span><br><span class="line">				<span class="keyword">RETURN</span> sum;</span><br><span class="line">		<span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line">DELIMITER ;</span><br><span class="line"><span class="keyword">SET</span> <span class="variable">@f1</span> <span class="operator">=</span> <span class="number">12.25</span>;</span><br><span class="line"><span class="keyword">SET</span> <span class="variable">@f2</span> <span class="operator">=</span> <span class="number">36.55</span>;</span><br><span class="line"><span class="keyword">SELECT</span> add_float(<span class="variable">@f1</span>,<span class="variable">@f2</span>); #<span class="number">48.8</span></span><br></pre></td></tr></table></figure>

<h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a><strong>流程控制</strong></h2><h3 id="创建函数test-if-case-，实现传入成绩，如果成绩-gt-90-返回A，如果成绩-gt-80-返回B，如果成绩-gt-60-返回-C，否则返回D-要求：分别使用if结构和case结构实现"><a href="#创建函数test-if-case-，实现传入成绩，如果成绩-gt-90-返回A，如果成绩-gt-80-返回B，如果成绩-gt-60-返回-C，否则返回D-要求：分别使用if结构和case结构实现" class="headerlink" title="创建函数test_if_case()，实现传入成绩，如果成绩&gt;90,返回A，如果成绩&gt;80,返回B，如果成绩&gt;60,返回 C，否则返回D ,要求：分别使用if结构和case结构实现"></a>创建函数test_if_case()，实现传入成绩，如果成绩&gt;90,返回A，如果成绩&gt;80,返回B，如果成绩&gt;60,返回 C，否则返回D ,要求：分别使用if结构和case结构实现</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#<span class="number">1.</span> 创建函数test_if_case()，实现传入成绩，</span><br><span class="line">#		如果成绩<span class="operator">&gt;</span><span class="number">90</span>,返回A，如果成绩<span class="operator">&gt;</span><span class="number">80</span>,返回B，如果成绩<span class="operator">&gt;</span><span class="number">60</span>,返回C，否则返回D</span><br><span class="line"></span><br><span class="line">#		要求：分别使用if结构和<span class="keyword">case</span>结构实现</span><br><span class="line"># 方式<span class="number">1</span>：使用if结构实现</span><br><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> test_if(score <span class="type">INT</span> )</span><br><span class="line"><span class="keyword">RETURNS</span> <span class="type">CHAR</span></span><br><span class="line">		<span class="keyword">BEGIN</span></span><br><span class="line">				<span class="keyword">DECLARE</span> grade <span class="type">CHAR</span>;</span><br><span class="line">				IF score <span class="operator">&gt;</span> <span class="number">90</span></span><br><span class="line">						<span class="keyword">THEN</span> <span class="keyword">SET</span> grade <span class="operator">=</span> <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">				ELSEIF score <span class="operator">&gt;</span> <span class="number">80</span> </span><br><span class="line">						<span class="keyword">THEN</span> <span class="keyword">SET</span> grade <span class="operator">=</span> <span class="string">&#x27;B&#x27;</span>;</span><br><span class="line">				ELSEIF score <span class="operator">&gt;</span> <span class="number">60</span></span><br><span class="line">						<span class="keyword">THEN</span> <span class="keyword">SET</span> grade <span class="operator">=</span> <span class="string">&#x27;C&#x27;</span>;</span><br><span class="line">				<span class="keyword">ELSE</span></span><br><span class="line">						<span class="keyword">SET</span> grade <span class="operator">=</span> <span class="string">&#x27;D&#x27;</span>;</span><br><span class="line">				<span class="keyword">END</span> IF;</span><br><span class="line">				<span class="keyword">RETURN</span> grade;</span><br><span class="line">		<span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line">DELIMITER ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> test_if(<span class="number">95</span>); #A</span><br><span class="line"><span class="keyword">SELECT</span> test_if(<span class="number">65</span>); #C</span><br><span class="line"># 方式<span class="number">2</span>：使用<span class="keyword">case</span>结构实现</span><br><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> test_case(score <span class="type">INT</span>)</span><br><span class="line"><span class="keyword">RETURNS</span> <span class="type">CHAR</span></span><br><span class="line">		<span class="keyword">BEGIN</span></span><br><span class="line"></span><br><span class="line">				<span class="keyword">DECLARE</span> grade <span class="type">CHAR</span>;</span><br><span class="line">				<span class="keyword">CASE</span> <span class="keyword">WHEN</span> score <span class="operator">&gt;</span> <span class="number">90</span> <span class="keyword">THEN</span> <span class="keyword">SET</span> grade <span class="operator">=</span> <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">						 <span class="keyword">WHEN</span> score <span class="operator">&gt;</span> <span class="number">80</span> <span class="keyword">THEN</span> <span class="keyword">SET</span> grade <span class="operator">=</span> <span class="string">&#x27;B&#x27;</span>;</span><br><span class="line">						 <span class="keyword">WHEN</span> score <span class="operator">&gt;</span> <span class="number">60</span> <span class="keyword">THEN</span> <span class="keyword">SET</span> grade <span class="operator">=</span> <span class="string">&#x27;C&#x27;</span>;</span><br><span class="line">						 <span class="keyword">ELSE</span> <span class="keyword">SET</span> grade <span class="operator">=</span> <span class="string">&#x27;D&#x27;</span>;</span><br><span class="line">				<span class="keyword">END</span> <span class="keyword">CASE</span>;</span><br><span class="line">				<span class="keyword">RETURN</span> grade;</span><br><span class="line">		<span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> test_case(<span class="number">87</span>); # B</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> test_case(<span class="number">56</span>); # D</span><br></pre></td></tr></table></figure>

<h3 id="创建存储过程test-if-pro-，传入工资值，如果工资值-lt-3000-则删除工资为此值的员工，如果3000-lt-x3D-工-资值-lt-x3D-5000-则修改此工资值的员工薪资涨1000，否则涨工资500"><a href="#创建存储过程test-if-pro-，传入工资值，如果工资值-lt-3000-则删除工资为此值的员工，如果3000-lt-x3D-工-资值-lt-x3D-5000-则修改此工资值的员工薪资涨1000，否则涨工资500" class="headerlink" title="创建存储过程test_if_pro()，传入工资值，如果工资值&lt;3000,则删除工资为此值的员工，如果3000 &lt;&#x3D; 工 资值 &lt;&#x3D; 5000,则修改此工资值的员工薪资涨1000，否则涨工资500"></a>创建存储过程test_if_pro()，传入工资值，如果工资值&lt;3000,则删除工资为此值的员工，如果3000 &lt;&#x3D; 工 资值 &lt;&#x3D; 5000,则修改此工资值的员工薪资涨1000，否则涨工资500</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#<span class="number">2.</span> 创建存储过程test_if_pro()，传入工资值，</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#  如果工资值<span class="operator">&lt;</span><span class="number">3000</span>,则删除工资为此值的员工，如果<span class="number">3000</span> <span class="operator">&lt;=</span> 工</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#  资值 <span class="operator">&lt;=</span> <span class="number">5000</span>,则修改此工资值的员工薪资涨<span class="number">1000</span>，否则涨工资<span class="number">500</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> test_if_pro(<span class="keyword">IN</span> salary <span class="keyword">DOUBLE</span>(<span class="number">8</span>,<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="keyword">BEGIN</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">				IF sal<span class="operator">&lt;</span><span class="number">3000</span> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">						<span class="keyword">THEN</span> <span class="keyword">DELETE</span> <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> salary <span class="operator">=</span> sal; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">				ELSEIF sal <span class="operator">&lt;=</span> <span class="number">5000</span> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">						<span class="keyword">THEN</span> <span class="keyword">UPDATE</span> employees <span class="keyword">SET</span> salary <span class="operator">=</span> salary<span class="operator">+</span><span class="number">1000</span> <span class="keyword">WHERE</span> salary <span class="operator">=</span> sal; 			 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">				<span class="keyword">ELSE</span> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">						<span class="keyword">UPDATE</span> employees <span class="keyword">SET</span> salary <span class="operator">=</span> salary<span class="operator">+</span><span class="number">500</span> <span class="keyword">WHERE</span> salary <span class="operator">=</span> sal; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">				<span class="keyword">END</span> IF;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>

<h3 id="创建存储过程insert-data-传入参数为-IN-的-INT-类型变量-insert-count-实现向admin表中批量插入insert-count条记录"><a href="#创建存储过程insert-data-传入参数为-IN-的-INT-类型变量-insert-count-实现向admin表中批量插入insert-count条记录" class="headerlink" title="创建存储过程insert_data(),传入参数为 IN 的 INT 类型变量 insert_count,实现向admin表中批量插入insert_count条记录"></a>创建存储过程insert_data(),传入参数为 IN 的 INT 类型变量 insert_count,实现向admin表中批量插入insert_count条记录</h3><p>题目：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> admin(</span><br><span class="line">id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY AUTO_INCREMENT,</span><br><span class="line">user_name <span class="type">VARCHAR</span>(<span class="number">25</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">user_pwd <span class="type">VARCHAR</span>(<span class="number">35</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> admin;</span><br></pre></td></tr></table></figure>

<p>答案：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#<span class="number">3.</span> 创建存储过程insert_data(),传入参数为 <span class="keyword">IN</span> 的 <span class="type">INT</span> 类型变量 insert_count,</span><br><span class="line"># 实现向admin表中批量插入insert_count条记录</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> admin(</span><br><span class="line">		id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY AUTO_INCREMENT,</span><br><span class="line">		user_name <span class="type">VARCHAR</span>(<span class="number">25</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">		user_pwd <span class="type">VARCHAR</span>(<span class="number">35</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> admin; # <span class="keyword">NULL</span>  <span class="keyword">NULL</span>  <span class="keyword">NULL</span></span><br><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> insert_data(<span class="keyword">IN</span> insert_count <span class="type">INT</span>)</span><br><span class="line">		<span class="keyword">BEGIN</span></span><br><span class="line">			<span class="keyword">DECLARE</span> num <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">1</span>;#记录循环次数</span><br><span class="line">			WHILE num <span class="operator">&lt;=</span> insert_count DO</span><br><span class="line">					<span class="keyword">INSERT</span> <span class="keyword">INTO</span> admin(user_name,user_pwd)					<span class="keyword">VALUES</span>(CONCAT(<span class="string">&#x27;Tom&#x27;</span>,num),ROUND(RAND() <span class="operator">*</span> <span class="number">100000000</span>));</span><br><span class="line"></span><br><span class="line">					<span class="keyword">SET</span> num <span class="operator">=</span> num <span class="operator">+</span> <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">END</span> WHILE;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br><span class="line"><span class="keyword">CALL</span> insert_data(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> admin;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/202210071239323593.png" alt="img"></p>
<h2 id="游标的使用"><a href="#游标的使用" class="headerlink" title="游标的使用"></a><strong>游标的使用</strong></h2><p>​    创建存储过程update_salary() ，参数 1 为 IN 的 INT 型变量 dept_id ，表示部门 id ；参数 2 为 IN 的 INT 型变量 change_sal_count，表示要调整薪资的员工个数。查询指定 id 部门的员工信息，按照 salary 升序排列，根 据hire_date 的情况，调整前 change_sal_count 个员工的薪资，详情如下。</p>
<p><img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/202210071239333599.png" alt="img"></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 游标的使用</span><br><span class="line">#创建存储过程update_salary()，参数<span class="number">1</span>为 <span class="keyword">IN</span> 的<span class="type">INT</span>型变量dept_id，表示部门id；</span><br><span class="line">#  参数<span class="number">2</span>为 <span class="keyword">IN</span>的<span class="type">INT</span>型变量change_sal_count，表示要调整薪资的员工个数。</span><br><span class="line">#  查询指定id部门的员工信息，按照salary升序排列，根据hire_date的情况，</span><br><span class="line">#  调整前change_sal_count个员工的薪资，详情如下。</span><br><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> update_salary(<span class="keyword">IN</span> dept_id <span class="type">INT</span>,<span class="keyword">IN</span> change_sal_count <span class="type">INT</span>)</span><br><span class="line">		<span class="keyword">BEGIN</span></span><br><span class="line">				#声明变量</span><br><span class="line">				<span class="keyword">DECLARE</span> hire_year <span class="keyword">DOUBLE</span>; #记录某个员工的入职年份</span><br><span class="line">				<span class="keyword">DECLARE</span> id <span class="type">INT</span>; #记录员工的id</span><br><span class="line">				<span class="keyword">DECLARE</span> num <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>; #记录循环的次数</span><br><span class="line">				#定义游标</span><br><span class="line">				<span class="keyword">DECLARE</span> emp_cursor <span class="keyword">CURSOR</span> <span class="keyword">FOR</span> <span class="keyword">SELECT</span> <span class="keyword">YEAR</span>(hire_date),employee_id </span><br><span class="line">			<span class="keyword">FROM</span> employees </span><br><span class="line">														<span class="keyword">WHERE</span> department_id <span class="operator">=</span> dept_id					<span class="keyword">ORDER</span> <span class="keyword">BY</span> salary <span class="keyword">ASC</span>;</span><br><span class="line">				#打开游标</span><br><span class="line">				<span class="keyword">OPEN</span> emp_cursor;</span><br><span class="line"></span><br><span class="line">				#使用游标</span><br><span class="line"></span><br><span class="line">				WHILE num <span class="operator">&lt;=</span> change_sal_count DO</span><br><span class="line">						<span class="keyword">FETCH</span> emp_cursor <span class="keyword">INTO</span> hire_year,id;</span><br><span class="line"></span><br><span class="line">						IF hire_year <span class="operator">&lt;</span> <span class="number">1995</span></span><br><span class="line">								<span class="keyword">THEN</span> <span class="keyword">UPDATE</span> employees <span class="keyword">SET</span> salary <span class="operator">=</span> salary <span class="operator">*</span> <span class="number">1.2</span> <span class="keyword">WHERE</span> employee_id <span class="operator">=</span> id;</span><br><span class="line">						ELSEIF hire_year <span class="operator">&lt;</span> <span class="number">1998</span> </span><br><span class="line">								<span class="keyword">THEN</span> <span class="keyword">UPDATE</span> employees <span class="keyword">SET</span> salary <span class="operator">=</span> salary <span class="operator">*</span> <span class="number">1.15</span> <span class="keyword">WHERE</span> employee_id <span class="operator">=</span> id;</span><br><span class="line">						ELSEIF hire_year <span class="operator">&lt;</span> <span class="number">2001</span> </span><br><span class="line">								<span class="keyword">THEN</span> <span class="keyword">UPDATE</span> employees <span class="keyword">SET</span> salary <span class="operator">=</span> salary <span class="operator">*</span> <span class="number">1.10</span> <span class="keyword">WHERE</span> employee_id <span class="operator">=</span> id;</span><br><span class="line">						<span class="keyword">ELSE</span> </span><br><span class="line">								<span class="keyword">UPDATE</span> employees <span class="keyword">SET</span> salary <span class="operator">=</span> salary <span class="operator">*</span> <span class="number">1.05</span> <span class="keyword">WHERE</span> employee_id <span class="operator">=</span> id;</span><br><span class="line"></span><br><span class="line">						<span class="keyword">END</span> IF;</span><br><span class="line">						<span class="keyword">SET</span> num <span class="operator">=</span> num <span class="operator">+</span> <span class="number">1</span>;</span><br><span class="line">				<span class="keyword">END</span> WHILE;</span><br><span class="line">				# 关闭游标</span><br><span class="line">				<span class="keyword">CLOSE</span> emp_cursor;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line">DELIMITER ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> employee_id ,<span class="keyword">YEAR</span>(hire_date),salary</span><br><span class="line"><span class="keyword">FROM</span> employees </span><br><span class="line"><span class="keyword">WHERE</span> department_id <span class="operator">=</span> <span class="number">100</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> salary <span class="keyword">ASC</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CALL</span> update_salary(<span class="number">100</span>,<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> employee_id ,<span class="keyword">YEAR</span>(hire_date),salary</span><br><span class="line"><span class="keyword">FROM</span> employees </span><br><span class="line"><span class="keyword">WHERE</span> department_id <span class="operator">=</span> <span class="number">100</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> salary <span class="keyword">ASC</span>;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/202210071239333659.png" alt="img"></p>
<h1 id="MySQL-触发器"><a href="#MySQL-触发器" class="headerlink" title="MySQL 触发器"></a>MySQL 触发器</h1><p>​     在实际开发中，我们经常会遇到这样的情况：有 2 个或者多个相互关联的表，如 商品信息 和 库存信息 分别存放在 2 个不同的数据表中，我们在添加一条新商品记录的时候，为了保证数据的完整性，必须同时在库存表中添加一条库存记录。</p>
<p>​    这样一来，我们就必须把这两个关联的操作步骤写到程序里面，而且要用 事务 包裹起来，确保这两个操作成为一个 原子操作 ，要么全部执行，要么全部不执行。要是遇到特殊情况，可能还需要对数据进行手动维护，这样就很 容易忘记其中的一步 ，导致数据缺失。</p>
<p>​    这个时候，咱们可以使用触发器。 <strong>你可以创建一个触发器，让商品信息数据的插入操作自动触发库存数</strong> <strong>据的插入操作。</strong> 这样一来，就不用担心因为忘记添加库存数据而导致的数据缺失了。</p>
<h2 id="触发器概述"><a href="#触发器概述" class="headerlink" title="触发器概述"></a><strong>触发器概述</strong></h2><p>​    MySQL从 5.0.2 版本开始支持触发器。 MySQL 的触发器和存储过程一样，都是嵌入到 MySQL 服务器的一段程序。</p>
<p>​    触发器是由 事件来触发 某个操作，这些事件包括 INSERT 、 UPDATE 、 DELETE 事件。所谓事件就是指用户的动作或者触发某项行为。如果定义了触发程序，当数据库执行这些语句时候，就相当于事件发生了，就会 自动 激发触发器执行相应的操作。</p>
<p>​    当对数据表中的数据执行插入、更新和删除操作，需要自动执行一些数据库逻辑时，可以使用触发器来实现。</p>
<h2 id="触发器的创建"><a href="#触发器的创建" class="headerlink" title="触发器的创建"></a><strong>触发器的创建</strong></h2><h3 id="创建触发器语法"><a href="#创建触发器语法" class="headerlink" title="创建触发器语法"></a><strong>创建触发器语法</strong></h3><p><em><strong>*创建触发器的语法结构是：*</strong></em></p>
<blockquote>
<p>​    <em><strong>*CREATE TRIGGER** **触发器名称*</strong></em></p>
<p>​    <em>*<em>*{BEFORE|*</em>*<em>AFTER*</em>**} {INSERT|*</em>*<em>UPDATE*</em>*<em>|*</em>*<em>DELETE*</em>*<em>}*</em> *<em>ON*</em> *<em>表名*</em>**</p>
<p>​    <em><strong>*FOR EACH ROW*</strong></em></p>
<p>​    <em><strong>*触发器执行的语句块;*</strong></em></p>
</blockquote>
<p><em><strong>*说明：*</strong></em></p>
<p>​    <em><strong>*表名** **：表示触发器监控的对象。*</strong></em></p>
<p>​    <em>*<em>*BEFORE|AFTER*</em> *<em>：表示触发的时间。*</em>*<em>BEFORE*</em> *<em>表示在事件之前触发；*</em>*</em></p>
<p>​                                   <em><strong>*AFTER 表示在事件之后触发。*</strong></em></p>
<p>​    <em><strong>*INSERT|UPDATE|DELETE** **：表示触发的事件。*</strong></em></p>
<p>​        <em><strong>*INSERT 表示插入记录时触发；*</strong></em></p>
<p>​        <em><strong>*UPDATE 表示更新记录时触发；*</strong></em></p>
<p>​        <em><strong>*DELETE 表示删除记录时触发。*</strong></em></p>
<p>​     <em>*<em>*触发器执行的语句块*</em> *<em>：可以是单条*</em>*<em>SQL*</em>*<em>语句，也可以是由*</em>*<em>BEGIN…END*</em>*</em> <strong>结构组成的复合语句块。</strong></p>
<h3 id="代码举例-2"><a href="#代码举例-2" class="headerlink" title="代码举例"></a><strong>代码举例</strong></h3><p><em><strong>*举例1：*</strong></em></p>
<p><em>*<em>*1*</em>*<em>、创建数据表：*</em>*</em></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> test_trigger (</span><br><span class="line">id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY AUTO_INCREMENT,</span><br><span class="line">t_note <span class="type">VARCHAR</span>(<span class="number">30</span>)</span><br><span class="line">);</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> test_trigger_log (</span><br><span class="line">id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY AUTO_INCREMENT,</span><br><span class="line">t_log <span class="type">VARCHAR</span>(<span class="number">30</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p><em>*<em>*2*</em>*<em>、创建触发器：创建名称为*</em>*<em>before_insert*</em>*<em>的触发器，向*</em>*<em>test_trigger*</em>*<em>数据表插入数据之前，向*</em>*</em></p>
<p><em>*<em>*test_trigger_log*</em>*<em>数据表中插入*</em>*<em>before_insert*</em>*<em>的日志信息。*</em>*</em></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># <span class="number">2</span>、创建触发器：创建名称为before_insert的触发器，向test_trigger数据表插入数据之前，</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#   向test_trigger_log数据表中插入before_insert的日志信息。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> before_insert</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">BEFORE <span class="keyword">INSERT</span> <span class="keyword">ON</span> test_trigger</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">BEGIN</span> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="keyword">INSERT</span> <span class="keyword">INTO</span> test_trigger_log(t_log)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="keyword">VALUES</span> (<span class="string">&#x27;before into ...&#x27;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>

<p><em>*<em>*3*</em>*<em>、向*</em>*<em>test_trigger*</em>*<em>数据表中插入数据*</em>*</em></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># <span class="number">3</span>、向test_trigger数据表中插入数据</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test_trigger(t_note)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27; 测试 before into 触发器&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p><em>*<em>*4*</em>*<em>、查看*</em>*<em>test_trigger_log*</em>*<em>数据表中的数据*</em>*</em></p>
<p><img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/202210071239333798.png" alt="img"></p>
<p><em>*<em>*举例*</em>*<em>2*</em>*<em>：*</em>*</em> <strong>创建名称为after_insert</strong> <em>*<em>*的触发器，向*</em>*<em>test_trigger*</em>*<em>数据表插入数据之后，向*</em>*<em>test_trigger_log*</em>*<em>数据表中插入after_insert*</em>*<em>的日志信息。*</em>*</em></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 举例<span class="number">2</span>： 创建名称为after_insert的触发器，向test_trigger数据表插入数据之后，</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 向test_trigger_log数据表中插入after_insert的日志信息。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> after_insert</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">AFTER <span class="keyword">INSERT</span> <span class="keyword">ON</span> test_trigger</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="keyword">INSERT</span> <span class="keyword">INTO</span> test_trigger_log(t_log)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="keyword">VALUES</span> (<span class="string">&#x27;after insert ...&#x27;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test_trigger(t_note)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">VALUES</span>(<span class="string">&#x27;测试 after insert 触发器&#x27;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> test_trigger;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> test_trigger_log;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/202210071239343860.png" alt="img"></p>
<p><em>*<em>*举例*</em>*<em>3*</em>*<em>：*</em>*<em>定义触发器*</em>*<em>“salary_check_trigger”*</em>*<em>，基于员工表*</em>*<em>“employees”*</em>*<em>的*</em>*<em>INSERT*</em>*<em>事件，在*</em>*<em>INSERT*</em>*<em>之前检查将要添加的新员工薪资是否大于他领导的薪资，如果大于领导薪资，则报sqlstate_value*</em>*<em>为*</em>**’HY000’*</em>*<em>的错误，从而使得添加失败。*</em>**</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 举例<span class="number">3</span>：定义触发器“salary_check_trigger”，基于员工表“employees”的<span class="keyword">INSERT</span>事件，</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#	 在<span class="keyword">INSERT</span>之前检查将要添加的新员工薪资是否大于他领导的薪资，</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#	 如果大于领导薪资，则报sqlstate_value为<span class="string">&#x27;HY000&#x27;</span>的错误，从而使得添加失败。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 准备工作</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> employees</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> atguigudb.`employees`;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> departments</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> atguigudb.`departments`;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">DESC</span> employees;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#创建触发器</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> salary_check_trigger</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">BEFORE <span class="keyword">INSERT</span> <span class="keyword">ON</span> employees</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="keyword">BEGIN</span> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">				#查询到要添加的数据的manager的薪资</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">				<span class="keyword">DECLARE</span> mgr_sal <span class="keyword">DOUBLE</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">				</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">				<span class="keyword">SELECT</span> salary <span class="keyword">INTO</span> mgr_sal</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">				<span class="keyword">FROM</span> employees</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">				<span class="keyword">WHERE</span> employee_id <span class="operator">=</span> NEW.manager_id;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">				</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">				IF NEW.salary <span class="operator">&gt;</span> mgr_sal</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">					<span class="keyword">THEN</span> SIGNAL <span class="keyword">SQLSTATE</span> <span class="string">&#x27;HY000&#x27;</span> <span class="keyword">SET</span> MESSAGE_TEXT <span class="operator">=</span> <span class="string">&#x27;薪资高于领导薪资错误&#x27;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">				<span class="keyword">END</span> IF;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">				</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#测试</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#添加成功：依然触发了触发器salary_check_trigger的执行</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employees(employee_id,last_name,email,hire_date,job_id,salary,manager_id)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">				<span class="keyword">VALUES</span>(<span class="number">300</span>,<span class="string">&#x27;Tom&#x27;</span>,<span class="string">&#x27;Tom@123.com&#x27;</span>,CURDATE(),<span class="string">&#x27;AD_VP&#x27;</span>,<span class="number">8000</span>,<span class="number">206</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># <span class="number">1644</span> <span class="operator">-</span> 薪资高于领导薪资错误</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employees(employee_id,last_name,email,hire_date,job_id,salary,manager_id)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">				<span class="keyword">VALUES</span>(<span class="number">301</span>,<span class="string">&#x27;Tom2&#x27;</span>,<span class="string">&#x27;Tom2@123.com&#x27;</span>,CURDATE(),<span class="string">&#x27;AD_VP&#x27;</span>,<span class="number">9000</span>,<span class="number">206</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">				</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/202210071239344054.png" alt="img"></p>
<p>​     <strong>上面触发器声明过程中的NEW关键字代表INSERT添加语句的新记录。</strong></p>
<p>​    <strong>还有OLD表示原有的数据记录。</strong></p>
<h2 id="查看、删除触发器"><a href="#查看、删除触发器" class="headerlink" title="查看、删除触发器"></a><strong>查看、删除触发器</strong></h2><h3 id="查看触发器"><a href="#查看触发器" class="headerlink" title="查看触发器"></a><strong>查看触发器</strong></h3><p>​    查看触发器是查看数据库中已经存在的触发器的定义、状态和语法信息等。</p>
<h3 id="方式1：查看当前数据库的所有触发器的定义"><a href="#方式1：查看当前数据库的所有触发器的定义" class="headerlink" title="方式1：查看当前数据库的所有触发器的定义"></a><strong>方式1：查看当前数据库的所有触发器的定义</strong></h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> TRIGGERS\G</span><br></pre></td></tr></table></figure>

<p><img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/202210071239344072.png" alt="img"></p>
<h3 id="方式2：查看当前数据库中某个触发器的定义"><a href="#方式2：查看当前数据库中某个触发器的定义" class="headerlink" title="方式2：查看当前数据库中某个触发器的定义"></a><strong>方式2：查看当前数据库中某个触发器的定义</strong></h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> 触发器名</span><br></pre></td></tr></table></figure>

<p><img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/202210071239344080.png" alt="img"></p>
<h3 id="方式3：从系统库information-schema的TRIGGERS表中查询"><a href="#方式3：从系统库information-schema的TRIGGERS表中查询" class="headerlink" title="*方式3：从系统库information_schema的TRIGGERS表中查询*"></a><em><strong>*方式3：从系统库information_schema的TRIGGERS表中查询*</strong></em></h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> information_schema.TRIGGERS;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/202210071239354088.png" alt="img"></p>
<h3 id="删除触发器"><a href="#删除触发器" class="headerlink" title="删除触发器"></a><strong>删除触发器</strong></h3><p>​    <strong>触发器也是数据库对象，删除触发器也用DROP</strong> <em><strong>*语句，语法格式如下：*</strong></em></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TRIGGER</span> [IF <span class="keyword">EXISTS</span>] 触发器名称;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/202210071239354098.png" alt="img"></p>
<h2 id="触发器的优缺点"><a href="#触发器的优缺点" class="headerlink" title="触发器的优缺点"></a><strong>触发器的优缺点</strong></h2><h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a><strong>优点</strong></h3><h4 id="触发器可以确保数据的完整性。"><a href="#触发器可以确保数据的完整性。" class="headerlink" title="触发器可以确保数据的完整性。"></a><strong>触发器可以确保数据的完整性</strong>。</h4><p>​    假设我们用 进货单头表 （demo.importhead）来保存进货单的总体信息，包括进货单编号、供货商编 号、仓库编号、总计进货数量、总计进货金额和验收日期。</p>
<p><img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/202210071239354108.png" alt="img"></p>
<p>​    用 进货单明细表 （demo.importdetails）来保存进货商品的明细，包括进货单编号、商品编号、进货数量、进货价格和进货金额。</p>
<p><img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/202210071239364112.png" alt="img"></p>
<p>​    每当我们录入、删除和修改一条进货单明细数据的时候，进货单明细表里的数据就会发生变动。这个时候，在进货单头表中的总计数量和总计金额就必须重新计算，否则，进货单头表中的总计数量和总计金额就不等于进货单明细表中数量合计和金额合计了，这就是数据不一致。</p>
<p>​    为了解决这个问题，我们就可以使用触发器， <strong>规定每当进货单明细表有数据插入、修改和删除的操作</strong> <strong>时，自动触发</strong> <strong>2</strong> <strong>步操作：</strong></p>
<p>​    1）重新计算进货单明细表中的数量合计和金额合计；</p>
<p>​    2）用第一步中计算出来的值更新进货单头表中的合计数量与合计金额。</p>
<p>​    这样一来，进货单头表中的合计数量与合计金额的值，就始终与进货单明细表中计算出来的合计数量与合计金额的值相同，数据就是一致的，不会互相矛盾。</p>
<h4 id="触发器可以帮助我们记录操作日志。"><a href="#触发器可以帮助我们记录操作日志。" class="headerlink" title="触发器可以帮助我们记录操作日志。"></a><strong>触发器可以帮助我们记录操作日志。</strong></h4><p>​    利用触发器，可以具体记录什么时间发生了什么。比如，记录修改会员储值金额的触发器，就是一个很好的例子。这对我们还原操作执行时的具体场景，更好地定位问题原因很有帮助。</p>
<h4 id="触发器还可以用在操作数据前，对数据进行合法性检查。"><a href="#触发器还可以用在操作数据前，对数据进行合法性检查。" class="headerlink" title="触发器还可以用在操作数据前，对数据进行合法性检查。"></a><strong>触发器还可以用在操作数据前，对数据进行合法性检查。</strong></h4><p>​    比如，超市进货的时候，需要库管录入进货价格。但是，人为操作很容易犯错误，比如说在录入数量的时候，把条形码扫进去了；录入金额的时候，看串了行，录入的价格远超售价，导致账面上的巨亏……</p>
<p>​    这些都可以通过触发器，在实际插入或者更新操作之前，对相应的数据进行检查，及时提示错误，防止错误数据进入系统.</p>
<h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a><strong>缺点</strong></h3><h4 id="触发器最大的一个问题就是可读性差。"><a href="#触发器最大的一个问题就是可读性差。" class="headerlink" title="触发器最大的一个问题就是可读性差。"></a><strong>触发器最大的一个问题就是可读性差。</strong></h4><p>​    因为触发器存储在数据库中，并且由事件驱动，这就意味着触发器有可能 不受应用层的控制 。这对系统 维护是非常有挑战的。</p>
<p>​    比如，创建触发器用于修改会员储值操作。如果触发器中的操作出了问题，会导致会员储值金额更新失败。我用下面的代码演示一下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> demo.membermaster <span class="keyword">set</span> memberdeposit<span class="operator">=</span><span class="number">20</span> <span class="keyword">where</span> memberid <span class="operator">=</span> <span class="number">2</span>; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#ERROR <span class="number">1054</span> (<span class="number">42</span>S22): <span class="literal">Unknown</span> <span class="keyword">column</span> <span class="string">&#x27;aa&#x27;</span> <span class="keyword">in</span> <span class="string">&#x27;field list&#x27;</span></span><br></pre></td></tr></table></figure>

<p>​    结果显示，系统提示错误，字段“aa”不存在。 这是因为，触发器中的数据插入操作多了一个字段，系统提示错误。可是，如果你不了解这个触发器，很可能会认为是更新语句本身的问题，或者是会员信息表的结构出了问题。说不定你还会给会员信息表添加一个叫“aa”的字段，试图解决这个问题，结果只能是白费力。</p>
<h4 id="相关数据的变更，可能会导致触发器出错。"><a href="#相关数据的变更，可能会导致触发器出错。" class="headerlink" title="相关数据的变更，可能会导致触发器出错。"></a><strong>相关数据的变更，可能会导致触发器出错。</strong></h4><p>​    特别是数据表结构的变更，都可能会导致触发器出错，进而影响数据操作的正常运行。这些都会由于触发器本身的隐蔽性，影响到应用中错误原因排查的效率。</p>
<h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a><strong>注意点</strong></h3><p>​    注意，如果在子表中定义了外键约束，并且外键指定了ON UPDATE&#x2F;DELETE CASCADE&#x2F;SET NULL 子句，此时修改父表被引用的键值或删除父表被引用的记录行时，也会引起子表的修改和删除操作，此时基于子 表的UPDATE 和 DELETE 语句定义的触发器并不会被激活。</p>
<p>​    例如：基于子表员工表（t_employee）的DELETE 语句定义了触发器 t1 ，而子表的部门编号（did）字段定义了外键约束引用了父表部门表（t_department）的主键列部门编号（did），并且该外键加了 “ON DELETE SET NULL”子句，那么如果此时删除父表部门表（</p>
<p>t_department ）在子表员工表（t_employee）有匹配记录的部门记录时，会引起子表员工表（t_employee）匹配记录的部门编号（did）修改为 NULL 但是此时不会激活触发器 t1 。只有直接对子表员工表（ t_employee ）执行 DELETE 语句时才会激活触发器 t1 。</p>
<h2 id="练习-2"><a href="#练习-2" class="headerlink" title="练习"></a>练习</h2><h3 id="练习1-2"><a href="#练习1-2" class="headerlink" title="练习1"></a>练习1</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#<span class="number">0.</span> 准备工作</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> emps</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> employee_id,last_name,salary</span><br><span class="line"><span class="keyword">FROM</span> atguigudb.`employees`;</span><br></pre></td></tr></table></figure>

<h4 id="复制一张emps表的空表emps-back，只有表结构，不包含任何数据"><a href="#复制一张emps表的空表emps-back，只有表结构，不包含任何数据" class="headerlink" title="复制一张emps表的空表emps_back，只有表结构，不包含任何数据"></a>复制一张emps表的空表emps_back，只有表结构，不包含任何数据</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#<span class="number">1.</span> 复制一张emps表的空表emps_back，只有表结构，不包含任何数据</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> emps_back</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> </span><br><span class="line"><span class="keyword">FROM</span> emps</span><br><span class="line"><span class="keyword">WHERE</span> employee_id <span class="operator">=</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<h4 id="查询emps-back表中的数据"><a href="#查询emps-back表中的数据" class="headerlink" title="查询emps_back表中的数据"></a>查询emps_back表中的数据</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#<span class="number">2.</span> 查询emps_back表中的数据</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> emps_back;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/202210071239364201.png" alt="img"></p>
<h4 id="创建触发器emps-insert-trigger，每当向emps表中添加一条记录时，同步将这条记录添加到emps-back表中"><a href="#创建触发器emps-insert-trigger，每当向emps表中添加一条记录时，同步将这条记录添加到emps-back表中" class="headerlink" title="创建触发器emps_insert_trigger，每当向emps表中添加一条记录时，同步将这条记录添加到emps_back表中"></a>创建触发器emps_insert_trigger，每当向emps表中添加一条记录时，同步将这条记录添加到emps_back表中</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#<span class="number">3.</span> 创建触发器emps_insert_trigger，每当向emps表中添加一条记录时，</span><br><span class="line">#   同步将这条记录添加到emps_back表中</span><br><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> emps_insert_trigger</span><br><span class="line">AFTER <span class="keyword">INSERT</span> <span class="keyword">ON</span> emps</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span></span><br><span class="line">		<span class="keyword">BEGIN</span></span><br><span class="line">				<span class="keyword">INSERT</span> <span class="keyword">INTO</span> emps_back(employee_id,last_name,salary)</span><br><span class="line">				<span class="keyword">VALUES</span> (NEW.employee_id,NEW.last_name,NEW.salary);</span><br><span class="line">		<span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>

<h4 id="验证触发器是否起作用"><a href="#验证触发器是否起作用" class="headerlink" title="验证触发器是否起作用"></a>验证触发器是否起作用</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#<span class="number">4.</span> 验证触发器是否起作用</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> emps <span class="keyword">VALUES</span>(<span class="number">300</span>,<span class="string">&#x27;Tom&#x27;</span>,<span class="number">5600</span>); </span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> emps_back; #<span class="number">300</span>	Tom	<span class="number">5600.00</span></span><br></pre></td></tr></table></figure>

<h3 id="练习2-2"><a href="#练习2-2" class="headerlink" title="练习2"></a>练习2</h3><h4 id="复制一张emps表的空表emps-back1，只有表结构，不包含任何数据"><a href="#复制一张emps表的空表emps-back1，只有表结构，不包含任何数据" class="headerlink" title="复制一张emps表的空表emps_back1，只有表结构，不包含任何数据"></a>复制一张emps表的空表emps_back1，只有表结构，不包含任何数据</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 练习<span class="number">2</span></span><br><span class="line">#<span class="number">1.</span> 复制一张emps表的空表emps_back1，只有表结构，不包含任何数据</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> emps_back1</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> </span><br><span class="line"><span class="keyword">FROM</span> emps</span><br><span class="line"><span class="keyword">WHERE</span> <span class="number">1</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<h4 id="查询emps-back1表中的数据"><a href="#查询emps-back1表中的数据" class="headerlink" title="查询emps_back1表中的数据"></a>查询emps_back1表中的数据</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#<span class="number">2.</span> 查询emps_back1表中的数据</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> emps_back1; #	<span class="keyword">NULL</span> <span class="keyword">NULL</span> <span class="keyword">NULL</span>	</span><br></pre></td></tr></table></figure>

<h4 id="创建触发器emps-del-trigger，每当向emps表中删除一条记录时，同步将删除的这条记录添加到emps-back1表中"><a href="#创建触发器emps-del-trigger，每当向emps表中删除一条记录时，同步将删除的这条记录添加到emps-back1表中" class="headerlink" title="创建触发器emps_del_trigger，每当向emps表中删除一条记录时，同步将删除的这条记录添加到emps_back1表中"></a>创建触发器emps_del_trigger，每当向emps表中删除一条记录时，同步将删除的这条记录添加到emps_back1表中</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#<span class="number">3.</span> 创建触发器emps_del_trigger，每当向emps表中删除一条记录时，</span><br><span class="line">#		同步将删除的这条记录添加到emps_back1表中</span><br><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> emps_del_trigger</span><br><span class="line">BEFORE <span class="keyword">DELETE</span> <span class="keyword">ON</span> emps</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span></span><br><span class="line">		<span class="keyword">BEGIN</span></span><br><span class="line">			<span class="keyword">INSERT</span> <span class="keyword">INTO</span> emps_back1(employee_id,last_name,salary)</span><br><span class="line">			<span class="keyword">VALUES</span> (OLD.employee_id,OLD.last_name,OLD.salary); </span><br><span class="line">		<span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>

<h4 id="验证触发器是否起作用-1"><a href="#验证触发器是否起作用-1" class="headerlink" title="验证触发器是否起作用"></a>验证触发器是否起作用</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#<span class="number">4.</span> 验证触发器是否起作用</span><br><span class="line"></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> emps</span><br><span class="line"><span class="keyword">WHERE</span> employee_id <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> emps_back1; # <span class="number">100</span>	King	<span class="number">24000.00</span></span><br></pre></td></tr></table></figure>

<h1 id="MySQL8新特性概述"><a href="#MySQL8新特性概述" class="headerlink" title="MySQL8新特性概述"></a><strong>MySQL8</strong>新特性概述</h1><p>​    MySQL从 5.7 版本直接跳跃发布了 8.0 版本 ，可见这是一个令人兴奋的里程碑版本。 MySQL 8 版本在功能上 做了显著的改进与增强，开发者对MySQL 的源代码进行了重构，最突出的一点是多 MySQL Optimizer 优化器进行了改进。不仅在速度上得到了改善，还为用户带来了更好的性能和更棒的体验。</p>
<h2 id="MySQL8-0-新增特性"><a href="#MySQL8-0-新增特性" class="headerlink" title="MySQL8.0 新增特性"></a><strong>MySQL8.0 新增特性</strong></h2><h3 id="更简便的NoSQL支持"><a href="#更简便的NoSQL支持" class="headerlink" title="更简便的NoSQL支持"></a><strong>更简便的NoSQL支持</strong></h3><p>​     NoSQL 泛指非关系型数据库和数据存储。随着互联网平台的规模飞速发展，传统 的关系型数据库已经越来越不能满足需求。从5.6 版本开始， MySQL 就开始支持简单的 NoSQL 存储功能。</p>
<p>MySQL 8 对这一功能做了优化，以更灵活的方式实现 NoSQL 功能，不再依赖模式（</p>
<p>schema ）。</p>
<h3 id="更好的索引"><a href="#更好的索引" class="headerlink" title="更好的索引"></a><strong>更好的索引</strong></h3><p>​    在查询中，正确地使用索引可以提高查询的效率。MySQL 8 中新增了 隐藏索引 和 降序索引 。隐藏索引可以用来测试去掉索引对查询性能的影响。在查询中混合存在多列索引时，使用降序索引可以提高查询的性能。</p>
<h3 id="更完善的JSON支持"><a href="#更完善的JSON支持" class="headerlink" title="更完善的JSON支持"></a><strong>更完善的JSON支持</strong></h3><p>​    ySQL从 5.7 开始支持原生 JSON 数据的存储， MySQL 8 对这一功能做了优化，增加了聚合函数 JSON_ARRAYAGG() 和 JSON_OBJECTAGG() ，将参数聚合为 JSON 数组或对象，新增了行内</p>
<p>操作符 -&gt;&gt; ，是列路径运算符 -&gt; 的增强，对 JSON 排序做了提升，并优化了 JSON 的更新操作。</p>
<h3 id="安全和账户管理"><a href="#安全和账户管理" class="headerlink" title="安全和账户管理"></a><strong>安全和账户管理</strong></h3><p>​     MySQL 8 中新增了 caching_sha2_password 授权插件、角色、密码历史记录和 FIPS模式支持，这些特性提高了数据库的安全性和性能，使数据库管理员能够更灵活地进行账户管理工作。</p>
<h3 id="InnoDB的变化"><a href="#InnoDB的变化" class="headerlink" title="InnoDB的变化"></a><strong>InnoDB的变化</strong></h3><p>​    InnoDB是 MySQL 默认的存储引擎 ，是事务型数据库的首选引擎，支持事务安全表</p>
<p>（ACID），支持行锁定和外键。在 MySQL 8 版本中， InnoDB 在自增、索引、加密、死锁、共享锁等方面做了大量的 改进和优化 ，并且支持原子数据定义语言（DDL），提高了数据安全性，对事务提供更好的支持。</p>
<h3 id="数据字典"><a href="#数据字典" class="headerlink" title="数据字典"></a><strong>数据字典</strong></h3><p>​     在之前的 MySQL 版本中，字典数据都存储在元数据文件和非事务表中。从 MySQL 8 开始新增</p>
<p>了事务数据字典，在这个字典里存储着数据库对象信息，这些数据字典存储在内部事务表中。</p>
<h3 id="原子数据定义语句"><a href="#原子数据定义语句" class="headerlink" title="原子数据定义语句"></a><strong>原子数据定义语句</strong></h3><p>​    MySQL 8开始支持原子数据定义语句（Automic DDL），即 原子 DDL 。目前，只有InnoDB存储引擎支持原子 DDL 。原子数据定义语句（DDL）将与 DDL 操作相关的数据字典更新、存储引擎</p>
<p>操作、二进制日志写入结合到一个单独的原子事务中，这使得即使服务器崩溃，事务也会提交或回滚。</p>
<p>​    使用支持原子操作的存储引擎所创建的表，在执行DROP TABLE 、 CREATE TABLE 、 ALTER TABLE 、RENAME TABLE、 TRUNCATE TABLE 、 CREATE TABLESPACE 、 DROP TABLESPACE 等操作时，都支持原子操作，即事务要么完全操作成功，要么失败后回滚，不再进行部分提交。 对于从MySQL 5.7 复制到 MySQL 8版本中的语句，可以添加 IF EXISTS 或 IF NOT EXISTS 语句来避免发生错误。</p>
<h3 id="资源管理"><a href="#资源管理" class="headerlink" title="资源管理"></a><strong>资源管理</strong></h3><p>​     MySQL 8 开始支持创建和管理资源组，允许将服务器内运行的线程分配给特定的分组，以便 线程根据组内可用资源执行。组属性能够控制组内资源，启用或限制组内资源消耗。数据库管理员能够根据不同的工作负载适当地更改这些属性。 目前，CPU 时间是可控资源，由 “ 虚拟 CPU” 这个概念来表示，此术语包含CPU 的核心数，超线程，硬件线程等等。服务器在启动时确定可用的虚拟 CPU 数量。拥有对应权限的数据库管理员可以将这些CPU 与资源组关联，并为资源组分配线程。 资源组组件为 MySQL中 的资源组管理提供了 SQL 接口。资源组的属性用于定义资源组。 MySQL 中存在两个默认组，系统组和用户 组，默认的组不能被删除，其属性也不能被更改。对于用户自定义的组，资源组创建时可初始化所有的 属性，除去名字和类型，其他属性都可在创建之后进行更改。 在一些平台下，或进行了某些 MySQL 的配 置时，资源管理的功能将受到限制，甚至不可用。例如，如果安装了线程池插件，或者使用的是 macOS 系统，资源管理将处于不可用状态。在 FreeBSD 和 Solaris 系统中，资源线程优先级将失效。在 Linux 系统 中，只有配置了 CAP_SYS_NICE 属性，资源管理优先级才能发挥作用。</p>
<h3 id="字符集支持"><a href="#字符集支持" class="headerlink" title="字符集支持"></a><strong>字符集支持</strong></h3><p>​     MySQL 8 中默认的字符集由 latin1 更改为 utf8mb4 ，并首次增加了日语所特定使用的集合，utf8mb4_ja_0900_as_cs 。</p>
<h3 id="优化器增强"><a href="#优化器增强" class="headerlink" title="优化器增强"></a><strong>优化器增强</strong></h3><p>​     MySQL 优化器开始支持隐藏索引和降序索引。隐藏索引不会被优化器使用，验证索引的必要性时不需要删除索引，先将索引隐藏，如果优化器性能无影响就可以真正地删除索引。降序索引允许优化器对多个列进行排序，并且允许排序顺序不一致。</p>
<h3 id="公用表表达式"><a href="#公用表表达式" class="headerlink" title="公用表表达式"></a><strong>公用表表达式</strong></h3><p>​    公用表表达式（Common Table Expressions）简称为CTE ， MySQL 现在支持递归和非递</p>
<p>归两种形式的 CTE 。 CTE 通过在 SELECT 语句或其他特定语句前 使用 WITH 语句对临时结果集 进行命名。</p>
<p><em><strong>*基础语法如下：*</strong></em></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">WITH</span> cte_name (col_name1,col_name2 ...) <span class="keyword">AS</span> (Subquery)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> cte_name;</span><br></pre></td></tr></table></figure>

<p>​    <strong>Subquery代表子查询，子查询前使用</strong> <em>*<em>*WITH*</em>*<em>语句将结果集命名为*</em>*<em>cte_name*</em>*<em>，在后续的查询中即可使用cte_name进行查询。*</em>*</em></p>
<h3 id="窗口函数"><a href="#窗口函数" class="headerlink" title="窗口函数"></a><strong>窗口函数</strong></h3><p>​     MySQL 8 开始支持窗口函数。在之前的版本中已存在的大部分 聚合函数 在 MySQL 8 中也可以作为窗口函数来使用。</p>
<p><img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/202210071239364357.png" alt="img"></p>
<h3 id="正则表达式支持"><a href="#正则表达式支持" class="headerlink" title="正则表达式支持"></a><strong>正则表达式支持</strong></h3><p>​     MySQL 在 8.0.4 以后的版本中采用支持 Unicode 的国际化组件库实现正则表达式操作，这种方式不仅能提供完全的Unicode 支持，而且是多字节安全编码。 MySQL 增加了 REGEXP_LIKE() 、</p>
<p>EGEXP_INSTR() 、 REGEXP_REPLACE() 和 REGEXP_SUBSTR() 等函数来提升性能。另外， regexp_stack_limit 和regexp_time_limit 系统变量能够通过匹配引擎来控制资源消耗。</p>
<h3 id="内部临时表"><a href="#内部临时表" class="headerlink" title="内部临时表"></a><strong>内部临时表</strong></h3><p>​     TempTable 存储引擎取代 MEMORY 存储引擎成为内部临时表的默认存储引擎 。 TempTable 存储引擎为VARCHAR 和 VARBINARY 列提供高效存储。 internal_tmp_mem_storage_engine 会话变量定义了内部临时表的存储引擎，可选的值有两个，TempTable 和 MEMORY ，其中 TempTable 为默认的存储引擎。</p>
<p>​    temptable_max_ram系统配置项定义了TempTable 存储引擎可使用的最大内存数量。</p>
<h3 id="日志记录"><a href="#日志记录" class="headerlink" title="日志记录"></a><strong>日志记录</strong></h3><p>​     在 MySQL 8 中错误日志子系统由一系列 MySQL 组件构成。这些组件的构成由系统变量</p>
<p>log_error_services 来配置，能够实现日志事件的过滤和写入</p>
<h3 id="备份锁"><a href="#备份锁" class="headerlink" title="备份锁"></a><strong>备份锁</strong></h3><p>​     新的备份锁允许在线备份期间执行数据操作语句，同时阻止可能造成快照不一致的操作。新备份锁由 LOCK INSTANCE FOR BACKUP 和 UNLOCK INSTANCE 语法提供支持，执行这些操作需要备份管理员特权。</p>
<h3 id="增强的MySQL复制"><a href="#增强的MySQL复制" class="headerlink" title="增强的MySQL复制"></a><strong>增强的MySQL复制</strong></h3><p>​     MySQL 8 复制支持对 JSON 文档 进行部分更新的 二进制日志记录 ，该记录 使用紧凑的二进制格式 ，从而节省记录完整 JSON 文档的空间。当使用基于语句的日志记录时，这种紧凑的日志记</p>
<p>录会自动完成，并且可以通过将新的 binlog_row_value_options 系统变量值设置为 PARTIAL_JSON 来启用。</p>
<h2 id="MySQL8-0移除的旧特性"><a href="#MySQL8-0移除的旧特性" class="headerlink" title="MySQL8.0移除的旧特性"></a><strong>MySQL8.0移除的旧特性</strong></h2><p>​    在MySQL 5.7 版本上开发的应用程序如果使用了 MySQL8.0 移除的特性，语句可能会失败，或者产生不同的执行结果。为了避免这些问题，对于使用了移除特性的应用，应当尽力修正避免使用这些特性，并尽可能使用替代方法。</p>
<h3 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a><strong>查询缓存</strong></h3><p>​    查询缓存已被移除 ，删除的项有：</p>
<p>​        <strong>（1）语句：</strong> FLUSH QUERY CACHE 和 RESET QUERY CACHE。</p>
<p>​        <strong>（2）系统变量：</strong> query_cache_limit 、 query_cache_min_res_unit 、 query_cache_size 、</p>
<p>​                      query_cache_type、query_cache_wlock_invalidate。</p>
<p>​        <strong>（3）状态变量：</strong> Qcache_free_blocks、 Qcache_free_memory、Qcache_hits、</p>
<p>​                      Qcache_inserts、Qcache_lowmem_prunes、Qcache_not_cached、</p>
<p>​                      Qcache_queries_in_cache、Qcache_total_blocks。</p>
<p>​        <strong>（4）线程状态：</strong> checking privileges on cached query、checking query cache for                           query、invalidating query cache entries、sending cached result to</p>
<p>​                      client、storing result in query cache、waiting for query cache lock。</p>
<h3 id="加密相关"><a href="#加密相关" class="headerlink" title="加密相关"></a><strong>加密相关</strong></h3><p>​     删除的加密相关的内容有： ENCODE() 、 DECODE() 、 ENCRYPT() 、 DES_ENCRYPT() 和</p>
<p>DES_DECRYPT() 函数，配置项 des-key-file ，系统变量 have_crypt ， FLUSH 语句 DES_KEY_FILE 选项，HAVE_CRYPT CMake选项。 对于移除的 ENCRYPT() 函数，考虑使用 SHA2() 替代，对于其他移除的函数，使用AES_ENCRYPT() 和 AES_DECRYPT() 替代。</p>
<h3 id="空间函数相关"><a href="#空间函数相关" class="headerlink" title="空间函数相关"></a><strong>空间函数相关</strong></h3><p>​     在 MySQL 5.7 版本中，多个空间函数已被标记为过时。这些过时函数在 MySQL 8 中都已被</p>
<p>移除，只保留了对应的 ST_ 和 MBR 函数。</p>
<h3 id="N和NULL"><a href="#N和NULL" class="headerlink" title="\N和NULL"></a><strong>\N和NULL</strong></h3><p>​    在SQL语句中，解析器不再将\N视为NULL，所以在SQL语句中应使用NULL代替\N。这项变化不会影响使用LOAD DATA INFILE或者SELECT…INTO OUTFILE操作文件的导入和导出。在这类操作中，NULL仍等同于\N。</p>
<h3 id="mysql-install-db"><a href="#mysql-install-db" class="headerlink" title="mysql_install_db"></a><strong>mysql_install_db</strong></h3><p>​     在 MySQL 分布中，已移除了 mysql_install_db 程序，数据字典初始化需要调用带着 –</p>
<p>initialize 或者 –initialize-insecure 选项的 mysqld 来代替实现。另外， –bootstrap 和 INSTALL_SCRIPTDIRCMake也已被删除。</p>
<h3 id="通用分区处理程序"><a href="#通用分区处理程序" class="headerlink" title="通用分区处理程序"></a><strong>通用分区处理程序</strong></h3><p>​     通用分区处理程序已从 MySQL 服务中被移除。为了实现给定表分区，表所使用的存</p>
<p>储引擎需要自有的分区处理程序。 提供本地分区支持的 MySQL 存储引擎有两个，即 InnoDB 和 NDB ，而在MySQL 8中只支持 InnoDB 。</p>
<h3 id="系统和状态变量信息"><a href="#系统和状态变量信息" class="headerlink" title="系统和状态变量信息"></a><strong>系统和状态变量信息</strong></h3><p>​     在 INFORMATION_SCHEMA 数据库中，对系统和状态变量信息不再进行维护。</p>
<p>GLOBAL_VARIABLES 、 SESSION_VARIABLES 、 GLOBAL_STATUS 、 SESSION_STATUS 表都已被删除。另外，系统变量show_compatibility_56 也已被删除。被删除的状态变量有 Slave_heartbeat_period 、Slave_last_heartbeat,Slave_received_heartbeats、 Slave_retried_transactions 、 Slave_running 。以上被删除的内容都可使用性能模式中对应的内容进行替代。</p>
<h3 id="mysql-plugin工具"><a href="#mysql-plugin工具" class="headerlink" title="mysql_plugin工具"></a><strong>mysql_plugin工具</strong></h3><p>​     mysql_plugin 工具用来配置 MySQL 服务器插件，现已被删除，可使用 –plugin-load 或 -</p>
<p>-plugin-load-add 选项在服务器启动时加载插件或者在运行时使用 INSTALL PLUGIN 语句加载插件来替代该工具。</p>
<h2 id="新特性1：窗口函数"><a href="#新特性1：窗口函数" class="headerlink" title="新特性1：窗口函数"></a><strong>新特性1：窗口函数</strong></h2><h3 id="使用窗口函数前后对比"><a href="#使用窗口函数前后对比" class="headerlink" title="使用窗口函数前后对比"></a><strong>使用窗口函数前后对比</strong></h3><p>假设我现在有这样一个数据表，它显示了某购物网站在每个城市每个区的销售额：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> sales(</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY AUTO_INCREMENT,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">city <span class="type">VARCHAR</span>(<span class="number">15</span>),</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">county <span class="type">VARCHAR</span>(<span class="number">15</span>),</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sales_value <span class="type">DECIMAL</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> sales(city,county,sales_value)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">VALUES</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">(<span class="string">&#x27;北京&#x27;</span>,<span class="string">&#x27;海淀&#x27;</span>,<span class="number">10.00</span>),</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">(<span class="string">&#x27;北京&#x27;</span>,<span class="string">&#x27;朝阳&#x27;</span>,<span class="number">20.00</span>),</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">(<span class="string">&#x27;上海&#x27;</span>,<span class="string">&#x27;黄埔&#x27;</span>,<span class="number">30.00</span>),</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">(<span class="string">&#x27;上海&#x27;</span>,<span class="string">&#x27;长宁&#x27;</span>,<span class="number">10.00</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 查看sales表</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> sales;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/202210071239364523.png" alt="img"></p>
<p> <strong>需求：</strong>现在计算这个网站在每个城市的销售总额、在全国的销售总额、每个区的销售额占所在城市销售额中的比率，以及占总销售额中的比率。</p>
<p>如果用分组和聚合函数，就需要分好几步来计算。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 需求：现在计算这个网站在每个城市的销售总额、全国的销售总额、</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#				每个区的销售额占所在城市销售额中的比率，以及占总销售额中的比率。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 方式<span class="number">1</span>：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 第一步，计算总销售金额，并存入临时表 a：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> TEMPORARY <span class="keyword">TABLE</span> a <span class="comment">-- 创建临时表 </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">SUM</span>(sales_value) <span class="keyword">AS</span> sales_value <span class="comment">-- 计算总计金额 </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> sales;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> a; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 第二步，计算每个城市的销售总额并存入临时表 b：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> TEMPORARY <span class="keyword">TABLE</span> b <span class="comment">-- 创建临时表</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> city,<span class="built_in">SUM</span>(sales_value) <span class="keyword">AS</span> sales_value <span class="comment">-- 计算城市销售合计</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> sales</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> city;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> b;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 第三步，计算各区的销售占所在城市的总计金额的比例，和占全部销售总计金额的比例。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 		我们可以通过下面的连接查询获得需要的结果：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> s.city <span class="keyword">AS</span> 城市,s.county <span class="keyword">AS</span> 区,s.sales_value <span class="keyword">AS</span> 区销售额,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">b.sales_value <span class="keyword">AS</span> 市销售额,s.sales_value<span class="operator">/</span>b.sales_value <span class="keyword">AS</span> 市比率,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a.sales_value <span class="keyword">AS</span> 总销售额,s.sales_value<span class="operator">/</span>a.sales_value <span class="keyword">AS</span> 总比率</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> sales s</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">JOIN</span> b <span class="keyword">ON</span> (s.city<span class="operator">=</span>b.city) <span class="comment">-- 连接市统计结果临时表</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">JOIN</span> a <span class="comment">-- 连接总计金额临时表</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> s.city,s.county;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/202210071239364637.png" alt="img"></p>
<p> 结果显示：市销售金额、市销售占比、总销售金额、总销售占比都计算出来了。</p>
<p>同样的查询，如果用窗口函数，就简单多了。我们可以用下面的代码来实现：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 方式<span class="number">2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> city <span class="keyword">AS</span> 城市,county <span class="keyword">AS</span> 区,sales_value <span class="keyword">AS</span> 区销售额,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">SUM</span>(sales_value) <span class="keyword">OVER</span>(<span class="keyword">PARTITION</span> <span class="keyword">BY</span> city) <span class="keyword">AS</span> 市销售额, <span class="comment">-- 计算市销售额</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sales_value<span class="operator">/</span><span class="built_in">SUM</span>(sales_value) <span class="keyword">OVER</span>(<span class="keyword">PARTITION</span> <span class="keyword">BY</span> city) <span class="keyword">AS</span> 市比率,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">SUM</span>(sales_value) <span class="keyword">OVER</span>() <span class="keyword">AS</span> 总销售额, <span class="comment">-- 计算总销售额</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sales_value<span class="operator">/</span><span class="built_in">SUM</span>(sales_value) <span class="keyword">OVER</span>() <span class="keyword">AS</span> 总比率</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> sales</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> city,county;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/202210071239374677.png" alt="img"></p>
<p>​    结果显示，我们得到了与上面那种查询同样的结果。</p>
<p>​    使用窗口函数，只用了一步就完成了查询。而且，由于没有用到临时表，执行的效率也更高了。很显然， <strong>在这种需要用到分组统计的结果对每一条记录进行计算的场景下，使用窗口函数更好</strong> 。</p>
<h3 id="窗口函数分类"><a href="#窗口函数分类" class="headerlink" title="窗口函数分类"></a><strong>窗口函数分类</strong></h3><p>​    MySQL从 8.0 版本开始支持窗口函数。窗口函数的作用类似于在查询中对数据进行分组，不同的是，分组操作会把分组的结果聚合成一条记录，而窗口函数是将结果置于每一条数据记录中。</p>
<p>​    <strong>窗口函数可以分为</strong> <em><strong>*静态窗口函数** *<em>和*</em> *<em>动态窗口函数*</em> **。*</strong></em></p>
<p>​        <em><strong>*静态窗口函数的窗口大小是固定的，不会因为记录的不同而不同；*</strong></em></p>
<p>​        <em><strong>*动态窗口函数的窗口大小会随着记录的不同而变化。*</strong></em></p>
<p>​    MySQL官方网站窗口函数的网址为 <strong><a href="https://dev.mysql.com/doc/refman/8.0/en/window-function-descriptio">https://dev.mysql.com/doc/refman/8.0/en/window-function-descriptio</a></strong> <strong>ns.html#function_row-number</strong> 。</p>
<p>​    窗口函数总体上可以分为序号函数、分布函数、前后函数、首尾函数和其他函数，如下表：</p>
<p><img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/202210071239374699.png" alt="img"></p>
<h3 id="语法结构"><a href="#语法结构" class="headerlink" title="语法结构"></a><strong>语法结构</strong></h3><p><strong>窗口函数的语法结构是：</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">函数 <span class="keyword">OVER</span>（[<span class="keyword">PARTITION</span> <span class="keyword">BY</span> 字段名 <span class="keyword">ORDER</span> <span class="keyword">BY</span> 字段名 <span class="keyword">ASC</span><span class="operator">|</span><span class="keyword">DESC</span>]）</span><br><span class="line"># 或</span><br><span class="line">函数 <span class="keyword">OVER</span> 窗口名 … <span class="keyword">WINDOW</span> 窗口名 <span class="keyword">AS</span> （[<span class="keyword">PARTITION</span> <span class="keyword">BY</span> 字段名 <span class="keyword">ORDER</span> <span class="keyword">BY</span> 字段名 <span class="keyword">ASC</span><span class="operator">|</span><span class="keyword">DESC</span>]）</span><br></pre></td></tr></table></figure>

<p>​    <em><strong>*<img src="https://latex.codecogs.com/gif.latex?%5Cbullet" alt="\bullet"> OVER 关键字指定函数窗口的范围。*</strong></em></p>
<p>​        <strong><img src="https://latex.codecogs.com/gif.latex?%5Ccirc" alt="\circ"> 如果省略后面括号中的内容，则窗口会包含满足WHERE条件的所有记录，窗口函数会</strong></p>
<p>​          <strong>基于所有满足WHERE条件的记录进行计算。</strong></p>
<p>​        <strong><img src="https://latex.codecogs.com/gif.latex?%5Ccirc" alt="\circ"> 如果OVER关键字后面的括号不为空，则可以使用如下语法设置窗口。</strong></p>
<p>​    <strong><img src="https://latex.codecogs.com/gif.latex?%5Cbullet" alt="\bullet"> 窗口名：为窗口设置一个别名，用来标识窗口。</strong></p>
<p>​    <strong><img src="https://latex.codecogs.com/gif.latex?%5Cbullet" alt="\bullet"> PARTITION BY子句：指定窗口函数按照哪些字段进行分组。分组后，窗口函数可以在每个分组中分别执行。</strong></p>
<p>​    <strong><img src="https://latex.codecogs.com/gif.latex?%5Cbullet" alt="\bullet"> ORDER BY子句：指定窗口函数按照哪些字段进行排序。执行排序操作使窗口函数按照排序后的数据记录的顺序进行编号。</strong></p>
<p>​    <strong><img src="https://latex.codecogs.com/gif.latex?%5Cbullet" alt="\bullet"> FRAME子句：为分区中的某个子集定义规则，可以用来作为滑动窗口使用。</strong></p>
<h3 id="分类讲解"><a href="#分类讲解" class="headerlink" title="分类讲解"></a><strong>分类讲解</strong></h3><p>准备数据：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 准备数据</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> goods(</span><br><span class="line">	id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY AUTO_INCREMENT,</span><br><span class="line">	category_id <span class="type">INT</span>,</span><br><span class="line">	category <span class="type">VARCHAR</span>(<span class="number">15</span>),</span><br><span class="line">	NAME <span class="type">VARCHAR</span>(<span class="number">30</span>),</span><br><span class="line">	price <span class="type">DECIMAL</span>(<span class="number">10</span>,<span class="number">2</span>),</span><br><span class="line">	stock <span class="type">INT</span>,</span><br><span class="line">	upper_time DATETIME</span><br><span class="line">);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> goods(category_id,category,NAME,price,stock,upper_time)</span><br><span class="line"><span class="keyword">VALUES</span></span><br><span class="line">(<span class="number">1</span>, <span class="string">&#x27;女装/女士精品&#x27;</span>, <span class="string">&#x27;T恤&#x27;</span>, <span class="number">39.90</span>, <span class="number">1000</span>, <span class="string">&#x27;2020-11-10 00:00:00&#x27;</span>),</span><br><span class="line">(<span class="number">1</span>, <span class="string">&#x27;女装/女士精品&#x27;</span>, <span class="string">&#x27;连衣裙&#x27;</span>, <span class="number">79.90</span>, <span class="number">2500</span>, <span class="string">&#x27;2020-11-10 00:00:00&#x27;</span>),</span><br><span class="line">(<span class="number">1</span>, <span class="string">&#x27;女装/女士精品&#x27;</span>, <span class="string">&#x27;卫衣&#x27;</span>, <span class="number">89.90</span>, <span class="number">1500</span>, <span class="string">&#x27;2020-11-10 00:00:00&#x27;</span>),</span><br><span class="line">(<span class="number">1</span>, <span class="string">&#x27;女装/女士精品&#x27;</span>, <span class="string">&#x27;牛仔裤&#x27;</span>, <span class="number">89.90</span>, <span class="number">3500</span>, <span class="string">&#x27;2020-11-10 00:00:00&#x27;</span>),</span><br><span class="line">(<span class="number">1</span>, <span class="string">&#x27;女装/女士精品&#x27;</span>, <span class="string">&#x27;百褶裙&#x27;</span>, <span class="number">29.90</span>, <span class="number">500</span>, <span class="string">&#x27;2020-11-10 00:00:00&#x27;</span>),</span><br><span class="line">(<span class="number">1</span>, <span class="string">&#x27;女装/女士精品&#x27;</span>, <span class="string">&#x27;呢绒外套&#x27;</span>, <span class="number">399.90</span>, <span class="number">1200</span>, <span class="string">&#x27;2020-11-10 00:00:00&#x27;</span>),</span><br><span class="line">(<span class="number">2</span>, <span class="string">&#x27;户外运动&#x27;</span>, <span class="string">&#x27;自行车&#x27;</span>, <span class="number">399.90</span>, <span class="number">1000</span>, <span class="string">&#x27;2020-11-10 00:00:00&#x27;</span>),</span><br><span class="line">(<span class="number">2</span>, <span class="string">&#x27;户外运动&#x27;</span>, <span class="string">&#x27;山地自行车&#x27;</span>, <span class="number">1399.90</span>, <span class="number">2500</span>, <span class="string">&#x27;2020-11-10 00:00:00&#x27;</span>),</span><br><span class="line">(<span class="number">2</span>, <span class="string">&#x27;户外运动&#x27;</span>, <span class="string">&#x27;登山杖&#x27;</span>, <span class="number">59.90</span>, <span class="number">1500</span>, <span class="string">&#x27;2020-11-10 00:00:00&#x27;</span>),</span><br><span class="line">(<span class="number">2</span>, <span class="string">&#x27;户外运动&#x27;</span>, <span class="string">&#x27;骑行装备&#x27;</span>, <span class="number">399.90</span>, <span class="number">3500</span>, <span class="string">&#x27;2020-11-10 00:00:00&#x27;</span>),</span><br><span class="line">(<span class="number">2</span>, <span class="string">&#x27;户外运动&#x27;</span>, <span class="string">&#x27;运动外套&#x27;</span>, <span class="number">799.90</span>, <span class="number">500</span>, <span class="string">&#x27;2020-11-10 00:00:00&#x27;</span>),</span><br><span class="line">(<span class="number">2</span>, <span class="string">&#x27;户外运动&#x27;</span>, <span class="string">&#x27;滑板&#x27;</span>, <span class="number">499.90</span>, <span class="number">1200</span>, <span class="string">&#x27;2020-11-10 00:00:00&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p><img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/202210071239374764.png" alt="img"></p>
<p>下面针对 goods 表中的数据来验证每个窗口函数的功能。</p>
<h3 id="序号函数"><a href="#序号函数" class="headerlink" title="序号函数"></a><strong>序号函数</strong></h3><p><em><strong>*1．ROW_NUMBER()函数*</strong></em></p>
<p>ROW_NUMBER() 函数能够对数据中的序号进行顺序显示。</p>
<p><em><strong>*举例：查询** *<em>goods*</em> **数据表中每个商品分类下价格降序排列的各个商品信息。*</strong></em></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 序号函数</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#<span class="number">1</span>．<span class="built_in">ROW_NUMBER</span>()函数: 能够对数据中的序号进行顺序显示。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#举例：查询 goods 数据表中每个商品分类下价格降序排列的各个商品信息。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">ROW_NUMBER</span>() <span class="keyword">OVER</span>(<span class="keyword">PARTITION</span> <span class="keyword">BY</span> category_id <span class="keyword">ORDER</span> <span class="keyword">BY</span> price <span class="keyword">DESC</span>) <span class="keyword">AS</span> num,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">id,category_id,category,NAME,price,stock</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> goods;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/202210071239374800.png" alt="img"></p>
<p> <em>*<em>*举例：查询*</em> *<em>goods*</em> *<em>数据表中每个商品分类下价格最高的*</em>*<em>3*</em>*<em>种商品信息。*</em>*</em></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 举例：查询 goods 数据表中每个商品分类下价格最高的<span class="number">3</span>种商品信息。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> (<span class="keyword">SELECT</span> <span class="built_in">ROW_NUMBER</span>() <span class="keyword">OVER</span>(<span class="keyword">PARTITION</span> <span class="keyword">BY</span> category_id <span class="keyword">ORDER</span> <span class="keyword">BY</span> price <span class="keyword">DESC</span>) <span class="keyword">AS</span> num,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">			id,category_id,category,NAME,price,stock</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">			<span class="keyword">FROM</span> goods) t</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">WHERE</span> num <span class="operator">&lt;=</span> <span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/202210071239384828.png" alt="img"></p>
<p><strong>2．RANK()函数</strong></p>
<p>​    <em>*<em>*使用RANK()*</em>*<em>函数能够对序号进行并列排序，并且会跳过重复的序号，比如序号为*</em>*<em>1*</em>*<em>、*</em>*<em>1*</em>*<em>、*</em>*<em>3*</em>*<em>。*</em>*</em></p>
<p>​    在名称为“女装 &#x2F; 女士精品 ” 的商品类别中，有两款商品的价格为 89.90 元，分别是卫衣和牛仔裤。两款商品的序号都应该为2 ，而不是一个为 2 ，另一个为 3 。此时，可以使用 RANK() 函数和 DENSE_RANK() 函数解决。</p>
<p><em>*<em>*举例：使用*</em>*<em>RANK()*</em>*<em>函数获取*</em> *<em>goods*</em> *<em>数据表中各类别的价格从高到低排序的各商品信息。*</em>*</em></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># <span class="number">2.</span><span class="built_in">RANK</span>()函数</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 举例：使用<span class="built_in">RANK</span>()函数获取 goods 数据表中各类别的价格从高到低排序的各商品信息。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">RANK</span>() <span class="keyword">OVER</span>(<span class="keyword">PARTITION</span> <span class="keyword">BY</span> category_id <span class="keyword">ORDER</span> <span class="keyword">BY</span> price <span class="keyword">DESC</span>) num_rank,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">id,category_id,category,NAME,price,stock</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> goods;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/202210071239384862.png" alt="img"></p>
<p> <em>*<em>*举例：使用*</em>*<em>RANK()*</em>*<em>函数获取*</em> *<em>goods*</em> *<em>数据表中类别为*</em>*<em>“*</em>*<em>女装*</em>**&#x2F;*</em>*<em>女士精品*</em>*<em>”*</em>*<em>的价格最高的*</em>*<em>4*</em>*<em>款商品信息。*</em>**</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 举例：使用<span class="built_in">RANK</span>()函数获取 goods 数据表中类别为“女装<span class="operator">/</span>女士精品”的价格最高的<span class="number">4</span>款商品信息。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> (<span class="keyword">SELECT</span> <span class="built_in">RANK</span>() <span class="keyword">OVER</span>(<span class="keyword">PARTITION</span> <span class="keyword">BY</span> category_id <span class="keyword">ORDER</span> <span class="keyword">BY</span> price <span class="keyword">DESC</span>) num_rank,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">			id,category_id,category,NAME,price,stock</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">			<span class="keyword">FROM</span> goods) <span class="keyword">AS</span> t</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">WHERE</span> category_id <span class="operator">=</span> <span class="number">1</span> <span class="keyword">AND</span> num_rank <span class="operator">&lt;=</span> <span class="number">4</span>;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/202210071239384892.png" alt="img"></p>
<p> <em><strong>*3．DENSE_RANK()函数*</strong></em></p>
<p>​    DENSE_RANK()函数对序号进行并列排序，并且不会跳过重复的序号，比如序号为 1 、 1 、 2 。</p>
<p><em>*<em>*举例：使用*</em>*<em>DENSE_RANK()*</em>*<em>函数获取*</em> *<em>goods*</em> *<em>数据表中各类别的价格从高到低排序的各商品信息。*</em>*</em></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># <span class="number">3.</span><span class="built_in">DENSE_RANK</span>()函数</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 举例：使用<span class="built_in">DENSE_RANK</span>()函数获取 goods 数据表中各类别的价格从高到低排序的各商品信息。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">DENSE_RANK</span>() <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> category_id <span class="keyword">ORDER</span> <span class="keyword">BY</span> price <span class="keyword">DESC</span>) num_dense_rank,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">id,category_id,category,NAME,price,stock</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> goods;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/202210071239384920.png" alt="img"></p>
<p> <em>*<em>*举例：使用*</em>*<em>DENSE_RANK()*</em>*<em>函数获取*</em> *<em>goods*</em> *<em>数据表中类别为*</em>*<em>“*</em>*<em>女装*</em>**&#x2F;*</em>*<em>女士精品*</em>*<em>”*</em>*<em>的价格最高的*</em>*<em>4*</em>*<em>款商品信息。*</em>**</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 举例：使用<span class="built_in">DENSE_RANK</span>()函数获取 goods 数据表中类别为“女装<span class="operator">/</span>女士精品”的价格最高的<span class="number">4</span>款商品信息。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> (<span class="keyword">SELECT</span> <span class="built_in">DENSE_RANK</span>() <span class="keyword">OVER</span>(<span class="keyword">PARTITION</span> <span class="keyword">BY</span> category_id <span class="keyword">ORDER</span> <span class="keyword">BY</span> price <span class="keyword">DESC</span>) num_dense_rank,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">			id,category_id,category,NAME,price,stock</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">			<span class="keyword">FROM</span> goods) <span class="keyword">AS</span> t</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">WHERE</span> category_id <span class="operator">=</span> <span class="number">1</span> <span class="keyword">AND</span> num_dense_rank <span class="operator">&lt;=</span> <span class="number">4</span>;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/202210071239394948.png" alt="img"></p>
<p>​     可以看到，使用DENSE_RANK()函数得出的行号为1、2、2、3，相同价格的商品序号相同，后面的商品序号是连续的，并且没有跳过重复的序号。</p>
<h3 id="分布函数"><a href="#分布函数" class="headerlink" title="分布函数"></a><strong>分布函数</strong></h3><p><strong>1．PERCENT_RANK()函数</strong></p>
<p>​    <strong>PERCENT_RANK()函数是等级值百分比函数。(可以抽象的理解为进度条)</strong></p>
<p><strong>按照如下方式进行计算。</strong></p>
<p>​        </p>
<blockquote>
<p><em>*<em>*(rank -*</em> *<em>1*</em>**) &#x2F; (rows -*</em> *<em>1*</em>*<em>)*</em>**</p>
</blockquote>
<p><em>*<em>*其中，*</em>*<em>rank*</em>*<em>的值为使用*</em>*<em>RANK()*</em>*<em>函数产生的序号，*</em>*<em>rows*</em>*<em>的值为当前窗口的总记录数。*</em>*</em></p>
<p><em>*<em>*举例：计算*</em> *<em>goods*</em> *<em>数据表中名称为*</em>*<em>“*</em>*<em>女装*</em>**&#x2F;*</em>*<em>女士精品*</em>*<em>”*</em>*<em>的类别下的商品的*</em>*<em>PERCENT_RANK*</em>** <strong>值。</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># <span class="number">2.</span> 分布函数</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># <span class="number">1.</span><span class="built_in">PERCENT_RANK</span>()函数</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 举例：计算 goods 数据表中名称为“女装<span class="operator">/</span>女士精品”的类别下的商品的PERCENT_RANK值。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 方式<span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">RANK</span>() <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> category_id <span class="keyword">ORDER</span> <span class="keyword">BY</span> price <span class="keyword">DESC</span>) <span class="keyword">AS</span> r,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">PERCENT_RANK</span>() <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> category_id <span class="keyword">ORDER</span> <span class="keyword">BY</span> price <span class="keyword">DESC</span>) <span class="keyword">AS</span> pr,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">id, category_id, category, NAME, price, stock</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> goods</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">WHERE</span> category_id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 方式<span class="number">2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">RANK</span>() <span class="keyword">OVER</span> w <span class="keyword">AS</span> r,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">			<span class="built_in">PERCENT_RANK</span>() <span class="keyword">OVER</span> w <span class="keyword">AS</span> pr,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">			id,category_id,category,NAME,price,stock</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> goods</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">WINDOW</span> w <span class="keyword">AS</span>  (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> category_id <span class="keyword">ORDER</span> <span class="keyword">BY</span> price <span class="keyword">DESC</span>);</span><br></pre></td></tr></table></figure>

<p><img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/202210071239395034.png" alt="img"></p>
<p><strong>2．CUME_DIST()函数</strong></p>
<p>​    <strong>CUME_DIST()函数主要用于查询小于或等于某个值的比例。</strong></p>
<p><em>*<em>*举例：查询*</em>*<em>goods*</em>*<em>数据表中小于或等于当前价格的比例。*</em>*</em></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># <span class="number">2</span>．<span class="built_in">CUME_DIST</span>()函数</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 举例：查询goods数据表中小于或等于当前价格的比例。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">RANK</span>() <span class="keyword">OVER</span> w <span class="keyword">AS</span> r,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">			<span class="built_in">CUME_DIST</span>() <span class="keyword">OVER</span> w <span class="keyword">AS</span> cd,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">			id,category_id,category,NAME,price,stock</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> goods</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">WINDOW</span> w <span class="keyword">AS</span>  (<span class="keyword">ORDER</span> <span class="keyword">BY</span> price <span class="keyword">DESC</span>);</span><br></pre></td></tr></table></figure>

<p><img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/202210071239395070.png" alt="img"></p>
<h3 id="前后函数"><a href="#前后函数" class="headerlink" title="前后函数"></a><strong>前后函数</strong></h3><p><strong>1．LAG(expr,n)函数</strong></p>
<p>​    <strong>LAG(expr,n)函数返回当前行的前</strong> <em>*<em>*n*</em>*<em>行的*</em>*<em>expr*</em>*<em>的值。*</em>*</em></p>
<p><em>*<em>*举例：查询*</em>*<em>goods*</em>*<em>数据表中前一个商品价格与当前商品价格的差值。*</em>*</em></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#<span class="number">3.</span> 前后函数</span><br><span class="line"># <span class="number">1</span>．<span class="built_in">LAG</span>(expr,n)函数:返回当前行的前n行的expr的值。</span><br><span class="line">#举例：查询goods数据表中前一个商品价格与当前商品价格的差值。</span><br><span class="line"><span class="keyword">SELECT</span> id,category_id,category,NAME,price,lag_price,</span><br><span class="line">			 lag_price <span class="operator">-</span> price <span class="keyword">AS</span> price_diff,stock</span><br><span class="line"><span class="keyword">FROM</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> id,category_id,category,NAME,price,<span class="built_in">LAG</span>(price,<span class="number">1</span>) <span class="keyword">OVER</span> w <span class="keyword">AS</span> lag_price,stock</span><br><span class="line">    <span class="keyword">FROM</span> goods</span><br><span class="line">    <span class="keyword">WINDOW</span> w <span class="keyword">AS</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> category_id <span class="keyword">ORDER</span> <span class="keyword">BY</span> price <span class="keyword">DESC</span>) </span><br><span class="line">) t;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/202210071239395095.png" alt="img"></p>
<p><strong>2．LEAD(expr,n)函数</strong></p>
<p>​    <em>*<em>*LEAD(expr,n)函数返回当前行的后*</em>*<em>n*</em>*<em>行的*</em>*<em>expr*</em>*<em>的值。*</em>*</em></p>
<p><em>*<em>*举例：查询*</em>*<em>goods*</em>*<em>数据表中后一个商品价格与当前商品价格的差值。*</em>*</em></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># <span class="number">2</span>．<span class="built_in">LEAD</span>(expr,n)函数</span><br><span class="line"></span><br><span class="line"># <span class="built_in">LEAD</span>(expr,n)函数返回当前行的后n行的expr的值。</span><br><span class="line"></span><br><span class="line"># 举例：查询goods数据表中后一个商品价格与当前商品价格的差值。</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> id,category_id,category,NAME,price,lead_price,</span><br><span class="line">			 price <span class="operator">-</span> lead_price <span class="keyword">AS</span> price_diff,stock</span><br><span class="line"><span class="keyword">FROM</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> id,category_id,category,NAME,price,<span class="built_in">LEAD</span>(price,<span class="number">1</span>) <span class="keyword">OVER</span> w <span class="keyword">AS</span> lead_price,stock</span><br><span class="line">    <span class="keyword">FROM</span> goods</span><br><span class="line">    <span class="keyword">WINDOW</span> w <span class="keyword">AS</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> category_id <span class="keyword">ORDER</span> <span class="keyword">BY</span> price <span class="keyword">DESC</span>)</span><br><span class="line">) t;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/202210071239395121.png" alt="img"></p>
<h3 id="首尾函数"><a href="#首尾函数" class="headerlink" title="首尾函数"></a><strong>首尾函数</strong></h3><p><strong>1．FIRST_VALUE(expr)函数</strong></p>
<p>​    <em>*<em>*FIRST_VALUE(expr)函数返回第一个*</em>*<em>expr*</em>*<em>的值。*</em>*</em></p>
<p><em>*<em>*举例：按照价格排序，查询第*</em>*<em>1*</em>*<em>个商品的价格信息*</em>*</em></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#<span class="number">4.</span> 首尾函数</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># <span class="number">1</span>．<span class="built_in">FIRST_VALUE</span>(expr)函数:返回第一个expr的值。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#举例：按照价格排序，查询第<span class="number">1</span>个商品的价格信息</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> id,category_id,category,NAME,stock,price,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">			 <span class="built_in">FIRST_VALUE</span>(price) <span class="keyword">OVER</span> w <span class="keyword">AS</span> fir_price</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> goods</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">WINDOW</span> w <span class="keyword">AS</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> category_id <span class="keyword">ORDER</span> <span class="keyword">BY</span> price <span class="keyword">DESC</span>);</span><br></pre></td></tr></table></figure>

<p><img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/202210071239405159.png" alt="img"></p>
<p><strong>2．LAST_VALUE(expr)函数</strong></p>
<p>​    LAST_VALUE取得的是当前窗口到此条记录的最后一行，即当前记录；</p>
<p><em><strong>*举例：按照价格排序，查询最后一个商品的价格信息。*</strong></em></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#<span class="number">2</span>．<span class="built_in">LAST_VALUE</span>(expr)函数</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#举例：按照价格排序，查询最后一个商品的价格信息。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> id,category_id,category,NAME,stock,price,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">			 <span class="built_in">LAST_VALUE</span>(price) <span class="keyword">OVER</span> w <span class="keyword">AS</span> last_price</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> goods</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">WINDOW</span> w <span class="keyword">AS</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> category_id <span class="keyword">ORDER</span> <span class="keyword">BY</span> price <span class="keyword">DESC</span>);</span><br></pre></td></tr></table></figure>

<p><img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/202210071239405193.png" alt="img"></p>
<h3 id="其他函数"><a href="#其他函数" class="headerlink" title="其他函数"></a><strong>其他函数</strong></h3><p><strong>1．NTH_VALUE(expr,n)函数</strong></p>
<p>​    <em>*<em>*NTH_VALUE(expr,n)函数返回第*</em>*<em>n*</em>*<em>个*</em>*<em>expr*</em>*<em>的值。*</em>*</em></p>
<p><em>*<em>*举例：查询*</em>*<em>goods*</em>*<em>数据表中排名第*</em>*<em>2*</em>*<em>和第*</em>*<em>3*</em>*<em>的价格信息。*</em>*</em></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#<span class="number">5.</span> 其他函数</span><br><span class="line"># <span class="number">1</span>．<span class="built_in">NTH_VALUE</span>(expr,n)函数,返回第n个expr的值。</span><br><span class="line"></span><br><span class="line">#举例：查询goods数据表中排名第<span class="number">2</span>和第<span class="number">3</span>的价格信息。</span><br><span class="line"><span class="keyword">SELECT</span> id,category,NAME,stock,price,</span><br><span class="line">		<span class="built_in">NTH_VALUE</span>(price,<span class="number">2</span>) <span class="keyword">OVER</span> w <span class="keyword">AS</span> second_price,</span><br><span class="line">		<span class="built_in">NTH_VALUE</span>(price,<span class="number">3</span>) <span class="keyword">OVER</span> w <span class="keyword">AS</span> third_price</span><br><span class="line"><span class="keyword">FROM</span> goods</span><br><span class="line"><span class="keyword">WINDOW</span> w <span class="keyword">AS</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> category <span class="keyword">ORDER</span> <span class="keyword">BY</span> price <span class="keyword">DESC</span>);</span><br></pre></td></tr></table></figure>

<p><img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/202210071239405217.png" alt="img"></p>
<p><strong>2．NTILE(n)函数</strong></p>
<p>​    <em>*<em>*NTILE(n)函数将分区中的有序数据分为*</em>*<em>n*</em>*<em>个桶，记录桶编号。*</em>*</em></p>
<p><em>*<em>*举例：将*</em>*<em>goods*</em>*<em>表中的商品按照价格分为*</em>*<em>3*</em>*<em>组。*</em>*</em></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># <span class="number">2</span>．<span class="built_in">NTILE</span>(n)函数:将分区中的有序数据分为n个桶，记录桶编号。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 举例：将goods表中的商品按照价格分为<span class="number">3</span>组。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">NTILE</span>(<span class="number">3</span>) <span class="keyword">OVER</span> (<span class="keyword">ORDER</span> <span class="keyword">BY</span> price <span class="keyword">DESC</span>) <span class="keyword">AS</span> ntile_price,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">			id,category,NAME,price</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> goods;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/202210071239405245.png" alt="img"></p>
<h3 id="小-结"><a href="#小-结" class="headerlink" title="小 结"></a><strong>小 结</strong></h3><p>​    <strong>窗口函数的特点是可以分组，而且可以在分组内排序。另外，窗口函数不会因为分组而减少原表中的行数，这对我们在原表数据的基础上进行统计和排序非常有用。</strong></p>
<h2 id="新特性2：公用表表达式"><a href="#新特性2：公用表表达式" class="headerlink" title="新特性2：公用表表达式"></a><strong>新特性2：公用表表达式</strong></h2><p>​    公用表表达式（或通用表表达式）简称为<strong>CTE</strong> （Common Table Expressions）。 CTE 是一个命名的临时结果集，作用范围是当前语句。CTE 可以理解成一个可以复用的子查询，当然跟子查询还是有点区别的，CTE可以引用其他 CTE ，但子查询不能引用其他子查询。所以，可以考虑代替子查询。</p>
<p>​    <strong>依据语法结构和执行方式的不同，公用表表达式分为</strong> <em><strong>*普通公用表表达式** *<em>和*</em> *<em>递归公用表表达式*</em> *<em>2*</em> **种。*</strong></em></p>
<h3 id="普通公用表表达式"><a href="#普通公用表表达式" class="headerlink" title="普通公用表表达式"></a><strong>普通公用表表达式</strong></h3><p><em><strong>*普通公用表表达式的语法结构是：*</strong></em></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">WITH</span> CTE名称</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">AS</span> （子查询）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span><span class="operator">|</span><span class="keyword">DELETE</span><span class="operator">|</span><span class="keyword">UPDATE</span> 语句;</span><br></pre></td></tr></table></figure>

<p>​    普通公用表表达式类似于子查询，不过，跟子查询不同的是，它可以被多次引用，而且可以被其他的普通公用表表达式所引用。</p>
<p><em><strong>*举例：查询员工所在的部门的详细信息。*</strong></em></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># <span class="number">3.</span>公用表表达式</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># <span class="number">3.1</span> 普通公用表表达式</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 举例：查询员工所在的部门的详细信息。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># <span class="number">0.</span>准备工作</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> employees</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> atguigudb.employees;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> departments</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> atguigudb.departments;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 方式<span class="number">1</span>：使用子查询</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> departments</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">WHERE</span> department_id <span class="keyword">IN</span> (</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">											<span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> department_id</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">											<span class="keyword">FROM</span> employees</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">											);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 方式<span class="number">2</span>：使用公用表表达式</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">WITH</span> cte_emp_did</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">AS</span> (<span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> department_id <span class="keyword">FROM</span> employees)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> departments d <span class="keyword">JOIN</span> cte_emp_did c</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">WHERE</span> d.department_id <span class="operator">=</span> c.department_id;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/202210071239405387.png" alt="img"></p>
<p>​    例子说明，公用表表达式可以起到子查询的作用。以后如果遇到需要使用子查询的场景，你可以在查询之前，先定义公用表表达式，然后在查询中用它来代替子查询。而且，跟子查询相比，公用表表达式有一个优点，就是<strong>定义过公用表表达式之后的查询，可以像一个表一样多次引用公用表表达式，而子查询则不能。</strong></p>
<h3 id="递归公用表表达式"><a href="#递归公用表表达式" class="headerlink" title="递归公用表表达式"></a><strong>递归公用表表达式</strong></h3><p>​    递归公用表表达式也是一种公用表表达式，只不过，除了普通公用表表达式的特点以外，它还有自己的特点，就是 <strong>可以调用自己</strong> 。它的语法结构是：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">WITH</span> <span class="keyword">RECURSIVE</span></span><br><span class="line">CTE名称 <span class="keyword">AS</span> （子查询）</span><br><span class="line"><span class="keyword">SELECT</span><span class="operator">|</span><span class="keyword">DELETE</span><span class="operator">|</span><span class="keyword">UPDATE</span> 语句;</span><br></pre></td></tr></table></figure>

<p>​    递归公用表表达式由 2 部分组成，分别是种子查询和递归查询，中间通过关键字 UNION [ALL] 进行连接。这里的 <strong>种子查询，意思就是获得递归的初始值</strong> 。这个查询只会运行一次，以创建初始数据集，之后递归查询会一直执行，直到没有任何新的查询数据产生，递归返回。</p>
<p><strong>案例：</strong> 针对于我们常用的 employees 表，包含 employee_id ， last_name 和 manager_id 三个字段。如果 a 是 b的管理者，那么，我们可以把b 叫做 a 的下属，如果同时 b 又是 c 的管理者，那么 c 就是 b 的下属，是 a 的下下 属。</p>
<p>​    下面我们尝试用查询语句列出所有具有下下属身份的人员信息。</p>
<p>​    如果用我们之前学过的知识来解决，会比较复杂，至少要进行 4 次查询才能搞定：</p>
<p>​        第一步，先找出初代管理者，就是不以任何别人为管理者的人，把结果存入临时表；</p>
<p>​        第二步，找出所有以初代管理者为管理者的人，得到一个下属集，把结果存入临时表；</p>
<p>​        第三步，找出所有以下属为管理者的人，得到一个下下属集，把结果存入临时表。</p>
<p>​        第四步，找出所有以下下属为管理者的人，得到一个结果集。</p>
<p>​    如果第四步的结果集为空，则计算结束，第三步的结果集就是我们需要的下下属集了，否则就必须继续进行第四步，一直到结果集为空为止。比如上面的这个数据表，就需要到第五步，才能得到空结果集。</p>
<p>​    而且，最后还要进行第六步：把第三步和第四步的结果集合并，这样才能最终获得我们需要的结果集。</p>
<p><em><strong>*如果用递归公用表表达式，就非常简单了。我介绍下具体的思路。*</strong></em></p>
<p>​    <em>*<em>*用递归公用表表达式中的种子查询，找出初代管理者。字段 n*</em> *<em>表示代次，初始值为*</em> *<em>1*</em>*<em>，表示是第一代管理者。*</em>*</em></p>
<p>​    <em>*<em>*用递归公用表表达式中的递归查询，查出以这个递归公用表表达式中的人为管理者的人，并且代次的值加 1*</em>*<em>。直到没有人以这个递归公用表表达式中的人为管理者了，递归返回。在最后的查询中，选出所有代次大于等于 3*</em> *<em>的人，他们肯定是第三代及以上代次的下属了，也就是下下属了。这样就得到了我们需要的结果集。*</em>*</em></p>
<p>​    这里看似也是 3 步，实际上是一个查询的 3 个部分，只需要执行一次就可以了。而且也不需要用临时表保存中间结果，比刚刚的方法简单多了。</p>
<p><strong>代码实现：</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># <span class="number">3.2</span> 递归公用表表达式</span><br><span class="line">#案例：针对于我们常用的employees表，包含employee_id，last_name和manager_id三个字段。</span><br><span class="line">#     如果a是b的管理者，那么，我们可以把b叫做a的下属，</span><br><span class="line">#     如果同时b又是c的管理者，那么c就是b的下属，是a的下下属。</span><br><span class="line"><span class="keyword">WITH</span> <span class="keyword">RECURSIVE</span> cte</span><br><span class="line"></span><br><span class="line"><span class="keyword">AS</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> employee_id,last_name,manager_id,<span class="number">1</span> <span class="keyword">AS</span> n </span><br><span class="line">    <span class="keyword">FROM</span> employees </span><br><span class="line">    <span class="keyword">WHERE</span> manager_id <span class="keyword">IS</span> <span class="keyword">NULL</span></span><br><span class="line">    <span class="comment">-- 种子查询，找到第一代领</span></span><br><span class="line">    <span class="keyword">UNION</span> <span class="keyword">ALL</span></span><br><span class="line">    <span class="keyword">SELECT</span> e.employee_id,e.last_name,e.manager_id,n <span class="operator">+</span> <span class="number">1</span> </span><br><span class="line">    <span class="keyword">FROM</span> employees <span class="keyword">AS</span> e </span><br><span class="line">    <span class="keyword">JOIN</span> cte <span class="keyword">ON</span> e.manager_id <span class="operator">=</span> cte.employee_id </span><br><span class="line">    <span class="comment">-- 递归查询，找出以递归公用表表达式的人为领导的人</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> employee_id,last_name,manager_id,n <span class="keyword">FROM</span> cte <span class="keyword">WHERE</span> n <span class="operator">&gt;=</span> <span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/10/07/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%8B)/202210071239415453.png" alt="img"></p>
<p>​     <em><strong>*总之，递归公用表表达式对于查询一个有共同的根节点的树形结构数据，非常有用。它可以不受层级的限制，轻松查出所有节点的数据。如果用其他的查询方式，就比较复杂了。*</strong></em></p>
<h3 id="小-结-1"><a href="#小-结-1" class="headerlink" title="小 结"></a><strong>小 结</strong></h3><p>​    <strong>公用表表达式的作用是可以替代子查询，而且可以被多次引用。递归公用表表达式对查询有一个共同根节点的树形结构数据非常高效，可以轻松搞定其他查询方式难以处理的查询。</strong></p>
<h2 id="练习-3"><a href="#练习-3" class="headerlink" title="练习"></a>练习</h2><p>题目：</p>
<p>#1. 创建 students 数据表，如下</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> students(</span><br><span class="line">id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY AUTO_INCREMENT,</span><br><span class="line">student <span class="type">VARCHAR</span>(<span class="number">15</span>),</span><br><span class="line">points TINYINT</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>#2. 向表中添加数据如下</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> students(student,points)</span><br><span class="line"><span class="keyword">VALUES</span></span><br><span class="line">(<span class="string">&#x27;张三&#x27;</span>,<span class="number">89</span>),</span><br><span class="line"></span><br><span class="line">(<span class="string">&#x27;李四&#x27;</span>,<span class="number">77</span>),</span><br><span class="line"></span><br><span class="line">(<span class="string">&#x27;王五&#x27;</span>,<span class="number">88</span>),</span><br><span class="line"></span><br><span class="line">(<span class="string">&#x27;赵六&#x27;</span>,<span class="number">90</span>),</span><br><span class="line"></span><br><span class="line">(<span class="string">&#x27;孙七&#x27;</span>,<span class="number">90</span>),</span><br><span class="line"></span><br><span class="line">(<span class="string">&#x27;周八&#x27;</span>,<span class="number">88</span>);</span><br></pre></td></tr></table></figure>

<p>#3. 分别使用 RANK() 、 DENSE_RANK() 和 ROW_NUMBER() 函数对学生成绩降序排列情况进行显示</p>
<p>答案：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#<span class="number">3.</span> 分别使用<span class="built_in">RANK</span>()、<span class="built_in">DENSE_RANK</span>() 和 <span class="built_in">ROW_NUMBER</span>()函数对学生成绩降序排列情况进行显示</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">RANK</span>() <span class="keyword">OVER</span> w 排序<span class="number">1</span>,</span><br><span class="line">			 <span class="built_in">DENSE_RANK</span>() <span class="keyword">OVER</span> w 排序<span class="number">2</span>,</span><br><span class="line">			 <span class="built_in">ROW_NUMBER</span>() <span class="keyword">OVER</span> w 排序<span class="number">3</span>,</span><br><span class="line">			 id,student,points</span><br><span class="line"><span class="keyword">FROM</span> students</span><br><span class="line"><span class="keyword">WINDOW</span> w <span class="keyword">AS</span> (<span class="keyword">ORDER</span> <span class="keyword">BY</span> points <span class="keyword">DESC</span>);</span><br></pre></td></tr></table></figure>

<p><img src="/mysql(%E4%B8%8B)/202210071239415508.png" alt="img"></p>
]]></content>
      <categories>
        <category>MySQL学习</category>
        <category>MySQL基础篇</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL高级篇</title>
    <url>/2022/10/07/MySQL%E9%AB%98%E7%BA%A7%E7%AF%87/</url>
    <content><![CDATA[<hr>
<h1 id="Mycat概述"><a href="#Mycat概述" class="headerlink" title="Mycat概述"></a>Mycat概述</h1><p>如今随着互联网的发展，数据的量级也是成指数的增长，从 GB 到 TB 到 PB。对数据的各种操作也是愈加的困难，传统的关系性数据库已经无法满足快速查询与插入数据的需求。这个时候 NoSQL 的出现暂时解决了这一危机。它通过降低数据的安全性，减少对事务的支持，减少对复杂查询的支持，来获取性能上的提升。</p>
<p>但是，在有些场合 NoSQL 一些折衷是无法满足使用场景的，就比如有些使用场景是绝对要有事务与安全指标的。这个时候 NoSQL 肯定是无法满足的，所以还是需要使用关系性数据库。如何使用关系型数据库解决海量存储的问题呢？此时就需要做数据库集群，为了提高查询性能将一个数据库的数据分散到不同的数据库中存储。</p>
<h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><p>Mycat是<code>数据库分库分表</code>中间件。</p>
<p><img src="/2022/10/07/MySQL%E9%AB%98%E7%BA%A7%E7%AF%87/image-20210829223150660.png" alt="image-20210829223150660"></p>
<p><strong>1、数据库中间件</strong></p>
<p><strong>中间件：是一类连接软件组件和应用的计算机软件，以便于软件各部件之间的沟通。</strong></p>
<p>例子：Tomcat，web中间件。</p>
<p>数据库中间件：连接java应用程序和数据库</p>
<p><strong>2、为什么要用Mycat？</strong></p>
<p>①  Java与数据库紧耦合。万一耦合的MySQL DBMS挂了怎么办？</p>
<p>②  高访问量、高并发对数据库的压力。</p>
<p>③  多个数据库读写请求数据不一致</p>
<p><strong>3、数据库中间件对比</strong></p>
<p><img src="/2022/10/07/MySQL%E9%AB%98%E7%BA%A7%E7%AF%87/zhognjianjian.png" alt="zhognjianjian"></p>
<p>①  <code>Cobar</code>属于阿里B2B事业群，始于2008年，在阿里服役3年多，接管3000+个MySQL数据库的schema,集群日处理在线SQL请求50亿次以上。由于Cobar发起人的离职，Cobar停止维护。</p>
<p>②  <code>Mycat</code>是开源社区在阿里cobar基础上进行二次开发，解决了cobar存在的问题，并且加入了许多新的功能在其中。青出于蓝而胜于蓝。</p>
<p>③  <code>OneProxy</code>基于MySQL官方的proxy思想利用c语言进行开发的，OneProxy是一款商业<code>收费</code>的中间件。舍弃了一些功能，专注在<code>性能和稳定性上</code>。</p>
<p>④  <code>kingshard</code>由小团队用go语言开发，还需要发展，需要不断完善。</p>
<p>⑤  <code>Vitess</code>是Youtube生产在使用，架构很复杂。不支持MySQL原生协议，使用<code>需要大量改造成本</code>。</p>
<p>⑥  <code>Atlas</code>是360团队基于mysql proxy改写，功能还需完善，高并发下不稳定。</p>
<p>⑦  <code>MaxScale</code>是mariadb（MySQL原作者维护的一个版本） 研发的中间件</p>
<p>⑧  <code>MySQLRoute</code>是MySQL官方Oracle公司发布的中间件</p>
<p><img src="/2022/10/07/MySQL%E9%AB%98%E7%BA%A7%E7%AF%87/image-20210829223348714.png" alt="image-20210829223348714"></p>
<p><strong>3、Mycat的官网</strong></p>
<p>  <a href="http://www.mycat.io/">http://www.mycat.io/</a></p>
 <img src="image-20210815142309672.png" alt="image-20210815142309672" style="zoom:50%;" />

<h2 id="Mycat作用"><a href="#Mycat作用" class="headerlink" title="Mycat作用"></a>Mycat作用</h2><p><strong>1、读写分离</strong></p>
<p><img src="/2022/10/07/MySQL%E9%AB%98%E7%BA%A7%E7%AF%87/image-20210825232422178.png" alt="image-20210825232422178"></p>
<p><img src="/2022/10/07/MySQL%E9%AB%98%E7%BA%A7%E7%AF%87/image-20210826191320528.png" alt="image-20210826191320528"></p>
<p><strong>2、数据分片</strong></p>
<p>垂直拆分（分库）、水平拆分（分表）、垂直+水平拆分（分库分表）</p>
<p><img src="/2022/10/07/MySQL%E9%AB%98%E7%BA%A7%E7%AF%87/shujufenpian.png" alt="shujufenpian"></p>
<p><img src="/2022/10/07/MySQL%E9%AB%98%E7%BA%A7%E7%AF%87/image-20210826234533399.png" alt="image-20210826234533399"></p>
<p><strong>3、多数据源整合</strong></p>
<p><img src="/2022/10/07/MySQL%E9%AB%98%E7%BA%A7%E7%AF%87/duoshujuyuanzhenghe.png" alt="duoshujuyuanzhenghe"></p>
<p>Mycat支持的数据库：</p>
<p><img src="/2022/10/07/MySQL%E9%AB%98%E7%BA%A7%E7%AF%87/image-20210829223416736.png" alt="image-20210829223416736"></p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>Mycat 的原理中最重要的一个动词是“<code>拦截</code>”，它拦截了用户发送过来的 SQL 语句，首先对 SQL 语句做了一些特定的分析：如<code>分片分析、路由分析、读写分离分析、缓存分析</code>等，然后将此 SQL 发往后端的真实数据库，并将返回的结果做适当的处理，最终再返回给用户。</p>
<p><img src="/2022/10/07/MySQL%E9%AB%98%E7%BA%A7%E7%AF%87/lanjie.png" alt="lanjie"></p>
<p>这种方式把数据库的分布式从代码中解耦出来，程序员察觉不出来后台使用<code>Mycat</code>还是<code>MySQL</code>。</p>
<p>整体过程可以概括为：<code>拦截</code> –  <code>分发</code> – <code>响应</code></p>
<h1 id="使用前准备工作"><a href="#使用前准备工作" class="headerlink" title="使用前准备工作"></a>使用前准备工作</h1><p>1、准备<code>4台</code>CentOS 虚拟机</p>
<p>2、每台虚拟机上需要安装好MySQL (可以是MySQL8.0 或者 MySQL5.7 皆可)</p>
<p>说明：前面我们讲过如何克隆一台CentOS。大家可以在一台CentOS上安装好MySQL，进而通过克隆的方式复制出3台包含MySQL的虚拟机。</p>
<p>注意：克隆的方式需要修改新克隆出来主机的：① <code>MAC地址</code> ② <code>hostname</code>  ③ <code>IP 地址</code>  ④ <code>UUID</code>。</p>
<p>此外，克隆的方式生成的虚拟机（包含MySQL Server），则克隆的虚拟机MySQL Server的UUID相同，必须修改，否则在有些场景会报错。比如：<code>show slave status\G</code>，报如下的错误：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Last_IO_Error: Fatal error: The slave I/O thread stops because master and slave have equal MySQL server UUIDs; these UUIDs must be different for replication to work.</span><br></pre></td></tr></table></figure>

<p>修改MySQL Server 的UUID方式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim /var/lib/mysql/auto.cnf</span><br><span class="line"></span><br><span class="line">systemctl restart mysqld</span><br></pre></td></tr></table></figure>



<h1 id="安装启动"><a href="#安装启动" class="headerlink" title="安装启动"></a>安装启动</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p><strong>1、解压后即可使用</strong></p>
<p> <img src="/2022/10/07/MySQL%E9%AB%98%E7%BA%A7%E7%AF%87/image-20210815142736156.png" alt="image-20210815142736156"></p>
<p>解压缩文件拷贝到linux下 <code>/usr/local/</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@atguigu02 opt]# tar -zxvf Mycat-server-1.6.7.1-release-20190627191042-linux.tar.gz</span><br><span class="line"></span><br><span class="line">[root@atguigu02 opt]# cp -r mycat/ /usr/local</span><br><span class="line"></span><br><span class="line">[root@atguigu02 opt]# rm -rf mycat</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p> <img src="/2022/10/07/MySQL%E9%AB%98%E7%BA%A7%E7%AF%87/image-20210829223555681.png" alt="image-20210829223555681"></p>
<p>打开mycat目录结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bin：二进制执行文件</span><br><span class="line">conf：配置文件目录</span><br><span class="line">lib：依赖</span><br><span class="line">logs：日志</span><br></pre></td></tr></table></figure>

<p><strong>2、conf目录下三个配置文件</strong></p>
<p> <img src="/2022/10/07/MySQL%E9%AB%98%E7%BA%A7%E7%AF%87/image-20210829223711744.png" alt="image-20210829223711744"></p>
<p>① <code>schema.xml</code>：定义逻辑库，表、分片节点等内容，实现读写分离</p>
<p>② <code>rule.xml</code>：定义分片规则，实现分库分表规则配置</p>
<p>③ <code>server.xml</code>：配置MyCat作为虚拟数据库的信息（地址、数据库名、用户名、密码等信息）</p>
<h2 id="配置与启动"><a href="#配置与启动" class="headerlink" title="配置与启动"></a>配置与启动</h2><p><strong>1、修改配置文件 server.xml</strong></p>
<p>修改用户信息，与MySQL区分，如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">…</span><br><span class="line"><span class="tag">&lt;<span class="name">user</span> <span class="attr">name</span>=<span class="string">&quot;mycat&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span>123456<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;schemas&quot;</span>&gt;</span>TESTDB<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">user</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 这里的TESTDB，理解为用户面向Mycat的统一的一个逻辑数据库。--&gt;</span></span><br></pre></td></tr></table></figure>

<p> <img src="/2022/10/07/MySQL%E9%AB%98%E7%BA%A7%E7%AF%87/image-20210815221401476.png" alt="image-20210815221401476"></p>
<p><strong>2、修改配置文件 schema.xml</strong></p>
<ul>
<li><p>删除<code>&lt;schema&gt;</code>标签间的表信息，增加dataNode属性 <code>dataNode=&quot;dn1&quot;</code></p>
</li>
<li><p><code>&lt;dataNode&gt;</code>标签只留一个，可修改属性值</p>
</li>
<li><p><code>&lt;dataHost&gt;</code>标签只留一个，修改属性值</p>
<ul>
<li>内部节点<code>&lt;writeHost&gt;</code> 和 <code>&lt;readHost&gt;</code>只留一对，修改属性值：url、user、password</li>
</ul>
</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mycat</span>:schema <span class="keyword">SYSTEM</span> <span class="string">&quot;schema.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mycat:schema</span> <span class="attr">xmlns:mycat</span>=<span class="string">&quot;http://io.mycat/&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 虚拟库与真实库的映射 </span></span><br><span class="line"><span class="comment">	name=&quot;TESTDB&quot; 虚拟库的名字，对应刚刚在server.xml中设置的TESTDB</span></span><br><span class="line"><span class="comment">	sqlMaxLimit=&quot;100&quot;，允许最大查询记录数</span></span><br><span class="line"><span class="comment">	checkSQLschema=&quot;false&quot; 是否检查自动删除 “虚拟库名”</span></span><br><span class="line"><span class="comment">	dataNode=&quot;dn1&quot; 虚拟库对应的真实database，值为dataNode标签的name</span></span><br><span class="line"><span class="comment">	--&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">schema</span> <span class="attr">name</span>=<span class="string">&quot;TESTDB&quot;</span> <span class="attr">checkSQLschema</span>=<span class="string">&quot;false&quot;</span> <span class="attr">sqlMaxLimit</span>=<span class="string">&quot;100&quot;</span> <span class="attr">dataNode</span>=<span class="string">&quot;dn1&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 可以访问的表，只有设置在这里的表才会被MyCat管理访问 </span></span><br><span class="line"><span class="comment">		dataNode:虚拟库对应的真实database，对应&lt;dataNode&gt;标签。如果做分片，则配置多个，用逗号分隔；或者使用db$0-99，代表db0到db99的database</span></span><br><span class="line"><span class="comment">		rule：分片规则，如果没有则删除</span></span><br><span class="line"><span class="comment">		--&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- &lt;table name=&quot;tb_item&quot; dataNode=&quot;dn1&quot;/&gt; --&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">schema</span>&gt;</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">&lt;!-- 真实的database信息，每一个dataNode就是一个数据库分片</span></span><br><span class="line"><span class="comment">		name：虚拟名称</span></span><br><span class="line"><span class="comment">		dataHost：真实库的主机信息，对应&lt;dataHost&gt;标签</span></span><br><span class="line"><span class="comment">		database：真实MySQL中真实的物理数据库名称</span></span><br><span class="line"><span class="comment">	--&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dataNode</span> <span class="attr">name</span>=<span class="string">&quot;dn1&quot;</span> <span class="attr">dataHost</span>=<span class="string">&quot;host1&quot;</span> <span class="attr">database</span>=<span class="string">&quot;testdb&quot;</span> /&gt;</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">&lt;!-- 真实库的主机信息</span></span><br><span class="line"><span class="comment">		name：主机名,name属性值要与dataNode节点中的dataHost属性值对应</span></span><br><span class="line"><span class="comment">		maxCon：最大连接， minCon：最小连接</span></span><br><span class="line"><span class="comment">		balance：负载均衡方式：0~3四种选项。0，不开启读写分离。1~3都开启，区别是主是否参与读</span></span><br><span class="line"><span class="comment">		writeType：写负载均衡。永远设置0</span></span><br><span class="line"><span class="comment">		dbDriver：驱动类型，推荐native，可选jdbc</span></span><br><span class="line"><span class="comment">		switchType：主从的自动切换</span></span><br><span class="line"><span class="comment">	--&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dataHost</span> <span class="attr">name</span>=<span class="string">&quot;host1&quot;</span> <span class="attr">maxCon</span>=<span class="string">&quot;1000&quot;</span> <span class="attr">minCon</span>=<span class="string">&quot;10&quot;</span> <span class="attr">balance</span>=<span class="string">&quot;0&quot;</span> <span class="attr">writeType</span>=<span class="string">&quot;0&quot;</span> <span class="attr">dbType</span>=<span class="string">&quot;mysql&quot;</span> <span class="attr">dbDriver</span>=<span class="string">&quot;native&quot;</span> <span class="attr">switchType</span>=<span class="string">&quot;1&quot;</span> <span class="attr">slaveThreshold</span>=<span class="string">&quot;100&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">		<span class="tag">&lt;<span class="name">heartbeat</span>&gt;</span>select user()<span class="tag">&lt;/<span class="name">heartbeat</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 这里设置写主机信息 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">writeHost</span> <span class="attr">host</span>=<span class="string">&quot;hostM1&quot;</span> <span class="attr">url</span>=<span class="string">&quot;192.168.140.128:3306&quot;</span> <span class="attr">user</span>=<span class="string">&quot;root&quot;</span> <span class="attr">password</span>=<span class="string">&quot;123123&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">			<span class="comment">&lt;!-- 这里设置读主机信息 --&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">readHost</span> <span class="attr">host</span>=<span class="string">&quot;hostS1&quot;</span> <span class="attr">url</span>=<span class="string">&quot;192.168.140.127:3306&quot;</span> <span class="attr">user</span>=<span class="string">&quot;root&quot;</span> <span class="attr">password</span>=<span class="string">&quot;123123&quot;</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">writeHost</span>&gt;</span></span><br><span class="line">	</span><br><span class="line">	<span class="tag">&lt;/<span class="name">dataHost</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">mycat:schema</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/2022/10/07/MySQL%E9%AB%98%E7%BA%A7%E7%AF%87/clip_image002-1628996577463.jpg" alt="img"></p>
<p><strong>3、验证数据库访问情况</strong></p>
<p>Mycat作为数据库中间件要和数据库部署在不同机器上，所以要验证远程访问情况。使用Mycat所在的主机访问Master和Slave端的MySQL Server。</p>
<p>注意：要关闭防火墙！</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#确认两台MySQL服务器可以通过远程进行访问</span><br><span class="line">mysql -uroot -p123123 -h 192.168.140.128 -P 3306</span><br><span class="line">mysql -uroot -p123123 -h 192.168.140.127 -P 3306</span><br><span class="line"></span><br><span class="line">#如远程访问报错，请建对应用户</span><br><span class="line">grant all privileges on *.* to root@&#x27;缺少的host&#x27;  identified by &#x27;123123&#x27;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>4、启动程序</strong></p>
<p>在 <code>mycat/bin</code> 目录下执行：</p>
<p><strong>方式1：控制台启动</strong> ： <code>./mycat console</code></p>
<p><strong>方式2：后台启动</strong> ： <code>./mycat start</code></p>
<p>为了能第一时间看到启动日志，方便定位问题，我们选择①控制台启动。</p>
<p><strong>其它操作：</strong></p>
<p>后台关闭：<code>./mycat stop</code></p>
<p>后台重启：<code>./mycat restart</code></p>
<p>状态： <code>./mycat status</code></p>
<p>日志文件：<code>mycat/logs/wrapper.log</code></p>
<p><strong>5、启动时可能出现报错</strong></p>
<p>如果操作系统是CentOS6.8，可能会出现域名解析失败错误，如下图：</p>
<p> <img src="/2022/10/07/MySQL%E9%AB%98%E7%BA%A7%E7%AF%87/clip_image002-1628996901367.jpg" alt="graphic"></p>
<p>可以按照以下步骤解决</p>
<p>①  用 <code>vim</code> 修改 <code>/etc/hosts</code> 文件，在 127.0.0.1 后面增加你的机器名</p>
<p> <img src="/2022/10/07/MySQL%E9%AB%98%E7%BA%A7%E7%AF%87/clip_image002-1628996913378.jpg" alt="graphic"></p>
<p>②  修改后重新启动网络服务</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">service network restart   #CentOS 6</span><br></pre></td></tr></table></figure>

<p> <img src="/2022/10/07/MySQL%E9%AB%98%E7%BA%A7%E7%AF%87/clip_image002-1628996973583.jpg" alt="graphic"></p>
<h2 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h2><h3 id="登录后台管理窗口"><a href="#登录后台管理窗口" class="headerlink" title="登录后台管理窗口"></a>登录后台管理窗口</h3><p><code>9066端口号对应后台管理窗口，用于运维人员管理维护Mycat使用</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql -umycat -p123456 -P 9066 -h 192.168.140.128</span><br></pre></td></tr></table></figure>

<p>注意：这里我是在对应MySQL8.0中使用的Mycat，可能会报错：</p>
<p> <img src="/2022/10/07/MySQL%E9%AB%98%E7%BA%A7%E7%AF%87/image-20210815225720216.png" alt="image-20210815225720216"></p>
<p>解决方式1：修改server.xml中的标签。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;nonePasswordLogin&quot;</span>&gt;</span>1<span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line"><span class="comment">&lt;!-- 0为需要密码登陆、1为不需要密码登陆 ,默认为0，设置为1则需要指定默认账户--&gt;</span></span><br></pre></td></tr></table></figure>

<p>重新启动mycat无密码登录，访问成功。 </p>
<p>解决方式2：更换MySQL的版本。</p>
<p><strong>常用命令如下：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show database</span><br></pre></td></tr></table></figure>

<p> <img src="/2022/10/07/MySQL%E9%AB%98%E7%BA%A7%E7%AF%87/clip_image001.png" alt="graphic"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show @@help</span><br></pre></td></tr></table></figure>

<p> <img src="/2022/10/07/MySQL%E9%AB%98%E7%BA%A7%E7%AF%87/clip_image003.jpg" alt="graphic"></p>
<h3 id="登录数据窗口"><a href="#登录数据窗口" class="headerlink" title="登录数据窗口"></a>登录数据窗口</h3><p><code>8066端口号对应开发人员使用，用于通过Mycat查询数据</code>，我们选择这种方式访问Mycat</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql -umycat -p123456 -P 8066 -h 192.168.140.128</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show databases;</span><br><span class="line"></span><br><span class="line">use TESTDB;</span><br><span class="line"></span><br><span class="line">show tables;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="项目中登录"><a href="#项目中登录" class="headerlink" title="项目中登录"></a>项目中登录</h3><p>其实项目中，只要改一个地方即可，就是jdbc的连接参数。</p>
<p> <img src="/2022/10/07/MySQL%E9%AB%98%E7%BA%A7%E7%AF%87/image-20210829224849931.png" alt="image-20210829224849931"></p>
<h1 id="主从复制原理"><a href="#主从复制原理" class="headerlink" title="主从复制原理"></a>主从复制原理</h1><p>我们通过Mycat和MySQL的主从复制配合搭建数据库的读写分离，实现MySQL的高可用性。我们将搭建：<code>一主一从</code>、<code>双主双从</code>两种读写分离模式。</p>
<h2 id="主从复制原理-1"><a href="#主从复制原理-1" class="headerlink" title="主从复制原理"></a>主从复制原理</h2><p><img src="/2022/10/07/MySQL%E9%AB%98%E7%BA%A7%E7%AF%87/clip_image004.jpg" alt="graphic"></p>
<p>提到主从同步的原理，我们就需要了解在数据库中的一个重要日志文件，那就是 Binlog 二 进制日志，它记录了对数据库进行更新的事件。实际上主从同步的原理就是基于 Binlog 进行数据同步的。在主从复制过程中，会基于 3 个线程来操作，一个<code>主库线程</code>，两个<code>从库线程</code>。 </p>
<p>二进制日志转储线程（Binlog dump thread）是一个主库线程。当从库线程连接的时候， 主库可以将二进制日志发送给从库，当主库读取事件的时候，会在 <code>Binlog 上加锁</code>，读取完成之后，再将锁释放掉。 </p>
<p>从库 I&#x2F;O 线程会连接到主库，向主库发送请求更新 Binlog。这时从库的 I&#x2F;O 线程就可以读取到主库的二进制日志转储线程发送的 <code>Binlog 更新部分</code>，并且拷贝到本地形成中继日志 （Relay log）。 </p>
<p>从库 SQL 线程会读取从库中的中继日志，并且<code>执行日志中的事件</code>，从而将从库中的数据与主库保持<code>同步</code>。</p>
<img src="image-20210826171726917.png" alt="image-20210826171726917" style="zoom: 80%;" />

<p>所以你能看到主从同步的内容就是二进制日志（Binlog），它虽然叫二进制日志，实际上存储的是一个又一个<code>事件（Event）</code>，这些事件分别对应着数据库的更新操作，比如 <code>INSERT</code>、<code>UPDATE</code>、<code>DELETE </code>等。另外我们还需要注意的是，不是所有版本的 MySQL 都默认开启服务器的二进制日志，在进行主从同步的时候，我们需要先检查服务器<code>是否已经开启了二进制日志</code>。</p>
<p>从服务器通过配置可以读取主服务器中二进制日志，并且执行日志中的事件。每个从服务器都能收到整个二进制日志的内容。从服务器需要识别日志中哪些语句应该被执行。除非特殊指定，<code>默认情况下主服务器中所有的事件都将被执行</code>。</p>
<h2 id="MySQL复制三步骤："><a href="#MySQL复制三步骤：" class="headerlink" title="MySQL复制三步骤："></a>MySQL复制三步骤：</h2><ol>
<li><code>Master</code>将写操作记录到二进制日志（<code>binlog</code>）。这些记录过程叫做<strong>二进制日志事件</strong>(binary log events)；</li>
<li><code>Slave</code>将<code>Master</code>的binary log  events拷贝到它的中继日志（<code>relay log</code>）；</li>
<li><code>Slave</code>重做中继日志中的事件，将改变应用到自己的数据库中。 MySQL复制是异步的且串行化的，而且重启后从接入点开始复制。</li>
</ol>
<h2 id="复制的问题"><a href="#复制的问题" class="headerlink" title="复制的问题"></a>复制的问题</h2><p>复制的最大问题：<strong>延时</strong>  </p>
<h2 id="复制的基本原则"><a href="#复制的基本原则" class="headerlink" title="复制的基本原则"></a>复制的基本原则</h2><ul>
<li><p>每个<code>Slave</code>只有一个<code>Master</code></p>
</li>
<li><p>每个<code>Slave</code>只能有一个唯一的服务器ID</p>
</li>
<li><p>每个<code>Master</code>可以有多个<code>Slave</code></p>
</li>
</ul>
<h1 id="主从复制与读写分离的实现"><a href="#主从复制与读写分离的实现" class="headerlink" title="主从复制与读写分离的实现"></a>主从复制与读写分离的实现</h1><h2 id="搭建主从复制：一主一从"><a href="#搭建主从复制：一主一从" class="headerlink" title="搭建主从复制：一主一从"></a>搭建主从复制：一主一从</h2><p>一台<code>主机</code>用于处理所有<code>写请求</code>，一台<code>从机</code>负责所有<code>读请求</code>，架构图如下：</p>
<p><img src="/2022/10/07/MySQL%E9%AB%98%E7%BA%A7%E7%AF%87/image-20210826172957062.png" alt="image-20210826172957062"></p>
<h3 id="搭建MySQL主从复制"><a href="#搭建MySQL主从复制" class="headerlink" title="搭建MySQL主从复制"></a>搭建MySQL主从复制</h3><p><strong>①  主机配置(host79)</strong></p>
<p>修改配置文件：<code>vim /etc/my.cnf</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#主服务器唯一ID</span><br><span class="line">server-id=1</span><br><span class="line"></span><br><span class="line">#启用二进制日志</span><br><span class="line">log-bin=mysql-bin</span><br><span class="line"></span><br><span class="line">#设置不要复制的数据库(可设置多个)</span><br><span class="line">binlog-ignore-db=mysql</span><br><span class="line">binlog-ignore-db=information_schema</span><br><span class="line"></span><br><span class="line">#设置需要复制的数据库。注意：MySQL是从接入点开始复制操作的</span><br><span class="line">binlog-do-db=需要复制的主数据库名字</span><br><span class="line"></span><br><span class="line">#设置logbin格式</span><br><span class="line">binlog_format=STATEMENT</span><br></pre></td></tr></table></figure>

<p>binlog日志三种格式：</p>
<ul>
<li><p><code>STATEMENT模式</code>（基于SQL语句的复制(statement-based replication, SBR)）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">binlog_format=STATEMENT</span><br></pre></td></tr></table></figure>

<p>每一条会修改数据的sql语句会记录到binlog中。这是默认的binlog格式。</p>
<p>优点：binlog文件较小，binlog可以用于实时的还原，而不仅仅用于复制。</p>
<p>缺点：使用以下函数的语句也无法被复制：LOAD_FILE()、UUID()、USER()、FOUND_ROWS()、SYSDATE() (除非启动时启用了 –sysdate-is-now 选项)。数据表必须几乎和主服务器保持一致才行，否则可能会导致复制出错。</p>
</li>
<li><p><code>ROW模式</code>（基于行的复制(row-based replication, RBR)）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">binlog_format=ROW</span><br></pre></td></tr></table></figure>

<p>不记录每条sql语句的上下文信息，仅需记录哪条数据被修改了，修改成什么样了。</p>
<p>优点：任何情况都可以被复制，这对复制来说是最安全可靠的。</p>
<p>缺点：binlog 大了很多。无法从 binlog 中看到都复制了写什么语句。</p>
</li>
<li><p><code>MIXED模式</code>（混合模式复制(mixed-based replication, MBR)）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">binlog_format=MIXED</span><br></pre></td></tr></table></figure>

<p>以上两种模式的混合使用。</p>
</li>
</ul>
<p><img src="/2022/10/07/MySQL%E9%AB%98%E7%BA%A7%E7%AF%87/clip_image002-1628997332911.jpg" alt="graphic"></p>
<p><strong>② 从机配置(host80)</strong></p>
<p>修改配置文件：<code>vim /etc/my.cnf</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#从服务器唯一ID</span><br><span class="line">server-id=2</span><br><span class="line"></span><br><span class="line">#启用中继日志</span><br><span class="line">relay-log=mysql-relay</span><br></pre></td></tr></table></figure>

<p><strong>③ 主机、从机重启MySQL服务</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl restart mysqld</span><br><span class="line"></span><br><span class="line">systemctl status mysqld</span><br></pre></td></tr></table></figure>

<p><strong>④ 主机从机都关闭防火墙</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl status firewalld</span><br></pre></td></tr></table></figure>

<p><strong>⑤ 在Master主机上建立帐户并授权slave</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#在主机MySQL里执行授权主从复制的命令</span><br><span class="line">GRANT REPLICATION SLAVE ON *.* TO &#x27;slave&#x27;@&#x27;%&#x27; IDENTIFIED BY &#x27;123123&#x27;;</span><br></pre></td></tr></table></figure>

<p><strong>注意：如果使用的是MySQL8，需要如下的方式建立账户，并授权slave：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create user &#x27;slave&#x27;@&#x27;%&#x27; identified by &#x27;HelloWorld_123&#x27;;</span><br><span class="line"></span><br><span class="line">GRANT REPLICATION SLAVE ON *.* TO slave@&#x27;%&#x27;;</span><br><span class="line"></span><br><span class="line">ALTER USER &#x27;slave&#x27;@&#x27;%&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;HelloWorld_123&#x27;;</span><br><span class="line"></span><br><span class="line">flush privileges;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>查询master的状态</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show master status; #查看当前最新的一个binlog日志的编号名称，及最后一个事件结束的位置</span><br></pre></td></tr></table></figure>

<p> <img src="/2022/10/07/MySQL%E9%AB%98%E7%BA%A7%E7%AF%87/clip_image001-1628997496560.png" alt="img"></p>
<ul>
<li>记录下File和Position的值</li>
</ul>
<p>注意：执行完此步骤后不要再操作主服务器MySQL，防止主服务器状态值变化</p>
<p><strong>⑥ 在从机上配置需要复制的主机</strong></p>
<ul>
<li>复制主机的命令</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CHANGE MASTER TO MASTER_HOST=&#x27;主机的IP地址&#x27;,</span><br><span class="line">MASTER_USER=&#x27;slave&#x27;,</span><br><span class="line">MASTER_PASSWORD=&#x27;123123&#x27;,</span><br><span class="line">MASTER_LOG_FILE=&#x27;mysql-bin.具体数字&#x27;,MASTER_LOG_POS=具体值;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">举例：</span><br><span class="line">CHANGE MASTER TO MASTER_HOST=&#x27;192.168.1.110&#x27;,</span><br><span class="line">MASTER_USER=&#x27;slave&#x27;,</span><br><span class="line">MASTER_PASSWORD=&#x27;HelloWorld_123&#x27;,</span><br><span class="line">MASTER_LOG_FILE=&#x27;mysql-bin.000002&#x27;,MASTER_LOG_POS=1133;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/10/07/MySQL%E9%AB%98%E7%BA%A7%E7%AF%87/clip_image001-1628997578261.png" alt="img"></p>
<ul>
<li><strong>启动从服务器复制功能</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">start slave;</span><br></pre></td></tr></table></figure>

<p>如果报错：</p>
<p><img src="/2022/10/07/MySQL%E9%AB%98%E7%BA%A7%E7%AF%87/image-20210826180046584.png" alt="image-20210826180046584"></p>
<p>可以执行如下操作，删除之前的relay_log信息。然后重新执行 change master to …语句即可。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; reset slave;</span><br></pre></td></tr></table></figure>

<ul>
<li>查看从服务器状态</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show slave status\G;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/10/07/MySQL%E9%AB%98%E7%BA%A7%E7%AF%87/clip_image001-1628997746000.png" alt="img"></p>
<p>下面两个参数都是Yes，则说明主从配置成功！</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Slave_IO_Running: Yes</span><br><span class="line">Slave_SQL_Running: Yes</span><br></pre></td></tr></table></figure>

<p>显式如下的情况，就是不正确的。可能错误的原因有：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 网络不通</span><br><span class="line">2. 账户密码错误</span><br><span class="line">3. 防火墙</span><br><span class="line">4. mysql配置文件问题</span><br><span class="line">5. 连接服务器时语法</span><br><span class="line">6. 主服务器mysql权限</span><br></pre></td></tr></table></figure>

<p><img src="/2022/10/07/MySQL%E9%AB%98%E7%BA%A7%E7%AF%87/image-20210816105407268.png" alt="image-20210816105407268"></p>
<p><strong>⑦ 主机新建库、新建表、insert记录，从机复制</strong></p>
<p><img src="/2022/10/07/MySQL%E9%AB%98%E7%BA%A7%E7%AF%87/clip_image002-1628997812192.jpg" alt="img"></p>
<p>以上就搭建好了<code>主从复制</code>。</p>
<p><strong>补充说明1：如何停止从服务复制功能</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">stop slave;</span><br></pre></td></tr></table></figure>

<p><strong>补充说明2：如何重新配置主从</strong></p>
<p>对于从机来说，如果之前搭过主从。会报错如下：</p>
<p> <img src="/2022/10/07/MySQL%E9%AB%98%E7%BA%A7%E7%AF%87/image-20210816092328495.png" alt="image-20210816092328495"></p>
<p>如何重新配置主从？在从机上执行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">stop slave; </span><br><span class="line"></span><br><span class="line">reset master;</span><br></pre></td></tr></table></figure>

<h3 id="Mycat登录访问"><a href="#Mycat登录访问" class="headerlink" title="Mycat登录访问"></a>Mycat登录访问</h3><p>（方便起见，可以Xshell中启动三个窗口，针对Mycat所在的服务器进行连接，窗口分别命名为：mycat、bin、conf）</p>
<p>启动Mycat，在mycat&#x2F;bin目录下执行如下命令，启动mycat</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./mycat console</span><br></pre></td></tr></table></figure>

<p>登录mycat账户，并访问数据库中的数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql -umycat -p123456 -h192.168.140.128 -P8066</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; show database;</span><br><span class="line">mysql&gt; use TESTDB;</span><br><span class="line">mysql&gt; select * from mytbl;</span><br></pre></td></tr></table></figure>

<h2 id="实现一主一从的读写分离"><a href="#实现一主一从的读写分离" class="headerlink" title="实现一主一从的读写分离"></a>实现一主一从的读写分离</h2><p>之前的配置已分配了读写主机，实现了主从复制，是否已实现读写分离？</p>
<h3 id="验证读写分离"><a href="#验证读写分离" class="headerlink" title="验证读写分离"></a>验证读写分离</h3><p>（1）在写主机插入如下数据，这样会出现主从主机数据不一致的情况。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">insert into mytbl values (1,@@hostname);</span><br></pre></td></tr></table></figure>

<p>（2）在Mycat里查询：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from mytbl; </span><br></pre></td></tr></table></figure>

<p>此时发现读取的数据<code>来自于写主机</code>。如果实现了读写分离，那此时应该读取的是从机的数据。说明此时没有实现读写分离。</p>
<h3 id="实现读写分离"><a href="#实现读写分离" class="headerlink" title="实现读写分离"></a>实现读写分离</h3><p>修改Mycat的配置文件<code>schema.xml</code>的<code>&lt;dataHost&gt;</code>的balance属性，通过此属性配置读写分离的类型</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">负载均衡类型，目前的取值有4 种：</span><br><span class="line">（1）balance=&quot;0&quot;, 不开启读写分离机制，所有读操作都发送到当前可用的 writeHost 上。</span><br><span class="line"></span><br><span class="line">（2）balance=&quot;1&quot;，全部的readHost 与 stand by writeHost 参与 select 语句的负载均衡，简单的说，当双主双从模式(M1-&gt;S1，M2-&gt;S2，并且 2M1 与 M2 互为主备)，正常情况下，M2,S1,S2 都参与 select 语句的负载均衡。</span><br><span class="line"></span><br><span class="line">（3）balance=&quot;2&quot;，所有读操作都随机的在 writeHost、readhost 上分发。</span><br><span class="line"></span><br><span class="line">（4）balance=&quot;3&quot;，所有读请求随机的分发到 readhost 执行，writerHost 不负担读压力。对应单主单从。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>读写分离情况下，<code>将balance设置成3是对的</code>。这里为了演示动态效果，把balance设置成2，这样会在两个机器间切换查询。</p>
<p>停止mycat服务，修改balance：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">…</span><br><span class="line">&lt;dataHost name=&quot;host1&quot; maxCon=&quot;1000&quot; minCon=&quot;10&quot; balance=&quot;2&quot; writeType=&quot;0&quot; dbType=&quot;mysql&quot; dbDriver=&quot;native&quot; switchType=&quot;1&quot; slaveThreshold=&quot;100&quot;&gt;</span><br><span class="line">…</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/2022/10/07/MySQL%E9%AB%98%E7%BA%A7%E7%AF%87/clip_image002-1628998155425.jpg" alt="img"></p>
<h3 id="启动Mycat"><a href="#启动Mycat" class="headerlink" title="启动Mycat"></a>启动Mycat</h3><h3 id="验证读写分离-1"><a href="#验证读写分离-1" class="headerlink" title="验证读写分离"></a>验证读写分离</h3><p>（1）在写主机数据库表mytbl中插入带系统变量数据，造成主从数据不一致</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO mytbl VALUES(2,@@hostname);</span><br></pre></td></tr></table></figure>

<p><img src="/2022/10/07/MySQL%E9%AB%98%E7%BA%A7%E7%AF%87/clip_image002-1628998267656.jpg" alt="img"></p>
<p> （2）在Mycat里查询mytbl表,可以看到查询语句在主从两个主机间切换</p>
<p><img src="/2022/10/07/MySQL%E9%AB%98%E7%BA%A7%E7%AF%87/clip_image001-1628998383828.png" alt="img"></p>
<h2 id="搭建主从复制：双主双从"><a href="#搭建主从复制：双主双从" class="headerlink" title="搭建主从复制：双主双从"></a>搭建主从复制：双主双从</h2><p>一个主机m1用于处理所有写请求，它的从机s1和另一台主机m2还有它的从机s2负责所有读请求。当m1主机宕机后，m2主机负责写请求，m1、m2互为备机。架构图如下：</p>
<p><img src="/2022/10/07/MySQL%E9%AB%98%E7%BA%A7%E7%AF%87/image-20210826191306073.png" alt="image-20210826191306073"></p>
<p><img src="/2022/10/07/MySQL%E9%AB%98%E7%BA%A7%E7%AF%87/clip_image002-1628998439368.jpg" alt="graphic"></p>
<table>
<thead>
<tr>
<th>编号</th>
<th>角色</th>
<th>IP地址</th>
<th>机器名</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>Master1</td>
<td>192.168.140.128</td>
<td>host79.atguigu</td>
</tr>
<tr>
<td>2</td>
<td>Slave1</td>
<td>192.168.140.127</td>
<td>host80.atguigu</td>
</tr>
<tr>
<td>3</td>
<td>Master2</td>
<td>192.168.140.126</td>
<td>host81.atguigu</td>
</tr>
<tr>
<td>4</td>
<td>Slave2</td>
<td>192.168.140.125</td>
<td>host82.atguigu</td>
</tr>
</tbody></table>
<h3 id="储备"><a href="#储备" class="headerlink" title="储备"></a>储备</h3><ul>
<li><p>记得删除演示一主一从模式时创建的数据库<code>testdb</code>。</p>
</li>
<li><p>记得在之前的从机上执行：<code>stop slave</code> 和 <code>reset master </code>。</p>
</li>
</ul>
<h3 id="搭建MySQL主从复制（双主双从）"><a href="#搭建MySQL主从复制（双主双从）" class="headerlink" title="搭建MySQL主从复制（双主双从）"></a>搭建MySQL主从复制（双主双从）</h3><p><strong>①  双主机配置</strong></p>
<p><strong>Master1配置：</strong></p>
<p>修改配置文件：<code>vim /etc/my.cnf</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#【必须】主服务器唯一ID</span><br><span class="line">server-id=1</span><br><span class="line"></span><br><span class="line">#【必须】启用二进制日志</span><br><span class="line">log-bin=mysql-bin</span><br><span class="line"></span><br><span class="line">#设置不要复制的数据库(可设置多个)</span><br><span class="line">binlog-ignore-db=mysql</span><br><span class="line">binlog-ignore-db=information_schema</span><br><span class="line"></span><br><span class="line">#【必须】设置需要复制的数据库</span><br><span class="line">binlog-do-db=需要复制的主数据库名字</span><br><span class="line"></span><br><span class="line">#设置logbin格式</span><br><span class="line">binlog_format=STATEMENT</span><br><span class="line"></span><br><span class="line">#【必须】在作为从数据库的时候，有写入操作也要更新二进制日志文件</span><br><span class="line">log-slave-updates </span><br><span class="line"></span><br><span class="line">#【必须】表示自增长字段每次递增的量，指自增字段的起始值，其默认值是1，取值范围是1 .. 65535</span><br><span class="line">auto-increment-increment=2 </span><br><span class="line"></span><br><span class="line">#【必须】表示自增长字段从哪个数开始，指字段一次递增多少，他的取值范围是1 .. 65535</span><br><span class="line">auto-increment-offset=1 </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>Master2配置：</strong></p>
<p>修改配置文件：<code>vim /etc/my.cnf</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#【必须】主服务器唯一ID</span><br><span class="line">server-id=3</span><br><span class="line"></span><br><span class="line">#【必须】启用二进制日志</span><br><span class="line">log-bin=mysql-bin</span><br><span class="line"></span><br><span class="line">#设置不要复制的数据库(可设置多个)</span><br><span class="line">binlog-ignore-db=mysql</span><br><span class="line">binlog-ignore-db=information_schema</span><br><span class="line"></span><br><span class="line">#【必须】设置需要复制的数据库</span><br><span class="line">binlog-do-db=需要复制的主数据库名字</span><br><span class="line"></span><br><span class="line">#设置logbin格式</span><br><span class="line">binlog_format=STATEMENT</span><br><span class="line"></span><br><span class="line">#【必须】在作为从数据库的时候，有写入操作也要更新二进制日志文件</span><br><span class="line">log-slave-updates </span><br><span class="line"></span><br><span class="line">#【必须】表示自增长字段每次递增的量，指自增字段的起始值，其默认值是1，取值范围是1 .. 65535</span><br><span class="line">auto-increment-increment=2 </span><br><span class="line"></span><br><span class="line">#【必须】表示自增长字段从哪个数开始，指字段一次递增多少，他的取值范围是1 .. 65535</span><br><span class="line">auto-increment-offset=2</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>② 双从机配置</strong></p>
<p><strong>Slave1配置：</strong></p>
<p>修改配置文件：<code>vim /etc/my.cnf</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#【必须】从服务器唯一ID</span><br><span class="line">server-id=2</span><br><span class="line"></span><br><span class="line">#【必须】启用中继日志</span><br><span class="line">relay-log=mysql-relay</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>Slave2配置：</strong></p>
<p>修改配置文件：<code>vim /etc/my.cnf</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#【必须】从服务器唯一ID</span><br><span class="line">server-id=4</span><br><span class="line"></span><br><span class="line">#【必须】启用中继日志</span><br><span class="line">relay-log=mysql-relay</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>③ 双主机、双从机重启mysql服务</strong></p>
<p><strong>④ 主机从机都关闭防火墙</strong></p>
<p><strong>⑤ 在两台主机上分别建立帐户并授权slave</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#在主机MySQL里执行授权命令</span><br><span class="line">GRANT REPLICATION SLAVE ON *.* TO &#x27;slave&#x27;@&#x27;%&#x27; IDENTIFIED BY &#x27;123123&#x27;;</span><br></pre></td></tr></table></figure>

<p><strong>注意：如果使用的是MySQL8，需要如下的方式建立账户，并授权slave：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create user &#x27;slave&#x27;@&#x27;%&#x27; identified by &#x27;HelloWorld_123&#x27;;</span><br><span class="line"></span><br><span class="line">GRANT REPLICATION SLAVE ON *.* TO slave@&#x27;%&#x27;;</span><br><span class="line"></span><br><span class="line">ALTER USER &#x27;slave&#x27;@&#x27;%&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;HelloWorld_123&#x27;;</span><br><span class="line"></span><br><span class="line">flush privileges;</span><br></pre></td></tr></table></figure>



<ul>
<li>查询Master1的状态：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show master status;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/10/07/MySQL%E9%AB%98%E7%BA%A7%E7%AF%87/clip_image001-1628999687408.png" alt="img"></p>
<ul>
<li>查询Master2的状态：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show master status;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/10/07/MySQL%E9%AB%98%E7%BA%A7%E7%AF%87/clip_image001-1628999711121.png" alt="img"></p>
<p>注意：</p>
<p>分别记录下File和Position的值。</p>
<p>执行完此步骤后不要再操作主服务器MySQL，防止主服务器状态值变化。</p>
<p><strong>⑥ 在从机上配置需要复制的主机</strong></p>
<p>Slave1复制Master1，Slave2复制Master2。</p>
<p>#复制主机的命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CHANGE MASTER TO MASTER_HOST=&#x27;主机的IP地址&#x27;,</span><br><span class="line">MASTER_USER=&#x27;slave&#x27;,</span><br><span class="line">MASTER_PASSWORD=&#x27;123123&#x27;,</span><br><span class="line">MASTER_LOG_FILE=&#x27;mysql-bin.具体数字&#x27;,MASTER_LOG_POS=具体值;</span><br></pre></td></tr></table></figure>

<p> 所以，</p>
<p>Slave1的复制命令：</p>
<p> <img src="/2022/10/07/MySQL%E9%AB%98%E7%BA%A7%E7%AF%87/clip_image001-1628999832033.png" alt="img"></p>
<p>Slave2的复制命令：</p>
<p> <img src="/2022/10/07/MySQL%E9%AB%98%E7%BA%A7%E7%AF%87/clip_image002.png" alt="img"></p>
<ul>
<li>启动两台从服务器复制功能</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">start slave;</span><br></pre></td></tr></table></figure>

<ul>
<li>查看从服务器状态</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show slave status\G;</span><br></pre></td></tr></table></figure>

<p>Slave1的复制Master1</p>
<p> <img src="/2022/10/07/MySQL%E9%AB%98%E7%BA%A7%E7%AF%87/clip_image003.png" alt="img"></p>
<p>Slave2的复制Master2</p>
<p> <img src="/2022/10/07/MySQL%E9%AB%98%E7%BA%A7%E7%AF%87/clip_image004.png" alt="img"></p>
<p>下面两个参数都是Yes，则说明主从配置成功！</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Slave_IO_Running: Yes</span><br><span class="line">Slave_SQL_Running: Yes</span><br></pre></td></tr></table></figure>

<ul>
<li>如果当初使用克隆的方式生成的虚拟机（包含MySQL Server），则克隆的虚拟机MySQL Server的UUID相同，必须修改，否则<code>show slave status\G</code>会报错。具体修改方式在《2.使用前准备工作》</li>
</ul>
<p><strong>⑦ 两个主服务器互相复制</strong></p>
<p>Master2复制Master1，Master1复制Master2</p>
<p>Master2的复制命令：</p>
<p> <img src="/2022/10/07/MySQL%E9%AB%98%E7%BA%A7%E7%AF%87/clip_image001-1629000179039.png" alt="img"></p>
<p>Master1的复制命令：</p>
<p> <img src="/2022/10/07/MySQL%E9%AB%98%E7%BA%A7%E7%AF%87/clip_image002-1629000179040.png" alt="img"></p>
<ul>
<li>启动两台主服务器复制功能</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">start slave;</span><br></pre></td></tr></table></figure>

<ul>
<li>查看从服务器状态</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show slave status\G;</span><br></pre></td></tr></table></figure>

<p> Master2的复制Master1：</p>
<p> <img src="/2022/10/07/MySQL%E9%AB%98%E7%BA%A7%E7%AF%87/clip_image003-1629000179040.png" alt="img"></p>
<p> Master1的复制Master2：</p>
<p> <img src="/2022/10/07/MySQL%E9%AB%98%E7%BA%A7%E7%AF%87/clip_image001-1629000184850.png" alt="img"></p>
<p>下面两个参数都是Yes，则说明主从配置成功！</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Slave_IO_Running: Yes</span><br><span class="line">Slave_SQL_Running: Yes</span><br></pre></td></tr></table></figure>

<p>⑧ Master1主机新建库、新建表、insert记录，Master2和从机复制</p>
<p><img src="/2022/10/07/MySQL%E9%AB%98%E7%BA%A7%E7%AF%87/clip_image002-1629000668802.jpg" alt="img"></p>
<p>⑨ 如何停止从服务复制功能</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">stop slave;</span><br></pre></td></tr></table></figure>

<p>⑩ 如何重新配置主从</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">stop slave; </span><br><span class="line">reset master;</span><br></pre></td></tr></table></figure>

<h2 id="实现双主双从机的读写分离"><a href="#实现双主双从机的读写分离" class="headerlink" title="实现双主双从机的读写分离"></a>实现双主双从机的读写分离</h2><p>上述操作实现了双主双从的复制，下面实现读写分离操作。</p>
<h3 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h3><p>修改Mycat的配置文件<code>schema.xml</code>的<code>&lt;dataHost&gt;</code>的<code>balance</code>属性，通过此属性配置读写分离的类型</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">负载均衡类型，目前的取值有4 种：</span><br><span class="line">（1）balance=&quot;0&quot;, 不开启读写分离机制，所有读操作都发送到当前可用的 writeHost 上。</span><br><span class="line"></span><br><span class="line">（2）balance=&quot;1&quot;，全部的 readHost 与 stand by writeHost 参与 select 语句的负载均衡，简单的说，当双主双从模式(M1-&gt;S1，M2-&gt;S2，并且 M1 与 M2 互为主备)，正常情况下，M2,S1,S2 都参与 select 语句的负载均衡。</span><br><span class="line"></span><br><span class="line">（3）balance=&quot;2&quot;，所有读操作都随机的在 writeHost、readhost 上分发。</span><br><span class="line"></span><br><span class="line">（4）balance=&quot;3&quot;，所有读请求随机的分发到 readhost 执行，writerHost 不负担读压力</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>为了双主双从读写分离balance设置为1：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">…</span><br><span class="line"><span class="tag">&lt;<span class="name">dataNode</span> <span class="attr">name</span>=<span class="string">&quot;dn1&quot;</span> <span class="attr">dataHost</span>=<span class="string">&quot;host1&quot;</span> <span class="attr">database</span>=<span class="string">&quot;testdb&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dataHost</span> <span class="attr">name</span>=<span class="string">&quot;host1&quot;</span> <span class="attr">maxCon</span>=<span class="string">&quot;1000&quot;</span> <span class="attr">minCon</span>=<span class="string">&quot;10&quot;</span> <span class="attr">balance</span>=<span class="string">&quot;1&quot;</span> <span class="attr">writeType</span>=<span class="string">&quot;0&quot;</span> <span class="attr">dbType</span>=<span class="string">&quot;mysql&quot;</span> <span class="attr">dbDriver</span>=<span class="string">&quot;native&quot;</span> <span class="attr">switchType</span>=<span class="string">&quot;1&quot;</span>  <span class="attr">slaveThreshold</span>=<span class="string">&quot;100&quot;</span> &gt;</span></span><br><span class="line"></span><br><span class="line">		<span class="tag">&lt;<span class="name">heartbeat</span>&gt;</span>select user()<span class="tag">&lt;/<span class="name">heartbeat</span>&gt;</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">&lt;!-- can have multi write hosts --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">writeHost</span> <span class="attr">host</span>=<span class="string">&quot;hostM1&quot;</span> <span class="attr">url</span>=<span class="string">&quot;192.168.140.128:3306&quot;</span> <span class="attr">user</span>=<span class="string">&quot;root&quot;</span> <span class="attr">password</span>=<span class="string">&quot;123123&quot;</span>&gt;</span></span><br><span class="line">			<span class="comment">&lt;!-- can have multi read hosts --&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">readHost</span> <span class="attr">host</span>=<span class="string">&quot;hostS1&quot;</span> <span class="attr">url</span>=<span class="string">&quot;192.168.140.127:3306&quot;</span> <span class="attr">user</span>=<span class="string">&quot;root&quot;</span> <span class="attr">password</span>=<span class="string">&quot;123123&quot;</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">writeHost</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!--  复制一份 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">writeHost</span> <span class="attr">host</span>=<span class="string">&quot;hostM2&quot;</span> <span class="attr">url</span>=<span class="string">&quot;192.168.140.126:3306&quot;</span> <span class="attr">user</span>=<span class="string">&quot;root&quot;</span> <span class="attr">password</span>=<span class="string">&quot;123123&quot;</span>&gt;</span></span><br><span class="line">			<span class="comment">&lt;!-- can have multi read hosts --&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">readHost</span> <span class="attr">host</span>=<span class="string">&quot;hostS2&quot;</span> <span class="attr">url</span>=<span class="string">&quot;192.168.140.125:3306&quot;</span> <span class="attr">user</span>=<span class="string">&quot;root&quot;</span> <span class="attr">password</span>=<span class="string">&quot;123123&quot;</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">writeHost</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">dataHost</span>&gt;</span></span><br><span class="line">…</span><br><span class="line"></span><br><span class="line">#balance=&quot;1&quot;: 全部的readHost与stand by writeHost参与select语句的负载均衡。</span><br><span class="line"></span><br><span class="line">#writeType=&quot;0&quot;: 所有写操作发送到配置的第一个writeHost，第一个挂了切到还生存的第二个</span><br><span class="line">#writeType=&quot;1&quot;，所有写操作都随机的发送到配置的 writeHost，1.5 以后废弃不推荐</span><br><span class="line">#writeHost，重新启动后以切换后的为准，切换记录在配置文件中:dnindex.properties 。</span><br><span class="line">#switchType=&quot;1&quot;: 1 默认值，自动切换。</span><br><span class="line">#               -1 表示不自动切换</span><br><span class="line">#                2 基于 MySQL 主从同步的状态决定是否切换。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>主要修改内容见下图红框：</p>
<p><img src="/2022/10/07/MySQL%E9%AB%98%E7%BA%A7%E7%AF%87/image-20210816203836804.png" alt="image-20210816203836804">  </p>
<h3 id="启动Mycat-1"><a href="#启动Mycat-1" class="headerlink" title="启动Mycat"></a>启动Mycat</h3><h3 id="验证读写分离-2"><a href="#验证读写分离-2" class="headerlink" title="验证读写分离"></a>验证读写分离</h3><p>在写主机Master1数据库表mytbl中插入带系统变量数据，造成主从数据不一致  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO mytbl VALUES(3,@@hostname);  </span><br></pre></td></tr></table></figure>

<p><img src="/2022/10/07/MySQL%E9%AB%98%E7%BA%A7%E7%AF%87/clip_image004-1629000737205.jpg" alt="img">  #</p>
<p>在Mycat里查询mytbl表,可以看到查询语句在Master2（host81）、Slave1（host80）、Slave2（host82）主从三个主机间切换。</p>
<p>  <img src="/2022/10/07/MySQL%E9%AB%98%E7%BA%A7%E7%AF%87/clip_image005.png" alt="img">     </p>
<h3 id="抗风险能力测试"><a href="#抗风险能力测试" class="headerlink" title="抗风险能力测试"></a>抗风险能力测试</h3><p>停止数据库Master1</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl stop mysqld</span><br><span class="line"></span><br><span class="line">systemctl status mysqld</span><br></pre></td></tr></table></figure>

<p>  <img src="/2022/10/07/MySQL%E9%AB%98%E7%BA%A7%E7%AF%87/clip_image006.png" alt="img"></p>
<p>在Mycat里插入数据依然成功，Master2自动切换为写主机</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO  mytbl VALUES(3,@@hostname);</span><br></pre></td></tr></table></figure>

<p> <img src="/2022/10/07/MySQL%E9%AB%98%E7%BA%A7%E7%AF%87/clip_image007.png" alt="img"></p>
<p>启动数据库Master1：</p>
<p> <img src="/2022/10/07/MySQL%E9%AB%98%E7%BA%A7%E7%AF%87/clip_image008.png" alt="img"></p>
<p>在Mycat里查询mytbl表,可以看到查询语句在Master1（host79）、Slave1（host80）、Slave2（host82）主从三个主机间切换：</p>
<p> <img src="/2022/10/07/MySQL%E9%AB%98%E7%BA%A7%E7%AF%87/clip_image009.png" alt="img">        </p>
<p>Master1、Master2互做备机，负责写的主机宕机，备机切换负责写操作，保证数据库读写分离高可用性。</p>
<h1 id="Mycat数据分片"><a href="#Mycat数据分片" class="headerlink" title="Mycat数据分片"></a>Mycat数据分片</h1><h2 id="什么是数据分片？"><a href="#什么是数据分片？" class="headerlink" title="什么是数据分片？"></a>什么是数据分片？</h2><p>简单来说，就是指通过某种特定的条件，将我们存放在同一个数据库中的数据分散存放到多个数据库（主机）上面，以达到分散单台设备负载的效果。</p>
<h2 id="切分模式"><a href="#切分模式" class="headerlink" title="切分模式"></a>切分模式</h2><p>数据的切分（Sharding）根据其切分规则的类型，可以分为两种切分模式：</p>
<p><strong>1. 垂直（纵向）切分</strong>：是按照不同的表（或者 Schema）来切分到不同的数据库（主机）之上</p>
<p><strong>2. 水平（横向）切分</strong>：是根据表中的数据的逻辑关系，将同一个表中的数据按照某种条件拆分到多台数据库（主机）上面。</p>
<h2 id="Mycat分片原理"><a href="#Mycat分片原理" class="headerlink" title="Mycat分片原理"></a>Mycat分片原理</h2><p>MyCat的分片实现：</p>
<p> <img src="/2022/10/07/MySQL%E9%AB%98%E7%BA%A7%E7%AF%87/image-20210829225324607.png" alt="image-20210829225324607"></p>
<p><strong>逻辑库(schema) ：</strong>MyCat作为一个数据库中间件，起到一个程序与数据库的桥梁作用。开发人员无需知道MyCat的存在，只需要知道数据库的概念即可。为了让MyCat更透明，它会把自己“伪装”成一个MySQL数据库，因此需要有一个虚拟的 database，在MyCat中也叫逻辑库，英文就是schema。</p>
<p><strong>逻辑表（table）：</strong>既然有逻辑库，那么就会有逻辑表，分布式数据库中，对应用来说，读写数据的表就是逻辑表。逻辑表，可以是数据切分后，分布在一个或多个分片库中，也可以不做数据切分，不分片，只有一个表构成。</p>
<p><strong>分片节点(dataNode)：</strong>数据切分后，一个大表被分到不同的分片数据库上面，每个表分片所在的数据库就是分片节点（dataNode）。</p>
<p><strong>节点主机(dataHost)：</strong>数据切分后，每个分片节点（dataNode）不一定都会独占一台机器，同一机器上面可以有多个分片数据库，这样一个或多个分片节点（dataNode）所在的机器就是节点主机（dataHost）,为了规避单节点主机并发数限制，尽量将读写压力高的分片节点（dataNode）均衡的放在不同的节点主机（dataHost）。</p>
<p><strong>分片规则(rule)：</strong>前面讲了数据切分，一个大表被分成若干个分片表，就需要一定的规则，这样按照某种业务规则把数据分到某个分片的规则就是分片规则，数据切分选择合适的分片规则非常重要，将极大的避免后续数据处理的难度。</p>
<h1 id="垂直拆分——分库"><a href="#垂直拆分——分库" class="headerlink" title="垂直拆分——分库"></a>垂直拆分——分库</h1><p>一个数据库由很多表构成，每个表对应着不同的业务，垂直拆分是指按照业务将表进行分类，分布到不同的数据库上面，这样也就将数据或者说压力分担到不同的库上面，如下图：</p>
<p><img src="/2022/10/07/MySQL%E9%AB%98%E7%BA%A7%E7%AF%87/clip_image001-1629001912396.png" alt="img"></p>
<p><img src="/2022/10/07/MySQL%E9%AB%98%E7%BA%A7%E7%AF%87/image-20210826210404801.png" alt="image-20210826210404801"></p>
<p>系统被拆分成了：用户、订单交易、支付几个模块。</p>
<blockquote>
<p>【推荐】单表行数超过 500 万行或者单表容量超过 2GB，才推荐进行分库分表。 </p>
<p>说明：如果预计三年后的数据量根本达不到这个级别，请不要在创建表时就分库分表。</p>
<p>来源：阿里巴巴《Java开发手册》</p>
</blockquote>
<h2 id="如何划分表"><a href="#如何划分表" class="headerlink" title="如何划分表"></a>如何划分表</h2><p>一个问题：在两台主机上的两个数据库中的表，能否JOIN关联查询？</p>
<p>答案：不可以关联查询。</p>
<p><strong>分库的原则：</strong></p>
<ol>
<li><strong>能不切分尽量不要切分</strong>。数据量不是很大的库或者表，尽量不要分片。</li>
<li><strong>尽量按照功能模块分库，避免跨库join。</strong></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#客户表  rows:20万 </span><br><span class="line">CREATE TABLE customer(</span><br><span class="line">    id INT AUTO_INCREMENT,</span><br><span class="line">    NAME VARCHAR(200),</span><br><span class="line">    PRIMARY KEY(id)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">#订单表   rows:600万</span><br><span class="line">CREATE TABLE orders(</span><br><span class="line">    id INT AUTO_INCREMENT,</span><br><span class="line">    order_type INT,</span><br><span class="line">    customer_id INT,</span><br><span class="line">    amount DECIMAL(10,2),</span><br><span class="line">    PRIMARY KEY(id)  </span><br><span class="line">); </span><br><span class="line"></span><br><span class="line">#订单详细表  rows:600万</span><br><span class="line">CREATE TABLE orders_detail(</span><br><span class="line">    id INT AUTO_INCREMENT,</span><br><span class="line">    detail VARCHAR(2000),</span><br><span class="line">    order_id INT,</span><br><span class="line">    PRIMARY KEY(id)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">#订单状态字典表   rows:20</span><br><span class="line">CREATE TABLE dict_order_type(</span><br><span class="line">    id INT AUTO_INCREMENT,</span><br><span class="line">    order_type VARCHAR(200),</span><br><span class="line">    PRIMARY KEY(id)</span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>以上四个表如何分库？客户表分在一个数据库，另外三张都需要关联查询，分在另外一个数据库。</p>
<blockquote>
<p>分布在同一台主机上不同数据库的表，可以进行JOIN查询操作。</p>
<p>分布在不同主机上的数据库中的表，不可以进行JOIN查询操作。</p>
</blockquote>
<h2 id="实现分库"><a href="#实现分库" class="headerlink" title="实现分库"></a>实现分库</h2><h3 id="修改schema配置文件"><a href="#修改schema配置文件" class="headerlink" title="修改schema配置文件"></a>修改schema配置文件</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">…</span><br><span class="line"><span class="tag">&lt;<span class="name">schema</span> <span class="attr">name</span>=<span class="string">&quot;TESTDB&quot;</span> <span class="attr">checkSQLschema</span>=<span class="string">&quot;false&quot;</span> <span class="attr">sqlMaxLimit</span>=<span class="string">&quot;100&quot;</span> <span class="attr">dataNode</span>=<span class="string">&quot;dn1&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">&quot;customer&quot;</span> <span class="attr">dataNode</span>=<span class="string">&quot;dn2&quot;</span> &gt;</span><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">schema</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dataNode</span> <span class="attr">name</span>=<span class="string">&quot;dn1&quot;</span> <span class="attr">dataHost</span>=<span class="string">&quot;host1&quot;</span> <span class="attr">database</span>=<span class="string">&quot;orders&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dataNode</span> <span class="attr">name</span>=<span class="string">&quot;dn2&quot;</span> <span class="attr">dataHost</span>=<span class="string">&quot;host2&quot;</span> <span class="attr">database</span>=<span class="string">&quot;orders&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dataHost</span> <span class="attr">name</span>=<span class="string">&quot;host1&quot;</span> <span class="attr">maxCon</span>=<span class="string">&quot;1000&quot;</span> <span class="attr">minCon</span>=<span class="string">&quot;10&quot;</span> <span class="attr">balance</span>=<span class="string">&quot;0&quot;</span> <span class="attr">writeType</span>=<span class="string">&quot;0&quot;</span> <span class="attr">dbType</span>=<span class="string">&quot;mysql&quot;</span> <span class="attr">dbDriver</span>=<span class="string">&quot;native&quot;</span> <span class="attr">switchType</span>=<span class="string">&quot;1&quot;</span>  <span class="attr">slaveThreshold</span>=<span class="string">&quot;100&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">heartbeat</span>&gt;</span>select user()<span class="tag">&lt;/<span class="name">heartbeat</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- can have multi write hosts --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">writeHost</span> <span class="attr">host</span>=<span class="string">&quot;hostM1&quot;</span> <span class="attr">url</span>=<span class="string">&quot;192.168.140.128:3306&quot;</span> <span class="attr">user</span>=<span class="string">&quot;root&quot;</span> <span class="attr">password</span>=<span class="string">&quot;123123&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">writeHost</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dataHost</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dataHost</span> <span class="attr">name</span>=<span class="string">&quot;hostM2&quot;</span> <span class="attr">maxCon</span>=<span class="string">&quot;1000&quot;</span> <span class="attr">minCon</span>=<span class="string">&quot;10&quot;</span> <span class="attr">balance</span>=<span class="string">&quot;0&quot;</span> <span class="attr">writeType</span>=<span class="string">&quot;0&quot;</span> <span class="attr">dbType</span>=<span class="string">&quot;mysql&quot;</span> <span class="attr">dbDriver</span>=<span class="string">&quot;native&quot;</span> <span class="attr">switchType</span>=<span class="string">&quot;1&quot;</span>  <span class="attr">slaveThreshold</span>=<span class="string">&quot;100&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">heartbeat</span>&gt;</span>select user()<span class="tag">&lt;/<span class="name">heartbeat</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">&lt;!-- can have multi write hosts --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">writeHost</span> <span class="attr">host</span>=<span class="string">&quot;hostM2&quot;</span> <span class="attr">url</span>=<span class="string">&quot;192.168.140.127:3306&quot;</span> <span class="attr">user</span>=<span class="string">&quot;root&quot;</span> <span class="attr">password</span>=<span class="string">&quot;123123&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">writeHost</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dataHost</span>&gt;</span></span><br><span class="line">…</span><br></pre></td></tr></table></figure>

<p>主要修改的内容如下图的红框：</p>
<p><img src="/2022/10/07/MySQL%E9%AB%98%E7%BA%A7%E7%AF%87/image-20210816233105601.png" alt="image-20210816233105601"></p>
<h3 id="新增两个空白库"><a href="#新增两个空白库" class="headerlink" title="新增两个空白库"></a>新增两个空白库</h3><p>分库操作不是在原来的老数据库上进行操作，需要准备两台机器分别安装新的数据库。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#在数据节点dn1、dn2上分别创建数据库orders</span><br><span class="line">CREATE DATABASE orders;</span><br></pre></td></tr></table></figure>

<h3 id="启动Mycat-2"><a href="#启动Mycat-2" class="headerlink" title="启动Mycat"></a>启动Mycat</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./mycat console</span><br></pre></td></tr></table></figure>

<p><img src="/2022/10/07/MySQL%E9%AB%98%E7%BA%A7%E7%AF%87/clip_image001-1629003929180.png" alt="img"></p>
<h3 id="访问Mycat进行分库"><a href="#访问Mycat进行分库" class="headerlink" title="访问Mycat进行分库"></a>访问Mycat进行分库</h3><p>访问Mycat</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql -umycat -p123456 -h 192.168.140.128 -P 8066</span><br></pre></td></tr></table></figure>

<p>切换到TESTDB，创建4张表，查看表信息，可以看到成功分库：</p>
<p><img src="/2022/10/07/MySQL%E9%AB%98%E7%BA%A7%E7%AF%87/clip_image002-1629004002080.jpg" alt="img"></p>
<h1 id="水平拆分——分表"><a href="#水平拆分——分表" class="headerlink" title="水平拆分——分表"></a>水平拆分——分表</h1><p>相对于垂直拆分，水平拆分不是将表做分类，而是按照某个字段的某种规则来分散到多个库之中，每个表中包含一部分数据。简单来说，我们可以将数据的水平切分<code>理解为是按照数据行的切分</code>，就是将表中的某些行切分到一个数据库，而另外的某些行又切分到其他的数据库中，如图： </p>
<p><img src="/2022/10/07/MySQL%E9%AB%98%E7%BA%A7%E7%AF%87/clip_image001-1629004058333.png" alt="img"> </p>
<h2 id="实现分表"><a href="#实现分表" class="headerlink" title="实现分表"></a>实现分表</h2><h3 id="选择要拆分的表"><a href="#选择要拆分的表" class="headerlink" title="选择要拆分的表"></a>选择要拆分的表</h3><p>MySQL单表存储数据条数是有瓶颈的，单表达到<code>1000万条</code>数据就达到了瓶颈，会影响查询效率，需要进行水平拆分（分表）进行优化。</p>
<p>例如：例子中的<code>orders</code>、<code>orders_detail</code>都已经达到600万行数据，需要进行分表优化。</p>
<h3 id="分表字段的考量"><a href="#分表字段的考量" class="headerlink" title="分表字段的考量"></a>分表字段的考量</h3><p>以<code>orders</code>表为例，可以根据不同字段进行分表。即相同字段值的数据放到同一台主机的表中。</p>
<table>
<thead>
<tr>
<th>编号</th>
<th>分表字段</th>
<th>效果</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>id（主键）、创建时间</td>
<td>查询订单注重时效，历史订单被查询的次数少，<br/>如此分片会造成一个节点访问多，一个访问少，不平均。</td>
</tr>
<tr>
<td>2</td>
<td>customer_id（客户id）</td>
<td>根据客户id去分，两个节点访问平均，一个客户<br/>的所有订单都在同一个节点</td>
</tr>
</tbody></table>
<h3 id="修改配置文件schema-xml"><a href="#修改配置文件schema-xml" class="headerlink" title="修改配置文件schema.xml"></a>修改配置文件schema.xml</h3><p>为orders表设置数据节点为dn1、dn2，并指定分片规则为mod_rule（自定义的名字）</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">&quot;orders&quot;</span> <span class="attr">dataNode</span>=<span class="string">&quot;dn1,dn2&quot;</span>  <span class="attr">rule</span>=<span class="string">&quot;mod_rule&quot;</span> &gt;</span><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如下图：</p>
<p><img src="/2022/10/07/MySQL%E9%AB%98%E7%BA%A7%E7%AF%87/clip_image001-1629006312997.png" alt="img"></p>
<h3 id="修改配置文件rule-xml"><a href="#修改配置文件rule-xml" class="headerlink" title="修改配置文件rule.xml"></a>修改配置文件rule.xml</h3><p>在rule配置文件里新增分片规则<code>mod_rule</code>，并指定规则适用字段为customer_id， 还有选择分片算法mod-long（对字段求模运算），customer_id对两个节点求模，根据结果分片。</p>
<p>配置算法<code>mod-long</code>参数count为2，两个节点</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tableRule</span> <span class="attr">name</span>=<span class="string">&quot;mod_rule&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">rule</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">columns</span>&gt;</span>customer_id<span class="tag">&lt;/<span class="name">columns</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">algorithm</span>&gt;</span>mod-long<span class="tag">&lt;/<span class="name">algorithm</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">rule</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tableRule</span>&gt;</span></span><br><span class="line">…</span><br><span class="line"><span class="tag">&lt;<span class="name">function</span> <span class="attr">name</span>=<span class="string">&quot;mod-long&quot;</span> <span class="attr">class</span>=<span class="string">&quot;io.mycat.route.function.PartitionByMod&quot;</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- how many data nodes --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;count&quot;</span>&gt;</span>2<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">function</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如下图：</p>
<p> <img src="/2022/10/07/MySQL%E9%AB%98%E7%BA%A7%E7%AF%87/clip_image001-1629006540842.png" alt="img"></p>
<p> <img src="/2022/10/07/MySQL%E9%AB%98%E7%BA%A7%E7%AF%87/clip_image001-1629006550971.png" alt="img"></p>
<h3 id="在数据节点dn2上建orders表"><a href="#在数据节点dn2上建orders表" class="headerlink" title="在数据节点dn2上建orders表"></a>在数据节点dn2上建orders表</h3><p>由于dn1在前面题目中已经创建了orders表，而dn2机器上没有。这里需要执行如下的命令，在dn2上创建orders表：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#订单表   rows:600万</span><br><span class="line">CREATE TABLE orders(</span><br><span class="line">    id INT AUTO_INCREMENT,</span><br><span class="line">    order_type INT,</span><br><span class="line">    customer_id INT,</span><br><span class="line">    amount DECIMAL(10,2),</span><br><span class="line">    PRIMARY KEY(id)  </span><br><span class="line">); </span><br></pre></td></tr></table></figure>

<h3 id="重启Mycat让配置生效"><a href="#重启Mycat让配置生效" class="headerlink" title="重启Mycat让配置生效"></a>重启Mycat让配置生效</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./mycat console</span><br></pre></td></tr></table></figure>

<h3 id="访问Mycat实现分片"><a href="#访问Mycat实现分片" class="headerlink" title="访问Mycat实现分片"></a>访问Mycat实现分片</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#在mycat里向orders表插入数据，INSERT字段不能省略</span><br><span class="line"></span><br><span class="line">INSERT INTO orders(id,order_type,customer_id,amount) VALUES(1,101,100,100100);</span><br><span class="line">INSERT INTO orders(id,order_type,customer_id,amount) VALUES(2,101,100,100300);</span><br><span class="line">INSERT INTO orders(id,order_type,customer_id,amount) VALUES(3,101,101,120000);</span><br><span class="line">INSERT INTO orders(id,order_type,customer_id,amount) VALUES(4,101,101,103000);</span><br><span class="line">INSERT INTO orders(id,order_type,customer_id,amount) VALUES(5,102,101,100400);</span><br><span class="line">INSERT INTO orders(id,order_type,customer_id,amount) VALUES(6,102,100,100020);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意，这里不能使用 INSERT INTO orders VALUES (1,101,100,100100); 语句实现向orders表中插入数据。因为但凡使用mycat实现分表，必须显式指明分表的字段。</p>
</blockquote>
<p>在mycat、dn1、dn2中查看orders表数据，分表成功。</p>
<p><img src="/2022/10/07/MySQL%E9%AB%98%E7%BA%A7%E7%AF%87/clip_image002-1629006654622.jpg" alt="img"></p>
<h2 id="Mycat-的分片-“join”"><a href="#Mycat-的分片-“join”" class="headerlink" title="Mycat 的分片 “join”"></a>Mycat 的分片 “join”</h2><p>Orders订单表已经进行分表操作了，和它关联的orders_detail订单详情表如何进行join查询。</p>
<p>我们也要对orders_detail进行分片操作。Join的原理如下图：</p>
<p><img src="/2022/10/07/MySQL%E9%AB%98%E7%BA%A7%E7%AF%87/clip_image002-1629006703402.jpg" alt="img"></p>
<h3 id="ER表"><a href="#ER表" class="headerlink" title="ER表"></a>ER表</h3><p>Mycat 借鉴了 NewSQL 领域的新秀 Foundation DB 的设计思路，Foundation DB 创新性的提出了 Table Group 的概念，其<strong>将子表的存储位置依赖于主表，并且物理上紧邻存放，因此彻底解决了 JOIN 的效率和性能问题</strong>，根据这一思路，提出了<code>基于 E-R 关系的数据分片</code>策略，子表的记录与所关联的父表记录存放在同一个数据分片上。</p>
<p><strong>① 修改schema.xml配置文件</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">…</span><br><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">&quot;orders&quot;</span> <span class="attr">dataNode</span>=<span class="string">&quot;dn1,dn2&quot;</span>  <span class="attr">rule</span>=<span class="string">&quot;mod_rule&quot;</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">childTable</span> <span class="attr">name</span>=<span class="string">&quot;orders_detail&quot;</span> <span class="attr">primaryKey</span>=<span class="string">&quot;id&quot;</span> <span class="attr">joinKey</span>=<span class="string">&quot;order_id&quot;</span> <span class="attr">parentKey</span>=<span class="string">&quot;id&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">…</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/2022/10/07/MySQL%E9%AB%98%E7%BA%A7%E7%AF%87/clip_image001-1629006789459.png" alt="img"></p>
<p><strong>② 在dn2创建orders_detail表</strong></p>
<p>重启Mycat前注意，dn2 上不存在orders_detail表，需要创建此表。语句见上面。</p>
<p><strong>③ 重启Mycat</strong></p>
<p><strong>④ 访问Mycat向orders_detail表插入数据：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO orders_detail(id,detail,order_id) values(1,&#x27;detail1&#x27;,1);</span><br><span class="line">INSERT INTO orders_detail(id,detail,order_id) VALUES(2,&#x27;detail1&#x27;,2);</span><br><span class="line">INSERT INTO orders_detail(id,detail,order_id) VALUES(3,&#x27;detail1&#x27;,3);</span><br><span class="line">INSERT INTO orders_detail(id,detail,order_id) VALUES(4,&#x27;detail1&#x27;,4);</span><br><span class="line">INSERT INTO orders_detail(id,detail,order_id) VALUES(5,&#x27;detail1&#x27;,5);</span><br><span class="line">INSERT INTO orders_detail(id,detail,order_id) VALUES(6,&#x27;detail1&#x27;,6);</span><br></pre></td></tr></table></figure>

<p><strong>⑤ 在mycat、dn1、dn2中运行两个表join语句</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Select o.*,od.detail </span><br><span class="line">from orders o inner join orders_detail od </span><br><span class="line">on o.id=od.order_id;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/10/07/MySQL%E9%AB%98%E7%BA%A7%E7%AF%87/clip_image002-1629006881311.jpg" alt="img"></p>
<h3 id="全局表"><a href="#全局表" class="headerlink" title="全局表"></a>全局表</h3><p>在分片的情况下，当业务表因为规模而进行分片以后，<code>业务表</code>与这些附属的<code>字典表</code>之间的关联，就成了比较棘手的问题，考虑到字典表具有以下几个<code>特性</code>：</p>
<p>​		①  变动不频繁</p>
<p>​		②  数据量总体变化不大</p>
<p>​		③  数据规模不大，很少有超过数十万条记录</p>
<p>鉴于此，Mycat 定义了一种特殊的表，称之为“<code>全局表</code>”，全局表具有以下特性：</p>
<p>​		①  全局表的插入、更新操作会实时在所有节点上执行，保持各个分片的数据一致性</p>
<p>​		②  全局表的查询操作，只从一个节点获取</p>
<p>​		③  全局表可以跟任何一个表进行 JOIN 操作</p>
<p>将字典表或者符合字典表特性的一些表定义为全局表，则从另外一个方面，很好的解决了数据 JOIN 的难题。通过<code>全局表 + 基于E-R关系</code>的分片策略，Mycat 可以满足 80%以上的企业应用开发。</p>
<p><strong>① 修改schema.xml配置文件</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">…</span><br><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">&quot;orders&quot;</span> <span class="attr">dataNode</span>=<span class="string">&quot;dn1,dn2&quot;</span>  <span class="attr">rule</span>=<span class="string">&quot;mod_rule&quot;</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">childTable</span> <span class="attr">name</span>=<span class="string">&quot;orders_detail&quot;</span> <span class="attr">primaryKey</span>=<span class="string">&quot;id&quot;</span> <span class="attr">joinKey</span>=<span class="string">&quot;order_id&quot;</span> <span class="attr">parentKey</span>=<span class="string">&quot;id&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">&quot;dict_order_type&quot;</span> <span class="attr">dataNode</span>=<span class="string">&quot;dn1,dn2&quot;</span> <span class="attr">type</span>=<span class="string">&quot;global&quot;</span> &gt;</span><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">…</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/2022/10/07/MySQL%E9%AB%98%E7%BA%A7%E7%AF%87/clip_image002-1629007043604.jpg" alt="img"></p>
<p><strong>② 在dn2创建dict_order_type表</strong></p>
<p>重启Mycat前注意，dn2 上不存在dict_order_type表，需要创建此表。语句见上面。</p>
<p><strong>③ 重启Mycat</strong></p>
<p><strong>④ 访问Mycat向dict_order_type表插入数据</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO dict_order_type(id,order_type) VALUES(101,&#x27;type1&#x27;);</span><br><span class="line">INSERT INTO dict_order_type(id,order_type) VALUES(102,&#x27;type2&#x27;);</span><br></pre></td></tr></table></figure>

<p><strong>⑤ 在Mycat、dn1、dn2中查询表数据</strong></p>
<p>在不同机器上查询dict_order_type表中的数据都是完整的。</p>
<p><img src="/2022/10/07/MySQL%E9%AB%98%E7%BA%A7%E7%AF%87/clip_image002-1629007094948.jpg" alt="img"></p>
<h2 id="常用分片规则"><a href="#常用分片规则" class="headerlink" title="常用分片规则"></a>常用分片规则</h2><h3 id="方式1：取模"><a href="#方式1：取模" class="headerlink" title="方式1：取模"></a>方式1：取模</h3><p>此规则是对分片字段求模运算。也是水平分表最常用规则。6.1配置分表中，orders表采用了此规则。</p>
<h3 id="方式2：分片枚举"><a href="#方式2：分片枚举" class="headerlink" title="方式2：分片枚举"></a>方式2：分片枚举</h3><p>通过在配置文件中配置可能的枚举id，自己配置分片。本规则适用于特定的场景，比如有些业务需要按照<code>省份</code>或<code>区县</code>来做保存，而全国省份区县固定的，这类业务使用本条规则。</p>
<p><strong>（1）修改schema.xml配置文件</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 订单归属区域信息表  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">&quot;orders_ware_info&quot;</span> <span class="attr">dataNode</span>=<span class="string">&quot;dn1,dn2&quot;</span> <span class="attr">rule</span>=<span class="string">&quot;sharding_by_intfile&quot;</span> &gt;</span><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>（2）修改rule.xml配置文件</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tableRule</span> <span class="attr">name</span>=<span class="string">&quot;sharding_by_intfile&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">rule</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">columns</span>&gt;</span>areacode<span class="tag">&lt;/<span class="name">columns</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">algorithm</span>&gt;</span>hash-int<span class="tag">&lt;/<span class="name">algorithm</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">rule</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tableRule</span>&gt;</span></span><br><span class="line"></span><br><span class="line">…</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">function</span> <span class="attr">name</span>=<span class="string">&quot;hash-int&quot;</span> <span class="attr">class</span>=<span class="string">&quot;io.mycat.route.function.PartitionByFileMap&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;mapFile&quot;</span>&gt;</span>partition-hash-int.txt<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;type&quot;</span>&gt;</span>1<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;defaultNode&quot;</span>&gt;</span>0<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">function</span>&gt;</span></span><br><span class="line"></span><br><span class="line"># columns：分片字段，algorithm：分片函数</span><br><span class="line"># mapFile：标识配置文件名称</span><br><span class="line"># type：0为int型、非0为String</span><br><span class="line">#defaultNode：默认节点:小于 0 表示不设置默认节点，大于等于 0 表示设置默认节点，</span><br><span class="line">#             设置默认节点如果碰到不识别的枚举值，就让它路由到默认节点，如不设置不识别就报错</span><br></pre></td></tr></table></figure>

<p><strong>（3）修改partition-hash-int.txt配置文件</strong></p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">110</span>=<span class="string">0    # 0 表示第1个数据节点</span></span><br><span class="line"><span class="attr">120</span>=<span class="string">1    # 1 表示第2个数据节点</span></span><br></pre></td></tr></table></figure>

<p><strong>（4）重启Mycat</strong></p>
<p><strong>（5）访问Mycat创建表</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#订单归属区域信息表  </span><br><span class="line">CREATE TABLE  orders_ware_info(</span><br><span class="line">    `id`        INT AUTO_INCREMENT comment &#x27;编号&#x27;,</span><br><span class="line">    `order_id`  INT comment &#x27;订单编号&#x27;,</span><br><span class="line">    `address`   VARCHAR(200) comment &#x27;地址&#x27;,</span><br><span class="line">    `areacode`  VARCHAR(20) comment &#x27;区域编号&#x27;,</span><br><span class="line">    PRIMARY KEY(id)</span><br><span class="line">); </span><br></pre></td></tr></table></figure>

<p><strong>（6）插入数据</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO orders_ware_info(id, order_id,address,areacode) VALUES (1,1,&#x27;北京&#x27;,&#x27;110&#x27;);</span><br><span class="line">INSERT INTO orders_ware_info(id, order_id,address,areacode) VALUES (2,2,&#x27;天津&#x27;,&#x27;120&#x27;);</span><br></pre></td></tr></table></figure>

<p><strong>（7）查询Mycat、dn1、dn2可以看到数据分片效果</strong></p>
<p> <img src="/2022/10/07/MySQL%E9%AB%98%E7%BA%A7%E7%AF%87/clip_image001-1629007161328.png" alt="img"></p>
<h3 id="方式3：范围约定"><a href="#方式3：范围约定" class="headerlink" title="方式3：范围约定"></a>方式3：范围约定</h3><p>此分片适用于，提前规划好分片字段某个范围属于哪个分片。</p>
<p><strong>（1）修改schema.xml配置文件</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 针对支付信息表 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">&quot;payment_info&quot;</span> <span class="attr">dataNode</span>=<span class="string">&quot;dn1,dn2&quot;</span> <span class="attr">rule</span>=<span class="string">&quot;auto_sharding_long&quot;</span> &gt;</span><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>（2）修改rule.xml配置文件</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tableRule</span> <span class="attr">name</span>=<span class="string">&quot;auto_sharding_long&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">rule</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">columns</span>&gt;</span>order_id<span class="tag">&lt;/<span class="name">columns</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">algorithm</span>&gt;</span>rang-long<span class="tag">&lt;/<span class="name">algorithm</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">rule</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tableRule</span>&gt;</span></span><br><span class="line">…</span><br><span class="line"><span class="tag">&lt;<span class="name">function</span> <span class="attr">name</span>=<span class="string">&quot;rang-long&quot;</span> <span class="attr">class</span>=<span class="string">&quot;io.mycat.route.function.AutoPartitionByLong&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;mapFile&quot;</span>&gt;</span>autopartition-long.txt<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;defaultNode&quot;</span>&gt;</span>0<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">function</span>&gt;</span> </span><br><span class="line"></span><br><span class="line"># columns：分片字段，algorithm：分片函数</span><br><span class="line"># mapFile：标识配置文件名称</span><br><span class="line"># defaultNode：默认节点:小于 0 表示不设置默认节点，大于等于 0 表示设置默认节点，</span><br><span class="line">#              设置默认节点如果碰到不识别的枚举值，就让它路由到默认节点，如不设置不识别就报错</span><br></pre></td></tr></table></figure>

<p><strong>（3）修改autopartition-long.txt配置文件</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0-102=0</span><br><span class="line">103-200=1 </span><br></pre></td></tr></table></figure>

<p><strong>（4）重启Mycat</strong><br><strong>（5）访问Mycat，并创建表</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#支付信息表  </span><br><span class="line">CREATE TABLE  payment_info(</span><br><span class="line">    `id`               INT AUTO_INCREMENT comment &#x27;编号&#x27;,</span><br><span class="line">    `order_id`         INT comment &#x27;订单编号&#x27;,</span><br><span class="line">    `payment_status`   INT comment &#x27;支付状态&#x27;,</span><br><span class="line">    PRIMARY KEY(id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p><strong>（6）插入数据</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO payment_info (id,order_id,payment_status) VALUES (1,101,0);</span><br><span class="line">INSERT INTO payment_info (id,order_id,payment_status) VALUES (2,102,1);</span><br><span class="line">INSERT INTO payment_info (id,order_id ,payment_status) VALUES (3,103,0);</span><br><span class="line">INSERT INTO payment_info (id,order_id,payment_status) VALUES (4,104,1);</span><br></pre></td></tr></table></figure>

<p><strong>（7）查询Mycat、dn1、dn2可以看到数据分片效果</strong></p>
<p> <img src="/2022/10/07/MySQL%E9%AB%98%E7%BA%A7%E7%AF%87/clip_image001-1629007430783.png" alt="img"></p>
<h3 id="方式4：按日期（天）分片"><a href="#方式4：按日期（天）分片" class="headerlink" title="方式4：按日期（天）分片"></a>方式4：按日期（天）分片</h3><p>此规则为按天分片。设定时间格式、范围：</p>
<p><strong>（1）修改schema.xml配置文件</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 针对用户信息表 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">&quot;login_info&quot;</span> <span class="attr">dataNode</span>=<span class="string">&quot;dn1,dn2&quot;</span> <span class="attr">rule</span>=<span class="string">&quot;sharding_by_date&quot;</span> &gt;</span><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>（2）修改rule.xml配置文件</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tableRule</span> <span class="attr">name</span>=<span class="string">&quot;sharding_by_date&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">rule</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">columns</span>&gt;</span>login_date<span class="tag">&lt;/<span class="name">columns</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">algorithm</span>&gt;</span>shardingByDate<span class="tag">&lt;/<span class="name">algorithm</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">rule</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tableRule</span>&gt;</span></span><br><span class="line">…</span><br><span class="line"><span class="tag">&lt;<span class="name">function</span> <span class="attr">name</span>=<span class="string">&quot;shardingByDate&quot;</span> <span class="attr">class</span>=<span class="string">&quot;io.mycat.route.function.PartitionByDate&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dateFormat&quot;</span>&gt;</span>yyyy-MM-dd<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;sBeginDate&quot;</span>&gt;</span>2019-01-01<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;sEndDate&quot;</span>&gt;</span>2019-01-04<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	 <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;sPartionDay&quot;</span>&gt;</span>2<span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">function</span>&gt;</span> </span><br><span class="line"></span><br><span class="line"># columns：分片字段，algorithm：分片函数</span><br><span class="line"># dateFormat ：日期格式</span><br><span class="line"># sBeginDate ：开始日期 </span><br><span class="line"># sEndDate：结束日期,则代表数据达到了这个日期的分片后循环从开始分片插入。如果不设定，会报错</span><br><span class="line"># sPartionDay ：分区天数，即默认从开始日期算起，分隔 2 天一个分区</span><br></pre></td></tr></table></figure>

<p><strong>（3）重启Mycat</strong><br><strong>（4）访问Mycat创建表</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#用户信息表  </span><br><span class="line">CREATE TABLE  login_info(</span><br><span class="line">    `id`            INT AUTO_INCREMENT comment &#x27;编号&#x27;,</span><br><span class="line">    `user_id`       INT comment &#x27;用户编号&#x27;,</span><br><span class="line">    `login_date`    date comment &#x27;登录日期&#x27;,</span><br><span class="line">    PRIMARY KEY(id)</span><br><span class="line">); </span><br></pre></td></tr></table></figure>

<p><strong>（6）插入数据</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO login_info(id,user_id,login_date) VALUES (1,101,&#x27;2019-01-01&#x27;);</span><br><span class="line">INSERT INTO login_info(id,user_id,login_date) VALUES (2,102,&#x27;2019-01-02&#x27;);</span><br><span class="line">INSERT INTO login_info(id,user_id,login_date) VALUES (3,103,&#x27;2019-01-03&#x27;);</span><br><span class="line">INSERT INTO login_info(id,user_id,login_date) VALUES  (4,104,&#x27;2019-01-04&#x27;);</span><br><span class="line">INSERT INTO login_info(id,user_id,login_date) VALUES (5,103,&#x27;2019-01-05&#x27;);</span><br><span class="line">INSERT INTO login_info(id,user_id,login_date) VALUES (6,104,&#x27;2019-01-06&#x27;); </span><br></pre></td></tr></table></figure>

<p><strong>（7）查询Mycat、dn1、dn2可以看到数据分片效果</strong></p>
<p> <img src="/2022/10/07/MySQL%E9%AB%98%E7%BA%A7%E7%AF%87/clip_image001-1629007482146.png" alt="img"></p>
<h2 id="全局ID序列"><a href="#全局ID序列" class="headerlink" title="全局ID序列"></a>全局ID序列</h2><p><strong>在实现分库分表的情况下，数据库自增主键已无法保证自增主键的全局唯一。</strong>为此，Mycat 提供了<code>全局 sequence</code>，并且提供了包含<code>本地配置</code>和<code>数据库配置</code>等多种实现方式。</p>
<h3 id="方式1：本地文件（不推荐）"><a href="#方式1：本地文件（不推荐）" class="headerlink" title="方式1：本地文件（不推荐）"></a>方式1：本地文件（不推荐）</h3><p>此方式 Mycat 将 sequence 配置到文件中，当使用到 sequence 中的配置后，Mycat 会更下 classpath 中的 <code>sequence_conf.properties</code> 文件中 <code>sequence 当前的值</code>。</p>
<p>​		①   优点：本地加载，读取速度较快</p>
<p>​		②   缺点：抗风险能力差，Mycat所在主机宕机后，无法读取本地文件。</p>
<h3 id="方式2：数据库方式（推荐）"><a href="#方式2：数据库方式（推荐）" class="headerlink" title="方式2：数据库方式（推荐）"></a>方式2：数据库方式（推荐）</h3><p>利用数据库一个表来进行计数累加，可行。但是每次生成序列都读写数据库，这样效率太低。</p>
<p><strong>优化：</strong>Mycat会预加载一部分号段到Mycat的内存中，这样大部分读写序列都是在内存中完成的。</p>
<p>如果内存中的号段用完了，Mycat会再向数据库要一次。</p>
<blockquote>
<p><strong>问：那如果Mycat崩溃了 ，那内存中的序列岂不是都没了？</strong></p>
<p><strong>答：</strong>是的。如果是这样，那么Mycat启动后会向数据库申请新的号段，原有号段会弃用。</p>
<p>也就是说如果Mycat重启，那么损失是当前的号段没用完的号码，但是不会因此出现主键重复。</p>
</blockquote>
<p><strong>① 建库序列脚本</strong></p>
<p>在dn1上执行如下操作：(以下脚本来自官方)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#在dn1上创建全局序列表</span><br><span class="line">CREATE TABLE MYCAT_SEQUENCE (NAME VARCHAR(50) NOT NULL,current_value INT NOT</span><br><span class="line">NULL,increment INT NOT NULL DEFAULT 100, PRIMARY KEY(NAME)) ENGINE=INNODB;</span><br><span class="line"></span><br><span class="line">#创建全局序列所需函数</span><br><span class="line">DELIMITER $$ </span><br><span class="line">CREATE FUNCTION mycat_seq_currval(seq_name VARCHAR(50)) RETURNS VARCHAR(64)</span><br><span class="line">DETERMINISTIC  </span><br><span class="line">BEGIN</span><br><span class="line">DECLARE retval VARCHAR(64);</span><br><span class="line">SET retval=&quot;-999999999,null&quot;;</span><br><span class="line">SELECT CONCAT(CAST(current_value AS CHAR),&quot;,&quot;,CAST(increment AS CHAR)) INTO retval FROM</span><br><span class="line">MYCAT_SEQUENCE WHERE NAME = seq_name;</span><br><span class="line">RETURN retval;</span><br><span class="line">END $$</span><br><span class="line">DELIMITER ;</span><br><span class="line"> </span><br><span class="line">DELIMITER $$</span><br><span class="line">CREATE FUNCTION mycat_seq_setval(seq_name VARCHAR(50),VALUE INTEGER) RETURNS VARCHAR(64)</span><br><span class="line">DETERMINISTIC</span><br><span class="line">BEGIN</span><br><span class="line">UPDATE MYCAT_SEQUENCE</span><br><span class="line">SET current_value = VALUE</span><br><span class="line">WHERE NAME = seq_name;</span><br><span class="line">RETURN mycat_seq_currval(seq_name);</span><br><span class="line">END $$</span><br><span class="line">DELIMITER ;</span><br><span class="line"> </span><br><span class="line">DELIMITER $$</span><br><span class="line">CREATE FUNCTION mycat_seq_nextval(seq_name VARCHAR(50)) RETURNS VARCHAR(64) </span><br><span class="line">DETERMINISTIC</span><br><span class="line">BEGIN</span><br><span class="line">UPDATE MYCAT_SEQUENCE</span><br><span class="line">SET current_value = current_value + increment WHERE NAME = seq_name;</span><br><span class="line">RETURN mycat_seq_currval(seq_name);</span><br><span class="line">END $$</span><br><span class="line">DELIMITER ;</span><br><span class="line"></span><br><span class="line">#初始化序列表记录</span><br><span class="line">INSERT INTO MYCAT_SEQUENCE(NAME,current_value,increment) </span><br><span class="line">VALUES (&#x27;ORDERS&#x27;, 400000,100);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p> <img src="/2022/10/07/MySQL%E9%AB%98%E7%BA%A7%E7%AF%87/clip_image001-1629007934487.png" alt="img"></p>
<p><strong>② 修改Mycat配置</strong></p>
<p><strong>修改sequence_db_conf.properties ：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim sequence_db_conf.properties</span><br></pre></td></tr></table></figure>

<p>意思是 ORDERS 这个序列在 dn1 这个节点上，具体dn1节点是哪台机子，请参考schema.xml</p>
<p> <img src="/2022/10/07/MySQL%E9%AB%98%E7%BA%A7%E7%AF%87/image-20210829230204587.png" alt="image-20210829230204587"></p>
<p><strong>修改server.xml  ：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim server.xml</span><br></pre></td></tr></table></figure>

<p>全局序列类型：0-本地文件，1-数据库方式，2-时间戳方式。此处应该修改成1。</p>
<p> <img src="/2022/10/07/MySQL%E9%AB%98%E7%BA%A7%E7%AF%87/image-20210829230232414.png" alt="image-20210829230232414"></p>
<p><strong>重启Mycat</strong></p>
<p><strong>③ 验证全局序列</strong></p>
<p>登录Mycat，插入数据：（可执行多次如下数据）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">insert into orders(id,amount,customer_id,order_type) values(next value for MYCATSEQ_ORDERS,1000,101,102);</span><br></pre></td></tr></table></figure>

<p> 查询数据</p>
<p><img src="/2022/10/07/MySQL%E9%AB%98%E7%BA%A7%E7%AF%87/clip_image001-1629008105303.png" alt="img"></p>
<p>模拟Mycat宕机（重启Mycat）后，再次Mycat中插入数据，再查询</p>
<p><img src="/2022/10/07/MySQL%E9%AB%98%E7%BA%A7%E7%AF%87/clip_image001-1629008119048.png" alt="img"></p>
<h3 id="方式3：时间戳方式（不推荐）"><a href="#方式3：时间戳方式（不推荐）" class="headerlink" title="方式3：时间戳方式（不推荐）"></a>方式3：时间戳方式（不推荐）</h3><p>全局序列ID&#x3D; <code>64 位二进制 (42(毫秒)</code>+<code>5(机器 ID)</code>+<code>5(业务编码)</code>+<code>12(重复累加)</code> 换算成十进制为 18 位数的 long 类型，每毫秒可以并发 12 位二进制的累加。 </p>
<p>​		①   优点：配置简单</p>
<p>​		②   缺点：18位ID过长</p>
<h3 id="方式4：自主生成全局序列"><a href="#方式4：自主生成全局序列" class="headerlink" title="方式4：自主生成全局序列"></a>方式4：自主生成全局序列</h3><p>可在<code>Java项目</code>里自己生成全局序列，如下：</p>
<p>​		①  根据业务逻辑组合</p>
<p>​		②  可以利用 redis 的单线程原子性 incr来生成序列</p>
<p>​		③  Twitter的雪花算法</p>
<p>但，自主生成需要单独在工程中用Java代码实现，还是推荐使用Mycat自带全局序列。</p>
]]></content>
      <categories>
        <category>MySQL学习</category>
        <category>MySQL高级篇</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>分享</tag>
      </tags>
  </entry>
</search>
